[ {
  "instance_id" : "FasterXML-jackson-databind-PR-5622",
  "repo" : "FasterXML/jackson-databind",
  "base_commit" : "3db1dbbdde8f9340af62d2feaf63e44ab9c7f0f6",
  "patch" : "diff --git a/release-notes/CREDITS b/release-notes/CREDITS\nindex c599ed6595..a2ffc8142d 100644\n--- a/release-notes/CREDITS\n+++ b/release-notes/CREDITS\n@@ -162,6 +162,11 @@ Oliver Drotbohm (@odrotbohm)\n  * Contributed #1196: Add opt-in error collection for deserialization\n   [3.1.0]\n \n+Jeff Maxwell (@jmax01)\n+ * Reported #1391: Default typing adds typing info to collections even with\n+  `@JsonTypeInfo(use = Id.NONE)` override\n+  [3.1.0]\n+\n Victor Noël (@victornoel)\n  * Requested #1497: Allow skipping `@JsonUnwrapped` values if no properties matched,\n    `DeserializationFeature.USE_NULL_FOR_EMPTY_UNWRAPPED` enabled\ndiff --git a/release-notes/VERSION b/release-notes/VERSION\nindex 5c01e21b63..83bff974fa 100644\n--- a/release-notes/VERSION\n+++ b/release-notes/VERSION\n@@ -17,6 +17,10 @@ Versions: 3.x (for earlier see VERSION-2.x)\n #1196: Add opt-in error collection for deserialization\n  (requested by @odrotbohm)\n  (contributed by @sri-adarsh-kumar)\n+#1391: Default typing adds typing info to collections even with\n+  `@JsonTypeInfo(use = Id.NONE)` override\n+ (reported by Jeff M)\n+ (fix by @cowtowncoder, w/ Claude code)\n #1419: `JsonFormat.Shape.POJO`  does not work for `Map.Entry` via property annotation\n  (fix by @cowtowncoder, w/ Claude code)\n #1497: Allow skipping `@JsonUnwrapped` values if no properties matched,\ndiff --git a/src/main/java/tools/jackson/databind/jsontype/TypeResolverProvider.java b/src/main/java/tools/jackson/databind/jsontype/TypeResolverProvider.java\nindex 7c6de1b8bb..20b3bb14a3 100644\n--- a/src/main/java/tools/jackson/databind/jsontype/TypeResolverProvider.java\n+++ b/src/main/java/tools/jackson/databind/jsontype/TypeResolverProvider.java\n@@ -110,6 +110,14 @@ public TypeSerializer findPropertyTypeSerializer(SerializationContext ctxt,\n         // As per definition of @JsonTypeInfo, check for annotation only for non-container types\n         if (!baseType.isContainerType() && !baseType.isReferenceType()) {\n             b = _findTypeResolver(config, accessor, baseType);\n+        } else {\n+            // [databind#1391]: For container/reference types, only check for @JsonTypeInfo(Id.NONE)\n+            // to allow disabling of default typing (other type info settings apply to content)\n+            TypeResolverBuilder<?> marker = _findTypeResolver(config, accessor, baseType);\n+            if (marker == NO_RESOLVER) {\n+                b = NO_RESOLVER;\n+            }\n+            // Otherwise b stays null to continue with default typing\n         }\n         // No annotation on property? Then base it on actual type (and further, default typing if need be)\n         if (b == null) {\n@@ -137,6 +145,14 @@ public TypeDeserializer findPropertyTypeDeserializer(DeserializationContext ctxt\n         // As per definition of @JsonTypeInfo, check for annotation only for non-container types\n         if (!baseType.isContainerType() && !baseType.isReferenceType()) {\n             b = _findTypeResolver(config, accessor, baseType);\n+        } else {\n+            // [databind#1391]: For container/reference types, only check for @JsonTypeInfo(Id.NONE)\n+            // to allow disabling of default typing (other type info settings apply to content)\n+            TypeResolverBuilder<?> marker = _findTypeResolver(config, accessor, baseType);\n+            if (marker == NO_RESOLVER) {\n+                b = NO_RESOLVER;\n+            }\n+            // Otherwise b stays null to continue with default typing\n         }\n         // No annotation on property? Then base it on actual type (and further, default typing if need be)\n         if (b == null) {\n",
  "test_patch" : "diff --git a/src/test/java/tools/jackson/databind/tofix/DefaultTypingOverride1391Test.java b/src/test/java/tools/jackson/databind/jsontype/DefaultTypingOverride1391Test.java\nsimilarity index 74%\nrename from src/test/java/tools/jackson/databind/tofix/DefaultTypingOverride1391Test.java\nrename to src/test/java/tools/jackson/databind/jsontype/DefaultTypingOverride1391Test.java\nindex c118671389..ffb85658e5 100644\n--- a/src/test/java/tools/jackson/databind/tofix/DefaultTypingOverride1391Test.java\n+++ b/src/test/java/tools/jackson/databind/jsontype/DefaultTypingOverride1391Test.java\n@@ -1,4 +1,4 @@\n-package tools.jackson.databind.tofix;\n+package tools.jackson.databind.jsontype;\n \n import java.util.Collection;\n import java.util.Collections;\n@@ -10,7 +10,6 @@\n import tools.jackson.databind.*;\n import tools.jackson.databind.testutil.DatabindTestUtil;\n import tools.jackson.databind.testutil.NoCheckSubTypeValidator;\n-import tools.jackson.databind.testutil.failure.JacksonTestFailureExpected;\n \n import static org.junit.jupiter.api.Assertions.assertEquals;\n \n@@ -18,15 +17,10 @@\n // via explicit {@link JsonTypeInfo}\n class DefaultTypingOverride1391Test extends DatabindTestUtil {\n     static class ListWrapper {\n-        /* 03-Oct-2016, tatu: This doesn't work because it applies to contents\n-         *   (elements), NOT the container. But there is no current mechanism\n-         *   to change that; would need to add a new feature or properties\n-         */\n         @JsonTypeInfo(use = JsonTypeInfo.Id.NONE)\n         public Collection<String> stuff = Collections.emptyList();\n     }\n \n-    @JacksonTestFailureExpected\n     @Test\n     void collectionWithOverride() throws Exception\n     {\n@@ -37,5 +31,9 @@ void collectionWithOverride() throws Exception\n             .build();\n         String json = mapper.writeValueAsString(new ListWrapper());\n         assertEquals(a2q(\"{'stuff':[]}\"), json);\n+\n+        // And verify deserialization works too\n+        ListWrapper result = mapper.readValue(json, ListWrapper.class);\n+        assertEquals(0, result.stuff.size());\n     }\n }\n",
  "problem_statement" : "Version: Jackson 2.8.2 \nJDK: 1.8.0_60\n\nIt appears that enableDefaultTypingAsProperty adds type info to collections regardless if @JsonTypeInfo(use = Id.NONE)  is specified on the property.\n\n``` javascript\n ({\"treeSetStrings\":[\"java.util.TreeSet\",[]],\"immutableSortedSetStrings\":[\"com.google.common.collect.EmptyImmutableSortedSet\",[]]})\n```\n\n``` java\nimport static org.junit.Assert.*;\n\nimport java.util.SortedSet;\nimport java.util.TreeSet;\n\nimport org.junit.Test;\n\nimport com.fasterxml.jackson.annotation.JsonTypeInfo;\nimport com.fasterxml.jackson.annotation.JsonTypeInfo.Id;\nimport com.fasterxml.jackson.core.JsonProcessingException;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.databind.ObjectMapper.DefaultTyping;\nimport com.google.common.collect.ImmutableSortedSet;\n\n@SuppressWarnings(\"javadoc\")\npublic class ObjectAndNonConcreteCollectionsTest {\n\n    final static ObjectMapper WITH_OBJECT_AND_NON_CONCRETE = new ObjectMapper().enableDefaultTypingAsProperty(\n            DefaultTyping.OBJECT_AND_NON_CONCRETE, \"$type\");\n\n    final static ObjectMapper PLAIN_OBJECT_MAPPER = new ObjectMapper();\n\n    static class MyClass {\n\n        private final SortedSet<String> treeSetStrings = new TreeSet<>();\n\n        private final SortedSet<String> immutableSortedSetStrings = ImmutableSortedSet.of();\n\n        @JsonTypeInfo(use = Id.NONE)\n        public SortedSet<String> getTreeSetStrings() {\n            return this.treeSetStrings;\n        }\n\n        @JsonTypeInfo(use = Id.NONE)\n        public SortedSet<String> getImmutableSortedSetStrings() {\n            return this.immutableSortedSetStrings;\n        }\n    }\n\n    @Test\n    public void testCollectionTyping() throws JsonProcessingException {\n\n        final MyClass toSerialize = new MyClass();\n\n        final String fromPlainObjectMapper = PLAIN_OBJECT_MAPPER.writeValueAsString(toSerialize);\n        System.out.println(\"\\nfrom plain ObjectMapper:\\n\" + fromPlainObjectMapper);\n\n        final String fromObjectMapperWithDefaultTyping = WITH_OBJECT_AND_NON_CONCRETE.writeValueAsString(toSerialize);\n        System.out.println(\"\\nfrom ObjectMapper with default typing:\\n\" + fromObjectMapperWithDefaultTyping);\n\n        assertEquals(fromPlainObjectMapper, fromObjectMapperWithDefaultTyping);\n\n    }\n\n}\n```\n",
  "hints_text" : null,
  "created_at" : "Wed Jan 28 03:58:09 CET 2026",
  "version" : null,
  "FAIL_TO_PASS" : [ "DefaultTypingOverride1391Test" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=DefaultTypingOverride1391Test",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : 1391,
  "pull_number" : 5622,
  "metadata" : null
}, {
  "instance_id" : "FasterXML-jackson-databind-PR-5621",
  "repo" : "FasterXML/jackson-databind",
  "base_commit" : "3db1dbbdde8f9340af62d2feaf63e44ab9c7f0f6",
  "patch" : "diff --git a/release-notes/CREDITS b/release-notes/CREDITS\nindex c599ed6595..28e5d60305 100644\n--- a/release-notes/CREDITS\n+++ b/release-notes/CREDITS\n@@ -187,6 +187,8 @@ Lee Jiwon (@dlwldnjs1009)\n  * Implemented #3284: Backward compatibility for timezone formats of UTC Date\n    serialization\n   [3.1.0]\n+ * Implemented #5621: Fix typo: MissingInjectableValueExcepion → MissingInjectableValueException\n+  [3.1.0]\n \n Garret Wilson (@garretwilson)\n  * Suggested #4157: Add `MapperFeature.INFER_RECORD_GETTERS_FROM_COMPONENTS_ONLY` to ignore\ndiff --git a/release-notes/VERSION b/release-notes/VERSION\nindex 5c01e21b63..b064002e4f 100644\n--- a/release-notes/VERSION\n+++ b/release-notes/VERSION\n@@ -157,6 +157,8 @@ Versions: 3.x (for earlier see VERSION-2.x)\n #5616: `ObjectWriter` serializes `Optional`s with subtypes incompletely\n  (reported by Brandon S)\n  (implemented by @cowtowncoder, w/ Claude code)\n+#5621: Fix typo: MissingInjectableValueExcepion → MissingInjectableValueException\n+ (implemented by Lee Jiwon)\n \n 3.0.4 (not yet released)\n \ndiff --git a/src/main/java/tools/jackson/databind/DeserializationContext.java b/src/main/java/tools/jackson/databind/DeserializationContext.java\nindex 2d7a5853ba..3ffbf11862 100644\n--- a/src/main/java/tools/jackson/databind/DeserializationContext.java\n+++ b/src/main/java/tools/jackson/databind/DeserializationContext.java\n@@ -2153,7 +2153,7 @@ public DatabindException missingTypeIdException(JavaType baseType,\n     public DatabindException missingInjectableValueException(String msg,\n             Object valueId,\n             BeanProperty forProperty, Object beanInstance) {\n-        return MissingInjectableValueExcepion.from(_parser, msg,\n+        return MissingInjectableValueException.from(_parser, msg,\n                 valueId, forProperty, beanInstance);\n     }\n \ndiff --git a/src/main/java/tools/jackson/databind/exc/MissingInjectableValueExcepion.java b/src/main/java/tools/jackson/databind/exc/MissingInjectableValueExcepion.java\nindex 5f171753f3..64c352bf8d 100644\n--- a/src/main/java/tools/jackson/databind/exc/MissingInjectableValueExcepion.java\n+++ b/src/main/java/tools/jackson/databind/exc/MissingInjectableValueExcepion.java\n@@ -5,6 +5,10 @@\n import tools.jackson.databind.BeanProperty;\n import tools.jackson.databind.DatabindException;\n \n+/**\n+ * @deprecated Use {@link MissingInjectableValueException} instead.\n+ */\n+@Deprecated\n public class MissingInjectableValueExcepion\n     extends DatabindException\n {\n@@ -23,10 +27,14 @@ protected MissingInjectableValueExcepion(JsonParser p, String msg,\n         _beanInstance = beanInstance;\n     }\n \n+    /**\n+     * @deprecated Use {@link MissingInjectableValueException#from} instead.\n+     */\n+    @Deprecated\n     public static MissingInjectableValueExcepion from(JsonParser p, String msg,\n             Object valueId, BeanProperty forProperty, Object beanInstance)\n     {\n-        return new MissingInjectableValueExcepion(p, msg, valueId, forProperty, beanInstance);\n+        return MissingInjectableValueException.from(p, msg, valueId, forProperty, beanInstance);\n     }\n \n     public Object getValueId() { return _valueId; }\ndiff --git a/src/main/java/tools/jackson/databind/exc/MissingInjectableValueException.java b/src/main/java/tools/jackson/databind/exc/MissingInjectableValueException.java\nnew file mode 100644\nindex 0000000000..23da604850\n--- /dev/null\n+++ b/src/main/java/tools/jackson/databind/exc/MissingInjectableValueException.java\n@@ -0,0 +1,24 @@\n+package tools.jackson.databind.exc;\n+\n+import tools.jackson.core.JsonParser;\n+\n+import tools.jackson.databind.BeanProperty;\n+\n+@SuppressWarnings(\"deprecation\") // extends deprecated MissingInjectableValueExcepion for backward compatibility\n+public class MissingInjectableValueException\n+    extends MissingInjectableValueExcepion\n+{\n+    private static final long serialVersionUID = 1L;\n+\n+    protected MissingInjectableValueException(JsonParser p, String msg,\n+            Object valueId, BeanProperty forProperty, Object beanInstance)\n+    {\n+        super(p, msg, valueId, forProperty, beanInstance);\n+    }\n+\n+    public static MissingInjectableValueException from(JsonParser p, String msg,\n+            Object valueId, BeanProperty forProperty, Object beanInstance)\n+    {\n+        return new MissingInjectableValueException(p, msg, valueId, forProperty, beanInstance);\n+    }\n+}\n",
  "test_patch" : "diff --git a/src/test/java/tools/jackson/databind/deser/inject/JacksonInject1381Test.java b/src/test/java/tools/jackson/databind/deser/inject/JacksonInject1381Test.java\nindex 0a22399954..51521df340 100644\n--- a/src/test/java/tools/jackson/databind/deser/inject/JacksonInject1381Test.java\n+++ b/src/test/java/tools/jackson/databind/deser/inject/JacksonInject1381Test.java\n@@ -7,7 +7,7 @@\n import tools.jackson.databind.DeserializationFeature;\n import tools.jackson.databind.InjectableValues;\n import tools.jackson.databind.ObjectMapper;\n-import tools.jackson.databind.exc.MissingInjectableValueExcepion;\n+import tools.jackson.databind.exc.MissingInjectableValueException;\n import tools.jackson.databind.testutil.DatabindTestUtil;\n \n import static org.junit.jupiter.api.Assertions.assertEquals;\n@@ -121,19 +121,19 @@ public String getField() {\n     @Test\n     @DisplayName(\"input NO, injectable NO, useInput DEFAULT|TRUE|FALSE => exception\")\n     void test1() {\n-        assertThrows(MissingInjectableValueExcepion.class,\n+        assertThrows(MissingInjectableValueException.class,\n                 () -> plainMapper.readValue(empty, InputDefault.class));\n-        assertThrows(MissingInjectableValueExcepion.class,\n+        assertThrows(MissingInjectableValueException.class,\n                 () -> plainMapper.readValue(empty, InputDefaultConstructor.class));\n \n-        assertThrows(MissingInjectableValueExcepion.class,\n+        assertThrows(MissingInjectableValueException.class,\n                 () -> plainMapper.readValue(empty, InputTrue.class));\n-        assertThrows(MissingInjectableValueExcepion.class,\n+        assertThrows(MissingInjectableValueException.class,\n                 () -> plainMapper.readValue(empty, InputTrueConstructor.class));\n \n-        assertThrows(MissingInjectableValueExcepion.class,\n+        assertThrows(MissingInjectableValueException.class,\n                 () -> plainMapper.readValue(empty, InputFalse.class));\n-        assertThrows(MissingInjectableValueExcepion.class,\n+        assertThrows(MissingInjectableValueException.class,\n                 () -> plainMapper.readValue(empty, InputFalseConstructor.class));\n     }\n \n@@ -151,14 +151,14 @@ void test2() throws Exception {\n     @Test\n     @DisplayName(\"input YES, injectable NO, useInput DEFAULT|FALSE => exception\")\n     void test3() {\n-        assertThrows(MissingInjectableValueExcepion.class,\n+        assertThrows(MissingInjectableValueException.class,\n                 () -> plainMapper.readValue(input, InputDefault.class));\n-        assertThrows(MissingInjectableValueExcepion.class,\n+        assertThrows(MissingInjectableValueException.class,\n                 () -> plainMapper.readValue(input, InputDefaultConstructor.class));\n \n-        assertThrows(MissingInjectableValueExcepion.class,\n+        assertThrows(MissingInjectableValueException.class,\n                 () -> plainMapper.readValue(input, InputFalse.class));\n-        assertThrows(MissingInjectableValueExcepion.class,\n+        assertThrows(MissingInjectableValueException.class,\n                 () -> plainMapper.readValue(input, InputFalseConstructor.class));\n     }\n \ndiff --git a/src/test/java/tools/jackson/databind/deser/inject/JacksonInject3072Test.java b/src/test/java/tools/jackson/databind/deser/inject/JacksonInject3072Test.java\nindex 7220a971c9..704ba7b4e3 100644\n--- a/src/test/java/tools/jackson/databind/deser/inject/JacksonInject3072Test.java\n+++ b/src/test/java/tools/jackson/databind/deser/inject/JacksonInject3072Test.java\n@@ -7,6 +7,7 @@\n \n import tools.jackson.databind.*;\n import tools.jackson.databind.exc.MissingInjectableValueExcepion;\n+import tools.jackson.databind.exc.MissingInjectableValueException;\n import tools.jackson.databind.testutil.DatabindTestUtil;\n \n import static org.assertj.core.api.AssertionsForClassTypes.assertThat;\n@@ -58,8 +59,8 @@ void testOptionalFieldNotFound() throws Exception {\n \n     @Test\n     void testMandatoryFieldNotFound() {\n-        MissingInjectableValueExcepion exception = assertThrows(\n-                MissingInjectableValueExcepion.class, () -> READER.readValue(\"{}\"));\n+        MissingInjectableValueException exception = assertThrows(\n+                MissingInjectableValueException.class, () -> READER.readValue(\"{}\"));\n \n         assertThat(exception.getMessage())\n             .startsWith(\"No injectable value with id 'id' found (for property 'id')\");\n@@ -72,8 +73,8 @@ void testRequiredAnnotatedField() throws Exception {\n         ObjectReader reader = READER.forType(DtoWithRequired.class)\n             .without(DeserializationFeature.FAIL_ON_UNKNOWN_INJECT_VALUE);\n \n-        MissingInjectableValueExcepion exception = assertThrows(\n-                MissingInjectableValueExcepion.class, () -> reader.readValue(\"{}\"));\n+        MissingInjectableValueException exception = assertThrows(\n+                MissingInjectableValueException.class, () -> reader.readValue(\"{}\"));\n \n         assertThat(exception.getMessage())\n             .startsWith(\"No injectable value with id 'requiredValue' found (for property 'requiredField')\");\n@@ -83,7 +84,7 @@ void testRequiredAnnotatedField() throws Exception {\n                 .addValue(\"id\", \"idValue\"));\n \n         exception = assertThrows(\n-                MissingInjectableValueExcepion.class, () -> reader2.readValue(\"{}\"));\n+                MissingInjectableValueException.class, () -> reader2.readValue(\"{}\"));\n \n         assertThat(exception.getMessage())\n              .startsWith(\"No injectable value with id 'requiredValue' found (for property 'requiredField')\");\n@@ -100,8 +101,8 @@ void testMandatoryFieldNotFoundWithInjectableValues() {\n         ObjectReader reader = READER\n                 .with(new InjectableValues.Std());\n \n-        MissingInjectableValueExcepion exception = assertThrows(\n-                MissingInjectableValueExcepion.class, () -> reader.readValue(\"{}\"));\n+        MissingInjectableValueException exception = assertThrows(\n+                MissingInjectableValueException.class, () -> reader.readValue(\"{}\"));\n \n         assertThat(exception.getMessage())\n             .startsWith(\"No injectable value with id 'id' found (for property 'id')\");\n@@ -142,4 +143,13 @@ void testOptionalFieldNotFoundWithoutInjectableValuesWithDeserializationFeature(\n         assertNull(dto.id);\n         assertNull(dto.optionalField);\n     }\n+\n+    @SuppressWarnings(\"deprecation\")\n+    @Test\n+    void testBackwardCompatWithDeprecatedClassName() throws Exception {\n+        MissingInjectableValueException ex = assertThrows(\n+                MissingInjectableValueException.class,\n+                () -> READER.readValue(\"{}\"));\n+        assertThat(ex).isInstanceOf(MissingInjectableValueExcepion.class);\n+    }\n }\n",
  "problem_statement" : "Fix typo: MissingInjectableValueExcepion → MissingInjectableValueException\n\n## Summary\r\n\r\nFix typo in exception class name:\r\n`MissingInjectableValueExcepion` → `MissingInjectableValueException` (missing \"t\").\r\n\r\n- Added correctly named exception as sub-type of existing one\r\n- Deprecated existing exception\r\n- Updated all in-repo references (prod + tests)\r\n\r\n## Test plan\r\n- [x] ./mvnw test -pl . -Dtest=\"JacksonInject*Test\"",
  "hints_text" : null,
  "created_at" : "Wed Jan 28 01:20:37 CET 2026",
  "version" : null,
  "FAIL_TO_PASS" : [ "JacksonInject1381Test", "JacksonInject3072Test" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=JacksonInject1381Test,JacksonInject3072Test",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 5621,
  "metadata" : null
}, {
  "instance_id" : "FasterXML-jackson-databind-PR-5620",
  "repo" : "FasterXML/jackson-databind",
  "base_commit" : "8c8bd3dbc0ade33ed96b7432acdcdd150c793086",
  "patch" : "diff --git a/release-notes/CREDITS-2.x b/release-notes/CREDITS-2.x\nindex 52be6b909f..de751c7eb5 100644\n--- a/release-notes/CREDITS-2.x\n+++ b/release-notes/CREDITS-2.x\n@@ -1994,3 +1994,7 @@ Johnny Lim (@izeye)\n Hélios Gilles (@RoiSoleil)\n  * Contributed #5413: Add/support forward reference resolution for array values\n   [2.21.0]\n+\n+Brandon Schmitt (@BrandonSchmitt)\n+ * Reported #5616: `ObjectWriter` serializes `Optional`s with subtypes incompletely\n+  [2.21.1]\ndiff --git a/release-notes/VERSION-2.x b/release-notes/VERSION-2.x\nindex fce978c962..6397922417 100644\n--- a/release-notes/VERSION-2.x\n+++ b/release-notes/VERSION-2.x\n@@ -6,7 +6,9 @@ Project: jackson-databind\n \n 2.21.1 (not yet released)\n \n-No changes since 2.21.0\n+#5616: `ObjectWriter` serializes Reference types (`AtomicReference`,\n+  `Optional`) containing subtypes incompletely\n+ (reported by Brandon S)\n \n 2.21.0 (18-Jan-2026)\n \ndiff --git a/src/main/java/com/fasterxml/jackson/databind/ser/std/ReferenceTypeSerializer.java b/src/main/java/com/fasterxml/jackson/databind/ser/std/ReferenceTypeSerializer.java\nindex c80bf5afbd..6585d29af7 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/ReferenceTypeSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/ReferenceTypeSerializer.java\n@@ -210,7 +210,9 @@ public JsonSerializer<?> createContextual(SerializerProvider provider,\n             ser = _valueSerializer;\n             if (ser == null) {\n                 // A few conditions needed to be able to fetch serializer here:\n-                if (_useStatic(provider, property, _referredType)) {\n+                // [databind#5616]: If we have a TypeSerializer for polymorphic types,\n+                // do NOT use static typing -- need dynamic lookup for subtypes\n+                if ((typeSer == null) && _useStatic(provider, property, _referredType)) {\n                     ser = _findSerializer(provider, _referredType, property);\n                 }\n             } else {\n",
  "test_patch" : "diff --git a/src/test/java/com/fasterxml/jackson/databind/ser/jdk/AtomicTypeSerializationTest.java b/src/test/java/com/fasterxml/jackson/databind/ser/jdk/AtomicTypeSerializationTest.java\nindex 4393bbfd14..7a3e34dd97 100644\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/jdk/AtomicTypeSerializationTest.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/jdk/AtomicTypeSerializationTest.java\n@@ -179,4 +179,17 @@ public void testWithUnwrappableUnwrapped() throws Exception\n         assertEquals(a2q(\"{'maybeText':'value'}\"),\n                 MAPPER.writeValueAsString(new MyBean2565()));\n     }\n+\n+    // [databind#5616]: AtomicReference with subtype, serialization as supertype\n+    @Test\n+    public void testAtomicReferenceWithSubtypeProperties() throws Exception\n+    {\n+        Strategy object = new Foo(99);\n+\n+        String json = MAPPER.writerFor(new com.fasterxml.jackson.core.type.TypeReference<AtomicReference<Strategy>>() {})\n+                .writeValueAsString(new AtomicReference<>(object));\n+\n+        // Must include subtype property \"foo\", not just type info\n+        assertEquals(\"{\\\"type\\\":\\\"Foo\\\",\\\"foo\\\":99}\", json);\n+    }\n }\n",
  "problem_statement" : "### Search before asking\n\n- [x] I searched in the [issues](https://github.com/FasterXML/jackson-databind/issues) and found nothing similar.\n\n### Describe the bug\n\nWhen you try to serialize an `Optional<Supertype>` and provide an appropriate `TypeReference`, additional object properties in sub-types are not serialized. For `List<Supertype>` this works.\n\n### Version Information\n\nJackson Databind 3.0.4 and also Jackson Databind 2.21.0\n\n### Reproduction\n\n```java\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.util.List;\nimport java.util.Optional;\n\nimport org.junit.jupiter.api.Test;\n\nimport com.fasterxml.jackson.annotation.JsonSubTypes;\nimport com.fasterxml.jackson.annotation.JsonTypeInfo;\n\nimport tools.jackson.core.type.TypeReference;\nimport tools.jackson.databind.json.JsonMapper;\n\nclass OptionalAndPolymorphismTest {\n\t@Test\n\tvoid test() {\n\t\tvar jsonMapper = new JsonMapper();\n\t\tSupertype object = new Supertype.Subtype();\n\n\t\t// succeeds\n\t\tassertEquals(\"[{\\\"@type\\\":\\\"subtype\\\",\\\"content\\\":\\\"hello\\\"}]\",\n\t\t\t\tjsonMapper.writerFor(new TypeReference<List<Supertype>>() {}).writeValueAsString(List.of(object)));\n\n\t\t// fails, actual: '{\"@type\":\"subtype\"}'\n\t\tassertEquals(\"{\\\"@type\\\":\\\"subtype\\\",\\\"content\\\":\\\"hello\\\"}\",\n\t\t\t\tjsonMapper.writerFor(new TypeReference<Optional<Supertype>>() {}).writeValueAsString(Optional.of(object)));\n\t}\n\n\t@JsonTypeInfo(use = JsonTypeInfo.Id.NAME)\n\t@JsonSubTypes({\n\t\t\t@JsonSubTypes.Type(value = Supertype.Subtype.class, name = \"subtype\"),\n\t})\n\tinterface Supertype {\n\t\tclass Subtype implements Supertype {\n\t\t\tpublic String content = \"hello\";\n\t\t}\n\t}\n}\n``` \n\n\n### Expected behavior\n\nWhen providing a `TypeReference<Optional<Supertype>>` I expect that the content of the subtype is also serialized, just like for `TypeReference<List<Supertype>>`\n\n### Additional context\n\n_No response_",
  "hints_text" : null,
  "created_at" : "Tue Jan 27 04:07:02 CET 2026",
  "version" : null,
  "FAIL_TO_PASS" : [ "AtomicTypeSerializationTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=AtomicTypeSerializationTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : 5616,
  "pull_number" : 5620,
  "metadata" : null
}, {
  "instance_id" : "FasterXML-jackson-databind-PR-5619",
  "repo" : "FasterXML/jackson-databind",
  "base_commit" : "e7d051a5cbfde7b59e235f2ceaa38f098137f1a3",
  "patch" : "diff --git a/release-notes/CREDITS b/release-notes/CREDITS\nindex e74920ed9c..723d60cffd 100644\n--- a/release-notes/CREDITS\n+++ b/release-notes/CREDITS\n@@ -224,3 +224,7 @@ Réda Housni Alaoui (@reda-alaoui)\n Flinter (@jhan0121)\n  * Contributed #5595: Add `FunctionalScalarDeserializer` for functional-style deserialization\n   [3.1.0]\n+\n+Brandon Schmitt (@BrandonSchmitt)\n+ * Reported #5616: `ObjectWriter` serializes `Optional`s with subtypes incompletely\n+  [3.1.0]\ndiff --git a/release-notes/VERSION b/release-notes/VERSION\nindex c18fbec70d..c1a9a10d79 100644\n--- a/release-notes/VERSION\n+++ b/release-notes/VERSION\n@@ -150,6 +150,9 @@ Versions: 3.x (for earlier see VERSION-2.x)\n #5595: Add `FunctionalScalarDeserializer` for functional-style deserialization\n  (contributed by @jhan0121)\n #5599: Reduce mutability of `JsonFormatVisitor` types in 3.1\n+#5616: `ObjectWriter` serializes `Optional`s with subtypes incompletely\n+ (reported by Brandon S)\n+ (implemented by @cowtowncoder, w/ Claude code)\n \n 3.0.4 (not yet released)\n \ndiff --git a/src/main/java/tools/jackson/databind/ser/std/ReferenceTypeSerializer.java b/src/main/java/tools/jackson/databind/ser/std/ReferenceTypeSerializer.java\nindex 0413f848c0..6fcb819793 100644\n--- a/src/main/java/tools/jackson/databind/ser/std/ReferenceTypeSerializer.java\n+++ b/src/main/java/tools/jackson/databind/ser/std/ReferenceTypeSerializer.java\n@@ -163,7 +163,9 @@ public ValueSerializer<?> createContextual(SerializationContext ctxt,\n             ser = _valueSerializer;\n             if (ser == null) {\n                 // A few conditions needed to be able to fetch serializer here:\n-                if (_useStatic(ctxt, property, _referredType)) {\n+                // [databind#5616]: If we have a TypeSerializer for polymorphic types,\n+                // do NOT use static typing -- need dynamic lookup for subtypes\n+                if ((typeSer == null) && _useStatic(ctxt, property, _referredType)) {\n                     ser = _findSerializer(ctxt, _referredType, property);\n                 }\n             } else {\n",
  "test_patch" : "diff --git a/src/test/java/tools/jackson/databind/ext/jdk8/OptionalSubtypeSerializationTest.java b/src/test/java/tools/jackson/databind/ext/jdk8/OptionalSubtypeSerializationTest.java\nnew file mode 100644\nindex 0000000000..8fd1e01823\n--- /dev/null\n+++ b/src/test/java/tools/jackson/databind/ext/jdk8/OptionalSubtypeSerializationTest.java\n@@ -0,0 +1,90 @@\n+package tools.jackson.databind.ext.jdk8;\n+\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import com.fasterxml.jackson.annotation.JsonSubTypes;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+\n+import tools.jackson.core.type.TypeReference;\n+import tools.jackson.databind.ObjectMapper;\n+import tools.jackson.databind.testutil.DatabindTestUtil;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+/**\n+ * Test for <a href=\"https://github.com/FasterXML/jackson-databind/issues/5616\">\n+ * [databind#5616]: ObjectWriter Serializes Optionals with SubTypes Incompletely\n+ * </a>\n+ * <p>\n+ * When serializing an {@code Optional<Supertype>} with a {@code TypeReference},\n+ * subtype-specific properties should be included in the output.\n+ */\n+public class OptionalSubtypeSerializationTest extends DatabindTestUtil\n+{\n+    @JsonTypeInfo(use = JsonTypeInfo.Id.NAME)\n+    @JsonSubTypes({\n+        @JsonSubTypes.Type(value = Supertype.Subtype.class, name = \"subtype\"),\n+    })\n+    interface Supertype {\n+        class Subtype implements Supertype {\n+            public String content = \"hello\";\n+        }\n+    }\n+\n+    private final ObjectMapper MAPPER = newJsonMapper();\n+\n+    // [databind#5616]: List<Supertype> works correctly (baseline test)\n+    @Test\n+    public void testListWithSubtypeProperties() throws Exception\n+    {\n+        Supertype object = new Supertype.Subtype();\n+\n+        String json = MAPPER.writerFor(new TypeReference<List<Supertype>>() {})\n+                .writeValueAsString(List.of(object));\n+\n+        // This works: subtype property \"content\" is included\n+        assertEquals(\"[{\\\"@type\\\":\\\"subtype\\\",\\\"content\\\":\\\"hello\\\"}]\", json);\n+    }\n+\n+    // [databind#5616]: Optional<Supertype> loses subtype properties\n+    @Test\n+    public void testOptionalWithSubtypeProperties() throws Exception\n+    {\n+        Supertype object = new Supertype.Subtype();\n+\n+        String json = MAPPER.writerFor(new TypeReference<Optional<Supertype>>() {})\n+                .writeValueAsString(Optional.of(object));\n+\n+        // This fails: actual output is '{\"@type\":\"subtype\"}' - missing \"content\" property\n+        assertEquals(\"{\\\"@type\\\":\\\"subtype\\\",\\\"content\\\":\\\"hello\\\"}\", json);\n+    }\n+\n+    // Additional test: direct subtype serialization works\n+    @Test\n+    public void testDirectSubtypeSerialization() throws Exception\n+    {\n+        Supertype.Subtype object = new Supertype.Subtype();\n+\n+        String json = MAPPER.writeValueAsString(object);\n+\n+        // Direct serialization includes all properties\n+        assertEquals(\"{\\\"@type\\\":\\\"subtype\\\",\\\"content\\\":\\\"hello\\\"}\", json);\n+    }\n+\n+    // Additional test: Optional without TypeReference uses runtime type\n+    @Test\n+    public void testOptionalWithoutTypeReference() throws Exception\n+    {\n+        Supertype object = new Supertype.Subtype();\n+\n+        // When not using TypeReference, it serializes based on actual runtime type\n+        // which is Subtype, so @type is not needed (not serializing as Supertype)\n+        String json = MAPPER.writeValueAsString(Optional.of(object));\n+\n+        // Serializes as Subtype directly (no @type discriminator needed)\n+        assertEquals(\"{\\\"content\\\":\\\"hello\\\"}\", json);\n+    }\n+}\n",
  "problem_statement" : "### Search before asking\n\n- [x] I searched in the [issues](https://github.com/FasterXML/jackson-databind/issues) and found nothing similar.\n\n### Describe the bug\n\nWhen you try to serialize an `Optional<Supertype>` and provide an appropriate `TypeReference`, additional object properties in sub-types are not serialized. For `List<Supertype>` this works.\n\n### Version Information\n\nJackson Databind 3.0.4 and also Jackson Databind 2.21.0\n\n### Reproduction\n\n```java\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.util.List;\nimport java.util.Optional;\n\nimport org.junit.jupiter.api.Test;\n\nimport com.fasterxml.jackson.annotation.JsonSubTypes;\nimport com.fasterxml.jackson.annotation.JsonTypeInfo;\n\nimport tools.jackson.core.type.TypeReference;\nimport tools.jackson.databind.json.JsonMapper;\n\nclass OptionalAndPolymorphismTest {\n\t@Test\n\tvoid test() {\n\t\tvar jsonMapper = new JsonMapper();\n\t\tSupertype object = new Supertype.Subtype();\n\n\t\t// succeeds\n\t\tassertEquals(\"[{\\\"@type\\\":\\\"subtype\\\",\\\"content\\\":\\\"hello\\\"}]\",\n\t\t\t\tjsonMapper.writerFor(new TypeReference<List<Supertype>>() {}).writeValueAsString(List.of(object)));\n\n\t\t// fails, actual: '{\"@type\":\"subtype\"}'\n\t\tassertEquals(\"{\\\"@type\\\":\\\"subtype\\\",\\\"content\\\":\\\"hello\\\"}\",\n\t\t\t\tjsonMapper.writerFor(new TypeReference<Optional<Supertype>>() {}).writeValueAsString(Optional.of(object)));\n\t}\n\n\t@JsonTypeInfo(use = JsonTypeInfo.Id.NAME)\n\t@JsonSubTypes({\n\t\t\t@JsonSubTypes.Type(value = Supertype.Subtype.class, name = \"subtype\"),\n\t})\n\tinterface Supertype {\n\t\tclass Subtype implements Supertype {\n\t\t\tpublic String content = \"hello\";\n\t\t}\n\t}\n}\n``` \n\n\n### Expected behavior\n\nWhen providing a `TypeReference<Optional<Supertype>>` I expect that the content of the subtype is also serialized, just like for `TypeReference<List<Supertype>>`\n\n### Additional context\n\n_No response_",
  "hints_text" : null,
  "created_at" : "Tue Jan 27 02:42:27 CET 2026",
  "version" : null,
  "FAIL_TO_PASS" : [ "OptionalSubtypeSerializationTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=OptionalSubtypeSerializationTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : 5616,
  "pull_number" : 5619,
  "metadata" : null
}, {
  "instance_id" : "FasterXML-jackson-databind-PR-5614",
  "repo" : "FasterXML/jackson-databind",
  "base_commit" : "0c4c8f9ba6138025791e2105b9fd0f18af8cc8e9",
  "patch" : "diff --git a/src/main/java/tools/jackson/databind/deser/std/FunctionalScalarDeserializer.java b/src/main/java/tools/jackson/databind/deser/std/FunctionalScalarDeserializer.java\nindex 9f47c6bd1d..1cc22d6b3c 100644\n--- a/src/main/java/tools/jackson/databind/deser/std/FunctionalScalarDeserializer.java\n+++ b/src/main/java/tools/jackson/databind/deser/std/FunctionalScalarDeserializer.java\n@@ -22,6 +22,15 @@\n  * supports other JSON scalar types via {@code getValueAsString()} coercion.\n  * Non-scalar JSON values (arrays, objects, embedded objects) are rejected.\n  * <p>\n+ * <b>Error handling:</b>\n+ * <ul>\n+ *   <li>{@link JacksonException} thrown by user code is propagated as-is.</li>\n+ *   <li>Other exceptions are wrapped in\n+ *       {@link tools.jackson.databind.exc.InvalidFormatException}.</li>\n+ *   <li>If {@link tools.jackson.databind.DeserializationFeature#WRAP_EXCEPTIONS}\n+ *       is disabled, {@link RuntimeException} is thrown as-is without wrapping.</li>\n+ * </ul>\n+ * <p>\n  * Usage examples:\n  * <pre>\n  * // Simple case - method reference\n",
  "test_patch" : "diff --git a/src/test/java/tools/jackson/databind/deser/std/FunctionalScalarDeserializer4004Test.java b/src/test/java/tools/jackson/databind/deser/std/FunctionalScalarDeserializer4004Test.java\nindex 5374c9b1af..4a5b0590e9 100644\n--- a/src/test/java/tools/jackson/databind/deser/std/FunctionalScalarDeserializer4004Test.java\n+++ b/src/test/java/tools/jackson/databind/deser/std/FunctionalScalarDeserializer4004Test.java\n@@ -5,8 +5,11 @@\n \n import org.junit.jupiter.api.Test;\n \n+import tools.jackson.core.JsonParser;\n import tools.jackson.core.type.TypeReference;\n \n+import tools.jackson.databind.DatabindException;\n+import tools.jackson.databind.DeserializationFeature;\n import tools.jackson.databind.JavaType;\n import tools.jackson.databind.ObjectMapper;\n import tools.jackson.databind.cfg.CoercionAction;\n@@ -514,4 +517,95 @@ public void testBiFunctionThrowsCustomException() throws Exception\n             verifyException(e, \"BiFunction custom error\");\n         }\n     }\n+\n+    @Test\n+    public void testFunctionThrowsJacksonExceptionPropagatedAsIs() throws Exception\n+    {\n+        SimpleModule module = new SimpleModule(\"test\");\n+        module.addDeserializer(Bar.class,\n+                new FunctionalScalarDeserializer<>(Bar.class, s -> {\n+                    throw DatabindException.from((JsonParser) null, \"User JacksonException\");\n+                }));\n+\n+        ObjectMapper mapper = jsonMapperBuilder()\n+                .addModule(module)\n+                .build();\n+\n+        try {\n+            mapper.readValue(\"\\\"test\\\"\", Bar.class);\n+            fail(\"Should throw exception\");\n+        } catch (DatabindException e) {\n+            assertEquals(\"User JacksonException\", e.getOriginalMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void testBiFunctionThrowsJacksonExceptionPropagatedAsIs() throws Exception\n+    {\n+        SimpleModule module = new SimpleModule(\"test\");\n+        module.addDeserializer(Bar.class,\n+                new FunctionalScalarDeserializer<>(Bar.class, (p, ctx) -> {\n+                    throw DatabindException.from(p, \"User BiFunction JacksonException\");\n+                }));\n+\n+        ObjectMapper mapper = jsonMapperBuilder()\n+                .addModule(module)\n+                .build();\n+\n+        try {\n+            mapper.readValue(\"\\\"test\\\"\", Bar.class);\n+            fail(\"Should throw exception\");\n+        } catch (DatabindException e) {\n+            assertEquals(\"User BiFunction JacksonException\", e.getOriginalMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void testWrapExceptionsEnabled() throws Exception\n+    {\n+        SimpleModule module = new SimpleModule(\"test\");\n+        module.addDeserializer(Bar.class,\n+                new FunctionalScalarDeserializer<>(Bar.class, s -> {\n+                    throw new RuntimeException(\"User error\");\n+                }));\n+\n+        ObjectMapper mapper = jsonMapperBuilder()\n+                .addModule(module)\n+                .enable(DeserializationFeature.WRAP_EXCEPTIONS)\n+                .build();\n+\n+        try {\n+            mapper.readValue(\"\\\"test\\\"\", Bar.class);\n+            fail(\"Should throw exception\");\n+        } catch (MismatchedInputException e) {\n+            verifyException(e, \"not a valid textual representation\");\n+            verifyException(e, \"User error\");\n+        } catch (Exception e) {\n+            fail(\"Should wrap as MismatchedInputException, got: \" + e.getClass().getName());\n+        }\n+    }\n+\n+    @Test\n+    public void testWrapExceptionsDisabled() throws Exception\n+    {\n+        SimpleModule module = new SimpleModule(\"test\");\n+        module.addDeserializer(Bar.class,\n+                new FunctionalScalarDeserializer<>(Bar.class, s -> {\n+                    throw new RuntimeException(\"User error\");\n+                }));\n+\n+        ObjectMapper mapper = jsonMapperBuilder()\n+                .addModule(module)\n+                .disable(DeserializationFeature.WRAP_EXCEPTIONS)\n+                .build();\n+\n+        try {\n+            mapper.readValue(\"\\\"test\\\"\", Bar.class);\n+            fail(\"Should throw exception\");\n+        } catch (MismatchedInputException e) {\n+            fail(\"Should not wrap exception when WRAP_EXCEPTIONS is disabled\");\n+        } catch (RuntimeException e) {\n+            verifyException(e, \"User error\");\n+        }\n+    }\n }\n",
  "problem_statement" : "Follow up on Issue #4004 and PR https://github.com/FasterXML/jackson-databind/pull/5595 \n\n### Is your feature request related to a problem? Please describe.\n\nLong story short, **error types are confusing and sometimes misleading.**\n\nJackson 3.1 introduced `FunctionalScalarDeserializer` that provides a rich and extensible deserialization model, but error handling in user-provided deserializers is currently too loose, leading to loss of semantic meaning\nin exception types.\n\n#### Problematic scenario\n\n\n\nConsider the following test:\n\n```java\n@Test\npublic void justThrowErrorEvenWithValidFormat() throws Exception\n{\n    SimpleModule module = new SimpleModule(\"test\");\n    module.addDeserializer(Bar.class,\n            new FunctionalScalarDeserializer<>(Bar.class, (p, ctx) -> {\n                // 1) Blindly throw user/business exception\n                throw new IllegalArgumentException(\n                        \"BiFunction error: \" + p.getValueAsString());\n            }));\n\n    ObjectMapper mapper = jsonMapperBuilder()\n            .addModule(module)\n            .build();\n\n    try {\n        // 2) JSON input is fully valid\n        mapper.readValue(\"{\\\"bar\\\":\\\"fieldValue\\\"}\", BarWrapper.class);\n        fail();\n    } catch (InvalidFormatException e) {\n        // 3) Jackson wraps the exception as InvalidFormatException\n        verifyException(e, \"Cannot deserialize\");\n    }\n}\n```\n\nIn this case:\n1. User code throws an arbitrary exception (`IllegalArgumentException`)\n2. The JSON input is valid\n3. Jackson wraps the failure as `InvalidFormatException` <--- why?\n\nFrom a user perspective, encountering `InvalidFormatException` strongly suggests that the input value itself is invalid or malformed.\nHowever, in this scenario the failure is entirely due to application/domain logic,\nnot input format.\n\nThis makes it difficult for users to correctly interpret and classify errors\n(e.g. client error vs server error).\n\nThere could be more cases.\n\n### Describe the solution you'd like\n\n**Goal: Make exception wrapping from user-provided deserializers predictable**\n\nJackson should apply deterministic wrapping rules when exceptions are thrown from user-provided deserialization callbacks (for example,\n`FunctionalScalarDeserializer`), so that the resulting exception type reflects\nthe nature of the failure.\n\n---\n\n### Proposed behavior\n\n1. Provide guidelines on HOW user should throw error (and which type)\n2. DO improve Exception handling logic within `FunctionalScalarDeserializer`\n\nBelow is my rough idea of mentioned guideline.\n```java\n/**\n * A general-purpose deserializer that uses a {@link Function} or {@link BiFunction}\n * to convert JSON scalar values (strings, numbers, booleans) into target type instances.\n * <p>\n * This deserializer is primarily designed for String-based conversions but also\n * supports other JSON scalar types via {@code getValueAsString()} coercion.\n * Non-scalar JSON values (arrays, objects, embedded objects) are rejected.\n * <p>\n * <b>Error handling guidelines:</b>\n * <ul>\n *   <li>Exceptions of type {@link com.fasterxml.jackson.databind.exc.InvalidFormatException}\n *       thrown by user code are treated as explicit signals of invalid input values\n *       and are propagated as-is.</li>\n *   <li>{@link com.fasterxml.jackson.databind.JsonMappingException} may be thrown by\n *       user code to indicate a deliberate mapping failure and will be propagated.</li>\n *   <li>Other runtime exceptions thrown by user code are considered application or\n *       domain failures and may be wrapped as {@link com.fasterxml.jackson.databind.JsonMappingException}\n *       rather than being reported as input-format errors.</li>\n * </ul>\n * <p>\n * Usage examples:\n * ...... rest omitted.....\n```\n\n---\n\n### Exception handling rules\n\n| Thrown by user code | Jackson behavior |\n|---------------------|------------------|\n| InvalidFormatException | Propagate as-is |\n| JsonMappingException | Propagate as-is |\n| Other Exceptions | Wrap in JsonMappingException |\n\n---\n\n### Resulting Benefit\n\n- Valid JSON input is not reported as format error\n- User intent is preserved when signaling mapping failures\n- Custom deserializer error behavior becomes consistent and predictable\n",
  "hints_text" : null,
  "created_at" : "Mon Jan 26 13:32:08 CET 2026",
  "version" : null,
  "FAIL_TO_PASS" : [ "FunctionalScalarDeserializer4004Test" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=FunctionalScalarDeserializer4004Test",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : 5608,
  "pull_number" : 5614,
  "metadata" : null
}, {
  "instance_id" : "FasterXML-jackson-databind-PR-5613",
  "repo" : "FasterXML/jackson-databind",
  "base_commit" : "19c42ead6449f7e23e0a05692925d6b30c1378ce",
  "patch" : "diff --git a/release-notes/CREDITS b/release-notes/CREDITS\nindex 723d60cffd..c599ed6595 100644\n--- a/release-notes/CREDITS\n+++ b/release-notes/CREDITS\n@@ -183,6 +183,11 @@ Kenneth Jorgensen (@kennethjor)\n   `@JsonDeserialize.builderPrefix` property\n   [3.1.0]\n \n+Lee Jiwon (@dlwldnjs1009)\n+ * Implemented #3284: Backward compatibility for timezone formats of UTC Date\n+   serialization\n+  [3.1.0]\n+\n Garret Wilson (@garretwilson)\n  * Suggested #4157: Add `MapperFeature.INFER_RECORD_GETTERS_FROM_COMPONENTS_ONLY` to ignore\n    getter method auto-detection for Records\ndiff --git a/release-notes/VERSION b/release-notes/VERSION\nindex c1a9a10d79..5c01e21b63 100644\n--- a/release-notes/VERSION\n+++ b/release-notes/VERSION\n@@ -51,6 +51,10 @@ Versions: 3.x (for earlier see VERSION-2.x)\n #2686: `@JsonBackReference` does not work with a builder\n  (reported by @janrieke)\n  (fix by @JacksonJang)\n+#3284: Backward compatibility for timezone formats of UTC Date\n+  serialization\n+ (requested by @arungitan)\n+ (implemented by Lee Jiwon)\n #3964: Deserialization issue: MismatchedInputException, Bean not\n   yet resolved\n  (reported by @detomarco)\ndiff --git a/src/main/java/tools/jackson/databind/SerializationContext.java b/src/main/java/tools/jackson/databind/SerializationContext.java\nindex 5e1047633d..2747e8d6a8 100644\n--- a/src/main/java/tools/jackson/databind/SerializationContext.java\n+++ b/src/main/java/tools/jackson/databind/SerializationContext.java\n@@ -35,6 +35,7 @@\n import tools.jackson.databind.ser.std.NullSerializer;\n import tools.jackson.databind.type.TypeFactory;\n import tools.jackson.databind.util.ClassUtil;\n+import tools.jackson.databind.util.StdDateFormat;\n import tools.jackson.databind.util.TokenBuffer;\n \n /**\n@@ -1451,8 +1452,15 @@ protected final DateFormat _dateFormat()\n         // At this point, all timezone configuration should have occurred, with respect\n         // to default dateformat configuration. But we still better clone\n         // an instance as formatters are stateful, not thread-safe.\n-        DateFormat df = _config.getDateFormat();\n-        _dateFormat = df = (DateFormat) df.clone();\n+        DateFormat df = (DateFormat) _config.getDateFormat().clone();\n+\n+        // [databind#3284]: Configure zero-offset format based on DateTimeFeature\n+        if (df instanceof StdDateFormat sdf\n+                && isEnabled(DateTimeFeature.WRITE_UTC_AS_OFFSET)) {\n+            df = sdf.withZeroOffsetAsZ(false);\n+        }\n+\n+        _dateFormat = df;\n         // [databind#939]: 26-Sep-2015, tatu: With 2.6, formatter has been (pre)configured\n         // with TimeZone, so we should NOT try overriding it unlike with earlier versions\n         /*\ndiff --git a/src/main/java/tools/jackson/databind/cfg/DateTimeFeature.java b/src/main/java/tools/jackson/databind/cfg/DateTimeFeature.java\nindex 7d314d6683..083396f3f2 100644\n--- a/src/main/java/tools/jackson/databind/cfg/DateTimeFeature.java\n+++ b/src/main/java/tools/jackson/databind/cfg/DateTimeFeature.java\n@@ -264,6 +264,36 @@ public enum DateTimeFeature implements DatatypeFeature\n      */\n     WRITE_DURATIONS_AS_TIMESTAMPS(false),\n \n+    /**\n+     * Feature that controls how <b>zero timezone offset</b> ({@code offset == 0})\n+     * is serialized: as \"Z\" (disabled) or as numeric offset\n+     * \"+00:00\" or \"+0000\" (enabled).\n+     *<p>\n+     * NOTE: the name \"UTC\" is historical; this feature applies to <b>all timezones\n+     * where the actual offset is zero</b> at serialization time (e.g., \"UTC\", \"GMT\",\n+     * \"Europe/London\" in winter), regardless of the timezone ID.\n+     *<p>\n+     * This feature only controls zero-offset formatting when using \"classic\" JDK date\n+     * types ({@link java.util.Date}, {@link java.util.Calendar}) and with\n+     * {@link tools.jackson.databind.util.StdDateFormat} (the default).\n+     * For Java 8 ({@code java.time.*}) and Joda date/time types, formatting is\n+     * controlled by {@code DateTimeFormatter} configuration and this feature\n+     * has no effect.\n+     * Custom {@link java.text.DateFormat} instances are also not modified.\n+     *<p>\n+     * NOTE: when enabled, this feature overrides any {@code StdDateFormat}\n+     * configuration set via\n+     * {@link tools.jackson.databind.util.StdDateFormat#withZeroOffsetAsZ(boolean)}.\n+     *<p>\n+     * When enabled, the colon format (\"+00:00\" vs \"+0000\") is controlled by\n+     * {@link tools.jackson.databind.util.StdDateFormat#withColonInTimeZone(boolean)}.\n+     *<p>\n+     * Feature is disabled by default to maintain Jackson 3.x standard behavior (\"Z\");\n+     * it is usually enabled to achieve behavior similar to Jackson 2.x.\n+     *\n+     * @since 3.1\n+     */\n+    WRITE_UTC_AS_OFFSET(false),\n     ;\n \n     private final static int FEATURE_INDEX = DatatypeFeatures.FEATURE_INDEX_DATETIME;\ndiff --git a/src/main/java/tools/jackson/databind/cfg/MapperBuilder.java b/src/main/java/tools/jackson/databind/cfg/MapperBuilder.java\nindex dce9905723..7531c4a54b 100644\n--- a/src/main/java/tools/jackson/databind/cfg/MapperBuilder.java\n+++ b/src/main/java/tools/jackson/databind/cfg/MapperBuilder.java\n@@ -833,6 +833,7 @@ public B configureForJackson2() {\n         return disable(DateTimeFeature.ONE_BASED_MONTHS)\n                 .enable(DateTimeFeature.WRITE_DATES_AS_TIMESTAMPS)\n                 .enable(DateTimeFeature.WRITE_DURATIONS_AS_TIMESTAMPS)\n+                .enable(DateTimeFeature.WRITE_UTC_AS_OFFSET) // [databind#3824]\n                 .disable(DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES)\n                 .disable(DeserializationFeature.FAIL_ON_TRAILING_TOKENS)\n                 .enable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)\ndiff --git a/src/main/java/tools/jackson/databind/util/StdDateFormat.java b/src/main/java/tools/jackson/databind/util/StdDateFormat.java\nindex 8a20048093..843196e2b1 100644\n--- a/src/main/java/tools/jackson/databind/util/StdDateFormat.java\n+++ b/src/main/java/tools/jackson/databind/util/StdDateFormat.java\n@@ -150,6 +150,18 @@ public class StdDateFormat\n      */\n     protected boolean _tzSerializedWithColon = true;\n \n+    /**\n+     * Whether zero timezone offset should be serialized as \"Z\" (true, default in 3.x)\n+     * or as numeric offset \"+00:00\"/\"+0000\" (false, legacy 2.x behavior).\n+     *<p>\n+     * NOTE: Applies to ALL timezones with zero offset, not just UTC TimeZone ID.\n+     *<p>\n+     * Default is {@code true} in Jackson 3.0; was effectively {@code false} in 2.x.\n+     *\n+     * @since 3.1\n+     */\n+    protected boolean _writeZeroOffsetAsZ = true;\n+\n     /*\n     /**********************************************************************\n     /* Life cycle, accessing singleton \"standard\" formats\n@@ -157,15 +169,26 @@ public class StdDateFormat\n      */\n \n     public StdDateFormat() {\n-        _locale = DEFAULT_LOCALE;\n+        // NOTE: _timezone intentionally left null (means \"use default when needed\")\n+        // Default 3.x behavior: colon in offset (\"+HH:mm\") and \"Z\" for zero offset\n+        this(null, DEFAULT_LOCALE, null, true, true);\n     }\n \n     protected StdDateFormat(TimeZone tz, Locale loc, Boolean lenient,\n             boolean formatTzOffsetWithColon) {\n+        this(tz, loc, lenient, formatTzOffsetWithColon, true);\n+    }\n+\n+    /**\n+     * @since 3.1\n+     */\n+    protected StdDateFormat(TimeZone tz, Locale loc, Boolean lenient,\n+            boolean formatTzOffsetWithColon, boolean writeZeroOffsetAsZ) {\n         _timezone = tz;\n         _locale = loc;\n         _lenient = lenient;\n         _tzSerializedWithColon = formatTzOffsetWithColon;\n+        _writeZeroOffsetAsZ = writeZeroOffsetAsZ;\n     }\n \n     public static TimeZone getDefaultTimeZone() {\n@@ -183,7 +206,7 @@ public StdDateFormat withTimeZone(TimeZone tz) {\n         if ((tz == _timezone) || tz.equals(_timezone)) {\n             return this;\n         }\n-        return new StdDateFormat(tz, _locale, _lenient, _tzSerializedWithColon);\n+        return new StdDateFormat(tz, _locale, _lenient, _tzSerializedWithColon, _writeZeroOffsetAsZ);\n     }\n \n     /**\n@@ -196,7 +219,7 @@ public StdDateFormat withLocale(Locale loc) {\n         if (loc.equals(_locale)) {\n             return this;\n         }\n-        return new StdDateFormat(_timezone, loc, _lenient, _tzSerializedWithColon);\n+        return new StdDateFormat(_timezone, loc, _lenient, _tzSerializedWithColon, _writeZeroOffsetAsZ);\n     }\n \n     /**\n@@ -208,7 +231,7 @@ public StdDateFormat withLenient(Boolean b) {\n         if (_equals(b, _lenient)) {\n             return this;\n         }\n-        return new StdDateFormat(_timezone, _locale, b, _tzSerializedWithColon);\n+        return new StdDateFormat(_timezone, _locale, b, _tzSerializedWithColon, _writeZeroOffsetAsZ);\n     }\n \n     /**\n@@ -226,14 +249,34 @@ public StdDateFormat withColonInTimeZone(boolean b) {\n         if (_tzSerializedWithColon == b) {\n             return this;\n         }\n-        return new StdDateFormat(_timezone, _locale, _lenient, b);\n-     }\n+        return new StdDateFormat(_timezone, _locale, _lenient, b, _writeZeroOffsetAsZ);\n+    }\n+\n+    /**\n+     * \"Mutant factory\" method that returns an instance that controls whether\n+     * zero timezone offset is serialized as \"Z\" ({@code true}) or as numeric\n+     * offset \"+00:00\"/\"+0000\" ({@code false}).\n+     *<p>\n+     * NOTE: Applies to ALL timezones with zero offset, not just UTC TimeZone ID.\n+     *<p>\n+     * When writing numeric offset, the colon inclusion is controlled by\n+     * {@link #withColonInTimeZone(boolean)}.\n+     *\n+     * @since 3.1\n+     */\n+    public StdDateFormat withZeroOffsetAsZ(boolean b) {\n+        if (_writeZeroOffsetAsZ == b) {\n+            return this;\n+        }\n+        return new StdDateFormat(_timezone, _locale, _lenient,\n+                _tzSerializedWithColon, b);\n+    }\n \n     @Override\n     public StdDateFormat clone() {\n         // Although there isn't that much state to share, we do need to\n         // orchestrate a bit, mostly since timezones may be changed\n-        return new StdDateFormat(_timezone, _locale, _lenient, _tzSerializedWithColon);\n+        return new StdDateFormat(_timezone, _locale, _lenient, _tzSerializedWithColon, _writeZeroOffsetAsZ);\n     }\n \n     /*\n@@ -417,21 +460,39 @@ protected void _format(TimeZone tz, Locale loc, Date date,\n \n         int offset = tz.getOffset(cal.getTimeInMillis());\n         if (offset != 0) {\n-            int hours = Math.abs((offset / (60 * 1000)) / 60);\n-            int minutes = Math.abs((offset / (60 * 1000)) % 60);\n-            buffer.append(offset < 0 ? '-' : '+');\n-            pad2(buffer, hours);\n-            if( _tzSerializedWithColon ) {\n-                buffer.append(':');\n-            }\n-            pad2(buffer, minutes);\n+            _appendOffset(buffer, offset);\n         } else {\n-            // 06-Mar-2020, tatu: Jackson versions 2.x forced use of numeric offset even\n-            //    for Zulu; for 3.0 `Z` is used.\n-            buffer.append('Z');\n+            // [databind#3284]: Allow legacy format via _writeZeroOffsetAsZ toggle\n+            if (_writeZeroOffsetAsZ) {\n+                // 06-Mar-2020, tatu: Jackson versions 2.x forced use of numeric offset even\n+                //    for Zulu; for 3.0 `Z` is used.\n+                buffer.append('Z');\n+            } else {\n+                _appendOffset(buffer, 0);\n+            }\n         }\n     }\n \n+    /**\n+     * Helper to append timezone offset in +HH:mm or +HHmm format.\n+     * Reused for both zero and non-zero offsets.\n+     *\n+     * @param buffer destination buffer\n+     * @param offsetMillis offset in milliseconds; truncated to whole minutes (as per original logic)\n+     */\n+    private void _appendOffset(StringBuffer buffer, int offsetMillis) {\n+        // Simplified calculation: divide once, then extract hours/minutes\n+        int totalMinutes = offsetMillis / (60 * 1000);\n+        int hours = Math.abs(totalMinutes / 60);\n+        int minutes = Math.abs(totalMinutes % 60);\n+        buffer.append(offsetMillis < 0 ? '-' : '+');\n+        pad2(buffer, hours);\n+        if (_tzSerializedWithColon) {\n+            buffer.append(':');\n+        }\n+        pad2(buffer, minutes);\n+    }\n+\n     protected void _formatBCEYear(StringBuffer buffer, int bceYearNoSign) {\n         // Ok. First of all, BCE 1 output (given as value `1` in era BCE) needs to become\n         // \"+0000\", but rest (from `2` up, in that era) need minus sign.\n",
  "test_patch" : "diff --git a/src/test/java/tools/jackson/databind/ser/jdk/JavaUtilDateSerializationTest.java b/src/test/java/tools/jackson/databind/ser/jdk/JavaUtilDateSerializationTest.java\nindex d468658ca3..865ad2ad4d 100644\n--- a/src/test/java/tools/jackson/databind/ser/jdk/JavaUtilDateSerializationTest.java\n+++ b/src/test/java/tools/jackson/databind/ser/jdk/JavaUtilDateSerializationTest.java\n@@ -402,6 +402,138 @@ public void testFormatWithoutPattern() throws Exception\n         assertEquals(a2q(\"{'date':'1970-01-01X01:00:00'}\"), json);\n     }\n \n+    /**\n+     * Test zero-offset as numeric format ([databind#3284])\n+     */\n+    @Test\n+    public void testDateISO8601_zeroOffsetAsNumeric() throws IOException {\n+        // 1) Default: zero offset should serialize as \"Z\"\n+        {\n+            ObjectMapper mapper = jsonMapperBuilder().build();\n+            serialize(mapper, judate(1970, 1, 1, 0, 0, 0, 0, \"UTC\"),\n+                    \"1970-01-01T00:00:00.000Z\");\n+        }\n+\n+        // 2) Feature enabled: zero offset should serialize as \"+00:00\" (colon=true by default)\n+        {\n+            ObjectMapper mapper = jsonMapperBuilder()\n+                    .enable(DateTimeFeature.WRITE_UTC_AS_OFFSET)\n+                    .build();\n+            serialize(mapper, judate(1970, 1, 1, 0, 0, 0, 0, \"UTC\"),\n+                    \"1970-01-01T00:00:00.000+00:00\");\n+        }\n+\n+        // 3) Feature enabled + colon disabled: zero offset should serialize as \"+0000\"\n+        {\n+            StdDateFormat df = new StdDateFormat()\n+                    .withColonInTimeZone(false)\n+                    .withZeroOffsetAsZ(false);\n+            ObjectMapper mapper = jsonMapperBuilder()\n+                    .defaultDateFormat(df)\n+                    .build();\n+            serialize(mapper, judate(1970, 1, 1, 0, 0, 0, 0, \"UTC\"),\n+                    \"1970-01-01T00:00:00.000+0000\");\n+        }\n+\n+        // 4) Regression: Non-zero offset should be unaffected\n+        // Use epoch (0L) with GMT+2 formatter to verify offset is correctly written\n+        {\n+            ObjectMapper mapper = jsonMapperBuilder()\n+                    .defaultTimeZone(TimeZone.getTimeZone(\"GMT+2\"))\n+                    .enable(DateTimeFeature.WRITE_UTC_AS_OFFSET)\n+                    .build();\n+            // epoch=0 formatted in GMT+2 => 1970-01-01T02:00:00.000+02:00\n+            serialize(mapper, new Date(0L), \"1970-01-01T02:00:00.000+02:00\");\n+        }\n+\n+        // 5) Calendar also respects the feature (exact match, not contains)\n+        {\n+            ObjectMapper mapper = jsonMapperBuilder()\n+                    .enable(DateTimeFeature.WRITE_UTC_AS_OFFSET)\n+                    .build();\n+            Calendar cal = Calendar.getInstance(TimeZone.getTimeZone(\"UTC\"));\n+            cal.setTimeInMillis(0);\n+            String json = mapper.writeValueAsString(cal);\n+            assertEquals(\"\\\"1970-01-01T00:00:00.000+00:00\\\"\", json);\n+        }\n+\n+        // 6) Non-UTC timezone ID with zero offset (e.g., \"GMT\") also uses numeric format\n+        {\n+            ObjectMapper mapper = jsonMapperBuilder()\n+                    .enable(DateTimeFeature.WRITE_UTC_AS_OFFSET)\n+                    .build();\n+            serialize(mapper, judate(1970, 1, 1, 0, 0, 0, 0, \"GMT\"),\n+                    \"1970-01-01T00:00:00.000+00:00\");\n+        }\n+\n+        // 7) Map<Date, ?> key serialization also respects the feature (exact match)\n+        {\n+            ObjectMapper mapper = jsonMapperBuilder()\n+                    .enable(DateTimeFeature.WRITE_UTC_AS_OFFSET)\n+                    .build();\n+            Map<Date, String> map = new LinkedHashMap<>();\n+            map.put(judate(1970, 1, 1, 0, 0, 0, 0, \"UTC\"), \"epoch\");\n+            String json = mapper.writeValueAsString(map);\n+            assertEquals(\"{\\\"1970-01-01T00:00:00.000+00:00\\\":\\\"epoch\\\"}\", json);\n+        }\n+\n+        // 8) Custom DateFormat is NOT affected by the feature (by design)\n+        {\n+            // Use fixed literal 'Z' suffix to ensure predictable output regardless of JDK\n+            SimpleDateFormat customFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\");\n+            customFormat.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n+            ObjectMapper mapper = jsonMapperBuilder()\n+                    .defaultDateFormat(customFormat)\n+                    .enable(DateTimeFeature.WRITE_UTC_AS_OFFSET)\n+                    .build();\n+            Date date = judate(1970, 1, 1, 0, 0, 0, 0, \"UTC\");\n+            String json = mapper.writeValueAsString(date);\n+            // Custom DateFormat controls output - feature has no effect\n+            // Output is literal 'Z' (not offset) because custom format overrides StdDateFormat\n+            assertEquals(\"\\\"1970-01-01T00:00:00.000Z\\\"\", json);\n+        }\n+\n+        // 9) Map key with WRITE_DATE_KEYS_AS_TIMESTAMPS=true is unaffected (uses timestamp, not format)\n+        {\n+            ObjectMapper mapper = jsonMapperBuilder()\n+                    .enable(DateTimeFeature.WRITE_DATE_KEYS_AS_TIMESTAMPS)\n+                    .enable(DateTimeFeature.WRITE_UTC_AS_OFFSET)\n+                    .build();\n+            Map<Date, String> map = new LinkedHashMap<>();\n+            map.put(judate(1970, 1, 1, 0, 0, 0, 0, \"UTC\"), \"epoch\");\n+            String json = mapper.writeValueAsString(map);\n+            assertEquals(\"{\\\"0\\\":\\\"epoch\\\"}\", json);\n+        }\n+\n+        // 10) WRITE_DATES_AS_TIMESTAMPS ignores the feature (outputs numeric timestamp)\n+        {\n+            ObjectMapper mapper = jsonMapperBuilder()\n+                    .enable(DateTimeFeature.WRITE_DATES_AS_TIMESTAMPS)\n+                    .enable(DateTimeFeature.WRITE_UTC_AS_OFFSET)\n+                    .build();\n+            String json = mapper.writeValueAsString(new Date(0L));\n+            assertEquals(\"0\", json);\n+        }\n+\n+        // 11) DST zone: Europe/London winter (offset=0) vs summer (offset=+01:00)\n+        // Verifies feature applies based on actual offset, not timezone ID\n+        {\n+            ObjectMapper mapper = jsonMapperBuilder()\n+                    .defaultTimeZone(TimeZone.getTimeZone(\"Europe/London\"))\n+                    .enable(DateTimeFeature.WRITE_UTC_AS_OFFSET)\n+                    .build();\n+            // Winter: 2024-01-15 00:00:00 UTC -> offset=0 -> should be +00:00\n+            Date winterDate = new Date(1705276800000L); // 2024-01-15T00:00:00Z\n+            String winterJson = mapper.writeValueAsString(winterDate);\n+            assertTrue(winterJson.endsWith(\"+00:00\\\"\"), \"Winter should end with +00:00: \" + winterJson);\n+\n+            // Summer: 2024-07-15 00:00:00 UTC -> offset=+01:00 -> should be +01:00\n+            Date summerDate = new Date(1721001600000L); // 2024-07-15T00:00:00Z\n+            String summerJson = mapper.writeValueAsString(summerDate);\n+            assertTrue(summerJson.endsWith(\"+01:00\\\"\"), \"Summer should end with +01:00: \" + summerJson);\n+        }\n+    }\n+\n     private static Date judate(int year, int month, int day, int hour, int minutes, int seconds, int millis, String tz) {\n         Calendar cal = Calendar.getInstance();\n         // 23-Nov-2018, tatu: Safer this way, even though negative appears to work too\n",
  "problem_statement" : "**Is your feature request related to a problem? Please describe.**\r\n\r\nThis is related to https://github.com/FasterXML/jackson-databind/commit/07422d34c530f6d9ad3be14315bb2922da0754ff\r\nSince the default serialization of Date is changing timezone offset from \"+00:00\" to \"Z\" (in Jackson 3.0), would it be possible to have some options in 3.x to produce the old backward compat formats \"+0000\" and \"+00:00\"?\r\nWe have some existing APIs which produce \"+0000\" and where (some) users are very sensitive to any change in the format. we were able to address this in 2.11 setting the provided colon flag to false. What would be the options to produce the same outputs in 3.x?\r\n\r\n**Describe the solution you'd like**\r\nsome flag (or other mechanism) that would allow default Date serialization to optionally produce the legacy \"+0000\"  and \"+00:00\" timezone offset formats instead of the default \"Z\"  \r\n\r\n**Usage example**\r\none possibility could be similar to the colon flag in 2.11. \r\nStdDateFormat::withLegacyTimeZoneForUTC(boolean useColon)\r\n\r\n**Additional context**\r\nAs mentioned above, this would help support backward compatibility of Date fields in existing api responses with minimal impact. \r\n",
  "hints_text" : null,
  "created_at" : "Mon Jan 26 07:10:00 CET 2026",
  "version" : null,
  "FAIL_TO_PASS" : [ "JavaUtilDateSerializationTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=JavaUtilDateSerializationTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : 3284,
  "pull_number" : 5613,
  "metadata" : null
}, {
  "instance_id" : "FasterXML-jackson-databind-PR-5612",
  "repo" : "FasterXML/jackson-databind",
  "base_commit" : "fe73c27e3a76bb14265ab4c558ab81ff4d22f074",
  "patch" : "diff --git a/src/main/java/tools/jackson/databind/ext/javatime/deser/InstantDeserializer.java b/src/main/java/tools/jackson/databind/ext/javatime/deser/InstantDeserializer.java\nindex 1ad0518231..297d50acfc 100644\n--- a/src/main/java/tools/jackson/databind/ext/javatime/deser/InstantDeserializer.java\n+++ b/src/main/java/tools/jackson/databind/ext/javatime/deser/InstantDeserializer.java\n@@ -164,6 +164,7 @@ protected InstantDeserializer(InstantDeserializer<T> base, DateTimeFormatter f)\n         _readTimestampsAsNanosOverride = base._readTimestampsAsNanosOverride;\n     }\n \n+    /*\n     @SuppressWarnings(\"unchecked\")\n     protected InstantDeserializer(InstantDeserializer<T> base, Boolean adjustToContextTimezoneOverride)\n     {\n@@ -176,6 +177,7 @@ protected InstantDeserializer(InstantDeserializer<T> base, Boolean adjustToConte\n         _adjustToContextTZOverride = adjustToContextTimezoneOverride;\n         _readTimestampsAsNanosOverride = base._readTimestampsAsNanosOverride;\n     }\n+    */\n \n     @SuppressWarnings(\"unchecked\")\n     protected InstantDeserializer(InstantDeserializer<T> base, DateTimeFormatter f, Boolean leniency)\ndiff --git a/src/main/java/tools/jackson/databind/ext/javatime/deser/JSR310DateTimeDeserializerBase.java b/src/main/java/tools/jackson/databind/ext/javatime/deser/JSR310DateTimeDeserializerBase.java\nindex 8bddb76e30..be53b5ae13 100644\n--- a/src/main/java/tools/jackson/databind/ext/javatime/deser/JSR310DateTimeDeserializerBase.java\n+++ b/src/main/java/tools/jackson/databind/ext/javatime/deser/JSR310DateTimeDeserializerBase.java\n@@ -20,7 +20,7 @@ public abstract class JSR310DateTimeDeserializerBase<T>\n     protected final DateTimeFormatter _formatter;\n \n     /**\n-     * Setting that indicates the {@link JsonFormat.Shape} specified for this deserializer\n+     * Setting that indicates the {@link Shape} specified for this deserializer\n      * as a {@link com.fasterxml.jackson.annotation.JsonFormat.Shape} annotation on\n      * property or class, or due to per-type \"config override\", or from global settings:\n      * If Shape is NUMBER_INT, the input value is considered to be epoch days. If not a\ndiff --git a/src/main/java/tools/jackson/databind/ext/javatime/deser/MonthDeserializer.java b/src/main/java/tools/jackson/databind/ext/javatime/deser/MonthDeserializer.java\nindex 03f319fb63..087db4fd66 100644\n--- a/src/main/java/tools/jackson/databind/ext/javatime/deser/MonthDeserializer.java\n+++ b/src/main/java/tools/jackson/databind/ext/javatime/deser/MonthDeserializer.java\n@@ -3,13 +3,13 @@\n import java.time.*;\n import java.time.format.DateTimeFormatter;\n import java.util.*;\n+import java.util.function.Function;\n import java.util.stream.Collectors;\n \n import tools.jackson.core.*;\n import tools.jackson.databind.DeserializationContext;\n import tools.jackson.databind.DeserializationFeature;\n import tools.jackson.databind.cfg.DateTimeFeature;\n-import tools.jackson.databind.exc.InvalidFormatException;\n \n import com.fasterxml.jackson.annotation.JsonFormat;\n \n@@ -20,7 +20,9 @@ public class MonthDeserializer extends JSR310DateTimeDeserializerBase<Month>\n {\n     public static final MonthDeserializer INSTANCE = new MonthDeserializer();\n \n-    private final Set<String> possibleMonthStringValues = Arrays.stream(Month.values()).map(Month::name).collect(Collectors.toSet());\n+    // @since 3.1\n+    private final Map<String, Month> _byNameLookup = Arrays.stream(Month.values())\n+            .collect(Collectors.toUnmodifiableMap(Month::name, Function.identity()));\n \n     /**\n      * NOTE: only {@code public} so that use via annotations (see [modules-java8#202])\n@@ -39,9 +41,7 @@ protected MonthDeserializer(MonthDeserializer base, Boolean leniency) {\n     }\n \n     protected MonthDeserializer(MonthDeserializer base,\n-                                   Boolean leniency,\n-                                   DateTimeFormatter formatter,\n-                                   JsonFormat.Shape shape) {\n+            Boolean leniency, DateTimeFormatter formatter, JsonFormat.Shape shape) {\n         super(base, leniency, formatter, shape);\n     }\n \n@@ -57,23 +57,18 @@ protected MonthDeserializer withDateFormat(DateTimeFormatter dtf) {\n \n     @Override\n     public Month deserialize(JsonParser p, DeserializationContext ctxt)\n-            throws JacksonException\n+        throws JacksonException\n     {\n         if (p.hasToken(JsonToken.VALUE_STRING)) {\n             return _fromString(p, ctxt, p.getString());\n         }\n         // Support numeric scalar input\n         if (p.hasToken(JsonToken.VALUE_NUMBER_INT)) {\n-            final int raw = p.getIntValue();\n+            final int monthIndex = p.getIntValue();\n             if (ctxt.isEnabled(DateTimeFeature.ONE_BASED_MONTHS)) {\n-                return _decodeMonth(raw, ctxt);\n+                return _decode1BasedMonth(monthIndex, ctxt);\n             }\n-            // default: 0‑based index (0 == JANUARY)\n-            if (raw < 0 || raw >= 12) {\n-                return (Month) ctxt.handleWeirdNumberValue(handledType(),\n-                        raw, \"Month index (%s) outside 0-11 range\", raw);\n-            }\n-            return Month.values()[raw];\n+            return _decode0BasedMonth(monthIndex, ctxt);\n         }\n         // 30-Sep-2020, tatu: New! \"Scalar from Object\" (mostly for XML)\n         if (p.isExpectedStartObjectToken()) {\n@@ -113,8 +108,8 @@ public Month deserialize(JsonParser p, DeserializationContext ctxt)\n     }\n \n     protected Month _fromString(JsonParser p, DeserializationContext ctxt,\n-                                   String string0)\n-            throws JacksonException\n+            String string0)\n+        throws JacksonException\n     {\n         String string = string0.trim();\n         if (string.length() == 0) {\n@@ -127,44 +122,56 @@ protected Month _fromString(JsonParser p, DeserializationContext ctxt,\n             if (_formatter == null) {\n                 // First: try purely numeric input\n                 try {\n-                    int oneBasedMonthNumber = Integer.parseInt(string);\n+                    int monthIndex = Integer.parseInt(string);\n                     if (ctxt.isEnabled(DateTimeFeature.ONE_BASED_MONTHS)) {\n-                        return _decodeMonth(oneBasedMonthNumber, ctxt);\n-                    }\n-                    if (oneBasedMonthNumber < 0 || oneBasedMonthNumber >= 12) { // invalid for 0‑based\n-                        throw new InvalidFormatException(p, \"Month number \" + oneBasedMonthNumber + \" not allowed for 1-based Month.\", oneBasedMonthNumber, Integer.class);\n+                        return _decode1BasedMonth(monthIndex, ctxt);\n                     }\n-                    return Month.values()[oneBasedMonthNumber]; // 0‑based mapping\n+                    return _decode0BasedMonth(monthIndex, ctxt);\n                 } catch (NumberFormatException nfe) {\n                     // fall through – treat as textual month name\n                 }\n                 // Second: try textual input\n                 // Handle English month names such as \"JANUARY\" from the actual Month Enum names\n-                if (possibleMonthStringValues.contains(string)) {\n-                    return Month.valueOf(string);\n+                Month m = _byNameLookup.get(string);\n+                if (m != null) {\n+                    return m;\n                 }\n-                throw new InvalidFormatException(p, String.format(\"Cannot deserialize value of type `java.time.Month` from String \\\"%s\\\": not one of the values accepted for Enum class: %s\", string, Arrays.toString(Month.values())), string, Month.class);\n+                return (Month) ctxt.handleWeirdStringValue(handledType(), string, \n+                        \"not one of known `Month` values: %s\",\n+                                Arrays.toString(Month.values()));\n             }\n             return Month.from(_formatter.parse(string));\n         } catch (DateTimeException e) {\n             return _handleDateTimeFormatException(ctxt, e, _formatter, string);\n         } catch (NumberFormatException e) {\n             throw ctxt.weirdStringException(string, handledType(),\n-                    \"not a valid month value\");\n+                    \"not a valid Month value\");\n         }\n     }\n \n     /**\n      * Validate and convert a 1‑based month number to {@link Month}.\n      */\n-    private Month _decodeMonth(int oneBasedMonthNumber, DeserializationContext ctxt)\n-            throws JacksonException\n+    private Month _decode1BasedMonth(int monthIndex, DeserializationContext ctxt)\n+        throws JacksonException\n     {\n-        if (Month.JANUARY.getValue() <= oneBasedMonthNumber && oneBasedMonthNumber <= Month.DECEMBER.getValue()) {\n-            return Month.of(oneBasedMonthNumber);\n+        if (Month.JANUARY.getValue() <= monthIndex && monthIndex <= Month.DECEMBER.getValue()) {\n+            return Month.of(monthIndex);\n         }\n-        // If out of range, throw an exception\n         return (Month) ctxt.handleWeirdNumberValue(handledType(),\n-                oneBasedMonthNumber, \"Month number %s not allowed for 1-based Month.\", oneBasedMonthNumber);\n+                monthIndex, \"month number outside 1-12 range for 1-based `Month`s\");\n+    }\n+\n+    /**\n+     * Validate and convert a 0‑based month number to {@link Month}.\n+     */\n+    private Month _decode0BasedMonth(int monthIndex, DeserializationContext ctxt)\n+        throws JacksonException\n+    {\n+        if (monthIndex < 0 || monthIndex >= 12) { // invalid for 0‑based\n+            return (Month) ctxt.handleWeirdNumberValue(handledType(),\n+                    monthIndex, \"month number outside 0-11 range for 0-based `Month`s\");\n+        }\n+        return Month.values()[monthIndex]; // 0‑based mapping\n     }\n }\n",
  "test_patch" : "diff --git a/src/test/java/tools/jackson/databind/ext/javatime/deser/MonthDeserializerTest.java b/src/test/java/tools/jackson/databind/ext/javatime/deser/MonthDeserializerTest.java\nindex 22720e36be..3db218abe1 100644\n--- a/src/test/java/tools/jackson/databind/ext/javatime/deser/MonthDeserializerTest.java\n+++ b/src/test/java/tools/jackson/databind/ext/javatime/deser/MonthDeserializerTest.java\n@@ -1,6 +1,7 @@\n package tools.jackson.databind.ext.javatime.deser;\n \n import java.time.Month;\n+import java.time.format.DateTimeFormatter;\n import java.time.temporal.TemporalAccessor;\n \n import org.junit.jupiter.api.function.Executable;\n@@ -8,7 +9,12 @@\n import org.junit.jupiter.params.ParameterizedTest;\n import org.junit.jupiter.params.provider.CsvSource;\n import org.junit.jupiter.params.provider.EnumSource;\n+import org.junit.jupiter.params.provider.ValueSource;\n \n+import com.fasterxml.jackson.annotation.JsonFormat;\n+import com.fasterxml.jackson.annotation.OptBoolean;\n+\n+import tools.jackson.databind.DeserializationFeature;\n import tools.jackson.databind.MapperFeature;\n import tools.jackson.databind.ObjectMapper;\n import tools.jackson.databind.ObjectReader;\n@@ -32,6 +38,11 @@ static class Wrapper {\n         public Wrapper() { }\n     }\n \n+    static class WrapperWithFormat {\n+        @JsonFormat(pattern = \"MMM\", locale = \"en\")\n+        public Month value;\n+    }\n+\n     @ParameterizedTest\n     @EnumSource(Month.class)\n     public void testDeserializationAsString01_oneBased(Month expectedMonth) throws Exception\n@@ -65,11 +76,11 @@ public void testDeserializationAsString02_zeroBased(Month month) throws Exceptio\n \n     @ParameterizedTest\n     @CsvSource({\n-            \"notamonth , 'Cannot deserialize value of type `java.time.Month` from String \\\"notamonth\\\": not one of the values accepted for Enum class:'\",\n-            \"JANUAR    , 'Cannot deserialize value of type `java.time.Month` from String \\\"JANUAR\\\": not one of the values accepted for Enum class:'\",\n-            \"march     , 'Cannot deserialize value of type `java.time.Month` from String \\\"march\\\": not one of the values accepted for Enum class:'\",\n-            \"0         , 'Month number 0 not allowed for 1-based Month.'\",\n-            \"13        , 'Month number 13 not allowed for 1-based Month.'\",\n+            \"notamonth , 'Cannot deserialize value of type `java.time.Month` from String \\\"notamonth\\\": not one of known `Month` values:'\",\n+            \"JANUAR    , 'Cannot deserialize value of type `java.time.Month` from String \\\"JANUAR\\\": not one of known `Month` values:'\",\n+            \"march     , 'Cannot deserialize value of type `java.time.Month` from String \\\"march\\\": not one of known `Month` values:'\",\n+            \"0         , 'month number outside 1-12'\",\n+            \"13        , 'month number outside 1-12'\",\n     })\n     public void testBadDeserializationAsString01_oneBased(String monthSpec, String expectedMessage) {\n         String value = \"\\\"\" + monthSpec + '\"';\n@@ -197,6 +208,334 @@ public void testDeserializeFromEmptyString() throws Exception\n         assertNull(m);\n     }\n \n+    /*\n+    /**********************************************************************\n+    /* Tests for numeric int input (VALUE_NUMBER_INT)\n+    /**********************************************************************\n+     */\n+\n+    @ParameterizedTest\n+    @EnumSource(Month.class)\n+    public void testDeserializationAsInt_zeroBased(Month expectedMonth) throws Exception\n+    {\n+        int monthIndex = expectedMonth.ordinal();\n+        assertEquals(expectedMonth, readerForZeroBased().readValue(String.valueOf(monthIndex)));\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(Month.class)\n+    public void testDeserializationAsInt_oneBased(Month expectedMonth) throws Exception\n+    {\n+        int monthNum = expectedMonth.getValue();\n+        assertEquals(expectedMonth, readerForOneBased().readValue(String.valueOf(monthNum)));\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(ints = {-1, 12, 13, 100})\n+    public void testDeserializationAsIntOutOfRange_zeroBased(int invalidValue) throws Exception\n+    {\n+        assertError(\n+            () -> readerForZeroBased().readValue(String.valueOf(invalidValue)),\n+            MismatchedInputException.class,\n+            \"month number outside 0-11 range\"\n+        );\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(ints = {0, -1, 13, 100})\n+    public void testDeserializationAsIntOutOfRange_oneBased(int invalidValue) throws Exception\n+    {\n+        assertError(\n+            () -> readerForOneBased().readValue(String.valueOf(invalidValue)),\n+            MismatchedInputException.class,\n+            \"month number outside 1-12 range\"\n+        );\n+    }\n+\n+    /*\n+    /**********************************************************************\n+    /* Tests for array handling\n+    /**********************************************************************\n+     */\n+\n+    @Test\n+    public void testDeserializationAsEmptyArray() throws Exception\n+    {\n+        // Empty array returns null\n+        Month result = readerForOneBased().readValue(\"[]\");\n+        assertNull(result);\n+    }\n+\n+    @Test\n+    public void testDeserializationAsArrayWithIntValue() throws Exception\n+    {\n+        // Array with single int value (interpreted as 1-based month)\n+        Month result = readerForOneBased().readValue(\"[3]\");\n+        assertEquals(Month.MARCH, result);\n+    }\n+\n+    @Test\n+    public void testDeserializationAsArrayWithIntValue_zeroBased() throws Exception\n+    {\n+        // Array with single int value (0-based mode still uses Month.of for array)\n+        Month result = readerForZeroBased().readValue(\"[3]\");\n+        assertEquals(Month.MARCH, result);\n+    }\n+\n+    @Test\n+    public void testDeserializationAsArrayWithMoreThanOneElement() throws Exception\n+    {\n+        assertError(\n+            () -> readerForOneBased().readValue(\"[1, 2]\"),\n+            MismatchedInputException.class,\n+            \"Expected array to end\"\n+        );\n+    }\n+\n+    @Test\n+    public void testDeserializationAsArrayWithWrongToken() throws Exception\n+    {\n+        // Boolean in array without UNWRAP should fail with specific error\n+        assertError(\n+            () -> readerForOneBased().readValue(\"[true]\"),\n+            MismatchedInputException.class,\n+            \"Expected VALUE_NUMBER_INT\"\n+        );\n+    }\n+\n+    @Test\n+    public void testDeserializationAsArrayWithStringUnwrapDisabled() throws Exception\n+    {\n+        // String in array without UNWRAP_SINGLE_VALUE_ARRAYS should fail\n+        assertError(\n+            () -> readerForOneBased().readValue(\"[\\\"JANUARY\\\"]\"),\n+            MismatchedInputException.class,\n+            \"Expected VALUE_NUMBER_INT\"\n+        );\n+    }\n+\n+    @Test\n+    public void testDeserializationAsArrayWithFloatUnwrapDisabled() throws Exception\n+    {\n+        // Float in array without UNWRAP should fail\n+        assertError(\n+            () -> readerForOneBased().readValue(\"[1.5]\"),\n+            MismatchedInputException.class,\n+            \"Expected VALUE_NUMBER_INT\"\n+        );\n+    }\n+\n+    @Test\n+    public void testDeserializationAsArrayWithObjectUnwrapDisabled() throws Exception\n+    {\n+        // Object in array without UNWRAP should fail\n+        assertError(\n+            () -> readerForOneBased().readValue(\"[{}]\"),\n+            MismatchedInputException.class,\n+            \"Expected VALUE_NUMBER_INT\"\n+        );\n+    }\n+\n+    @Test\n+    public void testDeserializationAsArrayWithStringUnwrapEnabled() throws Exception\n+    {\n+        // String in array with UNWRAP_SINGLE_VALUE_ARRAYS should work\n+        Month result = MAPPER.readerFor(Month.class)\n+                .with(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)\n+                .with(DateTimeFeature.ONE_BASED_MONTHS)\n+                .readValue(\"[\\\"JANUARY\\\"]\");\n+        assertEquals(Month.JANUARY, result);\n+    }\n+\n+    @Test\n+    public void testDeserializationAsArrayWithNumericStringUnwrapEnabled() throws Exception\n+    {\n+        // Numeric string in array with UNWRAP_SINGLE_VALUE_ARRAYS\n+        Month result = MAPPER.readerFor(Month.class)\n+                .with(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)\n+                .with(DateTimeFeature.ONE_BASED_MONTHS)\n+                .readValue(\"[\\\"5\\\"]\");\n+        assertEquals(Month.MAY, result);\n+    }\n+\n+    @Test\n+    public void testDeserializationAsArrayWithMoreThanOneString() throws Exception\n+    {\n+        // More than one string with UNWRAP_SINGLE_VALUE_ARRAYS should fail\n+        assertError(\n+            () -> MAPPER.readerFor(Month.class)\n+                    .with(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)\n+                    .readValue(\"[\\\"JANUARY\\\", \\\"FEBRUARY\\\"]\"),\n+            MismatchedInputException.class,\n+            \"Attempted to unwrap\"\n+        );\n+    }\n+\n+    /*\n+    /**********************************************************************\n+    /* Tests for zero-based string parsing edge cases\n+    /**********************************************************************\n+     */\n+\n+    @ParameterizedTest\n+    @CsvSource({\n+            \"12  , 'month number outside 0-11'\",\n+            \"-1  , 'month number outside 0-11'\",\n+            \"100 , 'month number outside 0-11'\",\n+    })\n+    public void testBadDeserializationAsString_zeroBasedOutOfRange(String monthSpec, String expectedMessage) {\n+        String value = q(monthSpec);\n+        assertError(\n+            () -> readerForZeroBased().readValue(value),\n+            InvalidFormatException.class,\n+            expectedMessage\n+        );\n+    }\n+\n+    /*\n+    /**********************************************************************\n+    /* Tests for whitespace handling\n+    /**********************************************************************\n+     */\n+\n+    @Test\n+    public void testDeserializationWithWhitespace() throws Exception\n+    {\n+        // Whitespace around month name should be trimmed\n+        Month result = readerForOneBased().readValue(\"\\\" JANUARY \\\"\");\n+        assertEquals(Month.JANUARY, result);\n+    }\n+\n+    @Test\n+    public void testDeserializationWithWhitespaceNumeric() throws Exception\n+    {\n+        // Whitespace around numeric value should be trimmed\n+        Month result = readerForOneBased().readValue(\"\\\" 6 \\\"\");\n+        assertEquals(Month.JUNE, result);\n+    }\n+\n+    /*\n+    /**********************************************************************\n+    /* Tests for unexpected tokens\n+    /**********************************************************************\n+     */\n+\n+    @Test\n+    public void testDeserializationFromBoolean() throws Exception\n+    {\n+        // Bare boolean should be handled as unexpected token\n+        assertError(\n+            () -> readerForOneBased().readValue(\"true\"),\n+            MismatchedInputException.class,\n+            \"Unexpected token (VALUE_TRUE)\"\n+        );\n+    }\n+\n+    @Test\n+    public void testDeserializationFromFloat() throws Exception\n+    {\n+        // Bare float should be handled as unexpected token\n+        assertError(\n+            () -> readerForOneBased().readValue(\"1.5\"),\n+            MismatchedInputException.class,\n+            \"Unexpected token (VALUE_NUMBER_FLOAT)\"\n+        );\n+    }\n+\n+    @Test\n+    public void testDeserializationFromObject() throws Exception\n+    {\n+        // Object without scalar extraction should fail\n+        assertError(\n+            () -> readerForOneBased().readValue(\"{}\"),\n+            MismatchedInputException.class,\n+            \"Unexpected token (START_OBJECT)\"\n+        );\n+    }\n+\n+    /*\n+    /**********************************************************************\n+    /* Tests for custom DateTimeFormatter\n+    /**********************************************************************\n+     */\n+\n+    @Test\n+    public void testDeserializationWithCustomFormat() throws Exception\n+    {\n+        WrapperWithFormat result = MAPPER.readValue(\"{\\\"value\\\":\\\"Jan\\\"}\", WrapperWithFormat.class);\n+        assertEquals(Month.JANUARY, result.value);\n+    }\n+\n+    @Test\n+    public void testDeserializationWithCustomFormatMarch() throws Exception\n+    {\n+        WrapperWithFormat result = MAPPER.readValue(\"{\\\"value\\\":\\\"Mar\\\"}\", WrapperWithFormat.class);\n+        assertEquals(Month.MARCH, result.value);\n+    }\n+\n+    @Test\n+    public void testDeserializationWithCustomFormatInvalid() throws Exception\n+    {\n+        assertError(\n+            () -> MAPPER.readValue(\"{\\\"value\\\":\\\"NotAMonth\\\"}\", WrapperWithFormat.class),\n+            InvalidFormatException.class,\n+            \"could not be parsed\"\n+        );\n+    }\n+\n+    static class WrapperWithFullMonthFormat {\n+        @JsonFormat(pattern = \"MMMM\", locale = \"en\")\n+        public Month value;\n+    }\n+\n+    @Test\n+    public void testDeserializationWithFullMonthFormat() throws Exception\n+    {\n+        WrapperWithFullMonthFormat result = MAPPER.readValue(\n+                \"{\\\"value\\\":\\\"January\\\"}\", WrapperWithFullMonthFormat.class);\n+        assertEquals(Month.JANUARY, result.value);\n+    }\n+\n+    /*\n+    /**********************************************************************\n+    /* Tests for leniency settings\n+    /**********************************************************************\n+     */\n+\n+    static class WrapperStrict {\n+        @JsonFormat(lenient = OptBoolean.FALSE)\n+        public Month value;\n+    }\n+\n+    static class WrapperLenient {\n+        @JsonFormat(lenient = OptBoolean.TRUE)\n+        public Month value;\n+    }\n+\n+    @Test\n+    public void testWithLeniencyCreatesNewInstance() throws Exception\n+    {\n+        MonthDeserializer original = MonthDeserializer.INSTANCE;\n+        MonthDeserializer strict = original.withLeniency(false);\n+        assertNotSame(original, strict);\n+        assertFalse(strict.isLenient());\n+    }\n+\n+    @Test\n+    public void testWithDateFormatCreatesNewInstance() throws Exception\n+    {\n+        MonthDeserializer original = MonthDeserializer.INSTANCE;\n+        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"MMM\");\n+        MonthDeserializer withFormatter = original.withDateFormat(formatter);\n+        assertNotSame(original, withFormatter);\n+    }\n+\n+    /*\n+    /**********************************************************************\n+    /* Helper methods\n+    /**********************************************************************\n+     */\n+\n     private ObjectReader readerForZeroBased() {\n         return MAPPER\n                 .readerFor(Month.class)\ndiff --git a/src/test/java/tools/jackson/databind/ext/javatime/deser/OffsetTimeDeserTest.java b/src/test/java/tools/jackson/databind/ext/javatime/deser/OffsetTimeDeserTest.java\nindex 9dd79631b8..7819da5c60 100644\n--- a/src/test/java/tools/jackson/databind/ext/javatime/deser/OffsetTimeDeserTest.java\n+++ b/src/test/java/tools/jackson/databind/ext/javatime/deser/OffsetTimeDeserTest.java\n@@ -10,6 +10,7 @@\n \n import com.fasterxml.jackson.annotation.JsonFormat;\n import com.fasterxml.jackson.annotation.JsonFormat.Feature;\n+import com.fasterxml.jackson.annotation.OptBoolean;\n \n import tools.jackson.core.type.TypeReference;\n \n@@ -61,6 +62,24 @@ public WrapperWithReadTimestampsAsNanosEnabled() { }\n         public WrapperWithReadTimestampsAsNanosEnabled(OffsetTime v) { value = v; }\n     }\n \n+    // For testing custom format (covers withDateFormat)\n+    static class WrapperWithCustomPattern {\n+        @JsonFormat(pattern = \"HH:mm:ssXXX\")\n+        public OffsetTime value;\n+\n+        public WrapperWithCustomPattern() { }\n+        public WrapperWithCustomPattern(OffsetTime v) { value = v; }\n+    }\n+\n+    // For testing strict mode with custom format\n+    static class StrictWrapper {\n+        @JsonFormat(pattern = \"HH:mmXXX\", lenient = OptBoolean.FALSE)\n+        public OffsetTime value;\n+\n+        public StrictWrapper() { }\n+        public StrictWrapper(OffsetTime v) { value = v; }\n+    }\n+\n     private final ObjectMapper MAPPER = newMapper();\n     private final ObjectReader READER = MAPPER.readerFor(OffsetTime.class);\n \n@@ -347,4 +366,112 @@ public void testStrictDeserializeFromEmptyString() throws Exception {\n         String valueFromEmptyStr = mapper.writeValueAsString(asMap(key, \"\"));\n         assertThrows(MismatchedInputException.class, () -> objectReader.readValue(valueFromEmptyStr));\n     }\n+\n+    /*\n+    /**********************************************************\n+    /* Tests for custom pattern/format (covers withDateFormat)\n+    /**********************************************************\n+     */\n+\n+    @Test\n+    public void testDeserializationWithCustomPattern() throws Exception\n+    {\n+        ObjectReader reader = MAPPER.readerFor(WrapperWithCustomPattern.class);\n+\n+        OffsetTime expected = OffsetTime.of(15, 30, 45, 0, ZoneOffset.ofHours(2));\n+        WrapperWithCustomPattern result = reader.readValue(a2q(\"{'value':'15:30:45+02:00'}\"));\n+        assertEquals(expected, result.value);\n+\n+        // Also test with UTC offset\n+        expected = OffsetTime.of(10, 15, 30, 0, ZoneOffset.UTC);\n+        result = reader.readValue(a2q(\"{'value':'10:15:30Z'}\"));\n+        assertEquals(expected, result.value);\n+    }\n+\n+    @Test\n+    public void testStrictCustomPatternInvalidFormat() throws Exception\n+    {\n+        // The strict wrapper expects HH:mmXXX format, so full timestamp should fail\n+        assertThrows(MismatchedInputException.class,\n+                () -> MAPPER.readValue(\"{\\\"value\\\":\\\"15:30:45+02:00\\\"}\", StrictWrapper.class));\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Tests for TRUNCATE_TO_MSECS_ON_READ feature\n+    /**********************************************************\n+     */\n+\n+    @Test\n+    public void testDeserializationTruncateToMillis() throws Exception\n+    {\n+        ObjectReader reader = MAPPER.readerFor(OffsetTime.class)\n+                .with(DateTimeFeature.TRUNCATE_TO_MSECS_ON_READ);\n+\n+        // From string with nanoseconds\n+        OffsetTime result = reader.readValue(\"\\\"10:30:45.123456789+02:00\\\"\");\n+        assertEquals(123000000, result.getNano(), \"Nanoseconds should be truncated to milliseconds\");\n+        assertEquals(10, result.getHour());\n+        assertEquals(30, result.getMinute());\n+        assertEquals(45, result.getSecond());\n+\n+        // From array with nanoseconds\n+        result = reader.with(DateTimeFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)\n+                .readValue(\"[10,30,45,123456789,\\\"+02:00\\\"]\");\n+        assertEquals(123000000, result.getNano(), \"Nanoseconds from array should be truncated to milliseconds\");\n+    }\n+\n+    @Test\n+    public void testDeserializationTruncateToMillisAlreadyTruncated() throws Exception\n+    {\n+        ObjectReader reader = MAPPER.readerFor(OffsetTime.class)\n+                .with(DateTimeFeature.TRUNCATE_TO_MSECS_ON_READ);\n+\n+        // Value already at millisecond precision should remain unchanged\n+        OffsetTime result = reader.readValue(\"\\\"10:30:45.123+02:00\\\"\");\n+        assertEquals(123000000, result.getNano());\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Tests for error cases\n+    /**********************************************************\n+     */\n+\n+    @Test\n+    public void testDeserializationFromIntegerFails() throws Exception\n+    {\n+        // OffsetTime cannot be deserialized from a standalone integer\n+        // (needs timezone info)\n+        try {\n+            READER.readValue(\"12345\");\n+            fail(\"Should not accept integer for OffsetTime\");\n+        } catch (MismatchedInputException e) {\n+            verifyException(e, \"raw timestamp\");\n+        }\n+    }\n+\n+    @Test\n+    public void testDeserializationFromArrayMissingTimeZone() throws Exception\n+    {\n+        // Array with numeric values but missing timezone string at the end\n+        try {\n+            READER.readValue(\"[10,30,45,123]\");\n+            fail(\"Should fail when timezone string is missing\");\n+        } catch (MismatchedInputException e) {\n+            verifyException(e, \"Expected string for TimeZone\");\n+        }\n+    }\n+\n+    @Test\n+    public void testDeserializationFromArrayMissingTimeZoneMinimal() throws Exception\n+    {\n+        // Array with just hour and minute but no timezone\n+        try {\n+            READER.readValue(\"[10,30]\");\n+            fail(\"Should fail when timezone string is missing\");\n+        } catch (MismatchedInputException e) {\n+            verifyException(e, \"Expected string for TimeZone\");\n+        }\n+    }\n }\n",
  "problem_statement" : "Increase test coverage",
  "hints_text" : null,
  "created_at" : "Mon Jan 26 03:50:47 CET 2026",
  "version" : null,
  "FAIL_TO_PASS" : [ "OffsetTimeDeserTest", "MonthDeserializerTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=OffsetTimeDeserTest,MonthDeserializerTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 5612,
  "metadata" : null
}, {
  "instance_id" : "FasterXML-jackson-databind-PR-5611",
  "repo" : "FasterXML/jackson-databind",
  "base_commit" : "540722065dabad138b41eeb4804bc896f31178d3",
  "patch" : "diff --git a/release-notes/CREDITS b/release-notes/CREDITS\nindex e1036a01cd..e74920ed9c 100644\n--- a/release-notes/CREDITS\n+++ b/release-notes/CREDITS\n@@ -166,6 +166,8 @@ Victor Noël (@victornoel)\n  * Requested #1497: Allow skipping `@JsonUnwrapped` values if no properties matched,\n    `DeserializationFeature.USE_NULL_FOR_EMPTY_UNWRAPPED` enabled\n   [3.1.0]\n+ * Requested #2343: Add `JsonNode.asArray()` and `JsonNode.asObject()`\n+  [3.1.0]\n \n Ulf Andersson (@ulfandersson)\n  * Reported #2124: Allow coercion of '[ ]' into empty/null String with\ndiff --git a/release-notes/VERSION b/release-notes/VERSION\nindex c416d75c5d..c18fbec70d 100644\n--- a/release-notes/VERSION\n+++ b/release-notes/VERSION\n@@ -39,6 +39,8 @@ Versions: 3.x (for earlier see VERSION-2.x)\n   `ACCEPT_EMPTY_ARRAY_AS_NULL_OBJECT`\n  (reported by Ulf A)\n  (fix by @cowtowncoder, w/ Claude code)\n+#2343: Add `JsonNode.asArray()` and `JsonNode.asObject()`\n+ (requested by Victor N)\n #2438: Prevent use of setter/field in case Creator property\n   already exists, duplicate value seen\n #2617: `@JsonDeserialize.converter` from an interface doesn't work\ndiff --git a/src/main/java/tools/jackson/databind/JsonNode.java b/src/main/java/tools/jackson/databind/JsonNode.java\nindex 0a55e5b560..c0af446053 100644\n--- a/src/main/java/tools/jackson/databind/JsonNode.java\n+++ b/src/main/java/tools/jackson/databind/JsonNode.java\n@@ -1343,6 +1343,56 @@ public String asText(String defaultValue) {\n      */\n     public abstract Optional<BigDecimal> asDecimalOpt();\n \n+    // // Container access: ArrayNode / ObjectNode\n+\n+    /**\n+     * Method that will try to return this node as an {@link ArrayNode}:\n+     * if this node is already an {@code ArrayNode}, {@code this} is returned;\n+     * otherwise a {@link JsonNodeException} will be thrown.\n+     *\n+     * @return This node as {@link ArrayNode} (if it is one)\n+     *\n+     * @throws JsonNodeException if this node is not an {@link ArrayNode}\n+     *\n+     * @since 3.1\n+     */\n+    public abstract ArrayNode asArray();\n+\n+    /**\n+     * Similar to {@link #asArray()}, but instead of throwing an exception for\n+     * non-array nodes, will return {@code Optional.empty()}.\n+     *\n+     * @return This node as {@code Optional<ArrayNode>} (if it is an array node);\n+     *   {@code Optional.empty()} otherwise\n+     *\n+     * @since 3.1\n+     */\n+    public abstract Optional<ArrayNode> asArrayOpt();\n+\n+    /**\n+     * Method that will try to return this node as an {@link ObjectNode}:\n+     * if this node is already an {@code ObjectNode}, {@code this} is returned;\n+     * otherwise a {@link JsonNodeException} will be thrown.\n+     *\n+     * @return This node as {@link ObjectNode} (if it is one)\n+     *\n+     * @throws JsonNodeException if this node is not an {@link ObjectNode}\n+     *\n+     * @since 3.1\n+     */\n+    public abstract ObjectNode asObject();\n+\n+    /**\n+     * Similar to {@link #asObject()}, but instead of throwing an exception for\n+     * non-object nodes, will return {@code Optional.empty()}.\n+     *\n+     * @return This node as {@code Optional<ObjectNode>} (if it is an object node);\n+     *   {@code Optional.empty()} otherwise\n+     *\n+     * @since 3.1\n+     */\n+    public abstract Optional<ObjectNode> asObjectOpt();\n+\n     /*\n     /**********************************************************************\n     /* Public API, extended traversal with \"required()\"\ndiff --git a/src/main/java/tools/jackson/databind/ObjectMapper.java b/src/main/java/tools/jackson/databind/ObjectMapper.java\nindex 516e180234..adee668f0d 100644\n--- a/src/main/java/tools/jackson/databind/ObjectMapper.java\n+++ b/src/main/java/tools/jackson/databind/ObjectMapper.java\n@@ -1291,6 +1291,10 @@ public <T> T treeToValue(JsonNode n, Class<T> valueType)\n         return readValue(treeAsTokens(n), valueType);\n     }\n \n+\n+    /**\n+     * @deprecated Since 3.1 use overload with {@link JsonNode} as first argument\n+     */\n     @Deprecated // @since 3.1\n     public <T> T treeToValue(TreeNode n, Class<T> valueType)\n         throws JacksonException\ndiff --git a/src/main/java/tools/jackson/databind/node/ArrayNode.java b/src/main/java/tools/jackson/databind/node/ArrayNode.java\nindex 83247c0464..ad05b46763 100644\n--- a/src/main/java/tools/jackson/databind/node/ArrayNode.java\n+++ b/src/main/java/tools/jackson/databind/node/ArrayNode.java\n@@ -235,6 +235,16 @@ public boolean isArray() {\n         return true;\n     }\n \n+    @Override\n+    public ArrayNode asArray() {\n+        return this;\n+    }\n+\n+    @Override\n+    public Optional<ArrayNode> asArrayOpt() {\n+        return Optional.of(this);\n+    }\n+\n     @Override public JsonToken asToken() { return JsonToken.START_ARRAY; }\n \n     @Override\ndiff --git a/src/main/java/tools/jackson/databind/node/BaseJsonNode.java b/src/main/java/tools/jackson/databind/node/BaseJsonNode.java\nindex ade18183d5..2e9bbc6ca1 100644\n--- a/src/main/java/tools/jackson/databind/node/BaseJsonNode.java\n+++ b/src/main/java/tools/jackson/databind/node/BaseJsonNode.java\n@@ -409,6 +409,36 @@ public Optional<String> asStringOpt() {\n         return Optional.ofNullable(_asString());\n     }\n \n+    /*\n+    /**********************************************************************\n+    /* Defaulting for container access (asArray/asObject)\n+    /**********************************************************************\n+     */\n+\n+    @Override\n+    public ArrayNode asArray() {\n+        return _reportWrongNodeType(\n+                \"Can only call `asArray()` on `ArrayNode`, not %s\",\n+                ClassUtil.nameOf(getClass()));\n+    }\n+\n+    @Override\n+    public Optional<ArrayNode> asArrayOpt() {\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    public ObjectNode asObject() {\n+        return _reportWrongNodeType(\n+                \"Can only call `asObject()` on `ObjectNode`, not %s\",\n+                ClassUtil.nameOf(getClass()));\n+    }\n+\n+    @Override\n+    public Optional<ObjectNode> asObjectOpt() {\n+        return Optional.empty();\n+    }\n+\n     /*\n     /**********************************************************************\n     /* Basic definitions for non-container types\ndiff --git a/src/main/java/tools/jackson/databind/node/ObjectNode.java b/src/main/java/tools/jackson/databind/node/ObjectNode.java\nindex 810e54bff0..823e7bf12e 100644\n--- a/src/main/java/tools/jackson/databind/node/ObjectNode.java\n+++ b/src/main/java/tools/jackson/databind/node/ObjectNode.java\n@@ -244,6 +244,16 @@ public final boolean isObject() {\n         return true;\n     }\n \n+    @Override\n+    public ObjectNode asObject() {\n+        return this;\n+    }\n+\n+    @Override\n+    public Optional<ObjectNode> asObjectOpt() {\n+        return Optional.of(this);\n+    }\n+\n     @Override public JsonToken asToken() { return JsonToken.START_OBJECT; }\n \n     @Override\n",
  "test_patch" : "diff --git a/src/test/java/tools/jackson/databind/node/JsonNodeAsContainerTest.java b/src/test/java/tools/jackson/databind/node/JsonNodeAsContainerTest.java\nnew file mode 100644\nindex 0000000000..1251658ec8\n--- /dev/null\n+++ b/src/test/java/tools/jackson/databind/node/JsonNodeAsContainerTest.java\n@@ -0,0 +1,183 @@\n+package tools.jackson.databind.node;\n+\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import tools.jackson.databind.JsonNode;\n+import tools.jackson.databind.exc.JsonNodeException;\n+import tools.jackson.databind.testutil.DatabindTestUtil;\n+import tools.jackson.databind.util.RawValue;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+/**\n+ * Tests for [databind#2343], {@code JsonNode.asArray()}\n+ * and {@code JsonNode.asObject()}.\n+ */\n+public class JsonNodeAsContainerTest\n+    extends DatabindTestUtil\n+{\n+    private final JsonNodeFactory NODES = newJsonMapper().getNodeFactory();\n+\n+    // // // asArray() tests\n+\n+    @Test\n+    public void asArrayOkFromArrayNode()\n+    {\n+        ArrayNode array = NODES.arrayNode();\n+        array.add(1);\n+        array.add(\"two\");\n+\n+        // asArray() should return the same instance\n+        assertSame(array, array.asArray());\n+\n+        // asArrayOpt() should return Optional containing the same instance\n+        Optional<ArrayNode> opt = array.asArrayOpt();\n+        assertTrue(opt.isPresent());\n+        assertSame(array, opt.get());\n+    }\n+\n+    @Test\n+    public void asArrayFailFromObjectNode()\n+    {\n+        _assertFailAsArrayFor(NODES.objectNode());\n+    }\n+\n+    @Test\n+    public void asArrayFailFromScalars()\n+    {\n+        _assertFailAsArrayFor(NODES.booleanNode(true));\n+        _assertFailAsArrayFor(NODES.booleanNode(false));\n+        _assertFailAsArrayFor(NODES.numberNode(42));\n+        _assertFailAsArrayFor(NODES.numberNode(42L));\n+        _assertFailAsArrayFor(NODES.numberNode(42.5));\n+        _assertFailAsArrayFor(NODES.numberNode(42.5f));\n+        _assertFailAsArrayFor(NODES.numberNode(BigInteger.TEN));\n+        _assertFailAsArrayFor(NODES.numberNode(BigDecimal.valueOf(12.5)));\n+        _assertFailAsArrayFor(NODES.stringNode(\"test\"));\n+        _assertFailAsArrayFor(NODES.binaryNode(new byte[3]));\n+        _assertFailAsArrayFor(NODES.nullNode());\n+        _assertFailAsArrayFor(NODES.missingNode());\n+        _assertFailAsArrayFor(NODES.rawValueNode(new RawValue(\"abc\")));\n+        _assertFailAsArrayFor(NODES.pojoNode(new AtomicInteger(1)));\n+    }\n+\n+    // // // asObject() tests\n+\n+    @Test\n+    public void asObjectOkFromObjectNode()\n+    {\n+        ObjectNode obj = NODES.objectNode();\n+        obj.put(\"key\", \"value\");\n+\n+        // asObject() should return the same instance\n+        assertSame(obj, obj.asObject());\n+\n+        // asObjectOpt() should return Optional containing the same instance\n+        Optional<ObjectNode> opt = obj.asObjectOpt();\n+        assertTrue(opt.isPresent());\n+        assertSame(obj, opt.get());\n+    }\n+\n+    @Test\n+    public void asObjectFailFromArrayNode()\n+    {\n+        _assertFailAsObjectFor(NODES.arrayNode());\n+    }\n+\n+    @Test\n+    public void asObjectFailFromScalars()\n+    {\n+        _assertFailAsObjectFor(NODES.booleanNode(true));\n+        _assertFailAsObjectFor(NODES.booleanNode(false));\n+        _assertFailAsObjectFor(NODES.numberNode(42));\n+        _assertFailAsObjectFor(NODES.numberNode(42L));\n+        _assertFailAsObjectFor(NODES.numberNode(42.5));\n+        _assertFailAsObjectFor(NODES.numberNode(42.5f));\n+        _assertFailAsObjectFor(NODES.numberNode(BigInteger.TEN));\n+        _assertFailAsObjectFor(NODES.numberNode(BigDecimal.valueOf(12.5)));\n+        _assertFailAsObjectFor(NODES.stringNode(\"test\"));\n+        _assertFailAsObjectFor(NODES.binaryNode(new byte[3]));\n+        _assertFailAsObjectFor(NODES.nullNode());\n+        _assertFailAsObjectFor(NODES.missingNode());\n+        _assertFailAsObjectFor(NODES.rawValueNode(new RawValue(\"abc\")));\n+        _assertFailAsObjectFor(NODES.pojoNode(new AtomicInteger(1)));\n+    }\n+\n+    // // // Use case from issue: iterating array elements as objects\n+\n+    @Test\n+    public void iterateArrayElementsAsObjects()\n+    {\n+        ArrayNode array = NODES.arrayNode();\n+        array.addObject().put(\"name\", \"first\");\n+        array.addObject().put(\"name\", \"second\");\n+\n+        // Using asObject() to modify elements\n+        for (JsonNode element : array) {\n+            element.asObject().put(\"added\", true);\n+        }\n+\n+        // Verify modifications\n+        assertEquals(true, array.get(0).get(\"added\").booleanValue());\n+        assertEquals(true, array.get(1).get(\"added\").booleanValue());\n+    }\n+\n+    @Test\n+    public void iterateArrayElementsAsArrays()\n+    {\n+        ArrayNode outer = NODES.arrayNode();\n+        outer.addArray().add(1).add(2);\n+        outer.addArray().add(3).add(4);\n+\n+        // Using asArray() to modify elements\n+        for (JsonNode element : outer) {\n+            element.asArray().add(99);\n+        }\n+\n+        // Verify modifications\n+        assertEquals(3, outer.get(0).size());\n+        assertEquals(3, outer.get(1).size());\n+        assertEquals(99, outer.get(0).get(2).intValue());\n+        assertEquals(99, outer.get(1).get(2).intValue());\n+    }\n+\n+    // // // Helper methods\n+\n+    private void _assertFailAsArrayFor(JsonNode node)\n+    {\n+        // asArray() should throw exception\n+        Exception e = assertThrows(JsonNodeException.class,\n+                () -> node.asArray(),\n+                \"For (\" + node.getClass().getSimpleName() + \") value: \" + node);\n+        assertThat(e.getMessage())\n+            .contains(\"asArray()\")\n+            .contains(\"on `ArrayNode`\");\n+\n+        // asArrayOpt() should return empty Optional\n+        Optional<ArrayNode> opt = node.asArrayOpt();\n+        assertFalse(opt.isPresent(),\n+                \"Expected empty Optional for \" + node.getClass().getSimpleName());\n+    }\n+\n+    private void _assertFailAsObjectFor(JsonNode node)\n+    {\n+        // asObject() should throw exception\n+        Exception e = assertThrows(JsonNodeException.class,\n+                () -> node.asObject(),\n+                \"For (\" + node.getClass().getSimpleName() + \") value: \" + node);\n+        assertThat(e.getMessage())\n+            .contains(\"asObject()\")\n+            .contains(\"on `ObjectNode`\");\n+\n+        // asObjectOpt() should return empty Optional\n+        Optional<ObjectNode> opt = node.asObjectOpt();\n+        assertFalse(opt.isPresent(),\n+                \"Expected empty Optional for \" + node.getClass().getSimpleName());\n+    }\n+}\ndiff --git a/src/test/java/tools/jackson/databind/node/JsonNodeConversionsTest.java b/src/test/java/tools/jackson/databind/node/JsonNodeConversionsTest.java\nindex c7db52c345..a8b7a8d443 100644\n--- a/src/test/java/tools/jackson/databind/node/JsonNodeConversionsTest.java\n+++ b/src/test/java/tools/jackson/databind/node/JsonNodeConversionsTest.java\n@@ -397,7 +397,7 @@ public void testConversionsOfNull() throws Exception\n     public void testNodeConvert() throws Exception\n     {\n         ObjectNode src = (ObjectNode) MAPPER.readTree(\"{}\");\n-        TreeNode node = src;\n+        JsonNode node = src;\n         ObjectNode result = MAPPER.treeToValue(node, ObjectNode.class);\n         // should just cast...\n         assertSame(src, result);\n",
  "problem_statement" : "In the same way that there is various methods to manipulate a `JsonNode` to one of its potential real type (String, boolean, etc), there should be `asArray()` and `asObject()` available.\r\n\r\nCurrently the only way to retrieve a `JsonNode` as an `ObjectNode` or an `ArrayNode` is with the two methods `with(String)` and `withArray(String)` (even though in 2.9 their return type is broken).\r\n\r\nBut for example when manipulating an `ArrayNode`, it is not possible to get its elements as `ArrayNode` or `ObjectNode` (or I didn't find the way to do it).\r\n\r\nI would expect to be able, for example, to do:\r\n```java\r\nfor(JsonNode node: anArrayNode) {\r\n  node.asObject().set(\"a\", new TextNode(\"b\"));\r\n}\r\n```",
  "hints_text" : null,
  "created_at" : "Mon Jan 26 02:35:21 CET 2026",
  "version" : null,
  "FAIL_TO_PASS" : [ "JsonNodeAsContainerTest", "JsonNodeConversionsTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=JsonNodeAsContainerTest,JsonNodeConversionsTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : 2343,
  "pull_number" : 5611,
  "metadata" : null
}, {
  "instance_id" : "FasterXML-jackson-databind-PR-5606",
  "repo" : "FasterXML/jackson-databind",
  "base_commit" : "e5dfb2e8e6c2eeb0e083409d5cd91c84740e2efc",
  "patch" : "diff --git a/release-notes/CREDITS-2.x b/release-notes/CREDITS-2.x\nindex 52be6b909f..8a48cfb2ab 100644\n--- a/release-notes/CREDITS-2.x\n+++ b/release-notes/CREDITS-2.x\n@@ -1994,3 +1994,7 @@ Johnny Lim (@izeye)\n Hélios Gilles (@RoiSoleil)\n  * Contributed #5413: Add/support forward reference resolution for array values\n   [2.21.0]\n+\n+Lee Jiwon (@dlwldnjs1009)\n+ * Contributed #3884: Add `ObjectNode.put(JsonPointe, JsonNode)` method\n+  [2.22.0]\ndiff --git a/release-notes/VERSION-2.x b/release-notes/VERSION-2.x\nindex 14ad31f2d3..e8a1b1f5df 100644\n--- a/release-notes/VERSION-2.x\n+++ b/release-notes/VERSION-2.x\n@@ -4,6 +4,12 @@ Project: jackson-databind\n === Releases === \n ------------------------------------------------------------------------\n \n+2.22.0 (not yet released)\n+\n+#3884: Add `ObjectNode.put(JsonPointe, JsonNode)` method\n+ (requested by @SaiKrishna369)\n+ (contributed by Lee Jiwon)\n+\n 2.21.0 (18-Jan-2026)\n \n #1381: Add a way to specify \"inject-only\" with `@JacksonInject`\ndiff --git a/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java b/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java\nindex e943959af4..90f90e37e5 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java\n@@ -1142,6 +1142,70 @@ public ObjectNode put(String propertyName, byte[] v) {\n                 : binaryNode(v));\n     }\n \n+    /*\n+    /**********************************************************\n+    /* Extended ObjectNode API, mutators, JsonPointer-based\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method for setting value of a property at specified JSON Pointer location\n+     * on this {@code ObjectNode}. Intermediate {@link ObjectNode}s are created\n+     * as necessary (following the same logic as {@link #withObject(JsonPointer)}).\n+     *<p>\n+     * <b>Array index handling:</b> If the last segment appears to be an array index\n+     * (non-negative integer like {@code /arr/0}), the method checks if the parent\n+     * node already exists and is an {@link ArrayNode}:\n+     * <ul>\n+     *   <li>If parent is an existing {@link ArrayNode}: sets value at that index\n+     *       (the array must already contain enough elements; arrays are NOT expanded)</li>\n+     *   <li>Otherwise: treats the numeric segment as a property name (e.g., property \"0\")</li>\n+     * </ul>\n+     *<p>\n+     * <b>Limitations:</b>\n+     * <ul>\n+     *   <li>Empty pointer (referring to this node) throws {@link UnsupportedOperationException}</li>\n+     *   <li>Arrays are NOT created or expanded automatically</li>\n+     * </ul>\n+     *\n+     * @param ptr {@link JsonPointer} identifying location to set the value at\n+     * @param value Value to set at the specified path; {@code null} becomes a {@link NullNode}\n+     *\n+     * @return This node (to allow chaining)\n+     *\n+     * @throws UnsupportedOperationException if {@code ptr} is empty (refers to\n+     *         this node itself, which cannot be replaced)\n+     *\n+     * @since 2.22\n+     */\n+    public ObjectNode put(JsonPointer ptr, JsonNode value)\n+    {\n+        if (ptr.matches()) {\n+            return _reportWrongNodeOperation(\n+                \"Cannot use `put(JsonPointer, JsonNode)` with empty JSON Pointer: \"\n+                + \"root node cannot be replaced as it is the context node itself\");\n+        }\n+        if (value == null) {\n+            value = nullNode();\n+        }\n+        JsonPointer parentPtr = ptr.head();\n+        JsonPointer lastSegment = ptr.last();\n+\n+        if (lastSegment.mayMatchElement()) {\n+            int index = lastSegment.getMatchingIndex();\n+            if (index >= 0) {\n+                JsonNode parent = this.at(parentPtr);\n+                if (parent.isArray()) {\n+                    ((ArrayNode) parent).set(index, value);\n+                    return this;\n+                }\n+            }\n+        }\n+        String propName = lastSegment.getMatchingProperty();\n+        withObject(parentPtr).set(propName, value);\n+        return this;\n+    }\n+\n     /*\n     /**********************************************************\n     /* Standard methods\n",
  "test_patch" : "diff --git a/src/test/java/com/fasterxml/jackson/databind/node/ObjectNodeTest.java b/src/test/java/com/fasterxml/jackson/databind/node/ObjectNodeTest.java\nindex f5ceafdc28..3692fd43c6 100644\n--- a/src/test/java/com/fasterxml/jackson/databind/node/ObjectNodeTest.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/node/ObjectNodeTest.java\n@@ -11,6 +11,7 @@\n import com.fasterxml.jackson.annotation.JsonInclude;\n import com.fasterxml.jackson.annotation.JsonValue;\n import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.core.JsonPointer;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n import com.fasterxml.jackson.databind.exc.MismatchedInputException;\n@@ -651,6 +652,136 @@ private ObjectNode _objNode(String json) throws Exception {\n         }\n     }\n \n+    // [databind#3884]: put(JsonPointer, JsonNode)\n+    @Test\n+    public void testPutWithJsonPointer() throws Exception\n+    {\n+        ObjectNode root = MAPPER.createObjectNode();\n+        JsonNode value = MAPPER.getNodeFactory().textNode(\"test\");\n+\n+        ObjectNode result = root.put(JsonPointer.compile(\"/a/b/c\"), value);\n+\n+        assertSame(root, result);\n+        assertEquals(\"test\", root.at(\"/a/b/c\").asText());\n+    }\n+\n+    @Test\n+    public void testPutWithJsonPointerOverwrite() throws Exception\n+    {\n+        ObjectNode root = MAPPER.createObjectNode();\n+        root.put(\"key\", \"old\");\n+\n+        root.put(JsonPointer.compile(\"/key\"),\n+            MAPPER.getNodeFactory().textNode(\"new\"));\n+\n+        assertEquals(\"new\", root.get(\"key\").asText());\n+    }\n+\n+    @Test\n+    public void testPutWithJsonPointerChaining() throws Exception\n+    {\n+        ObjectNode root = MAPPER.createObjectNode();\n+        JsonNodeFactory f = MAPPER.getNodeFactory();\n+\n+        root.put(JsonPointer.compile(\"/a\"), f.textNode(\"A\"))\n+            .put(JsonPointer.compile(\"/b\"), f.textNode(\"B\"));\n+\n+        assertEquals(\"A\", root.get(\"a\").asText());\n+        assertEquals(\"B\", root.get(\"b\").asText());\n+    }\n+\n+    @Test\n+    public void testPutWithJsonPointerNullValue() throws Exception\n+    {\n+        ObjectNode root = MAPPER.createObjectNode();\n+\n+        root.put(JsonPointer.compile(\"/nullVal\"), null);\n+\n+        assertTrue(root.has(\"nullVal\"));\n+        assertTrue(root.get(\"nullVal\").isNull());\n+    }\n+\n+    @Test\n+    public void testPutWithJsonPointerRootFails()\n+    {\n+        ObjectNode root = MAPPER.createObjectNode();\n+\n+        assertThrows(UnsupportedOperationException.class,\n+            () -> root.put(JsonPointer.compile(\"\"), MAPPER.createObjectNode()));\n+    }\n+\n+    // [databind#3884]: put with array index in JsonPointer\n+    @Test\n+    public void testPutWithJsonPointerArrayIndex() throws Exception\n+    {\n+        ObjectNode root = MAPPER.createObjectNode();\n+        // Pre-create array with element (array must already have enough elements)\n+        root.withArray(\"/arr\").add(\"placeholder\");\n+\n+        JsonNode value = MAPPER.getNodeFactory().textNode(\"replaced\");\n+        root.put(JsonPointer.compile(\"/arr/0\"), value);\n+\n+        assertEquals(\"replaced\", root.at(\"/arr/0\").asText());\n+        assertEquals(1, root.at(\"/arr\").size());\n+        assertEquals(\"replaced\", root.at(\"/arr\").get(0).asText());\n+    }\n+\n+    @Test\n+    public void testPutWithJsonPointerNestedArrayIndex() throws Exception\n+    {\n+        ObjectNode root = MAPPER.createObjectNode();\n+        // Create nested structure: {\"data\": {\"items\": [\"x\", \"y\"]}}\n+        root.withArray(\"/data/items\").add(\"x\").add(\"y\");\n+\n+        root.put(JsonPointer.compile(\"/data/items/1\"),\n+            MAPPER.getNodeFactory().textNode(\"updated\"));\n+\n+        assertEquals(\"updated\", root.at(\"/data/items/1\").asText());\n+        assertEquals(\"x\", root.at(\"/data/items/0\").asText());\n+        assertEquals(2, root.at(\"/data/items\").size());\n+    }\n+\n+    // [databind#3884]: numeric segment is treated as property name unless parent is ArrayNode\n+    @Test\n+    public void testPutWithNumericPropertyName() throws Exception\n+    {\n+        ObjectNode root = MAPPER.createObjectNode();\n+\n+        // \"/0\" on ObjectNode: treat \"0\" as property name\n+        root.put(JsonPointer.compile(\"/0\"), MAPPER.getNodeFactory().textNode(\"value\"));\n+\n+        assertTrue(root.has(\"0\"));\n+        assertEquals(\"value\", root.get(\"0\").asText());\n+    }\n+\n+    // [databind#3884]: numeric segment is treated as property name when parent path is missing\n+    @Test\n+    public void testPutArrayIndexWhenParentMissing() throws Exception\n+    {\n+        ObjectNode root = MAPPER.createObjectNode();\n+\n+        // \"/arr/0\" with missing parent: treat \"0\" as property name -> {\"arr\":{\"0\":\"value\"}}\n+        root.put(JsonPointer.compile(\"/arr/0\"), MAPPER.getNodeFactory().textNode(\"value\"));\n+\n+        assertTrue(root.has(\"arr\"));\n+        assertTrue(root.get(\"arr\").isObject());\n+        assertEquals(\"value\", root.at(\"/arr/0\").asText());\n+    }\n+\n+    // [databind#3884]: numeric segment is treated as property name when parent is ObjectNode\n+    @Test\n+    public void testPutNumericSegmentOnExistingObject() throws Exception\n+    {\n+        ObjectNode root = MAPPER.createObjectNode();\n+        root.putObject(\"obj\");\n+\n+        // \"/obj/0\" with ObjectNode parent: treat \"0\" as property name\n+        root.put(JsonPointer.compile(\"/obj/0\"), MAPPER.getNodeFactory().textNode(\"value\"));\n+\n+        assertTrue(root.get(\"obj\").isObject());\n+        assertEquals(\"value\", root.at(\"/obj/0\").asText());\n+    }\n+\n     private String _toString(JsonNode n) {\n         return n.properties().stream()\n                 .map(e -> e.getKey() + \"/\" + e.getValue())\n",
  "problem_statement" : "There is no mechanism to edit/create a value in the json tree without first navigating to the parent node and then using `set` or `replace` or `put` methods.\r\nStarting from version 2.14, within an ObjectNode using `withObject` and `withArray` methods, new nodes can be created on a non-existent path. These two methods can further be extended to enhance `put` method, providing a feature to directly create and set value along a path or modify an existing path.\r\n\r\n**Describe the solution you'd like**\r\n`put(JsonPointer ptr, JsonNode node)` or `put(JsonPointer ptr, {primitiveDataType} value)` would create the path if it doesn't exist, then auto navigates to the node at`ptr.head()` and sets the provided value at the key `ptr.last()`.\r\n\r\n**Usage example**\r\n```\r\n@Test\r\npublic static void test_nestedArray() {\r\n        ObjectMapper mapper = new ObjectMapper();\r\n        JsonNode jsonObject\r\n        String json = \"{}\";\r\n        try {\r\n            jsonObject = mapper.readTree(json);\r\n            jsonObject.put(\"/key1/array1/0/element1\", 1);\r\n            jsonObject.put(\"/key1/array1/0/element2\", 2);\r\n            jsonObject.put(\"/key1/array1/1/element1\", 3);\r\n            jsonObject.put(\"/key1/array1/1/element2\", 4);\r\n        }\r\n        catch (Exception e) {\r\n            e.printStackTrace();\r\n        }\r\n        assertEquals(jsonObject.toString(), {\"key1\": { \"array1\": [ {\"element1\": 1, \"element2\": 2}, {\"element1\": 3, \"element2\": 4} ] } });\r\n    }\r\n```\r\n\r\n**Additional context**\r\n[Filtering Json] Right now, there is no straight forward way to copy selected paths from one json to another. This feature would simplify this task.\r\n",
  "hints_text" : null,
  "created_at" : "Thu Jan 22 14:15:06 CET 2026",
  "version" : null,
  "FAIL_TO_PASS" : [ "ObjectNodeTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=ObjectNodeTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : 3884,
  "pull_number" : 5606,
  "metadata" : null
}, {
  "instance_id" : "FasterXML-jackson-databind-PR-5604",
  "repo" : "FasterXML/jackson-databind",
  "base_commit" : "a2aa480528b6e426dce19c72737202ab93edb8ca",
  "patch" : "diff --git a/release-notes/CREDITS b/release-notes/CREDITS\nindex 3d781a3bf8..e1036a01cd 100644\n--- a/release-notes/CREDITS\n+++ b/release-notes/CREDITS\n@@ -175,7 +175,12 @@ Ulf Andersson (@ulfandersson)\n Erik Hesselink (@hesselink)\n  * Reported #2617: `@JsonDeserialize.converter` from an interface doesn't work\n   [3.1.0]\n- \n+\n+Kenneth Jorgensen (@kennethjor)\n+ * Requested #2624: Allow overriding builder's \"withPrefix\" with new\n+  `@JsonDeserialize.builderPrefix` property\n+  [3.1.0]\n+\n Garret Wilson (@garretwilson)\n  * Suggested #4157: Add `MapperFeature.INFER_RECORD_GETTERS_FROM_COMPONENTS_ONLY` to ignore\n    getter method auto-detection for Records\ndiff --git a/release-notes/VERSION b/release-notes/VERSION\nindex 4efe09f4b8..c416d75c5d 100644\n--- a/release-notes/VERSION\n+++ b/release-notes/VERSION\n@@ -43,6 +43,9 @@ Versions: 3.x (for earlier see VERSION-2.x)\n   already exists, duplicate value seen\n #2617: `@JsonDeserialize.converter` from an interface doesn't work\n  (reported by Erik H)\n+#2624: Allow overriding builder's \"withPrefix\" with new\n+  `@JsonDeserialize.builderPrefix` property\n+ (requested by Kenneth J)\n #2686: `@JsonBackReference` does not work with a builder\n  (reported by @janrieke)\n  (fix by @JacksonJang)\ndiff --git a/src/main/java/tools/jackson/databind/AnnotationIntrospector.java b/src/main/java/tools/jackson/databind/AnnotationIntrospector.java\nindex 5ddeb565d1..1e41c20679 100644\n--- a/src/main/java/tools/jackson/databind/AnnotationIntrospector.java\n+++ b/src/main/java/tools/jackson/databind/AnnotationIntrospector.java\n@@ -1134,6 +1134,24 @@ public JsonPOJOBuilder.Value findPOJOBuilderConfig(MapperConfig<?> config, Annot\n         return null;\n     }\n \n+    /**\n+     * Method for finding the builder prefix specified on the value class\n+     * via {@code @JsonDeserialize(builderPrefix=...)}. This provides an\n+     * alternative way to configure the prefix used by Builder \"with-methods\"\n+     * without having to annotate the Builder class itself with {@code @JsonPOJOBuilder}.\n+     *\n+     * @param config Effective mapper configuration in use\n+     * @param valueClass The value class (not Builder class!) to check for the annotation\n+     *\n+     * @return Builder prefix if explicitly specified; {@code null} to use default behavior\n+     *   (check {@code @JsonPOJOBuilder} on builder class, or use global default)\n+     *\n+     * @since 3.1\n+     */\n+    public String findBuilderPrefix(MapperConfig<?> config, AnnotatedClass valueClass) {\n+        return null;\n+    }\n+\n     /**\n      * Method called to check whether potential Creator (constructor or static factory\n      * method) has explicit annotation to indicate it as actual Creator; and if so,\ndiff --git a/src/main/java/tools/jackson/databind/annotation/JsonDeserialize.java b/src/main/java/tools/jackson/databind/annotation/JsonDeserialize.java\nindex b6ce56cdde..a4475bc4ad 100644\n--- a/src/main/java/tools/jackson/databind/annotation/JsonDeserialize.java\n+++ b/src/main/java/tools/jackson/databind/annotation/JsonDeserialize.java\n@@ -42,6 +42,15 @@\n @com.fasterxml.jackson.annotation.JacksonAnnotation\n public @interface JsonDeserialize\n {\n+    /**\n+     * Marker value used as default for {@link #builderPrefix} to indicate\n+     * that default handling should be used (check for {@link JsonPOJOBuilder}\n+     * annotation on builder class, or use default prefix of \"with\").\n+     *\n+     * @since 3.1\n+     */\n+    public static final String USE_DEFAULT_PREFIX = \"\\u0000\";\n+\n     // // // Annotations for explicitly specifying deserialize/builder\n \n     /**\n@@ -88,7 +97,23 @@ public Class<? extends KeyDeserializer> keyUsing()\n      */\n     public Class<?> builder() default Void.class;\n \n-    // // // Annotations for specifying intermediate Converters (2.2+)\n+    /**\n+     * Optional property for specifying the prefix used for builder\n+     * \"with\" methods when using {@link #builder()}. When set to a non-default value\n+     * (something other than {@link #USE_DEFAULT_PREFIX}), this overrides any\n+     * {@link JsonPOJOBuilder#withPrefix()} annotation on the builder class itself.\n+     * Can be set to empty string ({@code \"\"}) for no prefix (common with Lombok-generated\n+     * builders).\n+     *<p>\n+     * Defaults to {@link #USE_DEFAULT_PREFIX} which means the prefix is determined\n+     * by checking {@link JsonPOJOBuilder} annotation on the builder class, or using\n+     * the global default (\"with\").\n+     *\n+     * @since 3.1\n+     */\n+    public String builderPrefix() default USE_DEFAULT_PREFIX;\n+\n+    // // // Annotations for specifying intermediate Converters\n \n     /**\n      * Which helper object (if any) is to be used to convert from Jackson-bound\n@@ -97,17 +122,13 @@ public Class<? extends KeyDeserializer> keyUsing()\n      * for two-step deserialization; Jackson binds data into suitable intermediate\n      * type (like Tree representation), and converter then builds actual property\n      * type.\n-     *\n-     * @since 2.2\n      */\n     @SuppressWarnings(\"rawtypes\") // to work around JDK8 bug wrt Class-valued annotation properties\n     public Class<? extends Converter> converter() default Converter.None.class;\n \n     /**\n-     * Similar to {@link #converter}, but used for values of structures types\n+     * Similar to {@link #converter}, but used for values of structured types\n      * (List, arrays, Maps).\n-     *\n-     * @since 2.2\n      */\n     @SuppressWarnings(\"rawtypes\") // to work around JDK8 bug wrt Class-valued annotation properties\n     public Class<? extends Converter> contentConverter() default Converter.None.class;\ndiff --git a/src/main/java/tools/jackson/databind/introspect/AnnotationIntrospectorPair.java b/src/main/java/tools/jackson/databind/introspect/AnnotationIntrospectorPair.java\nindex efbeceee25..b2cd89b8c4 100644\n--- a/src/main/java/tools/jackson/databind/introspect/AnnotationIntrospectorPair.java\n+++ b/src/main/java/tools/jackson/databind/introspect/AnnotationIntrospectorPair.java\n@@ -635,6 +635,12 @@ public JsonPOJOBuilder.Value findPOJOBuilderConfig(MapperConfig<?> config, Annot\n         return (result == null) ? _secondary.findPOJOBuilderConfig(config, ac) : result;\n     }\n \n+    @Override\n+    public String findBuilderPrefix(MapperConfig<?> config, AnnotatedClass valueClass) {\n+        String result = _primary.findBuilderPrefix(config, valueClass);\n+        return (result == null) ? _secondary.findBuilderPrefix(config, valueClass) : result;\n+    }\n+\n     @Override\n     public JsonCreator.Mode findCreatorAnnotation(MapperConfig<?> config, Annotated a) {\n         JsonCreator.Mode mode = _primary.findCreatorAnnotation(config, a);\ndiff --git a/src/main/java/tools/jackson/databind/introspect/DefaultAccessorNamingStrategy.java b/src/main/java/tools/jackson/databind/introspect/DefaultAccessorNamingStrategy.java\nindex 2f4d369e44..999bcc1060 100644\n--- a/src/main/java/tools/jackson/databind/introspect/DefaultAccessorNamingStrategy.java\n+++ b/src/main/java/tools/jackson/databind/introspect/DefaultAccessorNamingStrategy.java\n@@ -420,10 +420,24 @@ public AccessorNamingStrategy forPOJO(MapperConfig<?> config, AnnotatedClass tar\n         public AccessorNamingStrategy forBuilder(MapperConfig<?> config,\n                 AnnotatedClass builderClass, BeanDescription valueTypeDesc)\n         {\n-            AnnotationIntrospector ai = config.isAnnotationProcessingEnabled()\n-                    ? config.getAnnotationIntrospector() : null;\n-            JsonPOJOBuilder.Value builderConfig = (ai == null) ? null : ai.findPOJOBuilderConfig(config, builderClass);\n-            String mutatorPrefix = (builderConfig == null) ? _withPrefix : builderConfig.withPrefix;\n+            final AnnotationIntrospector ai = config.getAnnotationIntrospector();\n+            // [databind#2624] First check @JsonDeserialize.builderPrefix on value class\n+            if (valueTypeDesc != null) {\n+                String prefix = ai.findBuilderPrefix(config, valueTypeDesc.getClassInfo());\n+                if (prefix != null) {\n+                    return new DefaultAccessorNamingStrategy(config, builderClass,\n+                            prefix, _getterPrefix, _isGetterPrefix,\n+                            _baseNameValidator);\n+                }\n+            }\n+\n+            // Otherwise check @JsonPOJOBuilder on builder class\n+            String mutatorPrefix = _withPrefix;\n+            JsonPOJOBuilder.Value builderConfig = ai.findPOJOBuilderConfig(config, builderClass);\n+            if (builderConfig != null) {\n+                mutatorPrefix = builderConfig.withPrefix;\n+            }\n+\n             return new DefaultAccessorNamingStrategy(config, builderClass,\n                     mutatorPrefix, _getterPrefix, _isGetterPrefix,\n                     _baseNameValidator);\ndiff --git a/src/main/java/tools/jackson/databind/introspect/JacksonAnnotationIntrospector.java b/src/main/java/tools/jackson/databind/introspect/JacksonAnnotationIntrospector.java\nindex e3e79c0586..38a5437441 100644\n--- a/src/main/java/tools/jackson/databind/introspect/JacksonAnnotationIntrospector.java\n+++ b/src/main/java/tools/jackson/databind/introspect/JacksonAnnotationIntrospector.java\n@@ -1351,6 +1351,19 @@ public JsonPOJOBuilder.Value findPOJOBuilderConfig(MapperConfig<?> config, Annot\n         return (ann == null) ? null : new JsonPOJOBuilder.Value(ann);\n     }\n \n+    @Override\n+    public String findBuilderPrefix(MapperConfig<?> config, AnnotatedClass valueClass)\n+    {\n+        JsonDeserialize ann = _findAnnotation(valueClass, JsonDeserialize.class);\n+        if (ann != null) {\n+            String prefix = ann.builderPrefix();\n+            if (!JsonDeserialize.USE_DEFAULT_PREFIX.equals(prefix)) {\n+                return prefix;\n+            }\n+        }\n+        return null;\n+    }\n+\n     /*\n     /**********************************************************************\n     /* Deserialization: property annotations\n",
  "test_patch" : "diff --git a/src/test/java/tools/jackson/databind/introspect/AccessorNamingForBuilderTest.java b/src/test/java/tools/jackson/databind/introspect/AccessorNamingForBuilderTest.java\nindex a3c0577937..1f3fe7e440 100644\n--- a/src/test/java/tools/jackson/databind/introspect/AccessorNamingForBuilderTest.java\n+++ b/src/test/java/tools/jackson/databind/introspect/AccessorNamingForBuilderTest.java\n@@ -4,6 +4,7 @@\n \n import tools.jackson.databind.*;\n import tools.jackson.databind.annotation.JsonDeserialize;\n+import tools.jackson.databind.annotation.JsonPOJOBuilder;\n import tools.jackson.databind.exc.UnrecognizedPropertyException;\n import tools.jackson.databind.testutil.DatabindTestUtil;\n \n@@ -43,6 +44,124 @@ public ValueClassXY build() {\n         }\n     }\n \n+    // [databind#2624]: Test with builderPrefix=\"\" on @JsonDeserialize (Lombok-style)\n+    @JsonDeserialize(builder=NoPrefixBuilderViaAnnotation.NoPrefixBuilder.class, builderPrefix=\"\")\n+    static class NoPrefixBuilderViaAnnotation\n+    {\n+        final int a, b;\n+\n+        protected NoPrefixBuilderViaAnnotation(int a, int b) {\n+            this.a = a;\n+            this.b = b;\n+        }\n+\n+        static class NoPrefixBuilder\n+        {\n+            protected int a, b;\n+\n+            public NoPrefixBuilder a(int a0) {\n+                this.a = a0;\n+                return this;\n+            }\n+\n+            public NoPrefixBuilder b(int b0) {\n+                this.b = b0;\n+                return this;\n+            }\n+\n+            public NoPrefixBuilderViaAnnotation build() {\n+                return new NoPrefixBuilderViaAnnotation(a, b);\n+            }\n+        }\n+    }\n+\n+    // [databind#2624]: Test with custom builderPrefix (\"set\") on @JsonDeserialize\n+    @JsonDeserialize(builder=SetPrefixBuilderViaAnnotation.SetPrefixBuilder.class, builderPrefix=\"set\")\n+    static class SetPrefixBuilderViaAnnotation\n+    {\n+        final String name;\n+        final int value;\n+\n+        protected SetPrefixBuilderViaAnnotation(String name, int value) {\n+            this.name = name;\n+            this.value = value;\n+        }\n+\n+        static class SetPrefixBuilder\n+        {\n+            protected String name;\n+            protected int value;\n+\n+            public SetPrefixBuilder setName(String n) {\n+                this.name = n;\n+                return this;\n+            }\n+\n+            public SetPrefixBuilder setValue(int v) {\n+                this.value = v;\n+                return this;\n+            }\n+\n+            public SetPrefixBuilderViaAnnotation build() {\n+                return new SetPrefixBuilderViaAnnotation(name, value);\n+            }\n+        }\n+    }\n+\n+    // [databind#2624]: Test that @JsonDeserialize.builderPrefix overrides @JsonPOJOBuilder.withPrefix\n+    @JsonDeserialize(builder=AnnotationOverrideTest.OverriddenBuilder.class, builderPrefix=\"\")\n+    static class AnnotationOverrideTest\n+    {\n+        final int x;\n+\n+        protected AnnotationOverrideTest(int x) {\n+            this.x = x;\n+        }\n+\n+        // Builder has @JsonPOJOBuilder(withPrefix=\"with\"), but @JsonDeserialize(builderPrefix=\"\") should win\n+        @JsonPOJOBuilder(withPrefix=\"with\")\n+        static class OverriddenBuilder\n+        {\n+            protected int x;\n+\n+            // Using no-prefix method name, not \"withX\"\n+            public OverriddenBuilder x(int x0) {\n+                this.x = x0;\n+                return this;\n+            }\n+\n+            public AnnotationOverrideTest build() {\n+                return new AnnotationOverrideTest(x);\n+            }\n+        }\n+    }\n+\n+    // [databind#2624]: Test that @JsonPOJOBuilder.withPrefix still works when builderPrefix not specified\n+    @JsonDeserialize(builder=FallbackToPojoBuilderTest.PojoBuilder.class)\n+    static class FallbackToPojoBuilderTest\n+    {\n+        final int y;\n+\n+        protected FallbackToPojoBuilderTest(int y) {\n+            this.y = y;\n+        }\n+\n+        @JsonPOJOBuilder(withPrefix=\"set\")\n+        static class PojoBuilder\n+        {\n+            protected int y;\n+\n+            public PojoBuilder setY(int y0) {\n+                this.y = y0;\n+                return this;\n+            }\n+\n+            public FallbackToPojoBuilderTest build() {\n+                return new FallbackToPojoBuilderTest(y);\n+            }\n+        }\n+    }\n+\n     // For [databind#2624]\n     @Test\n     public void testAccessorCustomWithMethod() throws Exception\n@@ -70,4 +189,46 @@ public void testAccessorCustomWithMethod() throws Exception\n         assertEquals(29, xy._x);\n         assertEquals(73, xy._y);\n     }\n+\n+    // [databind#2624]: Test @JsonDeserialize.builderPrefix with empty string (Lombok-style)\n+    @Test\n+    public void testBuilderPrefixEmptyViaAnnotation() throws Exception\n+    {\n+        final ObjectMapper mapper = newJsonMapper();\n+        final String json = a2q(\"{'a':10,'b':20}\");\n+        NoPrefixBuilderViaAnnotation result = mapper.readValue(json, NoPrefixBuilderViaAnnotation.class);\n+        assertEquals(10, result.a);\n+        assertEquals(20, result.b);\n+    }\n+\n+    // [databind#2624]: Test @JsonDeserialize.builderPrefix with custom prefix (\"set\")\n+    @Test\n+    public void testBuilderPrefixCustomViaAnnotation() throws Exception\n+    {\n+        final ObjectMapper mapper = newJsonMapper();\n+        final String json = a2q(\"{'name':'test','value':42}\");\n+        SetPrefixBuilderViaAnnotation result = mapper.readValue(json, SetPrefixBuilderViaAnnotation.class);\n+        assertEquals(\"test\", result.name);\n+        assertEquals(42, result.value);\n+    }\n+\n+    // [databind#2624]: Test that @JsonDeserialize.builderPrefix overrides @JsonPOJOBuilder.withPrefix\n+    @Test\n+    public void testBuilderPrefixOverridesJsonPOJOBuilder() throws Exception\n+    {\n+        final ObjectMapper mapper = newJsonMapper();\n+        final String json = a2q(\"{'x':99}\");\n+        AnnotationOverrideTest result = mapper.readValue(json, AnnotationOverrideTest.class);\n+        assertEquals(99, result.x);\n+    }\n+\n+    // [databind#2624]: Test fallback to @JsonPOJOBuilder when builderPrefix not specified\n+    @Test\n+    public void testFallbackToJsonPOJOBuilderPrefix() throws Exception\n+    {\n+        final ObjectMapper mapper = newJsonMapper();\n+        final String json = a2q(\"{'y':55}\");\n+        FallbackToPojoBuilderTest result = mapper.readValue(json, FallbackToPojoBuilderTest.class);\n+        assertEquals(55, result.y);\n+    }\n }\n",
  "problem_statement" : "It would be nice to be able to configure the builder method name prefix Jackson uses either globally through a configuration on `ObjectMapper` or through the `@JsonDeserialize` annotation itself. I'm currently using Lombok to generate my builders for me and to make it work nicely with Jackson I have to write boilerplate code, which is the whole point of lombok.\r\n\r\n## The Problem\r\n\r\nCurrently, in order to use Jackson and lombok in tandem, I have to write a model class like this:\r\n```\r\n@Builder\r\n@JsonDeserialize(builder = Model.ModelBuilder.class)\r\npublic class Model {\r\n\t\r\n\t/** various properties */\r\n\r\n\t@JsonPOJOBuilder(withPrefix = \"\")\r\n\tpublic static class ModelBuilder {\r\n\t}\r\n}\r\n```\r\n\r\nThe issue becomes even worse if using the `@SuperBuilder` annotation:\r\n```\r\n@SuperBuilder\r\n@JsonDeserialize(builder = Model.ModelBuilderImpl.class)\r\npublic class Model extends AbstractModel {\r\n\r\n\t/** various properties */\r\n\r\n\t@JsonPOJOBuilder(withPrefix = \"\")\r\n\tprotected static final class ModelBuilderImpl extends Model.ModelBuilder<Model, Model.ModelBuilderImpl> {\r\n\t}\r\n}\r\n```\r\n\r\nThere's also a blurb about the workaround in [Lombok's own documentation](https://projectlombok.org/features/Builder#jackson).\r\n\r\nRelated issue: https://github.com/FasterXML/jackson-databind/issues/1997\r\n\r\n## Global Config\r\nOne way to fix it would be to allow this to be configured globally on `ObjectMapper` like:\r\n```\r\nobjectMapper.configure(DeserializationFeature.POJO_BUILDER_PREFIX, \"\");\r\n```\r\n\r\n## JsonDeserialize Property\r\nAnother solution would be to allow it to be set on the `@JsonDeserialize` annotation itself, like:\r\n```\r\n@JsonDeserialize(builder = Model.ModelBuilder.class, withBuilderPrefix = \"\")\r\n```\r\n\r\nPersonally, I prefer option 2.",
  "hints_text" : null,
  "created_at" : "Thu Jan 22 05:56:10 CET 2026",
  "version" : null,
  "FAIL_TO_PASS" : [ "AccessorNamingForBuilderTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=AccessorNamingForBuilderTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : 2624,
  "pull_number" : 5604,
  "metadata" : null
}, {
  "instance_id" : "FasterXML-jackson-databind-PR-5603",
  "repo" : "FasterXML/jackson-databind",
  "base_commit" : "ddc955d41ceb8f1f365590b49a1b0607d55b5557",
  "patch" : "diff --git a/release-notes/CREDITS b/release-notes/CREDITS\nindex 29fee8ad52..3d781a3bf8 100644\n--- a/release-notes/CREDITS\n+++ b/release-notes/CREDITS\n@@ -172,6 +172,10 @@ Ulf Andersson (@ulfandersson)\n    `ACCEPT_EMPTY_ARRAY_AS_NULL_OBJECT`\n   [3.1.0]\n \n+Erik Hesselink (@hesselink)\n+ * Reported #2617: `@JsonDeserialize.converter` from an interface doesn't work\n+  [3.1.0]\n+ \n Garret Wilson (@garretwilson)\n  * Suggested #4157: Add `MapperFeature.INFER_RECORD_GETTERS_FROM_COMPONENTS_ONLY` to ignore\n    getter method auto-detection for Records\ndiff --git a/release-notes/VERSION b/release-notes/VERSION\nindex 39936e3279..4efe09f4b8 100644\n--- a/release-notes/VERSION\n+++ b/release-notes/VERSION\n@@ -1,4 +1,3 @@\n-\n Project: jackson-databind \n Versions: 3.x (for earlier see VERSION-2.x)\n \n@@ -42,6 +41,8 @@ Versions: 3.x (for earlier see VERSION-2.x)\n  (fix by @cowtowncoder, w/ Claude code)\n #2438: Prevent use of setter/field in case Creator property\n   already exists, duplicate value seen\n+#2617: `@JsonDeserialize.converter` from an interface doesn't work\n+ (reported by Erik H)\n #2686: `@JsonBackReference` does not work with a builder\n  (reported by @janrieke)\n  (fix by @JacksonJang)\ndiff --git a/src/main/java/tools/jackson/databind/deser/DeserializerCache.java b/src/main/java/tools/jackson/databind/deser/DeserializerCache.java\nindex 2c8446b2bf..adc015c209 100644\n--- a/src/main/java/tools/jackson/databind/deser/DeserializerCache.java\n+++ b/src/main/java/tools/jackson/databind/deser/DeserializerCache.java\n@@ -354,6 +354,13 @@ protected ValueDeserializer<Object> _createDeserializer(DeserializationContext c\n             if (!delegateType.hasRawClass(type.getRawClass())) {\n                 beanDescRef = ctxt.lazyIntrospectBeanDescription(delegateType);\n             }\n+            // [databind#2617]: Need to apply type modifications\n+            // (like @JsonDeserialize(as=...)) to the delegate type as well\n+            JavaType newDelegateType = modifyTypeByAnnotation(ctxt, beanDescRef.getClassInfo(), delegateType);\n+            if (newDelegateType != delegateType) {\n+                delegateType = newDelegateType;\n+                beanDescRef = ctxt.lazyIntrospectBeanDescription(delegateType);\n+            }\n             return new StdConvertingDeserializer<Object>(conv, delegateType,\n                     _createDeserializer2(ctxt, factory, delegateType, beanDescRef));\n         }\n",
  "test_patch" : "diff --git a/src/test/java/tools/jackson/databind/tofix/ConverterFromInterface2617Test.java b/src/test/java/tools/jackson/databind/convert/ConverterFromInterface2617Test.java\nsimilarity index 92%\nrename from src/test/java/tools/jackson/databind/tofix/ConverterFromInterface2617Test.java\nrename to src/test/java/tools/jackson/databind/convert/ConverterFromInterface2617Test.java\nindex 0a0c08d796..f70cb0d8a8 100644\n--- a/src/test/java/tools/jackson/databind/tofix/ConverterFromInterface2617Test.java\n+++ b/src/test/java/tools/jackson/databind/convert/ConverterFromInterface2617Test.java\n@@ -1,4 +1,4 @@\n-package tools.jackson.databind.tofix;\n+package tools.jackson.databind.convert;\n \n import org.junit.jupiter.api.Test;\n \n@@ -8,7 +8,6 @@\n \n import tools.jackson.databind.ObjectMapper;\n import tools.jackson.databind.testutil.DatabindTestUtil;\n-import tools.jackson.databind.testutil.failure.JacksonTestFailureExpected;\n import tools.jackson.databind.util.StdConverter;\n \n import static org.junit.jupiter.api.Assertions.assertEquals;\n@@ -62,7 +61,6 @@ public Concrete convert(From value) {\n \n     private final ObjectMapper MAPPER = newJsonMapper();\n \n-    @JacksonTestFailureExpected\n     @Test\n     public void testConverterFromInterface() throws Exception\n     {\n",
  "problem_statement" : "When deserializing a class using `@JsonDeserialize(converter = ...)`, if the converter's `FROM` type is an interface using `@JsonDeserialize(as = ...)`, deserialization fails. It looks like Jackson is failing to use the `as` setting when used as a `FROM` class in a converter.\r\n\r\nThis problem originally came up where `FROM` was generated by immutables, but I've simplified the code below to not depend on immutables. Using jackson-databind 2.10.2, the below test fails when converting from `From`, but succeeds when converting from `FromImpl`. The error is:\r\n\r\n```\r\ncom.fasterxml.jackson.databind.exc.InvalidDefinitionException: Cannot construct instance of `com.palantir.foundry.audit.ConverterTest$From` (no Creators, like default construct, exist): abstract types either need to be mapped to concrete types, have custom deserializer, or contain additional type information\r\n at [Source: (String)\"{\"field\": \"foo\"}\"; line: 1, column: 1]\r\n```\r\n\r\nIf other people run into this, my workaround is to use a custom deserializer which deserializes the `FROM` class and then calls the conversion function.\r\n\r\nReproducing code below:\r\n\r\n``` java\r\nimport static org.assertj.core.api.Assertions.assertThat;\r\n\r\nimport com.fasterxml.jackson.annotation.JsonProperty;\r\nimport com.fasterxml.jackson.core.JsonProcessingException;\r\nimport com.fasterxml.jackson.databind.ObjectMapper;\r\nimport com.fasterxml.jackson.databind.annotation.JsonDeserialize;\r\nimport com.fasterxml.jackson.databind.util.StdConverter;\r\nimport org.junit.Test;\r\n\r\npublic class ConverterTest {\r\n    @Test\r\n    public void testConverterOnConcreteClass() throws JsonProcessingException {\r\n        ObjectMapper mapper = new ObjectMapper();\r\n        Concrete value = mapper.readValue(\"{\\\"field\\\": \\\"foo\\\"}\", Concrete.class);\r\n        assertThat(value.getField()).isEqualTo(\"foo\");\r\n    }\r\n\r\n    @JsonDeserialize(converter = FromConverter.class)\r\n    static class Concrete {\r\n        private String field;\r\n\r\n        public String getField() {\r\n            return field;\r\n        }\r\n\r\n        public void setField(String field) {\r\n            this.field = field;\r\n        }\r\n    }\r\n\r\n    @JsonDeserialize(as = FromImpl.class)\r\n    interface From {\r\n        String field();\r\n    }\r\n\r\n    static class FromImpl implements From {\r\n        @JsonProperty\r\n        private String field;\r\n\r\n        @Override\r\n        public String field() {\r\n            return field;\r\n        }\r\n    }\r\n\r\n    private static class FromConverter extends StdConverter<From, Concrete> {\r\n        @Override\r\n        public Concrete convert(From value) {\r\n            Concrete test = new Concrete();\r\n            test.setField(value.field());\r\n            return test;\r\n        }\r\n    }\r\n}\r\n```",
  "hints_text" : null,
  "created_at" : "Thu Jan 22 05:30:54 CET 2026",
  "version" : null,
  "FAIL_TO_PASS" : [ "ConverterFromInterface2617Test" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=ConverterFromInterface2617Test",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : 2617,
  "pull_number" : 5603,
  "metadata" : null
}, {
  "instance_id" : "FasterXML-jackson-databind-PR-5600",
  "repo" : "FasterXML/jackson-databind",
  "base_commit" : "b2463a27be81da52cfdb12f9f595d69bf1f28a13",
  "patch" : "diff --git a/release-notes/VERSION b/release-notes/VERSION\nindex 7a06b1790e..d0c4370cb7 100644\n--- a/release-notes/VERSION\n+++ b/release-notes/VERSION\n@@ -141,6 +141,7 @@ Versions: 3.x (for earlier see VERSION-2.x)\n  (implemented by @cowtowncoder, w/ Claude code)\n #5586: Change `IndexOutOfBoundsException` that `ArrayNode.set()`/`replace()`\n   throw to `JsonNodeException`\n+#5599: Reduce mutability of `JsonFormatVisitor` types in 3.1\n \n 3.0.4 (not yet released)\n \ndiff --git a/src/main/java/tools/jackson/databind/jsonFormatVisitors/JsonArrayFormatVisitor.java b/src/main/java/tools/jackson/databind/jsonFormatVisitors/JsonArrayFormatVisitor.java\nindex bbb102ed89..3cbc56f670 100644\n--- a/src/main/java/tools/jackson/databind/jsonFormatVisitors/JsonArrayFormatVisitor.java\n+++ b/src/main/java/tools/jackson/databind/jsonFormatVisitors/JsonArrayFormatVisitor.java\n@@ -3,7 +3,7 @@\n import tools.jackson.databind.JavaType;\n import tools.jackson.databind.SerializationContext;\n \n-public interface JsonArrayFormatVisitor extends WithSettableSerializationContext\n+public interface JsonArrayFormatVisitor extends WithGettableSerializationContext\n {\n     /**\n      * Visit method called for structured types, as well as possibly\n@@ -30,17 +30,13 @@ public interface JsonArrayFormatVisitor extends WithSettableSerializationContext\n     public static class Base\n         implements JsonArrayFormatVisitor\n     {\n-        protected SerializationContext _context;\n+        protected final SerializationContext _context;\n \n-        public Base() { }\n         public Base(SerializationContext p) { _context = p; }\n \n         @Override\n         public SerializationContext getContext() { return _context; }\n \n-        @Override\n-        public void setContext(SerializationContext c) { _context = c; }\n-\n         @Override\n         public void itemsFormat(JsonFormatVisitable handler, JavaType elementType) { }\n \ndiff --git a/src/main/java/tools/jackson/databind/jsonFormatVisitors/JsonFormatVisitorWrapper.java b/src/main/java/tools/jackson/databind/jsonFormatVisitors/JsonFormatVisitorWrapper.java\nindex 81c443cbb2..45462f96d3 100644\n--- a/src/main/java/tools/jackson/databind/jsonFormatVisitors/JsonFormatVisitorWrapper.java\n+++ b/src/main/java/tools/jackson/databind/jsonFormatVisitors/JsonFormatVisitorWrapper.java\n@@ -55,8 +55,6 @@ public interface JsonFormatVisitorWrapper extends WithSettableSerializationConte\n     /**\n      * Method called when type is of Java {@link java.util.Map} type, and will\n      * be serialized as a JSON Object.\n-     *\n-     * @since 2.2\n      */\n     public JsonMapFormatVisitor expectMapFormat(JavaType type);\n \n@@ -65,8 +63,6 @@ public interface JsonFormatVisitorWrapper extends WithSettableSerializationConte\n      * sub-classing. Does implement {@link #setContext(SerializationContext)} and\n      * {@link #getContext()} as expected; other methods simply return null\n      * and do nothing.\n-     *\n-     * @since 2.5\n      */\n     public static class Base implements JsonFormatVisitorWrapper {\n         protected SerializationContext _context;\ndiff --git a/src/main/java/tools/jackson/databind/jsonFormatVisitors/JsonMapFormatVisitor.java b/src/main/java/tools/jackson/databind/jsonFormatVisitors/JsonMapFormatVisitor.java\nindex e341e39562..bddf6d2434 100644\n--- a/src/main/java/tools/jackson/databind/jsonFormatVisitors/JsonMapFormatVisitor.java\n+++ b/src/main/java/tools/jackson/databind/jsonFormatVisitors/JsonMapFormatVisitor.java\n@@ -3,7 +3,7 @@\n import tools.jackson.databind.JavaType;\n import tools.jackson.databind.SerializationContext;\n \n-public interface JsonMapFormatVisitor extends WithSettableSerializationContext\n+public interface JsonMapFormatVisitor extends WithGettableSerializationContext\n {\n     /**\n      * Visit method called to indicate type of keys of the Map type\n@@ -25,17 +25,13 @@ public interface JsonMapFormatVisitor extends WithSettableSerializationContext\n     public static class Base\n         implements JsonMapFormatVisitor\n     {\n-        protected SerializationContext _context;\n+        protected final SerializationContext _context;\n \n-        public Base() { }\n         public Base(SerializationContext p) { _context = p; }\n \n         @Override\n         public SerializationContext getContext() { return _context; }\n \n-        @Override\n-        public void setContext(SerializationContext p) { _context = p; }\n-\n         @Override\n         public void keyFormat(JsonFormatVisitable handler, JavaType keyType) { }\n         @Override\ndiff --git a/src/main/java/tools/jackson/databind/jsonFormatVisitors/JsonObjectFormatVisitor.java b/src/main/java/tools/jackson/databind/jsonFormatVisitors/JsonObjectFormatVisitor.java\nindex 563735148f..3f2e3b75fb 100644\n--- a/src/main/java/tools/jackson/databind/jsonFormatVisitors/JsonObjectFormatVisitor.java\n+++ b/src/main/java/tools/jackson/databind/jsonFormatVisitors/JsonObjectFormatVisitor.java\n@@ -9,7 +9,7 @@\n  * are being visited: this usually means POJOs, but sometimes other\n  * types use it too (like {@link java.util.EnumMap}).\n  */\n-public interface JsonObjectFormatVisitor extends WithSettableSerializationContext\n+public interface JsonObjectFormatVisitor extends WithGettableSerializationContext\n {\n     /**\n      * Callback method called when a POJO property is being traversed.\n@@ -35,17 +35,13 @@ public void optionalProperty(String name, JsonFormatVisitable handler,\n     public static class Base\n         implements JsonObjectFormatVisitor\n     {\n-        protected SerializationContext _context;\n+        protected final SerializationContext _context;\n \n-        public Base() { }\n         public Base(SerializationContext p) { _context = p; }\n \n         @Override\n         public SerializationContext getContext() { return _context; }\n \n-        @Override\n-        public void setContext(SerializationContext p) { _context = p; }\n-\n         @Override\n         public void property(BeanProperty prop) { }\n \n",
  "test_patch" : "diff --git a/src/test/java/tools/jackson/databind/jsonschema/FormatVisitor5393Test.java b/src/test/java/tools/jackson/databind/jsonschema/FormatVisitor5393Test.java\nindex 26d45d6198..8946defba2 100644\n--- a/src/test/java/tools/jackson/databind/jsonschema/FormatVisitor5393Test.java\n+++ b/src/test/java/tools/jackson/databind/jsonschema/FormatVisitor5393Test.java\n@@ -46,7 +46,7 @@ public void ignoreExplicitlyIgnoredAndAnyGetter() throws Exception {\n                 new JsonFormatVisitorWrapper.Base() {\n                     @Override\n                     public JsonObjectFormatVisitor expectObjectFormat(JavaType type) {\n-                        return new JsonObjectFormatVisitor.Base() {\n+                        return new JsonObjectFormatVisitor.Base(getContext()) {\n                             @Override\n                             public void property(BeanProperty prop) {\n                                 actual.add(prop.getName());\ndiff --git a/src/test/java/tools/jackson/databind/jsonschema/NewSchemaTest.java b/src/test/java/tools/jackson/databind/jsonschema/NewSchemaTest.java\nindex a75b2877d5..6f461aa2fa 100644\n--- a/src/test/java/tools/jackson/databind/jsonschema/NewSchemaTest.java\n+++ b/src/test/java/tools/jackson/databind/jsonschema/NewSchemaTest.java\n@@ -195,7 +195,7 @@ public JsonAnyFormatVisitor expectAnyFormat(JavaType type) {\n \n         @Override\n         public JsonMapFormatVisitor expectMapFormat(JavaType type) {\n-            return new JsonMapFormatVisitor.Base();\n+            return new JsonMapFormatVisitor.Base(getContext());\n         }\n     }\n \ndiff --git a/src/test/java/tools/jackson/databind/views/ViewsWithSchemaTest.java b/src/test/java/tools/jackson/databind/views/ViewsWithSchemaTest.java\nindex c845506143..0567950695 100644\n--- a/src/test/java/tools/jackson/databind/views/ViewsWithSchemaTest.java\n+++ b/src/test/java/tools/jackson/databind/views/ViewsWithSchemaTest.java\n@@ -31,11 +31,11 @@ static class POJO {\n \n     static class ListingVisitor extends JsonFormatVisitorWrapper.Base\n     {\n-        public final List<String> names = new ArrayList<String>();\n+        public final List<String> names = new ArrayList<>();\n \n         @Override\n         public JsonObjectFormatVisitor expectObjectFormat(JavaType type) {\n-            return new JsonObjectFormatVisitor.Base() {\n+            return new JsonObjectFormatVisitor.Base(getContext()) {\n                 @Override\n                 public void optionalProperty(BeanProperty writer) {\n                     names.add(writer.getName());\n",
  "problem_statement" : "Some visitor types in `tools.jackson.databind.jsonFormatVisitors` are mutable to allow assigning `SerializationContext`. Ideally this would not be necessary: let's see if visitors can be made immutable.\n\n",
  "hints_text" : null,
  "created_at" : "Wed Jan 21 03:40:27 CET 2026",
  "version" : null,
  "FAIL_TO_PASS" : [ "FormatVisitor5393Test", "NewSchemaTest", "ViewsWithSchemaTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=FormatVisitor5393Test,NewSchemaTest,ViewsWithSchemaTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : 5599,
  "pull_number" : 5600,
  "metadata" : null
}, {
  "instance_id" : "FasterXML-jackson-databind-PR-5595",
  "repo" : "FasterXML/jackson-databind",
  "base_commit" : "bd24fa564538bbda6ea4ba162c7e1a6739599f07",
  "patch" : "diff --git a/release-notes/CREDITS b/release-notes/CREDITS\nindex 38fde46b12..29fee8ad52 100644\n--- a/release-notes/CREDITS\n+++ b/release-notes/CREDITS\n@@ -209,3 +209,7 @@ Filip Hrisafov (@filiphr)\n Réda Housni Alaoui (@reda-alaoui)\n  * Requested #5575: Allow configuring a default serialization and deserialization view (3.x)\n   [3.1.0]\n+\n+Flinter (@jhan0121)\n+ * Contributed #5595: Add `FunctionalScalarDeserializer` for functional-style deserialization\n+  [3.1.0]\ndiff --git a/release-notes/VERSION b/release-notes/VERSION\nindex d0c4370cb7..39936e3279 100644\n--- a/release-notes/VERSION\n+++ b/release-notes/VERSION\n@@ -141,6 +141,8 @@ Versions: 3.x (for earlier see VERSION-2.x)\n  (implemented by @cowtowncoder, w/ Claude code)\n #5586: Change `IndexOutOfBoundsException` that `ArrayNode.set()`/`replace()`\n   throw to `JsonNodeException`\n+#5595: Add `FunctionalScalarDeserializer` for functional-style deserialization\n+ (contributed by @jhan0121)\n #5599: Reduce mutability of `JsonFormatVisitor` types in 3.1\n \n 3.0.4 (not yet released)\ndiff --git a/src/main/java/tools/jackson/databind/deser/std/FunctionalScalarDeserializer.java b/src/main/java/tools/jackson/databind/deser/std/FunctionalScalarDeserializer.java\nnew file mode 100644\nindex 0000000000..8c0d290a69\n--- /dev/null\n+++ b/src/main/java/tools/jackson/databind/deser/std/FunctionalScalarDeserializer.java\n@@ -0,0 +1,172 @@\n+package tools.jackson.databind.deser.std;\n+\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+\n+import tools.jackson.core.JacksonException;\n+import tools.jackson.core.JsonParser;\n+import tools.jackson.core.JsonToken;\n+\n+import tools.jackson.databind.DeserializationContext;\n+import tools.jackson.databind.JavaType;\n+import tools.jackson.databind.cfg.CoercionAction;\n+import tools.jackson.databind.cfg.CoercionInputShape;\n+import tools.jackson.databind.type.LogicalType;\n+\n+/**\n+ * A general-purpose deserializer that uses a {@link Function} or {@link BiFunction}\n+ * to convert JSON scalar values (strings, numbers, booleans) into target type instances.\n+ * <p>\n+ * This deserializer is primarily designed for String-based conversions but also\n+ * supports other JSON scalar types via {@code getValueAsString()} coercion.\n+ * Non-scalar JSON values (arrays, objects, embedded objects) are rejected.\n+ * <p>\n+ * Usage examples:\n+ * <pre>\n+ * // Simple case - method reference\n+ * new FunctionalScalarDeserializer<>(Bar.class, Bar::of)\n+ *\n+ * // Full access case\n+ * new FunctionalScalarDeserializer<>(Bar.class, (p, ctx) ->\n+ *     Bar.parse(p.getValueAsString(), ctx.getLocale()))\n+ * </pre>\n+ *\n+ * @param <T> Target type to deserialize into\n+ *\n+ * @since 3.1\n+ */\n+public class FunctionalScalarDeserializer<T> extends StdScalarDeserializer<T>\n+{\n+    protected final BiFunction<JsonParser, DeserializationContext, T> _biFunction;\n+    protected final Function<String, T> _stringFunction;\n+\n+    /*\n+    /**********************************************************************\n+    /* Life-cycle\n+    /**********************************************************************\n+     */\n+\n+    public FunctionalScalarDeserializer(Class<T> type,\n+            BiFunction<JsonParser, DeserializationContext, T> function) {\n+        super(type);\n+        _biFunction = function;\n+        _stringFunction = null;\n+    }\n+\n+    public FunctionalScalarDeserializer(JavaType type,\n+            BiFunction<JsonParser, DeserializationContext, T> function) {\n+        super(type);\n+        _biFunction = function;\n+        _stringFunction = null;\n+    }\n+\n+    public FunctionalScalarDeserializer(Class<T> type, Function<String, T> function) {\n+        super(type);\n+        _biFunction = null;\n+        _stringFunction = function;\n+    }\n+\n+    public FunctionalScalarDeserializer(JavaType type, Function<String, T> function) {\n+        super(type);\n+        _biFunction = null;\n+        _stringFunction = function;\n+    }\n+\n+    @Override\n+    public LogicalType logicalType() {\n+        return LogicalType.OtherScalar;\n+    }\n+\n+    /*\n+    /**********************************************************************\n+    /* Deserializer implementations\n+    /**********************************************************************\n+     */\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public T deserialize(JsonParser p, DeserializationContext ctxt)\n+        throws JacksonException\n+    {\n+        // BiFunction: invoke directly without any pre-processing\n+        if (_biFunction != null) {\n+            try {\n+                return _biFunction.apply(p, ctxt);\n+            } catch (Exception e) {\n+                return _handleException(p, ctxt, e);\n+            }\n+        }\n+\n+        // Function<String, T>: extract text and pass to function\n+        String text = p.getValueAsString();\n+\n+        if (text == null) {\n+            JsonToken t = p.currentToken();\n+            if (t == JsonToken.START_OBJECT) {\n+                text = ctxt.extractScalarFromObject(p, this, _valueClass);\n+                if (text == null) {\n+                    return (T) ctxt.handleUnexpectedToken(getValueType(ctxt), p);\n+                }\n+            } else {\n+                // Non-scalar tokens (arrays, embedded objects, etc.) are not supported\n+                return (T) ctxt.handleUnexpectedToken(getValueType(ctxt), p);\n+            }\n+        }\n+\n+        if (text.isEmpty()) {\n+            return (T) _deserializeFromEmptyString(ctxt);\n+        }\n+\n+        try {\n+            return _stringFunction.apply(text);\n+        } catch (Exception e) {\n+            return _handleException(text, ctxt, e);\n+        }\n+    }\n+\n+    private T _handleException(JsonParser p, DeserializationContext ctxt,\n+            Exception e)\n+        throws JacksonException\n+    {\n+        if (e instanceof JacksonException je) {\n+            throw je;\n+        }\n+        return _handleException(p.getValueAsString(), ctxt, e);\n+    }\n+\n+    private T _handleException(String text, DeserializationContext ctxt, Exception e)\n+        throws JacksonException\n+    {\n+        if (e instanceof JacksonException je) {\n+            throw je;\n+        }\n+        String msg = \"not a valid textual representation\";\n+        String m2 = e.getMessage();\n+        if (m2 != null) {\n+            msg = msg + \", problem: \" + m2;\n+        }\n+        throw ctxt.weirdStringException(text, _valueClass, msg)\n+                .withCause(e);\n+    }\n+\n+    /**\n+     * Handle empty String input according to {@link CoercionAction} configuration.\n+     */\n+    private Object _deserializeFromEmptyString(DeserializationContext ctxt)\n+        throws JacksonException\n+    {\n+        CoercionAction act = ctxt.findCoercionAction(logicalType(), _valueClass,\n+                CoercionInputShape.EmptyString);\n+\n+        if (act == CoercionAction.Fail) {\n+            ctxt.reportInputMismatch(this,\n+                    \"Cannot coerce empty String (\\\"\\\") to %s (but could if enabling coercion using `CoercionConfig`)\",\n+                    _coercedTypeDesc());\n+        }\n+        if (act == CoercionAction.AsEmpty) {\n+            return getEmptyValue(ctxt);\n+        }\n+        // if (act == CoercionAction.AsNull) etc\n+        return getNullValue(ctxt);\n+    }\n+}\n",
  "test_patch" : "diff --git a/src/test/java/tools/jackson/databind/deser/std/FunctionalScalarDeserializer4004Test.java b/src/test/java/tools/jackson/databind/deser/std/FunctionalScalarDeserializer4004Test.java\nnew file mode 100644\nindex 0000000000..5374c9b1af\n--- /dev/null\n+++ b/src/test/java/tools/jackson/databind/deser/std/FunctionalScalarDeserializer4004Test.java\n@@ -0,0 +1,517 @@\n+package tools.jackson.databind.deser.std;\n+\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import tools.jackson.core.type.TypeReference;\n+\n+import tools.jackson.databind.JavaType;\n+import tools.jackson.databind.ObjectMapper;\n+import tools.jackson.databind.cfg.CoercionAction;\n+import tools.jackson.databind.cfg.CoercionInputShape;\n+import tools.jackson.databind.exc.MismatchedInputException;\n+import tools.jackson.databind.module.SimpleModule;\n+import tools.jackson.databind.type.LogicalType;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+import static tools.jackson.databind.testutil.DatabindTestUtil.*;\n+\n+// [databind#4004]: Add FunctionalScalarDeserializer for functional-style deserialization\n+public class FunctionalScalarDeserializer4004Test\n+{\n+    // Simple value type for testing\n+    static class Bar {\n+        private final String value;\n+\n+        private Bar(String value) {\n+            this.value = value;\n+        }\n+\n+        public static Bar of(String value) {\n+            return new Bar(value);\n+        }\n+\n+        public String getValue() {\n+            return value;\n+        }\n+    }\n+\n+    // Wrapper POJO for testing deserialization as a field\n+    static class BarWrapper {\n+        public Bar bar;\n+    }\n+\n+    @Test\n+    public void testClassWithFunction() throws Exception\n+    {\n+        SimpleModule module = new SimpleModule(\"test\");\n+        module.addDeserializer(Bar.class,\n+                new FunctionalScalarDeserializer<>(Bar.class, Bar::of));\n+\n+        ObjectMapper mapper = jsonMapperBuilder()\n+                .addModule(module)\n+                .build();\n+\n+        Bar result = mapper.readValue(\"\\\"hello\\\"\", Bar.class);\n+        assertEquals(\"hello\", result.getValue());\n+    }\n+\n+    @Test\n+    public void testJavaTypeWithFunction() throws Exception\n+    {\n+        ObjectMapper baseMapper = jsonMapperBuilder().build();\n+        JavaType barType = baseMapper.constructType(Bar.class);\n+\n+        SimpleModule module = new SimpleModule(\"test\");\n+        module.addDeserializer(Bar.class,\n+                new FunctionalScalarDeserializer<>(barType, Bar::of));\n+\n+        ObjectMapper mapper = jsonMapperBuilder()\n+                .addModule(module)\n+                .build();\n+\n+        Bar result = mapper.readValue(\"\\\"javatype\\\"\", Bar.class);\n+        assertEquals(\"javatype\", result.getValue());\n+    }\n+\n+    @Test\n+    public void testClassWithBiFunction() throws Exception\n+    {\n+        SimpleModule module = new SimpleModule(\"test\");\n+        module.addDeserializer(Bar.class,\n+                new FunctionalScalarDeserializer<>(Bar.class,\n+                        (p, ctx) -> Bar.of(\"prefix:\" + p.getValueAsString())));\n+\n+        ObjectMapper mapper = jsonMapperBuilder()\n+                .addModule(module)\n+                .build();\n+\n+        Bar result = mapper.readValue(\"\\\"test\\\"\", Bar.class);\n+        assertEquals(\"prefix:test\", result.getValue());\n+    }\n+\n+    @Test\n+    public void testJavaTypeWithBiFunction() throws Exception\n+    {\n+        ObjectMapper baseMapper = jsonMapperBuilder().build();\n+        JavaType barType = baseMapper.constructType(Bar.class);\n+\n+        SimpleModule module = new SimpleModule(\"test\");\n+        module.addDeserializer(Bar.class,\n+                new FunctionalScalarDeserializer<>(barType,\n+                        (p, ctx) -> Bar.of(\"bi:\" + p.getValueAsString())));\n+\n+        ObjectMapper mapper = jsonMapperBuilder()\n+                .addModule(module)\n+                .build();\n+\n+        Bar result = mapper.readValue(\"\\\"test\\\"\", Bar.class);\n+        assertEquals(\"bi:test\", result.getValue());\n+    }\n+\n+    @Test\n+    public void testFromIntegerNumber() throws Exception\n+    {\n+        SimpleModule module = new SimpleModule(\"test\");\n+        module.addDeserializer(Bar.class,\n+                new FunctionalScalarDeserializer<>(Bar.class, Bar::of));\n+\n+        ObjectMapper mapper = jsonMapperBuilder()\n+                .addModule(module)\n+                .build();\n+\n+        Bar result = mapper.readValue(\"123\", Bar.class);\n+        assertEquals(\"123\", result.getValue());\n+    }\n+\n+    @Test\n+    public void testFromDecimalNumber() throws Exception\n+    {\n+        SimpleModule module = new SimpleModule(\"test\");\n+        module.addDeserializer(Bar.class,\n+                new FunctionalScalarDeserializer<>(Bar.class, Bar::of));\n+\n+        ObjectMapper mapper = jsonMapperBuilder()\n+                .addModule(module)\n+                .build();\n+\n+        Bar result = mapper.readValue(\"3.14159\", Bar.class);\n+        assertEquals(\"3.14159\", result.getValue());\n+    }\n+\n+    @Test\n+    public void testFromNegativeNumber() throws Exception\n+    {\n+        SimpleModule module = new SimpleModule(\"test\");\n+        module.addDeserializer(Bar.class,\n+                new FunctionalScalarDeserializer<>(Bar.class, Bar::of));\n+\n+        ObjectMapper mapper = jsonMapperBuilder()\n+                .addModule(module)\n+                .build();\n+\n+        Bar result = mapper.readValue(\"-42\", Bar.class);\n+        assertEquals(\"-42\", result.getValue());\n+    }\n+\n+    @Test\n+    public void testFromBooleanTrue() throws Exception\n+    {\n+        SimpleModule module = new SimpleModule(\"test\");\n+        module.addDeserializer(Bar.class,\n+                new FunctionalScalarDeserializer<>(Bar.class, Bar::of));\n+\n+        ObjectMapper mapper = jsonMapperBuilder()\n+                .addModule(module)\n+                .build();\n+\n+        Bar result = mapper.readValue(\"true\", Bar.class);\n+        assertEquals(\"true\", result.getValue());\n+    }\n+\n+    @Test\n+    public void testFromBooleanFalse() throws Exception\n+    {\n+        SimpleModule module = new SimpleModule(\"test\");\n+        module.addDeserializer(Bar.class,\n+                new FunctionalScalarDeserializer<>(Bar.class, Bar::of));\n+\n+        ObjectMapper mapper = jsonMapperBuilder()\n+                .addModule(module)\n+                .build();\n+\n+        Bar result = mapper.readValue(\"false\", Bar.class);\n+        assertEquals(\"false\", result.getValue());\n+    }\n+\n+    @Test\n+    public void testNullValue() throws Exception\n+    {\n+        SimpleModule module = new SimpleModule(\"test\");\n+        module.addDeserializer(Bar.class,\n+                new FunctionalScalarDeserializer<>(Bar.class, Bar::of));\n+\n+        ObjectMapper mapper = jsonMapperBuilder()\n+                .addModule(module)\n+                .build();\n+\n+        Bar result = mapper.readValue(\"null\", Bar.class);\n+        assertNull(result);\n+    }\n+\n+    @Test\n+    public void testEmptyStringDefault() throws Exception\n+    {\n+        SimpleModule module = new SimpleModule(\"test\");\n+        module.addDeserializer(Bar.class,\n+                new FunctionalScalarDeserializer<>(Bar.class, Bar::of));\n+\n+        ObjectMapper mapper = jsonMapperBuilder()\n+                .addModule(module)\n+                .build();\n+\n+        // By default, empty string returns null for OtherScalar type\n+        Bar result = mapper.readValue(\"\\\"\\\"\", Bar.class);\n+        assertNull(result);\n+    }\n+\n+    @Test\n+    public void testEmptyStringCoercionFail() throws Exception\n+    {\n+        SimpleModule module = new SimpleModule(\"test\");\n+        module.addDeserializer(Bar.class,\n+                new FunctionalScalarDeserializer<>(Bar.class, Bar::of));\n+\n+        ObjectMapper mapper = jsonMapperBuilder()\n+                .addModule(module)\n+                .withCoercionConfigDefaults(cfg -> cfg.setCoercion(\n+                        CoercionInputShape.EmptyString, CoercionAction.Fail))\n+                .build();\n+\n+        try {\n+            mapper.readValue(\"\\\"\\\"\", Bar.class);\n+            fail(\"Should throw exception for empty string with Fail action\");\n+        } catch (MismatchedInputException e) {\n+            verifyException(e, \"Cannot coerce empty String\");\n+        }\n+    }\n+\n+    @Test\n+    public void testEmptyStringCoercionAsNull() throws Exception\n+    {\n+        SimpleModule module = new SimpleModule(\"test\");\n+        module.addDeserializer(Bar.class,\n+                new FunctionalScalarDeserializer<>(Bar.class, Bar::of));\n+\n+        ObjectMapper mapper = jsonMapperBuilder()\n+                .addModule(module)\n+                .withCoercionConfig(LogicalType.OtherScalar, cfg -> cfg.setCoercion(\n+                        CoercionInputShape.EmptyString, CoercionAction.AsNull))\n+                .build();\n+\n+        Bar result = mapper.readValue(\"\\\"\\\"\", Bar.class);\n+        assertNull(result);\n+    }\n+\n+    @Test\n+    public void testEmptyStringCoercionAsEmpty() throws Exception\n+    {\n+        SimpleModule module = new SimpleModule(\"test\");\n+        module.addDeserializer(Bar.class,\n+                new FunctionalScalarDeserializer<>(Bar.class, Bar::of));\n+\n+        ObjectMapper mapper = jsonMapperBuilder()\n+                .addModule(module)\n+                .withCoercionConfig(LogicalType.OtherScalar, cfg -> cfg.setCoercion(\n+                        CoercionInputShape.EmptyString, CoercionAction.AsEmpty))\n+                .build();\n+\n+        // AsEmpty typically returns null for types without defined empty value\n+        Bar result = mapper.readValue(\"\\\"\\\"\", Bar.class);\n+        assertNull(result);\n+    }\n+\n+    @Test\n+    public void testAsPojoField() throws Exception\n+    {\n+        SimpleModule module = new SimpleModule(\"test\");\n+        module.addDeserializer(Bar.class,\n+                new FunctionalScalarDeserializer<>(Bar.class, Bar::of));\n+\n+        ObjectMapper mapper = jsonMapperBuilder()\n+                .addModule(module)\n+                .build();\n+\n+        BarWrapper result = mapper.readValue(\"{\\\"bar\\\":\\\"fieldValue\\\"}\", BarWrapper.class);\n+        assertNotNull(result.bar);\n+        assertEquals(\"fieldValue\", result.bar.getValue());\n+    }\n+\n+    @Test\n+    public void testInList() throws Exception\n+    {\n+        SimpleModule module = new SimpleModule(\"test\");\n+        module.addDeserializer(Bar.class,\n+                new FunctionalScalarDeserializer<>(Bar.class, Bar::of));\n+\n+        ObjectMapper mapper = jsonMapperBuilder()\n+                .addModule(module)\n+                .build();\n+\n+        List<Bar> result = mapper.readValue(\"[\\\"a\\\", \\\"b\\\", \\\"c\\\"]\",\n+                new TypeReference<List<Bar>>() {});\n+        assertEquals(3, result.size());\n+        assertEquals(\"a\", result.get(0).getValue());\n+        assertEquals(\"b\", result.get(1).getValue());\n+        assertEquals(\"c\", result.get(2).getValue());\n+    }\n+\n+    @Test\n+    public void testNullFieldInPojo() throws Exception\n+    {\n+        SimpleModule module = new SimpleModule(\"test\");\n+        module.addDeserializer(Bar.class,\n+                new FunctionalScalarDeserializer<>(Bar.class, Bar::of));\n+\n+        ObjectMapper mapper = jsonMapperBuilder()\n+                .addModule(module)\n+                .build();\n+\n+        BarWrapper result = mapper.readValue(\"{\\\"bar\\\":null}\", BarWrapper.class);\n+        assertNull(result.bar);\n+    }\n+\n+    @Test\n+    public void testRejectsJsonArray() throws Exception\n+    {\n+        SimpleModule module = new SimpleModule(\"test\");\n+        module.addDeserializer(Bar.class,\n+                new FunctionalScalarDeserializer<>(Bar.class, Bar::of));\n+\n+        ObjectMapper mapper = jsonMapperBuilder()\n+                .addModule(module)\n+                .build();\n+\n+        try {\n+            mapper.readValue(\"[\\\"hello\\\"]\", Bar.class);\n+            fail(\"Should not accept JSON array\");\n+        } catch (MismatchedInputException e) {\n+            verifyException(e, \"Cannot deserialize\");\n+        }\n+    }\n+\n+    @Test\n+    public void testRejectsJsonObject() throws Exception\n+    {\n+        SimpleModule module = new SimpleModule(\"test\");\n+        module.addDeserializer(Bar.class,\n+                new FunctionalScalarDeserializer<>(Bar.class, Bar::of));\n+\n+        ObjectMapper mapper = jsonMapperBuilder()\n+                .addModule(module)\n+                .build();\n+\n+        try {\n+            mapper.readValue(\"{\\\"value\\\":\\\"hello\\\"}\", Bar.class);\n+            fail(\"Should not accept JSON object\");\n+        } catch (MismatchedInputException e) {\n+            verifyException(e, \"Cannot deserialize\");\n+        }\n+    }\n+\n+    @Test\n+    public void testFunctionThrowsIllegalArgumentException() throws Exception\n+    {\n+        SimpleModule module = new SimpleModule(\"test\");\n+        module.addDeserializer(Bar.class,\n+                new FunctionalScalarDeserializer<>(Bar.class, s -> {\n+                    throw new IllegalArgumentException(\"Invalid format: \" + s);\n+                }));\n+\n+        ObjectMapper mapper = jsonMapperBuilder()\n+                .addModule(module)\n+                .build();\n+\n+        try {\n+            mapper.readValue(\"\\\"bad\\\"\", Bar.class);\n+            fail(\"Should throw exception\");\n+        } catch (MismatchedInputException e) {\n+            verifyException(e, \"not a valid textual representation\");\n+            verifyException(e, \"Invalid format\");\n+        }\n+    }\n+\n+    @Test\n+    public void testBiFunctionThrowsIllegalArgumentException() throws Exception\n+    {\n+        SimpleModule module = new SimpleModule(\"test\");\n+        module.addDeserializer(Bar.class,\n+                new FunctionalScalarDeserializer<>(Bar.class, (p, ctx) -> {\n+                    throw new IllegalArgumentException(\"BiFunction error: \" + p.getValueAsString());\n+                }));\n+\n+        ObjectMapper mapper = jsonMapperBuilder()\n+                .addModule(module)\n+                .build();\n+\n+        try {\n+            mapper.readValue(\"\\\"invalid\\\"\", Bar.class);\n+            fail(\"Should throw exception\");\n+        } catch (MismatchedInputException e) {\n+            verifyException(e, \"not a valid textual representation\");\n+            verifyException(e, \"BiFunction error\");\n+        }\n+    }\n+\n+    @Test\n+    public void testStringFunctionReceivesExtractedText() throws Exception\n+    {\n+        final AtomicReference<String> receivedValue = new AtomicReference<>();\n+\n+        SimpleModule module = new SimpleModule(\"test\");\n+        module.addDeserializer(Bar.class,\n+                new FunctionalScalarDeserializer<>(Bar.class, text -> {\n+                    receivedValue.set(text);\n+                    return Bar.of(text);\n+                }));\n+\n+        ObjectMapper mapper = jsonMapperBuilder()\n+                .addModule(module)\n+                .build();\n+\n+        Bar result = mapper.readValue(\"\\\"expected-value\\\"\", Bar.class);\n+\n+        assertEquals(\"expected-value\", receivedValue.get());\n+        assertEquals(\"expected-value\", result.getValue());\n+    }\n+\n+    @Test\n+    public void testBiFunctionReceivesParserDirectly() throws Exception\n+    {\n+        final AtomicReference<String> parserState = new AtomicReference<>();\n+\n+        SimpleModule module = new SimpleModule(\"test\");\n+        module.addDeserializer(Bar.class,\n+                new FunctionalScalarDeserializer<>(Bar.class, (p, ctx) -> {\n+                    parserState.set(p.currentToken().toString());\n+                    return Bar.of(p.getValueAsString());\n+                }));\n+\n+        ObjectMapper mapper = jsonMapperBuilder()\n+                .addModule(module)\n+                .build();\n+\n+        Bar result = mapper.readValue(\"\\\"test-value\\\"\", Bar.class);\n+\n+        assertEquals(\"VALUE_STRING\", parserState.get());\n+        assertEquals(\"test-value\", result.getValue());\n+    }\n+\n+    @Test\n+    public void testStringFunctionReceivesCoercedNumericText() throws Exception\n+    {\n+        final AtomicReference<String> receivedValue = new AtomicReference<>();\n+\n+        SimpleModule module = new SimpleModule(\"test\");\n+        module.addDeserializer(Bar.class,\n+                new FunctionalScalarDeserializer<>(Bar.class, text -> {\n+                    receivedValue.set(text);\n+                    return Bar.of(text);\n+                }));\n+\n+        ObjectMapper mapper = jsonMapperBuilder()\n+                .addModule(module)\n+                .build();\n+\n+        Bar result = mapper.readValue(\"12345\", Bar.class);\n+\n+        assertEquals(\"12345\", receivedValue.get());\n+        assertEquals(\"12345\", result.getValue());\n+    }\n+\n+    @Test\n+    public void testFunctionThrowsCustomException() throws Exception\n+    {\n+        SimpleModule module = new SimpleModule(\"test\");\n+        module.addDeserializer(Bar.class,\n+                new FunctionalScalarDeserializer<>(Bar.class, s -> {\n+                    throw new RuntimeException(\"Custom error: \" + s);\n+                }));\n+\n+        ObjectMapper mapper = jsonMapperBuilder()\n+                .addModule(module)\n+                .build();\n+\n+        try {\n+            mapper.readValue(\"\\\"bad\\\"\", Bar.class);\n+            fail(\"Should throw exception\");\n+        } catch (MismatchedInputException e) {\n+            verifyException(e, \"not a valid textual representation\");\n+            verifyException(e, \"Custom error\");\n+        }\n+    }\n+\n+    @Test\n+    public void testBiFunctionThrowsCustomException() throws Exception\n+    {\n+        SimpleModule module = new SimpleModule(\"test\");\n+        module.addDeserializer(Bar.class,\n+                new FunctionalScalarDeserializer<>(Bar.class, (p, ctx) -> {\n+                    throw new RuntimeException(\"BiFunction custom error: \" + p.getValueAsString());\n+                }));\n+\n+        ObjectMapper mapper = jsonMapperBuilder()\n+                .addModule(module)\n+                .build();\n+\n+        try {\n+            mapper.readValue(\"\\\"invalid\\\"\", Bar.class);\n+            fail(\"Should throw exception\");\n+        } catch (MismatchedInputException e) {\n+            verifyException(e, \"not a valid textual representation\");\n+            verifyException(e, \"BiFunction custom error\");\n+        }\n+    }\n+}\n",
  "problem_statement" : "As I noted on [Stack Overflow](https://stackoverflow.com/q/76560273), I'm using Java 17 and I have a `Bar` type I want serialized to JSON using its `toString()` method. I'm serializing using a Jackson `ObjectMapper` (created via a `JsonMapper.Builder`). I found out from [my other Stack Overflow question](https://stackoverflow.com/q/76559047) that I can specify a `ToStringSerializer` as a serializer in a `Module`, as the [answer](https://stackoverflow.com/a/76559162) indicated. (I had done this years ago, but forgotten how.)\r\n\r\n```java\r\n…\r\nmodule.addSerializer(Bar.class, new ToStringSerializer());\r\n//technically ToStringSerializer.instance would be better; I used instantiation for\r\n…\r\n```\r\n\r\nBut now how about deserializing `Bar` using a static factory method? Looking at the code from `FromStringDeserializer.Std._deserialize(…)`, I see that known types are simply checked using a `case` and then the static factory methods are explicitly invoked, e.g. `Charset.forName(value)` or `URI.create(value)`. This indicates to me that there may not be an existing deserializer for general serializer types—otherwise we could just use `new StaticFactoryDeserializer(\"forName\")` and `new StaticFactoryDeserializer(\"create\")`, etc. to do the same thing.\r\n\r\nOf course I can write one of these myself, but I'm curious whether this exists already. Basically I'd like to do this:\r\n\r\n```java\r\n…\r\nmodule.addDeserializer(Bar.class, new StaticFactoryDeserializer(\"createNewBarInstance\"));\r\n…\r\n```\r\n\r\n`StaticFactoryDeserializer` would also allow a `Function`, so I could use it like this:\r\n\r\n```java\r\n…\r\nmodule.addDeserializer(Bar.class, new StaticFactoryDeserializer(Bar::createNewBarInstance));\r\n…\r\n```\r\n\r\n(Probably the deserializer would create its own function instance internally when created with the method name, but that's an implementation detail.)\r\n\r\nDoes such a deserializer exist, or is one planned? If I wrote one, would it be something you'd be interested in including in Jackson?",
  "hints_text" : null,
  "created_at" : "Sun Jan 18 05:31:17 CET 2026",
  "version" : null,
  "FAIL_TO_PASS" : [ "FunctionalScalarDeserializer4004Test" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=FunctionalScalarDeserializer4004Test",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : 4004,
  "pull_number" : 5595,
  "metadata" : null
}, {
  "instance_id" : "FasterXML-jackson-databind-PR-5591",
  "repo" : "FasterXML/jackson-databind",
  "base_commit" : "96679ae8546db09ead6c70b43e6c1793eb65f793",
  "patch" : "diff --git a/src/main/java/tools/jackson/databind/deser/AbstractDeserializer.java b/src/main/java/tools/jackson/databind/deser/AbstractDeserializer.java\nindex e805bb6617..237594be9e 100644\n--- a/src/main/java/tools/jackson/databind/deser/AbstractDeserializer.java\n+++ b/src/main/java/tools/jackson/databind/deser/AbstractDeserializer.java\n@@ -313,7 +313,8 @@ protected Object _deserializeFromObjectId(JsonParser p, DeserializationContext c\n         Object pojo = roid.resolve();\n         if (pojo == null) { // not yet; should wait...\n             throw new UnresolvedForwardReference(p,\n-                    \"Could not resolve Object Id [\"+id+\"] -- unresolved forward-reference?\", p.currentLocation(), roid);\n+                    \"Could not resolve Object Id [\"+id+\"] -- unresolved forward-reference?\",\n+                    p.currentLocation(), roid);\n         }\n         return pojo;\n     }\ndiff --git a/src/main/java/tools/jackson/databind/deser/DeserializationContextExt.java b/src/main/java/tools/jackson/databind/deser/DeserializationContextExt.java\nindex d0c66b8203..1d56183c9e 100644\n--- a/src/main/java/tools/jackson/databind/deser/DeserializationContextExt.java\n+++ b/src/main/java/tools/jackson/databind/deser/DeserializationContextExt.java\n@@ -138,7 +138,8 @@ public void checkUnresolvedObjectId() throws UnresolvedForwardReference\n                 continue;\n             }\n             if (exception == null) {\n-                exception = new UnresolvedForwardReference(getParser(), \"Unresolved forward references for: \")\n+                exception = new UnresolvedForwardReference(getParser(),\n+                        \"Unresolved forward references: \")\n                         .withStackTrace();\n             }\n             Object key = roid.getKey().key;\ndiff --git a/src/main/java/tools/jackson/databind/deser/UnresolvedForwardReference.java b/src/main/java/tools/jackson/databind/deser/UnresolvedForwardReference.java\nindex 3d2838c4f7..255e04677f 100644\n--- a/src/main/java/tools/jackson/databind/deser/UnresolvedForwardReference.java\n+++ b/src/main/java/tools/jackson/databind/deser/UnresolvedForwardReference.java\n@@ -27,7 +27,7 @@ public UnresolvedForwardReference(JsonParser p, String msg, TokenStreamLocation\n \n     public UnresolvedForwardReference(JsonParser p, String msg) {\n         super(p, msg);\n-        _unresolvedIds = new ArrayList<UnresolvedId>();\n+        _unresolvedIds = new ArrayList<>();\n     }\n \n     /*\n@@ -55,21 +55,25 @@ public List<UnresolvedId> getUnresolvedIds(){\n     @Override\n     public String getMessage()\n     {\n-        String msg = super.getMessage();\n+        String msg = super.getOriginalMessage();\n         if (_unresolvedIds == null) {\n             return msg;\n         }\n \n         StringBuilder sb = new StringBuilder(msg);\n+        if (!msg.endsWith(\" \")) {\n+            sb.append(' ');\n+        }\n+        sb.append('[');\n         Iterator<UnresolvedId> iterator = _unresolvedIds.iterator();\n         while (iterator.hasNext()) {\n             UnresolvedId unresolvedId = iterator.next();\n-            sb.append(unresolvedId.toString());\n+            sb.append(unresolvedId.descForException());\n             if (iterator.hasNext()) {\n                 sb.append(\", \");\n             }\n         }\n-        sb.append('.');\n+        sb.append(']');\n         return sb.toString();\n     }\n \ndiff --git a/src/main/java/tools/jackson/databind/deser/UnresolvedId.java b/src/main/java/tools/jackson/databind/deser/UnresolvedId.java\nindex c404c2d72e..b4e15b76d4 100644\n--- a/src/main/java/tools/jackson/databind/deser/UnresolvedId.java\n+++ b/src/main/java/tools/jackson/databind/deser/UnresolvedId.java\n@@ -30,6 +30,17 @@ public UnresolvedId(Object id, Class<?> type, TokenStreamLocation where) {\n     public Class<?> getType() { return _type; }\n     public TokenStreamLocation getLocation() { return _location; }\n \n+    // @since 3.1\n+    public String descForException() {\n+        var sb = new StringBuilder(\"{Object id: \");\n+        if (_id instanceof String) {\n+            sb.append('\"').append(_id).append('\"');\n+        } else {\n+            sb.append(_id);\n+        }\n+        return sb.append('}').toString();\n+    }\n+\n     @Override\n     public String toString() {\n         return String.format(\"Object id [%s] (for %s) at %s\", _id,\n",
  "test_patch" : "diff --git a/src/test/java/tools/jackson/databind/deser/jdk/Base64DecodingTest.java b/src/test/java/tools/jackson/databind/deser/jdk/Base64DecodingTest.java\nindex 2fb7178a31..421e0e0269 100644\n--- a/src/test/java/tools/jackson/databind/deser/jdk/Base64DecodingTest.java\n+++ b/src/test/java/tools/jackson/databind/deser/jdk/Base64DecodingTest.java\n@@ -32,6 +32,18 @@ public void testInvalidBase64() throws Exception\n         _testInvalidBase64(MAPPER, BASE64_HELLO+\"!!\");\n     }\n \n+    @Test\n+    public void testBase64ViaWrapperByteArray() throws Exception\n+    {\n+        Byte[] b = MAPPER.readValue(q(BASE64_HELLO), Byte[].class);\n+        assertEquals(HELLO_BYTES.length, b.length);\n+        for (int i = 0; i < b.length; ++i) {\n+            if (b[i].byteValue() != HELLO_BYTES[i]) {\n+                fail(\"Wrong byte at #\"+i);\n+            }\n+        }\n+    }\n+    \n     private void _testInvalidBase64(ObjectMapper mapper, String value) throws Exception\n     {\n         // First, use data-binding\ndiff --git a/src/test/java/tools/jackson/databind/objectid/AbstractWithObjectIdTest.java b/src/test/java/tools/jackson/databind/objectid/AbstractWithObjectIdTest.java\nindex 0fd9d48cb0..5aaaee9461 100644\n--- a/src/test/java/tools/jackson/databind/objectid/AbstractWithObjectIdTest.java\n+++ b/src/test/java/tools/jackson/databind/objectid/AbstractWithObjectIdTest.java\n@@ -21,7 +21,7 @@ interface BaseInterface { }\n     static class BaseInterfaceImpl implements BaseInterface {\n \n         @JsonProperty\n-        private List<BaseInterfaceImpl> myInstances = new ArrayList<BaseInterfaceImpl>();\n+        private List<BaseInterfaceImpl> myInstances = new ArrayList<>();\n \n         void addInstance(BaseInterfaceImpl instance) {\n             myInstances.add(instance);\ndiff --git a/src/test/java/tools/jackson/databind/objectid/ObjectIdInObjectArray5413Test.java b/src/test/java/tools/jackson/databind/objectid/ObjectIdInObjectArray5413Test.java\nindex d93637af56..728478ab53 100644\n--- a/src/test/java/tools/jackson/databind/objectid/ObjectIdInObjectArray5413Test.java\n+++ b/src/test/java/tools/jackson/databind/objectid/ObjectIdInObjectArray5413Test.java\n@@ -7,6 +7,8 @@\n import com.fasterxml.jackson.annotation.JsonIdentityInfo;\n import com.fasterxml.jackson.annotation.JsonIdentityReference;\n import com.fasterxml.jackson.annotation.ObjectIdGenerators;\n+\n+import tools.jackson.databind.DeserializationFeature;\n import tools.jackson.databind.ObjectMapper;\n import tools.jackson.databind.testutil.DatabindTestUtil;\n \n@@ -55,7 +57,9 @@ public void setPoints(Point[] points) {\n     public static final record Point(int id, int x, int y) {\n     }\n \n-    private final ObjectMapper MAPPER = newJsonMapper();\n+    private final ObjectMapper MAPPER = jsonMapperBuilder()\n+            .enable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)\n+            .build();\n \n     // [databind#5413]\n     @Test\n@@ -73,8 +77,8 @@ public void testForwardReferenceResolution()\n         triangle.setPoints(new Point[] { point_0_2, point_1_3, point_2_2 });\n         draw.setAShapes(new Shape[] { square, triangle });\n         draw.setPoints(new Point[] { point_0_0, point_0_2, point_2_2, point_2_0, point_1_3 });\n-        final String JSON = MAPPER.writeValueAsString(draw);\n-        draw = MAPPER.readValue(JSON, Draw.class);\n+        final String json = MAPPER.writeValueAsString(draw);\n+        draw = MAPPER.readValue(json, Draw.class);\n         assertNotNull(draw);\n         assertEquals(5, draw.points.length);\n         assertEquals(2, draw.ashapes.length);\n@@ -89,4 +93,14 @@ public void testForwardReferenceResolution()\n         assertSame(draw.points[2], draw.ashapes[1].points[2]);\n     }\n \n+    @Test\n+    public void testNullHandling()\n+    {\n+        Draw draw = MAPPER.readValue(a2q(\"{'AShapes':[ null ], 'points': [ null ]}\"),\n+                Draw.class);\n+        assertEquals(1, draw.ashapes.length);\n+        assertNull(draw.ashapes[0]);\n+        assertEquals(1, draw.points.length);\n+        assertNull(draw.points[0]);\n+    }\n }\ndiff --git a/src/test/java/tools/jackson/databind/objectid/ObjectIdReordering1388Test.java b/src/test/java/tools/jackson/databind/objectid/ObjectIdReordering1388Test.java\nindex 0d1b50642e..a92b1b44d7 100644\n--- a/src/test/java/tools/jackson/databind/objectid/ObjectIdReordering1388Test.java\n+++ b/src/test/java/tools/jackson/databind/objectid/ObjectIdReordering1388Test.java\n@@ -8,6 +8,7 @@\n \n import tools.jackson.core.type.TypeReference;\n import tools.jackson.databind.*;\n+import tools.jackson.databind.deser.UnresolvedForwardReference;\n import tools.jackson.databind.testutil.DatabindTestUtil;\n \n import static org.junit.jupiter.api.Assertions.*;\n@@ -47,47 +48,68 @@ public int hashCode() {\n         }\n     }\n \n+    private final ObjectMapper MAPPER = newJsonMapper();\n \n+    private final TypeReference<List<NamedThing>> namedThingListType = new TypeReference<List<NamedThing>>() { };\n+    \n+    // [databind#1388]\n     @Test\n-    public void testDeserializationFinalClassJSOG() throws Exception\n+    public void testOrdering1388() throws Exception\n     {\n-        final ObjectMapper mapper = new ObjectMapper();\n         final UUID id = UUID.fromString(\"a59aa02c-fe3c-43f8-9b5a-5fe01878a818\");\n         final NamedThing thing = new NamedThing(id, \"Hello\");\n \n-        final TypeReference<List<NamedThing>> namedThingListType = new TypeReference<List<NamedThing>>() { };\n \n         {\n-            final String jsog = mapper.writeValueAsString(Arrays.asList(thing, thing, thing));\n-            final List<NamedThing> list = mapper.readValue(jsog, namedThingListType);\n+            final String json = MAPPER.writeValueAsString(Arrays.asList(thing, thing, thing));\n+            final List<NamedThing> list = MAPPER.readValue(json, namedThingListType);\n             _assertAllSame(list);\n             // this is the jsog representation of the list of 3 of the same item\n-            assertTrue(jsog.equals(\"[{\\\"@id\\\":1,\\\"id\\\":\\\"a59aa02c-fe3c-43f8-9b5a-5fe01878a818\\\",\\\"name\\\":\\\"Hello\\\"},1,1]\"));\n+            assertTrue(json.equals(\"[{\\\"@id\\\":1,\\\"id\\\":\\\"a59aa02c-fe3c-43f8-9b5a-5fe01878a818\\\",\\\"name\\\":\\\"Hello\\\"},1,1]\"));\n         }\n \n         // now move it around it have forward references\n         // this works\n         {\n             final String json = \"[1,1,{\\\"@id\\\":1,\\\"id\\\":\\\"a59aa02c-fe3c-43f8-9b5a-5fe01878a818\\\",\\\"name\\\":\\\"Hello\\\"}]\";\n-            final List<NamedThing> forward = mapper.readValue(json, namedThingListType);\n+            final List<NamedThing> forward = MAPPER.readValue(json, namedThingListType);\n             _assertAllSame(forward);\n         }\n \n         // next, move @id to between properties\n         {\n             final String json = a2q(\"[{'id':'a59aa02c-fe3c-43f8-9b5a-5fe01878a818','@id':1,'name':'Hello'}, 1, 1]\");\n-            final List<NamedThing> forward = mapper.readValue(json, namedThingListType);\n+            final List<NamedThing> forward = MAPPER.readValue(json, namedThingListType);\n             _assertAllSame(forward);\n         }\n \n         // and last, move @id to be not the first key in the object\n         {\n             final String json = a2q(\"[{'id':'a59aa02c-fe3c-43f8-9b5a-5fe01878a818','name':'Hello','@id':1}, 1, 1]\");\n-            final List<NamedThing> forward = mapper.readValue(json, namedThingListType);\n+            final List<NamedThing> forward = MAPPER.readValue(json, namedThingListType);\n             _assertAllSame(forward);\n         }\n     }\n \n+    @Test\n+    public void testNullsNoObjectId() throws Exception\n+    {\n+        final List<NamedThing> l = MAPPER.readValue(\"[null]\", namedThingListType);\n+        assertEquals(1, l.size());\n+        assertNull(l.get(0));\n+    }\n+    \n+    @Test\n+    public void testUnresolvedObjectId() throws Exception\n+    {\n+        try { \n+            MAPPER.readValue(\"[123]\", namedThingListType);\n+            fail(\"Should not pass\");\n+        } catch (UnresolvedForwardReference e) {\n+            verifyException(e, \"Unresolved forward references: [{Object id: 123}]\");\n+        }\n+    }\n+\n     private void _assertAllSame(List<?> entries) {\n         Object first = entries.get(0);\n         for (int i = 0, end = entries.size(); i < end; ++i) {\n",
  "problem_statement" : "Improvement to exception reporting for unresolved ObjectIds, test coverage",
  "hints_text" : null,
  "created_at" : "Fri Jan 16 04:05:39 CET 2026",
  "version" : null,
  "FAIL_TO_PASS" : [ "ObjectIdInObjectArray5413Test", "Base64DecodingTest", "ObjectIdReordering1388Test", "AbstractWithObjectIdTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=ObjectIdInObjectArray5413Test,Base64DecodingTest,ObjectIdReordering1388Test,AbstractWithObjectIdTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 5591,
  "metadata" : null
}, {
  "instance_id" : "FasterXML-jackson-databind-PR-5587",
  "repo" : "FasterXML/jackson-databind",
  "base_commit" : "182b3bda37223b0cd0f2ac144cbfa16c82d4b561",
  "patch" : "diff --git a/release-notes/VERSION b/release-notes/VERSION\nindex 83bf12b0aa..7e75f1a143 100644\n--- a/release-notes/VERSION\n+++ b/release-notes/VERSION\n@@ -136,6 +136,8 @@ Versions: 3.x (for earlier see VERSION-2.x)\n #5583 Improve `asXxx()` method impls of `MissingNode`, `POJONode(null)`,\n   to work like `NullNode`\n  (implemented by @cowtowncoder, w/ Claude code)\n+#5586: Change `IndexOutOfBoundsException` that `ArrayNode.set()`/`replace()`\n+  throw to `JsonNodeException`\n \n 3.0.4 (not yet released)\n \ndiff --git a/src/main/java/tools/jackson/databind/node/ArrayNode.java b/src/main/java/tools/jackson/databind/node/ArrayNode.java\nindex bcaacf2bc0..83247c0464 100644\n--- a/src/main/java/tools/jackson/databind/node/ArrayNode.java\n+++ b/src/main/java/tools/jackson/databind/node/ArrayNode.java\n@@ -426,7 +426,7 @@ public List<JsonNode> findParents(String propertyName, List<JsonNode> foundSoFar\n      *\n      * @return This node after adding/replacing property value (to allow chaining)\n      *\n-     * @throws IndexOutOfBoundsException If Array does not have specified element\n+     * @throws JsonNodeException If Array does not have specified element\n      *  (that is, index is outside valid range of elements in array)\n      */\n     public ArrayNode set(int index, JsonNode value)\n@@ -434,11 +434,7 @@ public ArrayNode set(int index, JsonNode value)\n         if (value == null) { // let's not store 'raw' nulls but nodes\n             value = nullNode();\n         }\n-        if (index < 0 || index >= _children.size()) {\n-            throw new IndexOutOfBoundsException(\"Illegal index \"+ index +\", array size \"+size());\n-        }\n-        _children.set(index, value);\n-        return this;\n+        return _set(index, value);\n     }\n \n     /**\n@@ -450,7 +446,7 @@ public ArrayNode set(int index, JsonNode value)\n      *\n      * @return Old value of the element, if any; null if no such element existed.\n      *\n-     * @throws IndexOutOfBoundsException If Array does not have specified element\n+     * @throws JsonNodeException If Array does not have specified element\n      *  (that is, index is outside valid range of elements in array)\n      */\n     public JsonNode replace(int index, JsonNode value)\n@@ -459,8 +455,10 @@ public JsonNode replace(int index, JsonNode value)\n             value = nullNode();\n         }\n         if (index < 0 || index >= _children.size()) {\n-            throw new IndexOutOfBoundsException(\"Illegal index \"+ index +\", array size \"+size());\n+            throw JsonNodeException.from(this,\n+                    \"Illegal index %d, array size %d\", index, size());\n         }\n+        // NOTE: cannot call `_set()` since it returns `this`, NOT old value\n         return _children.set(index, value);\n     }\n \n",
  "test_patch" : "diff --git a/src/test/java/tools/jackson/databind/node/ArrayNodeTest.java b/src/test/java/tools/jackson/databind/node/ArrayNodeTest.java\nindex 5ab2cd7594..bb34b0dc59 100644\n--- a/src/test/java/tools/jackson/databind/node/ArrayNodeTest.java\n+++ b/src/test/java/tools/jackson/databind/node/ArrayNodeTest.java\n@@ -10,6 +10,7 @@\n \n import tools.jackson.core.*;\n import tools.jackson.databind.*;\n+import tools.jackson.databind.exc.JsonNodeException;\n import tools.jackson.databind.exc.MismatchedInputException;\n import tools.jackson.databind.testutil.DatabindTestUtil;\n import tools.jackson.databind.util.RawValue;\n@@ -128,7 +129,7 @@ public void testDirectCreation2()\n         try {\n             n.set(2, NODE_F.nullNode());\n             fail(\"Should not pass\");\n-        } catch (IndexOutOfBoundsException e) {\n+        } catch (JsonNodeException e) {\n             verifyException(e, \"illegal index\");\n         }\n         n.insert(1, (String) null);\n@@ -219,11 +220,11 @@ public void testArrayReplace() {\n         try {\n             array.replace(100, null);\n             fail(\"Should not pass\");\n-        } catch (IndexOutOfBoundsException e) {\n-            ;\n+        } catch (JsonNodeException e) {\n+            verifyException(e, \"Illegal index 100, array size 1\");\n         }\n     }\n-    \n+\n     @Test\n     public void testArrayViaMapper()\n     {\ndiff --git a/src/test/java/tools/jackson/databind/node/TreeTraversingParserTest.java b/src/test/java/tools/jackson/databind/node/TreeTraversingParserTest.java\nindex bfadcd35d7..8483ee5b0f 100644\n--- a/src/test/java/tools/jackson/databind/node/TreeTraversingParserTest.java\n+++ b/src/test/java/tools/jackson/databind/node/TreeTraversingParserTest.java\n@@ -1,5 +1,6 @@\n package tools.jackson.databind.node;\n \n+import java.io.ByteArrayOutputStream;\n import java.math.BigInteger;\n import java.util.*;\n \n@@ -68,6 +69,9 @@ public void testSimple() throws Exception\n         assertEquals(\"a\", p.currentName());\n         assertEquals(123, p.getIntValue());\n         assertEquals((short) 123, p.getShortValue());\n+        assertEquals(123, p.getValueAsInt(-1));\n+        assertEquals(123L, p.getValueAsLong(42L));\n+        assertEquals(BigInteger.valueOf(123L), p.getBigIntegerValue());\n         assertEquals(\"123\", p.getString());\n \n         assertToken(JsonToken.PROPERTY_NAME, p.nextToken());\n@@ -81,18 +85,55 @@ public void testSimple() throws Exception\n         assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());\n         assertNull(p.currentName());\n         assertEquals(12.25, p.getDoubleValue(), 0);\n+        assertEquals(12.25f, p.getFloatValue(), 0);\n         assertEquals(NumberType.DOUBLE, p.getNumberType());\n         assertEquals(NumberTypeFP.DOUBLE64, p.getNumberTypeFP());\n         assertFalse(p.isNaN());\n+        try {\n+            p.getShortValue();\n+            fail(\"Should not pass\");\n+        } catch (InputCoercionException e) {\n+            verifyException(e, \"has fractional part; cannot convert to `short`\");\n+        }\n+        try {\n+            p.getIntValue();\n+            fail(\"Should not pass\");\n+        } catch (InputCoercionException e) {\n+            verifyException(e, \"has fractional part; cannot convert to `int`\");\n+        }\n+        assertEquals(12, p.getValueAsInt(1));\n+        try {\n+            p.getLongValue();\n+            fail(\"Should not pass\");\n+        } catch (InputCoercionException e) {\n+            verifyException(e, \"has fractional part; cannot convert to `long`\");\n+        }\n+        assertEquals(12L, p.getValueAsLong(2L));\n         assertEquals(\"12.25\", p.getString());\n \n         assertToken(JsonToken.VALUE_NULL, p.nextToken());\n         assertNull(p.currentName());\n+        assertNull(p.getNumberType());\n+        assertEquals(NumberTypeFP.UNKNOWN, p.getNumberTypeFP());\n         assertEquals(JsonToken.VALUE_NULL.asString(), p.getString());\n \n         assertToken(JsonToken.VALUE_TRUE, p.nextToken());\n         assertNull(p.currentName());\n         assertTrue(p.getBooleanValue());\n+        try {\n+            p.getValueAsInt(1);\n+            fail(\"Should not pass\");\n+        } catch (InputCoercionException e) {\n+            verifyException(e, \"Current token (VALUE_TRUE) not numeric, cannot use numeric value accessors\");\n+        }\n+        try {\n+            p.getValueAsLong(2L);\n+            fail(\"Should not pass\");\n+        } catch (InputCoercionException e) {\n+            verifyException(e, \"Current token (VALUE_TRUE) not numeric, cannot use numeric value accessors\");\n+        }\n+        assertNull(p.getNumberType());\n+        assertEquals(NumberTypeFP.UNKNOWN, p.getNumberTypeFP());\n         assertEquals(JsonToken.VALUE_TRUE.asString(), p.getString());\n \n         assertToken(JsonToken.START_OBJECT, p.nextToken());\n@@ -191,16 +232,21 @@ public void testBinaryPojo() throws Exception\n     {\n         byte[] inputBinary = new byte[] { 1, 2, 100 };\n         POJONode n = new POJONode(inputBinary);\n-        JsonParser p = n.traverse(ObjectReadContext.empty());\n-\n-        assertNull(p.currentToken());\n-        assertToken(JsonToken.VALUE_EMBEDDED_OBJECT, p.nextToken());\n-        byte[] data = p.getBinaryValue();\n-        assertNotNull(data);\n-        assertArrayEquals(inputBinary, data);\n-        Object pojo = p.getEmbeddedObject();\n-        assertSame(data, pojo);\n-        p.close();\n+        try (JsonParser p = n.traverse(ObjectReadContext.empty())) {\n+            assertNull(p.currentToken());\n+            assertToken(JsonToken.VALUE_EMBEDDED_OBJECT, p.nextToken());\n+            byte[] data = p.getBinaryValue();\n+            assertNotNull(data);\n+            assertArrayEquals(inputBinary, data);\n+            Object pojo = p.getEmbeddedObject();\n+            assertSame(data, pojo);\n+\n+            // and for code coverage\n+            ByteArrayOutputStream bout = new ByteArrayOutputStream();\n+            int count = p.readBinaryValue(Base64Variants.getDefaultVariant(), bout);\n+            assertEquals(data.length, count);\n+            assertArrayEquals(inputBinary, bout.toByteArray());\n+        }\n     }\n \n     @Test\n",
  "problem_statement" : "So: now that we have unchecked `JsonNodeException` let's use that instead of \"raw\" `IndexOutOfBoundsException` in `ArrayNode` methods `set()` and `replace()`.",
  "hints_text" : null,
  "created_at" : "Thu Jan 15 05:29:49 CET 2026",
  "version" : null,
  "FAIL_TO_PASS" : [ "ArrayNodeTest", "TreeTraversingParserTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=ArrayNodeTest,TreeTraversingParserTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : 5586,
  "pull_number" : 5587,
  "metadata" : null
}, {
  "instance_id" : "FasterXML-jackson-databind-PR-5584",
  "repo" : "FasterXML/jackson-databind",
  "base_commit" : "5708c4d10a7be71a8a83780f4da53d1f7d1bd6cb",
  "patch" : "diff --git a/release-notes/VERSION b/release-notes/VERSION\nindex 635d577b84..83bf12b0aa 100644\n--- a/release-notes/VERSION\n+++ b/release-notes/VERSION\n@@ -133,6 +133,9 @@ Versions: 3.x (for earlier see VERSION-2.x)\n  (implemented by @cowtowncoder, w/ Claude code)\n #5579: Add `JsonNode.map()` method\n #5581: Add functional conversion methods `JsonNode.nullAs()`, `JsonNode.missingAs()`\n+#5583 Improve `asXxx()` method impls of `MissingNode`, `POJONode(null)`,\n+  to work like `NullNode`\n+ (implemented by @cowtowncoder, w/ Claude code)\n \n 3.0.4 (not yet released)\n \ndiff --git a/src/main/java/tools/jackson/databind/node/MissingNode.java b/src/main/java/tools/jackson/databind/node/MissingNode.java\nindex d1470c00dc..ade2477bfd 100644\n--- a/src/main/java/tools/jackson/databind/node/MissingNode.java\n+++ b/src/main/java/tools/jackson/databind/node/MissingNode.java\n@@ -1,5 +1,7 @@\n package tools.jackson.databind.node;\n \n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n import java.util.List;\n import java.util.Optional;\n \n@@ -57,14 +59,62 @@ protected String _valueDesc() {\n         return \"<missing>\";\n     }\n \n-    // // Note: not a numeric node, hence default 'asXxx()' are fine:\n+    /*\n+    /**********************************************************************\n+    /* Overridden JsonNode methods, scalar access (following NullNode behavior)\n+    /**********************************************************************\n+     */\n+\n+    @Override\n+    public boolean asBoolean() {\n+        return false;\n+    }\n+\n+    @Override\n+    public String asString() {\n+        return \"\";\n+    }\n+\n+    @Override\n+    public short asShort() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int asInt() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public long asLong() {\n+        return 0L;\n+    }\n+\n+    @Override\n+    public BigInteger asBigInteger() {\n+        return BigInteger.ZERO;\n+    }\n+\n+    @Override\n+    public float asFloat() {\n+        return 0.0f;\n+    }\n+\n+    @Override\n+    public double asDouble() {\n+        return 0.0d;\n+    }\n+\n+    @Override\n+    public BigDecimal asDecimal() {\n+        return BigDecimal.ZERO;\n+    }\n \n     /*\n-    public int asInt(int defaultValue);\n-    public long asLong(long defaultValue);\n-    public double asDouble(double defaultValue);\n-    public boolean asBoolean(boolean defaultValue);\n-    */\n+    /**********************************************************************\n+    /* Other JsonNode method overrides\n+    /**********************************************************************\n+     */\n \n     @Override\n     public Optional<JsonNode> asOptional() {\ndiff --git a/src/main/java/tools/jackson/databind/node/POJONode.java b/src/main/java/tools/jackson/databind/node/POJONode.java\nindex aeee7fa30b..9f575a58b4 100644\n--- a/src/main/java/tools/jackson/databind/node/POJONode.java\n+++ b/src/main/java/tools/jackson/databind/node/POJONode.java\n@@ -2,11 +2,7 @@\n \n import java.math.BigDecimal;\n import java.math.BigInteger;\n-import java.util.Objects;\n-import java.util.Optional;\n-import java.util.OptionalDouble;\n-import java.util.OptionalInt;\n-import java.util.OptionalLong;\n+import java.util.*;\n \n import tools.jackson.core.*;\n \n@@ -59,38 +55,30 @@ public JsonNodeType getNodeType() {\n     @Override\n     protected Boolean _asBoolean()\n     {\n-        if (_value == null) {\n-            return Boolean.FALSE;\n-        }\n         if (_value instanceof Boolean B) {\n             return B;\n         }\n+        if (_value == null) {\n+            return Boolean.FALSE;\n+        }\n         return null;\n     }\n \n     @Override\n     public boolean asBoolean(boolean defaultValue) {\n-        // First, `null` same as `NullNode`\n-        if (_value == null) {\n-            return defaultValue;\n-        }\n         if (_value instanceof Boolean B) {\n             return B;\n         }\n+        // (also covers `null` case)\n         return defaultValue;\n     }\n \n     @Override\n     public Optional<Boolean> asBooleanOpt() {\n-        // First, `null` same as `NullNode`\n-        if (_value == null) {\n-            return Optional.empty();\n-        }\n-\n         if (_value instanceof Boolean B) {\n             return B ? OPT_TRUE : OPT_FALSE;\n         }\n-\n+        // (also covers `null` case)\n         return Optional.empty();\n     }\n \n@@ -99,23 +87,34 @@ protected String _asString() {\n         if (_value instanceof String str) {\n              return str;\n         }\n+        // [databind#5583]: Null to coerce into \"\"\n+        if (_value == null) {\n+            return \"\";\n+        }\n         // 21-Mar-2025, tatu: [databind#5034] Should we consider RawValue too?\n         //    (for now, won't)\n+        // (also covers `null` case)\n         return null;\n     }\n \n     @Override\n     public String asString(String defaultValue) {\n-        // First, `null` same as `NullNode`\n-        if (_value == null) {\n-            return defaultValue;\n-        }\n         if (_value instanceof String str) {\n             return str;\n         }\n+        // (also covers `null` case)\n         return defaultValue;\n     }\n \n+    @Override\n+    public Optional<String> asStringOpt() {\n+        if (_value instanceof String str) {\n+            return Optional.of(str);\n+        }\n+        // (also covers `null` case)\n+        return Optional.empty();\n+    }\n+\n     /**\n      * As it is possible that some implementations embed byte[] as POJONode\n      * (despite optimal being {@link BinaryNode}), let's add support for exposing\n@@ -144,7 +143,6 @@ public short asShort() {\n         if (_value == null) {\n             return 0;\n         }\n-\n         // Next, check if the value is NOT a Number\n         if (!(_value instanceof Number)) {\n             // report coercion fail\n@@ -166,7 +164,6 @@ public short asShort(short defaultValue) {\n         if (_value == null) {\n             return defaultValue;\n         }\n-\n         // Next, check if the value is NOT a Number\n         if (!(_value instanceof Number)) {\n             return defaultValue;\n@@ -226,12 +223,8 @@ public int asInt() {\n \n     @Override\n     public int asInt(int defaultValue) {\n-        // First, `null` same as `NullNode`\n-        if (_value == null) {\n-            return defaultValue;\n-        }\n-\n         // Next, check if the value is NOT a Number\n+        // (including `null`)\n         if (!(_value instanceof Number)) {\n             return defaultValue;\n         }\n@@ -246,12 +239,8 @@ public int asInt(int defaultValue) {\n \n     @Override\n     public OptionalInt asIntOpt() {\n-        // First, `null` same as `NullNode`\n-        if (_value == null) {\n-            return OptionalInt.empty();\n-        }\n-\n         // Next, check if the value is NOT a Number\n+        // (including `null`)\n         if (!(_value instanceof Number)) {\n             return OptionalInt.empty();\n         }\n@@ -290,16 +279,10 @@ public long asLong() {\n \n     @Override\n     public long asLong(long defaultValue) {\n-        // First, `null` same as `NullNode`\n-        if (_value == null) {\n-            return defaultValue;\n-        }\n-\n-        // Next, report coercion fail if the value is NOT a Number\n+        // If not a Number (including `null`), return default\n         if (!(_value instanceof Number)) {\n             return defaultValue;\n         }\n-\n         // Then, extract from Number\n         Long L = _extractAsLong();\n         if (L == null) {\n@@ -310,12 +293,7 @@ public long asLong(long defaultValue) {\n \n     @Override\n     public OptionalLong asLongOpt() {\n-        // First, `null` same as `NullNode`\n-        if (_value == null) {\n-            return OptionalLong.empty();\n-        }\n-\n-        // Next, report coercion fail if the value is NOT a Number\n+        // If not a Number (including `null`), return empty\n         if (!(_value instanceof Number)) {\n             return OptionalLong.empty();\n         }\n@@ -349,12 +327,7 @@ public BigInteger asBigInteger() {\n \n     @Override\n     public BigInteger asBigInteger(BigInteger defaultValue) {\n-        // First, `null` same as `NullNode`\n-        if (_value == null) {\n-            return defaultValue;\n-        }\n-\n-        // Next, check if the value is NOT a Number\n+        // If not a Number (including `null`), return default\n         if (!(_value instanceof Number)) {\n             return defaultValue;\n         }\n@@ -365,12 +338,7 @@ public BigInteger asBigInteger(BigInteger defaultValue) {\n \n     @Override\n     public Optional<BigInteger> asBigIntegerOpt() {\n-        // First, `null` same as `NullNode`\n-        if (_value == null) {\n-            return Optional.empty();\n-        }\n-\n-        // Next, check if the value is NOT a Number\n+        // If not a Number (including `null`), return empty\n         if (!(_value instanceof Number)) {\n             return Optional.empty();\n         }\n@@ -405,12 +373,7 @@ public float asFloat() {\n \n     @Override\n     public float asFloat(float defaultValue) {\n-        // First, `null` same as `NullNode`\n-        if (_value == null) {\n-            return defaultValue;\n-        }\n-\n-        // Next, check if the value is NOT a Number\n+        // If not a Number (including `null`), return default\n         if (!(_value instanceof Number)) {\n             return defaultValue;\n         }\n@@ -425,12 +388,7 @@ public float asFloat(float defaultValue) {\n \n     @Override\n     public Optional<Float> asFloatOpt() {\n-        // First, `null` same as `NullNode`\n-        if (_value == null) {\n-            return Optional.empty();\n-        }\n-\n-        // Next, check if the value is NOT a Number\n+        // If not a Number (including `null`), return empty\n         if (!(_value instanceof Number)) {\n             return Optional.empty();\n         }\n@@ -469,12 +427,7 @@ public double asDouble() {\n \n     @Override\n     public double asDouble(double defaultValue) {\n-        // First, `null` same as `NullNode`\n-        if (_value == null) {\n-            return defaultValue;\n-        }\n-\n-        // Next, check if the value is NOT a Number\n+        // If not a Number (including `null`), return default\n         if (!(_value instanceof Number)) {\n             return defaultValue;\n         }\n@@ -489,12 +442,7 @@ public double asDouble(double defaultValue) {\n \n     @Override\n     public OptionalDouble asDoubleOpt() {\n-        // First, `null` same as `NullNode`\n-        if (_value == null) {\n-            return OptionalDouble.empty();\n-        }\n-\n-        // Next, check if the value is NOT a Number\n+        // If not a Number (including `null`), return empty\n         if (!(_value instanceof Number)) {\n             return OptionalDouble.empty();\n         }\n@@ -528,12 +476,7 @@ public BigDecimal asDecimal() {\n \n     @Override\n     public BigDecimal asDecimal(BigDecimal defaultValue) {\n-        // First, `null` same as `NullNode`\n-        if (_value == null) {\n-            return defaultValue;\n-        }\n-\n-        // Next, check if the value is NOT a Number\n+        // If not a Number (including `null`), return default\n         if (!(_value instanceof Number)) {\n             return defaultValue;\n         }\n@@ -544,12 +487,7 @@ public BigDecimal asDecimal(BigDecimal defaultValue) {\n \n     @Override\n     public Optional<BigDecimal> asDecimalOpt() {\n-        // First, `null` same as `NullNode`\n-        if (_value == null) {\n-            return Optional.empty();\n-        }\n-\n-        // Next, check if the value is NOT a Number\n+        // If not a Number (including `null`), return empty\n         if (!(_value instanceof Number)) {\n             return Optional.empty();\n         }\n@@ -653,7 +591,8 @@ protected BigDecimal _extractAsBigDecimal() {\n      */\n \n     @Override\n-    public final void serialize(JsonGenerator gen, SerializationContext ctxt) throws JacksonException\n+    public final void serialize(JsonGenerator gen, SerializationContext ctxt)\n+        throws JacksonException\n     {\n         if (_value == null) {\n             ctxt.defaultSerializeNullValue(gen);\n",
  "test_patch" : "diff --git a/src/test/java/tools/jackson/databind/node/JsonNodeBigIntegerValueTest.java b/src/test/java/tools/jackson/databind/node/JsonNodeBigIntegerValueTest.java\nindex aaf5502c0a..223f6dff56 100644\n--- a/src/test/java/tools/jackson/databind/node/JsonNodeBigIntegerValueTest.java\n+++ b/src/test/java/tools/jackson/databind/node/JsonNodeBigIntegerValueTest.java\n@@ -194,8 +194,10 @@ public void asBigIntegerFromMiscOther()\n         assertEquals(BigInteger.valueOf(9999999L), NODES.nullNode().asBigInteger(BigInteger.valueOf(9999999L)));\n         assertFalse(NODES.nullNode().asBigIntegerOpt().isPresent());\n \n-        // But MissingNode still fails\n-        _assertAsBigIntegerFailForNonNumber(NODES.missingNode());\n+        // [databind#5583]: as of 3.1, MissingNode behaves like NullNode\n+        assertEquals(BigInteger.ZERO, NODES.missingNode().asBigInteger());\n+        assertEquals(BigInteger.valueOf(9999999L), NODES.missingNode().asBigInteger(BigInteger.valueOf(9999999L)));\n+        assertFalse(NODES.missingNode().asBigIntegerOpt().isPresent());\n     }\n     \n     // // // Shared helper methods\ndiff --git a/src/test/java/tools/jackson/databind/node/JsonNodeBooleanValueTest.java b/src/test/java/tools/jackson/databind/node/JsonNodeBooleanValueTest.java\nindex 066a3c0898..d2a6557ff6 100644\n--- a/src/test/java/tools/jackson/databind/node/JsonNodeBooleanValueTest.java\n+++ b/src/test/java/tools/jackson/databind/node/JsonNodeBooleanValueTest.java\n@@ -143,8 +143,10 @@ public void asBooleanFromNonNumberMisc()\n         _assertFalseFromAsBoolean(NODES.pojoNode(Boolean.FALSE));\n         _assertTrueFromAsBoolean(NODES.pojoNode(Boolean.TRUE));\n \n-        // but missing not\n-        _assertFailAsBooleanForNonBoolean(NODES.missingNode());\n+        // [databind#5583]: as of 3.1, MissingNode behaves like NullNode\n+        assertEquals(false, NODES.missingNode().asBoolean());\n+        assertEquals(true, NODES.missingNode().asBoolean(true));\n+        assertFalse(NODES.missingNode().asBooleanOpt().isPresent());\n     }\n \n     // // // Helper methods\ndiff --git a/src/test/java/tools/jackson/databind/node/JsonNodeDecimalValueTest.java b/src/test/java/tools/jackson/databind/node/JsonNodeDecimalValueTest.java\nindex 500efc241a..ddbc7d7393 100644\n--- a/src/test/java/tools/jackson/databind/node/JsonNodeDecimalValueTest.java\n+++ b/src/test/java/tools/jackson/databind/node/JsonNodeDecimalValueTest.java\n@@ -217,8 +217,10 @@ public void asDecimalFromMiscOther()\n         assertEquals(BD_DEFAULT, NODES.nullNode().asDecimal(BD_DEFAULT));\n         assertFalse(NODES.nullNode().asDecimalOpt().isPresent());\n \n-        // but \"missing\" still fails\n-        _assertFailAsDecimalForNonNumber(NODES.missingNode());\n+        // [databind#5583]: as of 3.1, MissingNode behaves like NullNode\n+        assertEquals(BigDecimal.ZERO, NODES.missingNode().asDecimal());\n+        assertEquals(BD_DEFAULT, NODES.missingNode().asDecimal(BD_DEFAULT));\n+        assertFalse(NODES.missingNode().asDecimalOpt().isPresent());\n     }\n     \n     // // // Shared helper methods\ndiff --git a/src/test/java/tools/jackson/databind/node/JsonNodeDoubleValueTest.java b/src/test/java/tools/jackson/databind/node/JsonNodeDoubleValueTest.java\nindex deff4480b3..2b3294419a 100644\n--- a/src/test/java/tools/jackson/databind/node/JsonNodeDoubleValueTest.java\n+++ b/src/test/java/tools/jackson/databind/node/JsonNodeDoubleValueTest.java\n@@ -232,14 +232,17 @@ public void asDoubleFromStructuralFail()\n     @Test\n     public void asDoubleFromMiscOther()\n     {\n-        // Null node converts to 0.0d; missing fails\n+        // Null node converts to 0.0d\n         assertEquals(0.0d, NODES.nullNode().asDouble());\n \n         // and defaults\n         assertEquals(-9999.5, NODES.nullNode().asDouble(-9999.5));\n         assertFalse(NODES.nullNode().asDoubleOpt().isPresent());\n \n-        _assertAsDoubleFailForNonNumber(NODES.missingNode());\n+        // [databind#5583]: as of 3.1, MissingNode behaves like NullNode\n+        assertEquals(0.0d, NODES.missingNode().asDouble());\n+        assertEquals(-9999.5, NODES.missingNode().asDouble(-9999.5));\n+        assertFalse(NODES.missingNode().asDoubleOpt().isPresent());\n     }\n \n     // // // Shared helper methods\ndiff --git a/src/test/java/tools/jackson/databind/node/JsonNodeFloatValueTest.java b/src/test/java/tools/jackson/databind/node/JsonNodeFloatValueTest.java\nindex 9d9ebea893..b2bebd18a5 100644\n--- a/src/test/java/tools/jackson/databind/node/JsonNodeFloatValueTest.java\n+++ b/src/test/java/tools/jackson/databind/node/JsonNodeFloatValueTest.java\n@@ -234,13 +234,17 @@ public void asFloatFromStructuralFail()\n     @Test\n     public void asFloatFromMiscOther()\n     {\n-        // Null node converts to 0.0f; missing fails\n+        // Null node converts to 0.0f\n         assertEquals(0.0f, NODES.nullNode().asFloat());\n \n         // and defaults\n         assertEquals(-9999.5f, NODES.nullNode().asFloat(-9999.5f));\n         assertFalse(NODES.nullNode().asFloatOpt().isPresent());\n-        _assertAsFloatFailForNonNumber(NODES.missingNode());\n+\n+        // [databind#5583]: as of 3.1, MissingNode behaves like NullNode\n+        assertEquals(0.0f, NODES.missingNode().asFloat());\n+        assertEquals(-9999.5f, NODES.missingNode().asFloat(-9999.5f));\n+        assertFalse(NODES.missingNode().asFloatOpt().isPresent());\n     }\n \n \ndiff --git a/src/test/java/tools/jackson/databind/node/JsonNodeIntValueTest.java b/src/test/java/tools/jackson/databind/node/JsonNodeIntValueTest.java\nindex 05a4ce0d17..179390ecf0 100644\n--- a/src/test/java/tools/jackson/databind/node/JsonNodeIntValueTest.java\n+++ b/src/test/java/tools/jackson/databind/node/JsonNodeIntValueTest.java\n@@ -300,14 +300,17 @@ public void asIntFromStructuralFail()\n     @Test\n     public void asIntFromMiscOther()\n     {\n-        // NullNode -> 0 but \"missing\" still fails\n+        // NullNode -> 0\n         assertEquals(0, NODES.nullNode().asInt());\n \n         // and defaulting\n         assertEquals(999_999, NODES.nullNode().asInt(999_999));\n         assertFalse(NODES.nullNode().asIntOpt().isPresent());\n \n-        _assertAsIntFailForNonNumber(NODES.missingNode());\n+        // [databind#5583]: as of 3.1, MissingNode behaves like NullNode\n+        assertEquals(0, NODES.missingNode().asInt());\n+        assertEquals(999_999, NODES.missingNode().asInt(999_999));\n+        assertFalse(NODES.missingNode().asIntOpt().isPresent());\n     }\n     \n     // // // Shared helper methods: intValue()\ndiff --git a/src/test/java/tools/jackson/databind/node/JsonNodeLongValueTest.java b/src/test/java/tools/jackson/databind/node/JsonNodeLongValueTest.java\nindex 2958b670e7..550f14c675 100644\n--- a/src/test/java/tools/jackson/databind/node/JsonNodeLongValueTest.java\n+++ b/src/test/java/tools/jackson/databind/node/JsonNodeLongValueTest.java\n@@ -295,14 +295,17 @@ public void asLongFromStructuralFail()\n     @Test\n     public void asLongFromMiscOther()\n     {\n-        // NullNode works, Missing fails\n+        // NullNode works\n         assertEquals(0L, NODES.nullNode().asLong());\n \n         // But also fallbacks\n         assertEquals(999999L, NODES.nullNode().asLong(999999L));\n         assertFalse(NODES.nullNode().asLongOpt().isPresent());\n \n-        _assertAsLongFailForNonNumber(NODES.missingNode());\n+        // [databind#5583]: as of 3.1, MissingNode behaves like NullNode\n+        assertEquals(0L, NODES.missingNode().asLong());\n+        assertEquals(999999L, NODES.missingNode().asLong(999999L));\n+        assertFalse(NODES.missingNode().asLongOpt().isPresent());\n     }\n     \n     // // // Shared helper methods, longValue()\ndiff --git a/src/test/java/tools/jackson/databind/node/JsonNodeShortValueTest.java b/src/test/java/tools/jackson/databind/node/JsonNodeShortValueTest.java\nindex ea19095515..2f96d591dd 100644\n--- a/src/test/java/tools/jackson/databind/node/JsonNodeShortValueTest.java\n+++ b/src/test/java/tools/jackson/databind/node/JsonNodeShortValueTest.java\n@@ -281,14 +281,17 @@ public void asIntFromStructuralFail()\n     @Test\n     public void asIntFromMiscOther()\n     {\n-        // NullNode -> 0 but \"missing\" still fails\n+        // NullNode -> 0\n         assertEquals((short) 0, NODES.nullNode().asShort());\n \n         // and defaulting\n         assertEquals((short) 99, NODES.nullNode().asShort((short) 99));\n         assertFalse(NODES.nullNode().asShortOpt().isPresent());\n \n-        _assertAsShortFailForNonNumber(NODES.missingNode());\n+        // [databind#5583]: as of 3.1, MissingNode behaves like NullNode\n+        assertEquals((short) 0, NODES.missingNode().asShort());\n+        assertEquals((short) 99, NODES.missingNode().asShort((short) 99));\n+        assertFalse(NODES.missingNode().asShortOpt().isPresent());\n     }\n \n \ndiff --git a/src/test/java/tools/jackson/databind/node/JsonNodeStringValueTest.java b/src/test/java/tools/jackson/databind/node/JsonNodeStringValueTest.java\nindex dcfc8a968b..58ad0615dd 100644\n--- a/src/test/java/tools/jackson/databind/node/JsonNodeStringValueTest.java\n+++ b/src/test/java/tools/jackson/databind/node/JsonNodeStringValueTest.java\n@@ -129,7 +129,10 @@ public void asStringFromNonNumberMisc()\n         assertEquals(\"fallback\", NODES.nullNode().asString(\"fallback\"));\n         assertFalse(NODES.nullNode().asStringOpt().isPresent());\n \n-        _assertAsStringFailForNonString(NODES.missingNode());\n+        // [databind#5583]: as of 3.1, MissingNode behaves like NullNode\n+        assertEquals(\"\", NODES.missingNode().asString());\n+        assertEquals(\"fallback\", NODES.missingNode().asString(\"fallback\"));\n+        assertFalse(NODES.missingNode().asStringOpt().isPresent());\n     }\n \n     // // // Helper methods:\ndiff --git a/src/test/java/tools/jackson/databind/node/MissingNodeTest.java b/src/test/java/tools/jackson/databind/node/MissingNodeTest.java\nindex a6eb7ec013..8c155525e0 100644\n--- a/src/test/java/tools/jackson/databind/node/MissingNodeTest.java\n+++ b/src/test/java/tools/jackson/databind/node/MissingNodeTest.java\n@@ -1,15 +1,16 @@\n package tools.jackson.databind.node;\n \n import java.io.StringReader;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n import java.util.Iterator;\n \n import org.junit.jupiter.api.Test;\n \n import tools.jackson.core.JsonToken;\n import tools.jackson.databind.JsonNode;\n-import tools.jackson.databind.exc.JsonNodeException;\n \n-import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+import static org.assertj.core.api.Assertions.assertThat;\n import static org.junit.jupiter.api.Assertions.*;\n \n public class MissingNodeTest extends NodeTestBase\n@@ -20,11 +21,10 @@ public void testMissing()\n         MissingNode n = MissingNode.getInstance();\n         assertTrue(n.isMissingNode());\n         assertEquals(JsonToken.NOT_AVAILABLE, n.asToken());\n-        // exception in 3.0:\n-        assertThatThrownBy(n::asString)\n-                .isInstanceOf(JsonNodeException.class)\n-                .hasMessage(\"'MissingNode' method `asString()` cannot coerce value <missing> to `java.lang.String`: value type not coercible\");\n+        // [databind#5583]: as of 3.1, MissingNode.asString() returns \"\" like NullNode\n+        assertEquals(\"\", n.asString());\n         assertEquals(\"default\", n.asString(\"default\"));\n+        assertFalse(n.asStringOpt().isPresent());\n         assertStandardEquals(n);\n         // 10-Dec-2018, tatu: With 2.10, should serialize same as via ObjectMapper/ObjectWriter\n         // 10-Dec-2019, tatu: Surprise! No, this is not how it worked in 2.9, nor does it make\n@@ -39,6 +39,52 @@ public void testMissing()\n         assertEquals(0.25, n.asDouble(0.25));\n     }\n \n+    // [databind#5583]: MissingNode should behave like NullNode for asXxx() methods\n+    @Test\n+    public void testMissingNodeNullLikeBehavior()\n+    {\n+        MissingNode n = MissingNode.getInstance();\n+\n+        // Boolean: asBoolean() returns false (like NullNode)\n+        assertThat(n.asBoolean()).isFalse();\n+        assertThat(n.asBoolean(true)).isTrue();\n+        assertThat(n.asBooleanOpt()).isNotPresent();\n+\n+        // String: asString() returns \"\" (like NullNode)\n+        assertThat(n.asString()).isEqualTo(\"\");\n+        assertThat(n.asString(\"default\")).isEqualTo(\"default\");\n+        assertThat(n.asStringOpt()).isNotPresent();\n+\n+        // Numeric types: asXxx() returns 0/ZERO (like NullNode)\n+        assertThat(n.asShort()).isEqualTo((short) 0);\n+        assertThat(n.asShort((short) 5)).isEqualTo((short) 5);\n+        assertThat(n.asShortOpt()).isNotPresent();\n+\n+        assertThat(n.asInt()).isEqualTo(0);\n+        assertThat(n.asInt(5)).isEqualTo(5);\n+        assertThat(n.asIntOpt()).isNotPresent();\n+\n+        assertThat(n.asLong()).isEqualTo(0L);\n+        assertThat(n.asLong(5L)).isEqualTo(5L);\n+        assertThat(n.asLongOpt()).isNotPresent();\n+\n+        assertThat(n.asBigInteger()).isEqualTo(BigInteger.ZERO);\n+        assertThat(n.asBigInteger(BigInteger.TEN)).isEqualTo(BigInteger.TEN);\n+        assertThat(n.asBigIntegerOpt()).isNotPresent();\n+\n+        assertThat(n.asFloat()).isEqualTo(0.0f);\n+        assertThat(n.asFloat(1.5f)).isEqualTo(1.5f);\n+        assertThat(n.asFloatOpt()).isNotPresent();\n+\n+        assertThat(n.asDouble()).isEqualTo(0.0d);\n+        assertThat(n.asDouble(1.5d)).isEqualTo(1.5d);\n+        assertThat(n.asDoubleOpt()).isNotPresent();\n+\n+        assertThat(n.asDecimal()).isEqualTo(BigDecimal.ZERO);\n+        assertThat(n.asDecimal(BigDecimal.TEN)).isEqualTo(BigDecimal.TEN);\n+        assertThat(n.asDecimalOpt()).isNotPresent();\n+    }\n+\n     /**\n      * Let's also verify behavior of \"MissingNode\" -- one needs to be able\n      * to traverse such bogus nodes with appropriate methods.\ndiff --git a/src/test/java/tools/jackson/databind/node/POJONodeTest.java b/src/test/java/tools/jackson/databind/node/POJONodeTest.java\nindex 11e58f764d..16903b9a98 100644\n--- a/src/test/java/tools/jackson/databind/node/POJONodeTest.java\n+++ b/src/test/java/tools/jackson/databind/node/POJONodeTest.java\n@@ -109,10 +109,8 @@ public void testAsBooleanOpt() {\n \n     @Test\n     public void testAsString() {\n-        assertThatThrownBy(() -> new POJONode(null).asString())\n-                .isInstanceOf(JsonNodeException.class)\n-                .hasMessage(\"'POJONode' method `asString()` cannot coerce value\"\n-                        + \" {POJO of type [null]} to `java.lang.String`: value type not coercible\");\n+        // [databind#5583]: as of 3.1, POJONode(null).asString() returns \"\" like NullNode\n+        assertThat(new POJONode(null).asString()).isEqualTo(\"\");\n         assertThat(new POJONode(\"test\").asString()).isEqualTo(\"test\");\n         assertThatThrownBy(() -> new POJONode(new Data()).asString())\n                 .isInstanceOf(JsonNodeException.class)\n@@ -222,16 +220,37 @@ public void testAsIntOpt() {\n     public void testAsLong() {\n         assertThat(new POJONode(null).asLong()).isEqualTo(0L);\n         assertThat(new POJONode(99.99D).asLong()).isEqualTo(99L);\n+        assertThat(new POJONode(33.3f).asLong()).isEqualTo(33L);\n         assertThat(new POJONode(99L).asLong()).isEqualTo(99L);\n         assertThat(new POJONode(99).asLong()).isEqualTo(99L);\n         assertThat(new POJONode((short) 99).asLong()).isEqualTo(99L);\n         assertThat(new POJONode((byte) 99).asLong()).isEqualTo(99L);\n         assertThat(new POJONode(BigInteger.valueOf(99)).asLong()).isEqualTo(99L);\n         assertThat(new POJONode(BigDecimal.valueOf(99.99)).asLong()).isEqualTo(99L);\n+\n         assertThatThrownBy(() -> new POJONode(new Data()).asLong())\n+            .isInstanceOf(JsonNodeException.class)\n+            .hasMessage(\"'POJONode' method `asLong()` cannot coerce value\"\n+                + \" {POJO of type `tools.jackson.databind.node.POJONodeTest$Data`} to `long`: value type not coercible\");\n+\n+        assertThatThrownBy(() -> new POJONode((float) Long.MAX_VALUE * 2.0f).asLong())\n+                .isInstanceOf(JsonNodeException.class)\n+                .hasMessageContaining(\"'POJONode' method `asLong()` cannot convert value\")\n+                .hasMessageContaining(\"value not in 64-bit `long` range\")\n+                ;\n+\n+        final double bigD = (double) Long.MAX_VALUE * 2.0;\n+        assertThatThrownBy(() -> new POJONode(bigD).asLong())\n                 .isInstanceOf(JsonNodeException.class)\n-                .hasMessage(\"'POJONode' method `asLong()` cannot coerce value\"\n-                        + \" {POJO of type `tools.jackson.databind.node.POJONodeTest$Data`} to `long`: value type not coercible\");\n+                .hasMessageContaining(\"'POJONode' method `asLong()` cannot convert value\")\n+                .hasMessageContaining(\"value not in 64-bit `long` range\")\n+                ;\n+\n+        assertThatThrownBy(() -> new POJONode(BigDecimal.valueOf(bigD)).asLong())\n+            .isInstanceOf(JsonNodeException.class)\n+            .hasMessageContaining(\"'POJONode' method `asLong()` cannot convert value\")\n+            .hasMessageContaining(\"value not in 64-bit `long` range\")\n+            ;\n     }\n \n     @Test\n",
  "problem_statement" : "Currently (3.0.x) coercing non-defaulting accessors like `JsonNode.asString()` fail for `MissingNode` (and `POJONode` constructed to wrap `null`. They should instead work like `NullNode.asString()` -- similarly for other `asXxx()` accessors.\n\nDefaulting (`asString(String defaultValue)`) and optional (`asStringOpt()`) should work as-is, returning default / Optional.empty()` value.\n",
  "hints_text" : null,
  "created_at" : "Thu Jan 15 03:10:40 CET 2026",
  "version" : null,
  "FAIL_TO_PASS" : [ "JsonNodeLongValueTest", "POJONodeTest", "JsonNodeDecimalValueTest", "JsonNodeFloatValueTest", "JsonNodeIntValueTest", "MissingNodeTest", "JsonNodeStringValueTest", "JsonNodeDoubleValueTest", "JsonNodeBigIntegerValueTest", "JsonNodeShortValueTest", "JsonNodeBooleanValueTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=JsonNodeLongValueTest,POJONodeTest,JsonNodeDecimalValueTest,JsonNodeFloatValueTest,JsonNodeIntValueTest,MissingNodeTest,JsonNodeStringValueTest,JsonNodeDoubleValueTest,JsonNodeBigIntegerValueTest,JsonNodeShortValueTest,JsonNodeBooleanValueTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : 5583,
  "pull_number" : 5584,
  "metadata" : null
}, {
  "instance_id" : "FasterXML-jackson-databind-PR-5582",
  "repo" : "FasterXML/jackson-databind",
  "base_commit" : "6144f64acc4e9f478c2a24c4524cdd31a030cf3e",
  "patch" : "diff --git a/release-notes/VERSION b/release-notes/VERSION\nindex 674157f7bc..635d577b84 100644\n--- a/release-notes/VERSION\n+++ b/release-notes/VERSION\n@@ -132,6 +132,7 @@ Versions: 3.x (for earlier see VERSION-2.x)\n  (requested by Réda H-A)\n  (implemented by @cowtowncoder, w/ Claude code)\n #5579: Add `JsonNode.map()` method\n+#5581: Add functional conversion methods `JsonNode.nullAs()`, `JsonNode.missingAs()`\n \n 3.0.4 (not yet released)\n \ndiff --git a/src/main/java/tools/jackson/databind/JsonNode.java b/src/main/java/tools/jackson/databind/JsonNode.java\nindex 3731cb0ced..769d6eeed5 100644\n--- a/src/main/java/tools/jackson/databind/JsonNode.java\n+++ b/src/main/java/tools/jackson/databind/JsonNode.java\n@@ -5,6 +5,7 @@\n import java.util.*;\n import java.util.function.BiConsumer;\n import java.util.function.Function;\n+import java.util.function.Supplier;\n import java.util.stream.Stream;\n \n import tools.jackson.core.*;\n@@ -2029,6 +2030,92 @@ public <R> R map(Function<? super JsonNode, ? extends R> mapper) {\n         return mapper.apply(this);\n     }\n \n+    /**\n+     * Method for handling {@code null} values: if this node represents JSON {@code null}\n+     * value (that is, {@link #isNull()} returns {@code true}), returns the specified\n+     * replacement value; otherwise returns {@code this} node.\n+     *<p>\n+     * This enables functional-style handling of null values:\n+     *<pre>\n+     *   JsonNode node = ...;\n+     *   JsonNode nonNull = node.nullAs(defaultNode);\n+     *</pre>\n+     *\n+     * @param replacement Value to return if this node is a null node\n+     *\n+     * @return {@code this} node if not null, otherwise the replacement node\n+     *\n+     * @since 3.1\n+     */\n+    public JsonNode nullAs(JsonNode replacement) {\n+        return isNull() ? replacement : this;\n+    }\n+\n+    /**\n+     * Method for handling {@code null} values with deferred evaluation: if this node\n+     * represents JSON {@code null} value (that is, {@link #isNull()} returns {@code true}),\n+     * invokes the supplier and returns its result; otherwise returns {@code this} node\n+     * without invoking the supplier.\n+     *<p>\n+     * This enables functional-style handling of null values with lazy evaluation:\n+     *<pre>\n+     *   JsonNode node = ...;\n+     *   JsonNode nonNull = node.nullAs(() -&gt; computeDefault());\n+     *</pre>\n+     *\n+     * @param supplier Supplier to invoke if this node is a null node\n+     *\n+     * @return {@code this} node if not null, otherwise the result from the supplier\n+     *\n+     * @since 3.1\n+     */\n+    public JsonNode nullAs(Supplier<? extends JsonNode> supplier) {\n+        return isNull() ? supplier.get() : this;\n+    }\n+\n+    /**\n+     * Method for handling missing nodes: if this node is a {@link MissingNode}\n+     * (that is, {@link #isMissingNode()} returns {@code true}), returns the specified\n+     * replacement value; otherwise returns {@code this} node.\n+     *<p>\n+     * This enables functional-style handling of missing values:\n+     *<pre>\n+     *   JsonNode node = objectNode.path(\"mayNotExist\");\n+     *   JsonNode present = node.missingAs(defaultNode);\n+     *</pre>\n+     *\n+     * @param replacement Value to return if this node is a missing node\n+     *\n+     * @return {@code this} node if not missing, otherwise the replacement node\n+     *\n+     * @since 3.1\n+     */\n+    public JsonNode missingAs(JsonNode replacement) {\n+        return isMissingNode() ? replacement : this;\n+    }\n+\n+    /**\n+     * Method for handling missing nodes with deferred evaluation: if this node is a\n+     * {@link MissingNode} (that is, {@link #isMissingNode()} returns {@code true}),\n+     * invokes the supplier and returns its result; otherwise returns {@code this} node\n+     * without invoking the supplier.\n+     *<p>\n+     * This enables functional-style handling of missing values with lazy evaluation:\n+     *<pre>\n+     *   JsonNode node = objectNode.path(\"mayNotExist\");\n+     *   JsonNode present = node.missingAs(() -&gt; computeDefault());\n+     *</pre>\n+     *\n+     * @param supplier Supplier to invoke if this node is a missing node\n+     *\n+     * @return {@code this} node if not missing, otherwise the result from the supplier\n+     *\n+     * @since 3.1\n+     */\n+    public JsonNode missingAs(Supplier<? extends JsonNode> supplier) {\n+        return isMissingNode() ? supplier.get() : this;\n+    }\n+\n     /*\n     /**********************************************************************\n     /* Public API, comparison\n",
  "test_patch" : "diff --git a/src/test/java/tools/jackson/databind/node/JsonNodeMapTest.java b/src/test/java/tools/jackson/databind/node/JsonNodeMapTest.java\nindex 61d9f8631b..d4c6c84692 100644\n--- a/src/test/java/tools/jackson/databind/node/JsonNodeMapTest.java\n+++ b/src/test/java/tools/jackson/databind/node/JsonNodeMapTest.java\n@@ -106,5 +106,132 @@ public void testMapWithComplexTransformation()\n         assertEquals(20, point.y);\n     }\n \n-    // // // Other tests\n+    // // // Tests for JsonNode.nullAs()\n+\n+    @Test\n+    public void testNullAsWithNullNode()\n+    {\n+        JsonNode defaultNode = MAPPER.stringNode(\"default\");\n+        JsonNode result = MAPPER.nullNode().nullAs(defaultNode);\n+        assertSame(defaultNode, result);\n+    }\n+\n+    @Test\n+    public void testNullAsWithNonNullNode()\n+    {\n+        JsonNode stringNode = MAPPER.stringNode(\"hello\");\n+        JsonNode defaultNode = MAPPER.stringNode(\"default\");\n+\n+        assertSame(stringNode, stringNode.nullAs(defaultNode));\n+    }\n+\n+    @Test\n+    public void testNullAsSupplierWithNullNode()\n+    {\n+        JsonNode defaultNode = MAPPER.stringNode(\"supplied\");\n+\n+        JsonNode result = MAPPER.nullNode().nullAs(() -> defaultNode);\n+        assertSame(defaultNode, result);\n+    }\n+\n+    @Test\n+    public void testNullAsSupplierWithNonNullNode()\n+    {\n+        JsonNode stringNode = MAPPER.stringNode(\"hello\");\n+        boolean[] supplierCalled = {false};\n+\n+        JsonNode result = stringNode.nullAs(() -> {\n+            supplierCalled[0] = true;\n+            return MAPPER.stringNode(\"supplied\");\n+        });\n+\n+        assertSame(stringNode, result);\n+        assertFalse(supplierCalled[0], \"Supplier should not be called for non-null node\");\n+    }\n+\n+    @Test\n+    public void testNullAsWithMissingNode()\n+    {\n+        // MissingNode is not a null node, so should return itself\n+        JsonNode missingNode = MAPPER.missingNode();\n+        JsonNode defaultNode = MAPPER.stringNode(\"default\");\n+\n+        assertSame(missingNode, missingNode.nullAs(defaultNode));\n+    }\n+\n+    // // // Tests for JsonNode.missingAs()\n+\n+    @Test\n+    public void testMissingAsWithMissingNode()\n+    {\n+        JsonNode defaultNode = MAPPER.stringNode(\"default\");\n+        JsonNode result = MAPPER.missingNode().missingAs(defaultNode);\n+        assertSame(defaultNode, result);\n+    }\n+\n+    @Test\n+    public void testMissingAsWithNonMissingNode()\n+    {\n+        JsonNode stringNode = MAPPER.stringNode(\"hello\");\n+        JsonNode defaultNode = MAPPER.stringNode(\"default\");\n+\n+        assertSame(stringNode, stringNode.missingAs(defaultNode));\n+    }\n+\n+    @Test\n+    public void testMissingAsSupplierWithMissingNode()\n+    {\n+        JsonNode defaultNode = MAPPER.stringNode(\"supplied\");\n+\n+        JsonNode result = MAPPER.missingNode().missingAs(() -> defaultNode);\n+        assertSame(defaultNode, result);\n+    }\n+\n+    @Test\n+    public void testMissingAsSupplierWithNonMissingNode()\n+    {\n+        JsonNode stringNode = MAPPER.stringNode(\"hello\");\n+        boolean[] supplierCalled = {false};\n+\n+        JsonNode result = stringNode.missingAs(() -> {\n+            supplierCalled[0] = true;\n+            return MAPPER.stringNode(\"supplied\");\n+        });\n+\n+        assertSame(stringNode, result);\n+        assertFalse(supplierCalled[0], \"Supplier should not be called for non-missing node\");\n+    }\n+\n+    @Test\n+    public void testMissingAsWithNullNode()\n+    {\n+        // NullNode is not a missing node, so should return itself\n+        JsonNode nullNode = MAPPER.nullNode();\n+        JsonNode defaultNode = MAPPER.stringNode(\"default\");\n+\n+        JsonNode result = nullNode.missingAs(defaultNode);\n+        assertSame(nullNode, result);\n+    }\n+\n+    @Test\n+    public void testNullAsAndMissingAsCombined()\n+    {\n+        // Test chaining both methods together\n+        JsonNode defaultNode = MAPPER.stringNode(\"default\");\n+\n+        // null.nullAs(...).missingAs(...) -> should return from nullAs\n+        JsonNode nullNode = MAPPER.nullNode();\n+        JsonNode result1 = nullNode.nullAs(defaultNode).missingAs(MAPPER.stringNode(\"other\"));\n+        assertSame(defaultNode, result1);\n+\n+        // missing.nullAs(...).missingAs(...) -> should return from missingAs\n+        JsonNode missingNode = MAPPER.missingNode();\n+        JsonNode result2 = missingNode.nullAs(MAPPER.stringNode(\"other\")).missingAs(defaultNode);\n+        assertSame(defaultNode, result2);\n+\n+        // regular.nullAs(...).missingAs(...) -> should return original\n+        JsonNode regularNode = MAPPER.stringNode(\"regular\");\n+        JsonNode result3 = regularNode.nullAs(MAPPER.stringNode(\"a\")).missingAs(MAPPER.stringNode(\"b\"));\n+        assertSame(regularNode, result3);\n+    }\n }\n",
  "problem_statement" : "There is need for additional functional transformation methods, and beyond general-purpose `JsonNode.map()` (see #5579) we probably could use some convenience variants too:\n\n* `JsonNode.nullAs(JsonNode)` / `JsonNode.nullAs(Supplier<? extends JsonNode>)` \n* `JsonNode.missingAs(JsonNode)` / `JsonNode.missingAs(Supplier<? extends JsonNode>)` \n\nin which in first case, converter (`Supplier`) is only called if node is a `NullNode` (`isNull()` returns `true`), and in second case if it is `MissingNode` (`isMissingNode()` returns `true`).\n\n",
  "hints_text" : null,
  "created_at" : "Thu Jan 15 02:48:02 CET 2026",
  "version" : null,
  "FAIL_TO_PASS" : [ "JsonNodeMapTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=JsonNodeMapTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : 5581,
  "pull_number" : 5582,
  "metadata" : null
}, {
  "instance_id" : "FasterXML-jackson-databind-PR-5580",
  "repo" : "FasterXML/jackson-databind",
  "base_commit" : "52aeb0aca9e4256dd85bfd880bdb84d5d9f53a66",
  "patch" : "diff --git a/release-notes/VERSION b/release-notes/VERSION\nindex 4cfe442e4f..674157f7bc 100644\n--- a/release-notes/VERSION\n+++ b/release-notes/VERSION\n@@ -131,6 +131,7 @@ Versions: 3.x (for earlier see VERSION-2.x)\n #5575: Allow configuring a default serialization and deserialization view (3.x)\n  (requested by Réda H-A)\n  (implemented by @cowtowncoder, w/ Claude code)\n+#5579: Add `JsonNode.map()` method\n \n 3.0.4 (not yet released)\n \ndiff --git a/src/main/java/tools/jackson/databind/JsonNode.java b/src/main/java/tools/jackson/databind/JsonNode.java\nindex 9166f7b8b6..3731cb0ced 100644\n--- a/src/main/java/tools/jackson/databind/JsonNode.java\n+++ b/src/main/java/tools/jackson/databind/JsonNode.java\n@@ -4,6 +4,7 @@\n import java.math.BigInteger;\n import java.util.*;\n import java.util.function.BiConsumer;\n+import java.util.function.Function;\n import java.util.stream.Stream;\n \n import tools.jackson.core.*;\n@@ -2000,6 +2001,34 @@ public ArrayNode withArrayProperty(String propName) {\n                 +getClass().getName()+\")`, cannot call `withArrayProperty(String)` on it\");\n     }\n \n+    /*\n+    /**********************************************************************\n+    /* Public API, conversions (3.1)\n+    /**********************************************************************\n+     */\n+\n+    /**\n+     * Method that applies a transformation function to this node and returns the result.\n+     * This enables functional-style transformations of {@link JsonNode} objects.\n+     *<p>\n+     * For example:\n+     *<pre>\n+     *   JsonNode node = ...;\n+     *   String upperCaseText = node.map(n -&gt; n.asString().toUpperCase());\n+     *   Integer value = node.map(n -&gt; n.asInt() * 2);\n+     *</pre>\n+     *\n+     * @param <R> The type of the result produced by the mapper function\n+     * @param mapper Function to apply to this node\n+     *\n+     * @return Result of applying the mapper function to this node\n+     *\n+     * @since 3.1\n+     */\n+    public <R> R map(Function<? super JsonNode, ? extends R> mapper) {\n+        return mapper.apply(this);\n+    }\n+\n     /*\n     /**********************************************************************\n     /* Public API, comparison\n",
  "test_patch" : "diff --git a/src/test/java/tools/jackson/databind/node/JsonNodeMapTest.java b/src/test/java/tools/jackson/databind/node/JsonNodeMapTest.java\nnew file mode 100644\nindex 0000000000..61d9f8631b\n--- /dev/null\n+++ b/src/test/java/tools/jackson/databind/node/JsonNodeMapTest.java\n@@ -0,0 +1,110 @@\n+package tools.jackson.databind.node;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import tools.jackson.databind.*;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+/**\n+ * Tests for {@link JsonNode#map(java.util.function.Function)} method\n+ */\n+public class JsonNodeMapTest extends NodeTestBase\n+{\n+    private final ObjectMapper MAPPER = newJsonMapper();\n+\n+    // // // Tests for JsonNode.map()\n+\n+    @Test\n+    public void testMapWithStringNode()\n+    {\n+        JsonNode node = MAPPER.stringNode(\"hello\");\n+\n+        // Map to upper-case string\n+        String result = node.map(n -> n.asString().toUpperCase());\n+        assertEquals(\"HELLO\", result);\n+\n+        // Map to string length\n+        Integer length = node.map(n -> n.asString().length());\n+        assertEquals(5, length);\n+    }\n+\n+    @Test\n+    public void testMapWithNumberNode()\n+    {\n+        JsonNode node = MAPPER.readTree(\"42\");\n+\n+        // Map to doubled value\n+        Integer doubled = node.map(n -> n.asInt() * 2);\n+        assertEquals(84, doubled);\n+\n+        // Map to String node\n+        JsonNode result = node.map(n -> MAPPER.stringNode(n.asString()));\n+        assertTrue(result.isString());\n+        assertEquals(\"42\", result.stringValue());\n+    }\n+\n+    @Test\n+    public void testMapWithBooleanNode()\n+    {\n+        assertEquals(\"yes\",\n+                MAPPER.booleanNode(true).map(n -> n.asBoolean() ? \"yes\" : \"no\"));\n+        assertEquals(\"no\",\n+                MAPPER.booleanNode(false).map(n -> n.asBoolean() ? \"yes\" : \"no\"));\n+    }\n+\n+    @Test\n+    public void testMapWithNullNode()\n+    {\n+        JsonNode node = MAPPER.readTree(\"null\");\n+\n+        // Map null to a default value\n+        String result = node.map(n -> n.isNull() ? \"default\" : n.asString());\n+        assertEquals(\"default\", result);\n+    }\n+\n+    @Test\n+    public void testMapWithObjectNode()\n+    {\n+        JsonNode node = MAPPER.readTree(\"{\\\"name\\\":\\\"John\\\",\\\"age\\\":30}\");\n+        // Map to extract a property\n+        assertEquals(\"John\", node.map(n -> n.get(\"name\").asString()));\n+    }\n+\n+    @Test\n+    public void testMapWithArrayNode()\n+    {\n+        JsonNode node = MAPPER.readTree(\"[1,2,3,4,5]\");\n+        Integer I = node.map(n -> n.size());\n+        assertEquals(5, I);\n+    }\n+\n+    @Test\n+    public void testMapWithMissingNode()\n+    {\n+        JsonNode missingNode = MAPPER.missingNode();\n+        assertEquals(\"not found\",\n+                missingNode.map(n -> n.isMissingNode() ? \"not found\" : n.asString()));\n+    }\n+\n+    @Test\n+    public void testMapReturningNull()\n+    {\n+        assertNull(MAPPER.stringNode(\"test\").map(n -> null));\n+    }\n+\n+    @Test\n+    public void testMapWithComplexTransformation()\n+    {\n+        JsonNode node = MAPPER.readTree(\"{\\\"x\\\":10,\\\"y\\\":20}\");\n+        Point point = node.map(n -> new Point(\n+            n.get(\"x\").asInt(),\n+            n.get(\"y\").asInt()\n+        ));\n+\n+        assertEquals(10, point.x);\n+        assertEquals(20, point.y);\n+    }\n+\n+    // // // Other tests\n+}\n",
  "problem_statement" : "As a simple functional add-on, let's add something like this on `JsonNode`:\n\n    public <R> R map(Function<? super JsonNode, ? extends R> mapper);\n",
  "hints_text" : null,
  "created_at" : "Thu Jan 15 02:11:12 CET 2026",
  "version" : null,
  "FAIL_TO_PASS" : [ "JsonNodeMapTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=JsonNodeMapTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : 5579,
  "pull_number" : 5580,
  "metadata" : null
}, {
  "instance_id" : "FasterXML-jackson-databind-PR-5577",
  "repo" : "FasterXML/jackson-databind",
  "base_commit" : "6eb4224c756a6479091ffeb4c6a01ec688ed4c02",
  "patch" : "diff --git a/src/main/java/tools/jackson/databind/node/ArrayNode.java b/src/main/java/tools/jackson/databind/node/ArrayNode.java\nindex e7a72097fc..bcaacf2bc0 100644\n--- a/src/main/java/tools/jackson/databind/node/ArrayNode.java\n+++ b/src/main/java/tools/jackson/databind/node/ArrayNode.java\n@@ -68,7 +68,11 @@ protected JsonNode _removeAt(JsonPointer ptr) {\n \n     @Override\n     protected String _valueDesc() {\n-        return \"[...(\" + _children.size() + \" elements)]\";\n+        int size = _children.size();\n+        if (size == 0) {\n+            return \"[ ]\";\n+        }\n+        return \"[...(\" + size + \" elements)]\";\n     }\n     \n     // note: co-variant to allow caller-side type safety\ndiff --git a/src/main/java/tools/jackson/databind/node/BaseJsonNode.java b/src/main/java/tools/jackson/databind/node/BaseJsonNode.java\nindex 8cbb063a69..ade18183d5 100644\n--- a/src/main/java/tools/jackson/databind/node/BaseJsonNode.java\n+++ b/src/main/java/tools/jackson/databind/node/BaseJsonNode.java\n@@ -62,12 +62,14 @@ protected BaseJsonNode() { }\n \n     @Override\n     public Number numberValue() {\n-        return _reportCoercionFail(\"numberValue()\", Number.class, \"value type not numeric\");\n+        return _reportCoercionFail(\"numberValue()\", Number.class,\n+                \"value type not numeric\");\n     }\n \n     @Override\n     public short shortValue() {\n-        return _reportCoercionFail(\"shortValue()\", Short.TYPE, \"value type not numeric\");\n+        return _reportCoercionFail(\"shortValue()\", Short.TYPE,\n+                \"value type not numeric\");\n     }\n \n     @Override\n@@ -84,7 +86,7 @@ public Optional<Short> shortValueOpt() {\n \n     @Override\n     public short asShort() {\n-        return _reportCoercionFail(\"asShort()\", Short.TYPE, \"value type not numeric\");\n+        return _reportCoercionFail(\"asShort()\", Short.TYPE);\n     }\n \n     @Override\n@@ -101,7 +103,8 @@ public Optional<Short> asShortOpt() {\n \n     @Override\n     public int intValue() {\n-        return _reportCoercionFail(\"intValue()\", Integer.TYPE, \"value type not numeric\");\n+        return _reportCoercionFail(\"intValue()\", Integer.TYPE,\n+                \"value type not numeric\");\n     }\n \n     @Override\n@@ -118,7 +121,7 @@ public OptionalInt intValueOpt() {\n \n     @Override\n     public int asInt() {\n-        return _reportCoercionFail(\"asInt()\", Integer.TYPE, \"value type not numeric\");\n+        return _reportCoercionFail(\"asInt()\", Integer.TYPE);\n     }\n \n     @Override\n@@ -135,7 +138,8 @@ public OptionalInt asIntOpt() {\n \n     @Override\n     public long longValue() {\n-        return _reportCoercionFail(\"longValue()\", Long.TYPE, \"value type not numeric\");\n+        return _reportCoercionFail(\"longValue()\", Long.TYPE,\n+                \"value type not numeric\");\n     }\n \n     @Override\n@@ -152,7 +156,7 @@ public OptionalLong longValueOpt() {\n \n     @Override\n     public long asLong() {\n-        return _reportCoercionFail(\"asLong()\", Long.TYPE, \"value type not numeric\");\n+        return _reportCoercionFail(\"asLong()\", Long.TYPE);\n     }\n \n     @Override\n@@ -169,7 +173,8 @@ public OptionalLong asLongOpt() {\n \n     @Override\n     public BigInteger bigIntegerValue() {\n-        return _reportCoercionFail(\"bigIntegerValue()\", BigInteger.class, \"value type not numeric\");\n+        return _reportCoercionFail(\"bigIntegerValue()\", BigInteger.class,\n+                \"value type not numeric\");\n     }\n \n     @Override\n@@ -186,7 +191,7 @@ public Optional<BigInteger> bigIntegerValueOpt() {\n \n     @Override\n     public BigInteger asBigInteger() {\n-        return _reportCoercionFail(\"asBigInteger()\", BigInteger.class, \"value type not numeric\");\n+        return _reportCoercionFail(\"asBigInteger()\", BigInteger.class);\n     }\n \n     @Override\n@@ -203,7 +208,8 @@ public Optional<BigInteger> asBigIntegerOpt() {\n \n     @Override\n     public float floatValue() {\n-        return _reportCoercionFail(\"floatValue()\", Float.TYPE, \"value type not numeric\");\n+        return _reportCoercionFail(\"floatValue()\", Float.TYPE,\n+                \"value type not numeric\");\n     }\n \n     @Override\n@@ -220,7 +226,7 @@ public Optional<Float> floatValueOpt() {\n \n     @Override\n     public float asFloat() {\n-        return _reportCoercionFail(\"asFloat()\", Float.TYPE, \"value type not numeric\");\n+        return _reportCoercionFail(\"asFloat()\", Float.TYPE);\n     }\n \n     @Override\n@@ -237,7 +243,8 @@ public Optional<Float> asFloatOpt() {\n \n     @Override\n     public double doubleValue() {\n-        return _reportCoercionFail(\"doubleValue()\", Double.TYPE, \"value type not numeric\");\n+        return _reportCoercionFail(\"doubleValue()\", Double.TYPE,\n+                \"value type not numeric\");\n     }\n \n     @Override\n@@ -254,7 +261,7 @@ public OptionalDouble doubleValueOpt() {\n \n     @Override\n     public double asDouble() {\n-        return _reportCoercionFail(\"asDouble()\", Double.TYPE, \"value type not numeric\");\n+        return _reportCoercionFail(\"asDouble()\", Double.TYPE);\n     }\n \n     @Override\n@@ -271,7 +278,8 @@ public OptionalDouble asDoubleOpt() {\n \n     @Override\n     public BigDecimal decimalValue() {\n-        return _reportCoercionFail(\"decimalValue()\", BigDecimal.class, \"value type not numeric\");\n+        return _reportCoercionFail(\"decimalValue()\", BigDecimal.class,\n+                \"value type not numeric\");\n     }\n \n     @Override\n@@ -288,8 +296,7 @@ public Optional<BigDecimal> decimalValueOpt() {\n \n     @Override\n     public BigDecimal asDecimal() {\n-        return _reportCoercionFail(\"asDecimal()\", BigDecimal.class,\n-                \"value type not coercible to `BigDecimal`\");\n+        return _reportCoercionFail(\"asDecimal()\", BigDecimal.class);\n     }\n \n     @Override\n@@ -312,13 +319,13 @@ public Optional<BigDecimal> asDecimalOpt() {\n \n     @Override\n     public byte[] binaryValue() {\n-        return _reportCoercionFail(\"binaryValue()\", Boolean.TYPE,\n+        return _reportConversionFail(\"binaryValue()\", Boolean.TYPE,\n                 \"value type not binary (or convertible to binary via Base64-decoding)\");\n     }\n \n     @Override\n     public boolean booleanValue() {\n-        return _reportCoercionFail(\"booleanValue()\", Boolean.TYPE,\n+        return _reportConversionFail(\"booleanValue()\", Boolean.TYPE,\n                 \"value type not boolean\");\n     }\n \n@@ -338,8 +345,7 @@ public Optional<Boolean> booleanValueOpt() {\n     public boolean asBoolean() {\n         Boolean b = _asBoolean();\n         if (b == null) {\n-            return _reportCoercionFail(\"asBoolean()\", Boolean.TYPE,\n-                    \"value type not coercible to `boolean`\");\n+            return _reportCoercionFail(\"asBoolean()\", Boolean.TYPE);\n         }\n         return b;\n     }\n@@ -364,7 +370,7 @@ public Optional<Boolean> asBooleanOpt() {\n \n     @Override\n     public String stringValue() {\n-        return _reportCoercionFail(\"stringValue()\", String.class,\n+        return _reportConversionFail(\"stringValue()\", String.class,\n                 \"value type not String\");\n     }\n \n@@ -384,8 +390,7 @@ public Optional<String> stringValueOpt() {\n     public String asString() {\n         String str = _asString();\n         if (str == null) {\n-            return _reportCoercionFail(\"asString()\", String.class,\n-                    \"value type not coercible to `String`\");\n+            return _reportCoercionFail(\"asString()\", String.class);\n         }\n         return str;\n     }\n@@ -649,76 +654,105 @@ public String toPrettyString() {\n     /**********************************************************************\n      */\n \n+    // @since 3.1\n+    protected <T> T _reportCoercionFail(String method, Class<?> targetType)\n+    {\n+        return _reportCoercionFail(method, targetType, \"value type not coercible\");\n+    }\n+\n+    // @since 3.0\n     protected <T> T _reportCoercionFail(String method, Class<?> targetType,\n             String message)\n+    {\n+        throw JsonNodeException.from(this, \"'%s' method `%s` cannot coerce value %s to %s: %s\",\n+                getClass().getSimpleName(), method,\n+                _valueDesc(), ClassUtil.nameOf(targetType), message);\n+    }\n+\n+    // @since 3.1\n+    protected <T> T _reportConversionFail(String method, Class<?> targetType,\n+            String message)\n     {\n         throw JsonNodeException.from(this, \"'%s' method `%s` cannot convert value %s to %s: %s\",\n                 getClass().getSimpleName(), method,\n                 _valueDesc(), ClassUtil.nameOf(targetType), message);\n     }\n \n-    protected short _reportShortCoercionRangeFail(String method) {\n-        return _reportCoercionFail(method, Short.TYPE,\n+    // @since 3.1\n+    protected short _reportShortConversionRangeFail(String method) {\n+        return _reportConversionFail(method, Short.TYPE,\n             \"value not in 16-bit `short` range\");\n     }\n \n-    protected int _reportIntCoercionRangeFail(String method) {\n-        return _reportCoercionFail(method, Integer.TYPE,\n+    // @since 3.1\n+    protected int _reportIntConversionRangeFail(String method) {\n+        return _reportConversionFail(method, Integer.TYPE,\n             \"value not in 32-bit `int` range\");\n     }\n \n-    protected long _reportLongCoercionRangeFail(String method) {\n-        return _reportCoercionFail(method, Long.TYPE,\n+    // @since 3.1\n+    protected long _reportLongConversionRangeFail(String method) {\n+        return _reportConversionFail(method, Long.TYPE,\n             \"value not in 64-bit `long` range\");\n     }\n \n-    protected float _reportFloatCoercionRangeFail(String method) {\n-        return _reportCoercionFail(method, Float.TYPE,\n+    // @since 3.1\n+    protected float _reportFloatConversionRangeFail(String method) {\n+        return _reportConversionFail(method, Float.TYPE,\n             \"value not in 32-bit `float` range\");\n     }\n \n-    protected double _reportDoubleCoercionRangeFail(String method) {\n-        return _reportCoercionFail(method, Double.TYPE,\n+    // @since 3.1\n+    protected double _reportDoubleConversionRangeFail(String method) {\n+        return _reportConversionFail(method, Double.TYPE,\n             \"value not in 64-bit `double` range\");\n     }\n \n-    protected short _reportShortCoercionFractionFail(String method) {\n-        return _reportCoercionFail(method, Short.TYPE,\n+    // @since 3.1\n+    protected short _reportShortConversionFractionFail(String method) {\n+        return _reportConversionFail(method, Short.TYPE,\n                 \"value has fractional part\");\n     }\n \n-    protected int _reportIntCoercionFractionFail(String method) {\n-        return _reportCoercionFail(method, Integer.TYPE,\n+    // @since 3.1\n+    protected int _reportIntConversionFractionFail(String method) {\n+        return _reportConversionFail(method, Integer.TYPE,\n                 \"value has fractional part\");\n     }\n \n-    protected long _reportLongCoercionFractionFail(String method) {\n-        return _reportCoercionFail(method, Long.TYPE,\n+    // @since 3.1\n+    protected long _reportLongConversionFractionFail(String method) {\n+        return _reportConversionFail(method, Long.TYPE,\n                 \"value has fractional part\");\n     }\n \n-    protected BigInteger _reportBigIntegerCoercionFractionFail(String method) {\n-        return _reportCoercionFail(method, BigInteger.class,\n+    // @since 3.1\n+    protected BigInteger _reportBigIntegerConversionFractionFail(String method) {\n+        return _reportConversionFail(method, BigInteger.class,\n                 \"value has fractional part\");\n     }\n \n-    protected int _reportIntCoercionNaNFail(String method) {\n-        return _reportCoercionFail(method, Integer.TYPE,\n+    // @since 3.1\n+    protected int _reportIntConversionNaNFail(String method) {\n+        return _reportConversionFail(method, Integer.TYPE,\n                 \"value non-Finite ('NaN')\");\n     }\n \n-    protected long _reportLongCoercionNaNFail(String method) {\n-        return _reportCoercionFail(method, Long.TYPE,\n+    // @since 3.1\n+    protected long _reportLongConversionNaNFail(String method) {\n+        return _reportConversionFail(method, Long.TYPE,\n                 \"value non-Finite ('NaN')\");\n     }\n \n-    protected BigInteger _reportBigIntegerCoercionNaNFail(String method) {\n-        return _reportCoercionFail(method, BigInteger.class,\n+    // @since 3.1\n+    protected BigInteger _reportBigIntegerConversionNaNFail(String method) {\n+        return _reportConversionFail(method, BigInteger.class,\n                 \"value non-Finite ('NaN')\");\n     }\n-    \n-    protected BigDecimal _reportBigDecimalCoercionNaNFail(String method) {\n-        return _reportCoercionFail(method, BigDecimal.class,\n+\n+    // @since 3.1\n+    protected BigDecimal _reportBigDecimalConversionNaNFail(String method) {\n+        return _reportConversionFail(method, BigDecimal.class,\n                 \"value non-Finite ('NaN')\");\n     }\n \ndiff --git a/src/main/java/tools/jackson/databind/node/BigIntegerNode.java b/src/main/java/tools/jackson/databind/node/BigIntegerNode.java\nindex 34aced0b57..6d76435a72 100644\n--- a/src/main/java/tools/jackson/databind/node/BigIntegerNode.java\n+++ b/src/main/java/tools/jackson/databind/node/BigIntegerNode.java\n@@ -72,7 +72,7 @@ public short shortValue() {\n         if (inShortRange()) {\n             return _value.shortValue();\n         }\n-        return _reportShortCoercionRangeFail(\"shortValue()\");\n+        return _reportShortConversionRangeFail(\"shortValue()\");\n     }\n \n     @Override\n@@ -90,7 +90,7 @@ public short asShort() {\n         if (inShortRange()) {\n             return _value.shortValue();\n         }\n-        return _reportShortCoercionRangeFail(\"asShort()\");\n+        return _reportShortConversionRangeFail(\"asShort()\");\n     }\n \n     @Override\n@@ -108,7 +108,7 @@ public int intValue() {\n         if (inIntRange()) {\n             return _value.intValue();\n         }\n-        return _reportIntCoercionRangeFail(\"intValue()\");\n+        return _reportIntConversionRangeFail(\"intValue()\");\n     }\n \n     @Override\n@@ -126,7 +126,7 @@ public int asInt() {\n         if (inIntRange()) {\n             return _value.intValue();\n         }\n-        return _reportIntCoercionRangeFail(\"asInt()\");\n+        return _reportIntConversionRangeFail(\"asInt()\");\n     }\n \n     @Override\n@@ -144,7 +144,7 @@ public long longValue() {\n         if (canConvertToLong()) {\n             return _value.longValue();\n         }\n-        return _reportLongCoercionRangeFail(\"longValue()\");\n+        return _reportLongConversionRangeFail(\"longValue()\");\n     }\n \n     @Override\n@@ -162,7 +162,7 @@ public long asLong() {\n         if (canConvertToLong()) {\n             return _value.longValue();\n         }\n-        return _reportLongCoercionRangeFail(\"asLong()\");\n+        return _reportLongConversionRangeFail(\"asLong()\");\n     }\n \n     @Override\n@@ -194,7 +194,7 @@ public float floatValue() {\n         if (Float.isFinite(f)) {\n             return f;\n         }\n-        return _reportFloatCoercionRangeFail(\"floatValue()\");\n+        return _reportFloatConversionRangeFail(\"floatValue()\");\n     }\n \n     @Override\n@@ -218,7 +218,7 @@ public float asFloat() {\n         if (Float.isFinite(f)) {\n             return f;\n         }\n-        return _reportFloatCoercionRangeFail(\"asFloat()\");\n+        return _reportFloatConversionRangeFail(\"asFloat()\");\n     }\n \n     @Override\n@@ -242,7 +242,7 @@ public double doubleValue() {\n         if (Double.isFinite(d)) {\n             return d;\n         }\n-        return _reportDoubleCoercionRangeFail(\"doubleValue()\");\n+        return _reportDoubleConversionRangeFail(\"doubleValue()\");\n     }\n \n     @Override\n@@ -266,7 +266,7 @@ public double asDouble() {\n         if (Double.isFinite(d)) {\n             return d;\n         }\n-        return _reportDoubleCoercionRangeFail(\"asDouble()\");\n+        return _reportDoubleConversionRangeFail(\"asDouble()\");\n     }\n \n     @Override\ndiff --git a/src/main/java/tools/jackson/databind/node/DecimalNode.java b/src/main/java/tools/jackson/databind/node/DecimalNode.java\nindex a2ab1f834d..4c0e48d886 100644\n--- a/src/main/java/tools/jackson/databind/node/DecimalNode.java\n+++ b/src/main/java/tools/jackson/databind/node/DecimalNode.java\n@@ -77,7 +77,7 @@ public float floatValue() {\n         if (Float.isFinite(f)) {\n             return f;\n         }\n-        return _reportFloatCoercionRangeFail(\"floatValue()\");\n+        return _reportFloatConversionRangeFail(\"floatValue()\");\n     }\n \n     @Override\n@@ -104,7 +104,7 @@ public float asFloat() {\n         if (Float.isFinite(f)) {\n             return f;\n         }\n-        return _reportFloatCoercionRangeFail(\"asFloat()\");\n+        return _reportFloatConversionRangeFail(\"asFloat()\");\n     }\n \n     @Override\n@@ -131,7 +131,7 @@ public double doubleValue() {\n         if (Double.isFinite(d)) {\n             return d;\n         }\n-        return _reportDoubleCoercionRangeFail(\"doubleValue()\");\n+        return _reportDoubleConversionRangeFail(\"doubleValue()\");\n     }\n \n     @Override\n@@ -158,7 +158,7 @@ public double asDouble() {\n         if (Double.isFinite(d)) {\n             return d;\n         }\n-        return _reportDoubleCoercionRangeFail(\"asDouble()\");\n+        return _reportDoubleConversionRangeFail(\"asDouble()\");\n     }\n \n     @Override\ndiff --git a/src/main/java/tools/jackson/databind/node/DoubleNode.java b/src/main/java/tools/jackson/databind/node/DoubleNode.java\nindex 73ef713866..138cb4a510 100644\n--- a/src/main/java/tools/jackson/databind/node/DoubleNode.java\n+++ b/src/main/java/tools/jackson/databind/node/DoubleNode.java\n@@ -75,7 +75,7 @@ public float floatValue() {\n         if (Float.isFinite(f)) {\n             return f;\n         }\n-        return _reportFloatCoercionRangeFail(\"floatValue()\");\n+        return _reportFloatConversionRangeFail(\"floatValue()\");\n     }\n \n     @Override\n@@ -102,7 +102,7 @@ public float asFloat() {\n         if (Float.isFinite(f)) {\n             return f;\n         }\n-        return _reportFloatCoercionRangeFail(\"asFloat()\");\n+        return _reportFloatConversionRangeFail(\"asFloat()\");\n     }\n \n     @Override\ndiff --git a/src/main/java/tools/jackson/databind/node/IntNode.java b/src/main/java/tools/jackson/databind/node/IntNode.java\nindex e6f36d2ca2..b08bc97a78 100644\n--- a/src/main/java/tools/jackson/databind/node/IntNode.java\n+++ b/src/main/java/tools/jackson/databind/node/IntNode.java\n@@ -87,7 +87,7 @@ public short shortValue() {\n         if (inShortRange()) {\n             return (short) _value;\n         }\n-        return _reportShortCoercionRangeFail(\"shortValue()\");\n+        return _reportShortConversionRangeFail(\"shortValue()\");\n     }\n \n     @Override\n@@ -105,7 +105,7 @@ public short asShort() {\n         if (inShortRange()) {\n             return (short) _value;\n         }\n-        return _reportShortCoercionRangeFail(\"asShort()\");\n+        return _reportShortConversionRangeFail(\"asShort()\");\n     }\n \n     @Override\ndiff --git a/src/main/java/tools/jackson/databind/node/LongNode.java b/src/main/java/tools/jackson/databind/node/LongNode.java\nindex 4f3919adcc..7966c609e7 100644\n--- a/src/main/java/tools/jackson/databind/node/LongNode.java\n+++ b/src/main/java/tools/jackson/databind/node/LongNode.java\n@@ -67,7 +67,7 @@ public short shortValue() {\n         if (inShortRange()) {\n             return (short) _value;\n         }\n-        return _reportShortCoercionRangeFail(\"shortValue()\");\n+        return _reportShortConversionRangeFail(\"shortValue()\");\n     }\n \n     @Override\n@@ -85,7 +85,7 @@ public short asShort() {\n         if (inShortRange()) {\n             return (short) _value;\n         }\n-        return _reportShortCoercionRangeFail(\"asShort()\");\n+        return _reportShortConversionRangeFail(\"asShort()\");\n     }\n \n     @Override\n@@ -103,7 +103,7 @@ public int intValue() {\n         if (inIntRange()) {\n             return (int) _value;\n         }\n-        return _reportIntCoercionRangeFail(\"intValue()\");\n+        return _reportIntConversionRangeFail(\"intValue()\");\n     }\n \n     @Override\n@@ -121,7 +121,7 @@ public int asInt() {\n         if (inIntRange()) {\n             return (int) _value;\n         }\n-        return _reportIntCoercionRangeFail(\"asInt()\");\n+        return _reportIntConversionRangeFail(\"asInt()\");\n     }\n \n     @Override\ndiff --git a/src/main/java/tools/jackson/databind/node/NumericFPNode.java b/src/main/java/tools/jackson/databind/node/NumericFPNode.java\nindex dca30a916f..792268841c 100644\n--- a/src/main/java/tools/jackson/databind/node/NumericFPNode.java\n+++ b/src/main/java/tools/jackson/databind/node/NumericFPNode.java\n@@ -61,12 +61,12 @@ public final boolean canConvertToExactIntegral() {\n     public final short shortValue() {\n         if (!inShortRange()) {\n             if (isNaN()) {\n-                _reportIntCoercionNaNFail(\"shortValue()\");\n+                _reportIntConversionNaNFail(\"shortValue()\");\n             }\n-            return _reportShortCoercionRangeFail(\"shortValue()\");\n+            return _reportShortConversionRangeFail(\"shortValue()\");\n         }\n         if (hasFractionalPart()) {\n-            _reportShortCoercionFractionFail(\"shortValue()\");\n+            _reportShortConversionFractionFail(\"shortValue()\");\n         }\n         return _asShortValueUnchecked();\n     }\n@@ -91,9 +91,9 @@ public final Optional<Short> shortValueOpt() {\n     public short asShort() {\n         if (!inShortRange()) {\n             if (isNaN()) {\n-                _reportIntCoercionNaNFail(\"asShort()\");\n+                _reportIntConversionNaNFail(\"asShort()\");\n             }\n-            return _reportShortCoercionRangeFail(\"asShort()\");\n+            return _reportShortConversionRangeFail(\"asShort()\");\n         }\n         return _asShortValueUnchecked();\n     }\n@@ -118,12 +118,12 @@ public Optional<Short> asShortOpt() {\n     public final int intValue() {\n         if (!inIntRange()) {\n             if (isNaN()) {\n-                _reportIntCoercionNaNFail(\"intValue()\");\n+                _reportIntConversionNaNFail(\"intValue()\");\n             }\n-            return _reportIntCoercionRangeFail(\"intValue()\");\n+            return _reportIntConversionRangeFail(\"intValue()\");\n         }\n         if (hasFractionalPart()) {\n-            _reportIntCoercionFractionFail(\"intValue()\");\n+            _reportIntConversionFractionFail(\"intValue()\");\n         }\n         return _asIntValueUnchecked();\n     }\n@@ -148,9 +148,9 @@ public final OptionalInt intValueOpt() {\n     public int asInt() {\n         if (!inIntRange()) {\n             if (isNaN()) {\n-                _reportIntCoercionNaNFail(\"asInt()\");\n+                _reportIntConversionNaNFail(\"asInt()\");\n             }\n-            return _reportIntCoercionRangeFail(\"asInt()\");\n+            return _reportIntConversionRangeFail(\"asInt()\");\n         }\n         return _asIntValueUnchecked();\n     }\n@@ -175,12 +175,12 @@ public OptionalInt asIntOpt() {\n     public final long longValue() {\n         if (!inLongRange()) {\n             if (isNaN()) {\n-                _reportLongCoercionNaNFail(\"longValue()\");\n+                _reportLongConversionNaNFail(\"longValue()\");\n             }\n-            return _reportLongCoercionRangeFail(\"longValue()\");\n+            return _reportLongConversionRangeFail(\"longValue()\");\n         }\n         if (hasFractionalPart()) {\n-            _reportLongCoercionFractionFail(\"longValue()\");\n+            _reportLongConversionFractionFail(\"longValue()\");\n         }\n         return _asLongValueUnchecked();\n     }\n@@ -205,9 +205,9 @@ public final OptionalLong longValueOpt() {\n     public final long asLong() {\n         if (!inLongRange()) {\n             if (isNaN()) {\n-                _reportLongCoercionNaNFail(\"asLong()\");\n+                _reportLongConversionNaNFail(\"asLong()\");\n             }\n-            return _reportLongCoercionRangeFail(\"asLong()\");\n+            return _reportLongConversionRangeFail(\"asLong()\");\n         }\n         return _asLongValueUnchecked();\n     }\n@@ -231,10 +231,10 @@ public final OptionalLong asLongOpt() {\n     @Override\n     public final BigInteger bigIntegerValue() {\n         if (isNaN()) {\n-            _reportBigIntegerCoercionNaNFail(\"bigIntegerValue()\");\n+            _reportBigIntegerConversionNaNFail(\"bigIntegerValue()\");\n         }\n         if (hasFractionalPart()) {\n-            _reportBigIntegerCoercionFractionFail(\"bigIntegerValue()\");\n+            _reportBigIntegerConversionFractionFail(\"bigIntegerValue()\");\n         }\n         return _asBigIntegerValueUnchecked();\n     }\n@@ -258,7 +258,7 @@ public final Optional<BigInteger> bigIntegerValueOpt() {\n     @Override\n     public final BigInteger asBigInteger() {\n         if (isNaN()) {\n-            _reportBigIntegerCoercionNaNFail(\"asBigInteger()\");\n+            _reportBigIntegerConversionNaNFail(\"asBigInteger()\");\n         }\n         return _asBigIntegerValueUnchecked();\n     }\n@@ -284,7 +284,7 @@ public final Optional<BigInteger> asBigIntegerOpt() {\n     @Override\n     public BigDecimal decimalValue() {\n         if (isNaN()) {\n-            _reportBigDecimalCoercionNaNFail(\"decimalValue()\");\n+            _reportBigDecimalConversionNaNFail(\"decimalValue()\");\n         }\n         return _asDecimalValueUnchecked();\n     }\n@@ -308,7 +308,7 @@ public Optional<BigDecimal> decimalValueOpt() {\n     @Override\n     public BigDecimal asDecimal() {\n         if (isNaN()) {\n-            _reportBigDecimalCoercionNaNFail(\"asDecimal()\");\n+            _reportBigDecimalConversionNaNFail(\"asDecimal()\");\n         }\n         return _asDecimalValueUnchecked();\n     }\ndiff --git a/src/main/java/tools/jackson/databind/node/POJONode.java b/src/main/java/tools/jackson/databind/node/POJONode.java\nindex 856c3a5a4f..4aefc34cf8 100644\n--- a/src/main/java/tools/jackson/databind/node/POJONode.java\n+++ b/src/main/java/tools/jackson/databind/node/POJONode.java\n@@ -117,7 +117,7 @@ public short asShort() {\n         Long L = _extractAsLong();\n         if (L == null || L < Short.MIN_VALUE || L > Short.MAX_VALUE) {\n             // report range fail\n-            _reportShortCoercionRangeFail(\"asShort()\");\n+            _reportShortConversionRangeFail(\"asShort()\");\n         }\n         return L.shortValue();\n     }\n@@ -181,7 +181,7 @@ public int asInt() {\n         Long L = _extractAsLong();\n         if (L == null || L < Integer.MIN_VALUE || L > Integer.MAX_VALUE) {\n             // report range fail\n-            _reportIntCoercionRangeFail(\"asInt()\");\n+            _reportIntConversionRangeFail(\"asInt()\");\n         }\n         return L.intValue();\n     }\n@@ -245,7 +245,7 @@ public long asLong() {\n         Long L = _extractAsLong();\n         if (L == null) {\n             // report range fail\n-            _reportLongCoercionRangeFail(\"asLong()\");\n+            _reportLongConversionRangeFail(\"asLong()\");\n         }\n         return L;\n     }\n@@ -360,7 +360,7 @@ public float asFloat() {\n         Float F = _extractAsFloat();\n         if (F == null) {\n             // report range fail\n-            _reportFloatCoercionRangeFail(\"asFloat()\");\n+            _reportFloatConversionRangeFail(\"asFloat()\");\n         }\n         return F;\n     }\n@@ -424,7 +424,7 @@ public double asDouble() {\n         Double D = _extractAsDouble();\n         if (D == null) {\n             // report range fail\n-            _reportDoubleCoercionRangeFail(\"asDouble()\");\n+            _reportDoubleConversionRangeFail(\"asDouble()\");\n         }\n         return D;\n     }\n",
  "test_patch" : "diff --git a/src/test/java/tools/jackson/databind/deser/jdk/Base64DecodingTest.java b/src/test/java/tools/jackson/databind/deser/jdk/Base64DecodingTest.java\nindex fc8b15c5d3..2fb7178a31 100644\n--- a/src/test/java/tools/jackson/databind/deser/jdk/Base64DecodingTest.java\n+++ b/src/test/java/tools/jackson/databind/deser/jdk/Base64DecodingTest.java\n@@ -53,7 +53,7 @@ private void _testInvalidBase64(ObjectMapper mapper, String value) throws Except\n             /*byte[] b =*/ nodeValue.binaryValue();\n             fail(\"Should not pass\");\n         } catch (JsonNodeException e) {\n-            verifyException(e, \"method `binaryValue()` cannot convert value\");\n+            verifyException(e, \"method `binaryValue()` cannot coerce value\");\n             verifyException(e, \"Illegal character '!'\");\n         }\n     }\ndiff --git a/src/test/java/tools/jackson/databind/node/JsonNodeBigIntegerValueTest.java b/src/test/java/tools/jackson/databind/node/JsonNodeBigIntegerValueTest.java\nindex 38742462ba..477d1d64ce 100644\n--- a/src/test/java/tools/jackson/databind/node/JsonNodeBigIntegerValueTest.java\n+++ b/src/test/java/tools/jackson/databind/node/JsonNodeBigIntegerValueTest.java\n@@ -223,7 +223,7 @@ private void _assertFailBigIntegerForNonNumber(JsonNode node) {\n                 () ->  node.bigIntegerValue(),\n                 \"For (\"+node.getClass().getSimpleName()+\") value: \"+node);\n         assertThat(e.getMessage())\n-            .contains(\"cannot convert value\")\n+            .contains(\"cannot coerce value\")\n             .contains(\"value type not numeric\");\n \n         // Verify default value handling\n@@ -261,7 +261,7 @@ private void _assertAsBigIntegerFailForNonNumber(JsonNode node, String extraMsg)\n                 () ->  node.asBigInteger(),\n                 \"For (\"+node.getClass().getSimpleName()+\") value: \"+node);\n         assertThat(e.getMessage())\n-            .contains(\"cannot convert value\");\n+            .contains(\"cannot coerce value\");\n \n         // Verify default value handling\n         assertEquals(BigInteger.ONE, node.asBigInteger(BigInteger.ONE));\ndiff --git a/src/test/java/tools/jackson/databind/node/JsonNodeBooleanValueTest.java b/src/test/java/tools/jackson/databind/node/JsonNodeBooleanValueTest.java\nindex 692fa574a0..96f3183f8c 100644\n--- a/src/test/java/tools/jackson/databind/node/JsonNodeBooleanValueTest.java\n+++ b/src/test/java/tools/jackson/databind/node/JsonNodeBooleanValueTest.java\n@@ -190,8 +190,8 @@ private void _assertFailAsBooleanForNonBoolean(JsonNode node) {\n                 () ->  node.asBoolean(),\n                 \"For (\"+node.getClass().getSimpleName()+\") value: \"+node);\n         assertThat(e.getMessage())\n-            .contains(\"cannot convert value\")\n-            .contains(\"value type not coercible to `boolean`\");\n+            .contains(\"cannot coerce value\")\n+            .contains(\"value type not coercible\");\n \n         // But also check defaulting\n         assertFalse(node.asBoolean(false));\ndiff --git a/src/test/java/tools/jackson/databind/node/JsonNodeDecimalValueTest.java b/src/test/java/tools/jackson/databind/node/JsonNodeDecimalValueTest.java\nindex 8f3e2f9855..93484f624b 100644\n--- a/src/test/java/tools/jackson/databind/node/JsonNodeDecimalValueTest.java\n+++ b/src/test/java/tools/jackson/databind/node/JsonNodeDecimalValueTest.java\n@@ -245,7 +245,7 @@ private void _assertFailDecimalValueForNonNumber(JsonNode node) {\n                 \"For (\"+node.getClass().getSimpleName()+\") value: \"+node);\n         assertThat(e.getMessage())\n             .contains(\"decimalValue()\")\n-            .contains(\"cannot convert value\")\n+            .contains(\"cannot coerce value\")\n             .contains(\"value type not numeric\");\n \n         // Verify default value handling\n@@ -268,7 +268,7 @@ private void _assertFailDecimalValueForNaN(JsonNode node) {\n     }\n \n     private void _assertFailAsDecimalForNonNumber(JsonNode node) {\n-        _assertFailAsDecimal(node, \"value type not coercible to `BigDecimal`\");\n+        _assertFailAsDecimal(node, \"value type not coercible\");\n     }\n \n     private void _assertFailAsDecimal(JsonNode node, String extraFailMsg) {\n@@ -277,7 +277,7 @@ private void _assertFailAsDecimal(JsonNode node, String extraFailMsg) {\n                 \"For (\"+node.getClass().getSimpleName()+\") value: \"+node);\n         assertThat(e.getMessage())\n             .contains(\"asDecimal()\")\n-            .contains(\"cannot convert value\")\n+            .contains(\"cannot coerce value\")\n             .contains(extraFailMsg);\n \n         // Verify default value handling\ndiff --git a/src/test/java/tools/jackson/databind/node/JsonNodeDoubleValueTest.java b/src/test/java/tools/jackson/databind/node/JsonNodeDoubleValueTest.java\nindex 578d0d5e11..876aadf555 100644\n--- a/src/test/java/tools/jackson/databind/node/JsonNodeDoubleValueTest.java\n+++ b/src/test/java/tools/jackson/databind/node/JsonNodeDoubleValueTest.java\n@@ -265,7 +265,7 @@ private void _assertDoubleValueFailForNonNumber(JsonNode node) {\n                 () ->  node.doubleValue(),\n                 \"For (\"+node.getClass().getSimpleName()+\") value: \"+node);\n         assertThat(e.getMessage())\n-            .contains(\"cannot convert value\")\n+            .contains(\"cannot coerce value\")\n             .contains(\"value type not numeric\");\n \n         assertEquals(1.5d, node.doubleValue(1.5d));\n@@ -294,7 +294,7 @@ private void _assertAsDoubleFailForValueRange(JsonNode node) {\n     }\n \n     private void _assertAsDoubleFailForNonNumber(JsonNode node) {\n-        _assertAsDoubleFailForNonNumber(node, \"value type not numeric\");\n+        _assertAsDoubleFailForNonNumber(node, \"value type not coercible\");\n     }\n \n     private void _assertAsDoubleFailForNonNumber(JsonNode node, String extraMatch) {\n@@ -303,7 +303,7 @@ private void _assertAsDoubleFailForNonNumber(JsonNode node, String extraMatch) {\n                 \"For (\"+node.getClass().getSimpleName()+\") value: \"+node);\n         assertThat(e.getMessage())\n             .contains(\"asDouble()\")\n-            .contains(\"cannot convert value\")\n+            .contains(\"cannot coerce value\")\n             .contains(extraMatch);\n \n         assertEquals(1.5d, node.asDouble(1.5d));\ndiff --git a/src/test/java/tools/jackson/databind/node/JsonNodeFloatValueTest.java b/src/test/java/tools/jackson/databind/node/JsonNodeFloatValueTest.java\nindex d8e62941b7..bf73afcafa 100644\n--- a/src/test/java/tools/jackson/databind/node/JsonNodeFloatValueTest.java\n+++ b/src/test/java/tools/jackson/databind/node/JsonNodeFloatValueTest.java\n@@ -267,7 +267,7 @@ private void _assertFailFloatForNonNumber(JsonNode node) {\n                 () ->  node.floatValue(),\n                 \"For (\"+node.getClass().getSimpleName()+\") value: \"+node);\n         assertThat(e.getMessage())\n-            .contains(\"cannot convert value\")\n+            .contains(\"cannot coerce value\")\n             .contains(\"value type not numeric\");\n \n         assertEquals(-2.25f, node.floatValue(-2.25f));\n@@ -296,7 +296,7 @@ private void _assertAsFloatFailForValueRange(JsonNode node) {\n     }\n \n     private void _assertAsFloatFailForNonNumber(JsonNode node) {\n-        _assertAsFloatFailForNonNumber(node, \"value type not numeric\");\n+        _assertAsFloatFailForNonNumber(node, \"value type not coercible\");\n     }\n \n     private void _assertAsFloatFailForNonNumber(JsonNode node, String extraMatch) {\n@@ -305,7 +305,7 @@ private void _assertAsFloatFailForNonNumber(JsonNode node, String extraMatch) {\n                 \"For (\"+node.getClass().getSimpleName()+\") value: \"+node);\n         assertThat(e.getMessage())\n                 .contains(\"asFloat()\")\n-                .contains(\"cannot convert value\")\n+                .contains(\"cannot coerce value\")\n                 .contains(extraMatch);\n \n         assertEquals(1.5f, node.asFloat(1.5f));\ndiff --git a/src/test/java/tools/jackson/databind/node/JsonNodeIntValueTest.java b/src/test/java/tools/jackson/databind/node/JsonNodeIntValueTest.java\nindex 66f9875d6d..6cbfb9f0f7 100644\n--- a/src/test/java/tools/jackson/databind/node/JsonNodeIntValueTest.java\n+++ b/src/test/java/tools/jackson/databind/node/JsonNodeIntValueTest.java\n@@ -351,7 +351,7 @@ private void _assertIntValueFailForNonNumber(JsonNode node) {\n                 \"For (\"+node.getClass().getSimpleName()+\") value: \"+node);\n         assertThat(e.getMessage())\n             .contains(\"intValue()\")\n-            .contains(\"cannot convert value\")\n+            .contains(\"cannot coerce value\")\n             .contains(\"value type not numeric\");\n \n         // assert defaulting\n@@ -399,7 +399,7 @@ private void _assertAsIntFailForValueRange(JsonNode node) {\n     }\n \n     private void _assertAsIntFailForNonNumber(JsonNode node) {\n-        _assertAsIntFailForNonNumber(node, \"value type not numeric\");\n+        _assertAsIntFailForNonNumber(node, \"value type not coercible\");\n     }\n \n     private void _assertAsIntFailForNonNumber(JsonNode node, String extraFailMsg) {\n@@ -408,7 +408,7 @@ private void _assertAsIntFailForNonNumber(JsonNode node, String extraFailMsg) {\n                 \"For (\"+node.getClass().getSimpleName()+\") value: \"+node);\n         assertThat(e.getMessage())\n             .contains(\"asInt()\")\n-            .contains(\"cannot convert value\")\n+            .contains(\"cannot coerce value\")\n             .contains(extraFailMsg);\n \n         // assert defaulting\ndiff --git a/src/test/java/tools/jackson/databind/node/JsonNodeLongValueTest.java b/src/test/java/tools/jackson/databind/node/JsonNodeLongValueTest.java\nindex 1d948e03f0..f041c99878 100644\n--- a/src/test/java/tools/jackson/databind/node/JsonNodeLongValueTest.java\n+++ b/src/test/java/tools/jackson/databind/node/JsonNodeLongValueTest.java\n@@ -346,7 +346,7 @@ private void _assertLongValueFailForNonNumber(JsonNode node) {\n                 \"For (\"+node.getClass().getSimpleName()+\") value: \"+node);\n         assertThat(e.getMessage())\n             .contains(\"longValue()\")\n-            .contains(\"cannot convert value\")\n+            .contains(\"cannot coerce value\")\n             .contains(\"value type not numeric\");\n \n         // Verify default value handling\n@@ -394,7 +394,7 @@ private void _assertAsLongFailForValueRange(JsonNode node) {\n     }\n \n     private void _assertAsLongFailForNonNumber(JsonNode node) {\n-        _assertAsLongFailForNonNumber(node, \"value type not numeric\");\n+        _assertAsLongFailForNonNumber(node, \"value type not coercible\");\n     }\n \n     private void _assertAsLongFailForNonNumber(JsonNode node, String extraMsg) {\n@@ -403,7 +403,7 @@ private void _assertAsLongFailForNonNumber(JsonNode node, String extraMsg) {\n                 \"For (\"+node.getClass().getSimpleName()+\") value: \"+node);\n         assertThat(e.getMessage())\n             .contains(\"asLong()\")\n-            .contains(\"cannot convert value\")\n+            .contains(\"cannot coerce value\")\n             .contains(extraMsg);\n \n         // Verify default value handling\ndiff --git a/src/test/java/tools/jackson/databind/node/JsonNodeNumberValueTest.java b/src/test/java/tools/jackson/databind/node/JsonNodeNumberValueTest.java\nindex ff4ca11eca..f171e8c983 100644\n--- a/src/test/java/tools/jackson/databind/node/JsonNodeNumberValueTest.java\n+++ b/src/test/java/tools/jackson/databind/node/JsonNodeNumberValueTest.java\n@@ -69,7 +69,7 @@ private void _assertFailForNonNumber(JsonNode node) {\n                 () ->  node.intValue(),\n                 \"For (\"+node.getClass().getSimpleName()+\") value: \"+node);\n         assertThat(e.getMessage())\n-            .contains(\"cannot convert value\")\n+            .contains(\"cannot coerce value\")\n             .contains(\"value type not numeric\");\n     }\n }\ndiff --git a/src/test/java/tools/jackson/databind/node/JsonNodeShortValueTest.java b/src/test/java/tools/jackson/databind/node/JsonNodeShortValueTest.java\nindex 4489fa08c1..9628d330ae 100644\n--- a/src/test/java/tools/jackson/databind/node/JsonNodeShortValueTest.java\n+++ b/src/test/java/tools/jackson/databind/node/JsonNodeShortValueTest.java\n@@ -331,7 +331,7 @@ private void _assertFailShortForNonNumber(JsonNode node) {\n                 () ->  node.shortValue(),\n                 \"For (\"+node.getClass().getSimpleName()+\") value: \"+node);\n         assertThat(e.getMessage())\n-            .contains(\"cannot convert value\")\n+            .contains(\"cannot coerce value\")\n             .contains(\"value type not numeric\");\n \n         // assert defaulting\n@@ -364,7 +364,7 @@ private void _assertAsShortFailForValueRange(JsonNode node) {\n     }\n \n     private void _assertAsShortFailForNonNumber(JsonNode node) {\n-        _assertAsShortFailForNonNumber(node, \"value type not numeric\");\n+        _assertAsShortFailForNonNumber(node, \"value type not coercible\");\n     }\n \n     private void _assertAsShortFailForNonNumber(JsonNode node, String extraFailMsg) {\n@@ -373,7 +373,7 @@ private void _assertAsShortFailForNonNumber(JsonNode node, String extraFailMsg)\n                 \"For (\"+node.getClass().getSimpleName()+\") value: \"+node);\n         assertThat(e.getMessage())\n                 .contains(\"asShort()\")\n-                .contains(\"cannot convert value\")\n+                .contains(\"cannot coerce value\")\n                 .contains(extraFailMsg);\n \n         // assert defaulting\ndiff --git a/src/test/java/tools/jackson/databind/node/JsonNodeStringValueTest.java b/src/test/java/tools/jackson/databind/node/JsonNodeStringValueTest.java\nindex 7d6e40f4ce..cc8c7dce2b 100644\n--- a/src/test/java/tools/jackson/databind/node/JsonNodeStringValueTest.java\n+++ b/src/test/java/tools/jackson/databind/node/JsonNodeStringValueTest.java\n@@ -156,8 +156,8 @@ private void _assertAsStringFailForNonString(JsonNode node) {\n                 () ->  node.asString(),\n                 \"For (\"+node.getClass().getSimpleName()+\") value: \"+node);\n         assertThat(e.getMessage())\n-            .contains(\"cannot convert value\")\n-            .contains(\"value type not coercible to `String`\");\n+            .contains(\"cannot coerce value\")\n+            .contains(\"value type not coercible\");\n \n         // But also check defaulting\n         assertEquals(\"foo\", node.asString(\"foo\"));\ndiff --git a/src/test/java/tools/jackson/databind/node/TreeTraversingParserTest.java b/src/test/java/tools/jackson/databind/node/TreeTraversingParserTest.java\nindex 15743f4441..af44ab3d94 100644\n--- a/src/test/java/tools/jackson/databind/node/TreeTraversingParserTest.java\n+++ b/src/test/java/tools/jackson/databind/node/TreeTraversingParserTest.java\n@@ -241,7 +241,7 @@ public void testTextAsBinary() throws Exception\n         try {\n             p.getBinaryValue();\n         } catch (JsonNodeException e) {\n-            verifyException(e, \"method `binaryValue()` cannot convert value\");\n+            verifyException(e, \"method `binaryValue()` cannot coerce value\");\n             verifyException(e, \"Illegal character\");\n         }\n         p.close();\n",
  "problem_statement" : "JsonNode changes to improve conversion vs coercion exception messages\n\nIntent is/was that:\r\n\r\n* Conversion refers to changes within similar types (mostly numbers), like `int` to `double` (or vice versa)\r\n* Coercion refers to force type change like JSON String \"true\" to `Boolean.TRUE`.\r\n\r\nso this PR tackles that aspect. Also attempts to streamline usage slightly.\r\n\r\nActual conversion/coercion rules are NOT to change in this PR.",
  "hints_text" : null,
  "created_at" : "Wed Jan 14 03:03:24 CET 2026",
  "version" : null,
  "FAIL_TO_PASS" : [ "JsonNodeLongValueTest", "JsonNodeDecimalValueTest", "JsonNodeFloatValueTest", "JsonNodeIntValueTest", "JsonNodeNumberValueTest", "JsonNodeStringValueTest", "JsonNodeDoubleValueTest", "TreeTraversingParserTest", "JsonNodeBigIntegerValueTest", "Base64DecodingTest", "JsonNodeShortValueTest", "JsonNodeBooleanValueTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=JsonNodeLongValueTest,JsonNodeDecimalValueTest,JsonNodeFloatValueTest,JsonNodeIntValueTest,JsonNodeNumberValueTest,JsonNodeStringValueTest,JsonNodeDoubleValueTest,TreeTraversingParserTest,JsonNodeBigIntegerValueTest,Base64DecodingTest,JsonNodeShortValueTest,JsonNodeBooleanValueTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 5577,
  "metadata" : null
} ]