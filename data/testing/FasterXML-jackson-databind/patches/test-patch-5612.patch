diff --git a/src/test/java/tools/jackson/databind/ext/javatime/deser/MonthDeserializerTest.java b/src/test/java/tools/jackson/databind/ext/javatime/deser/MonthDeserializerTest.java
index 22720e36be..3db218abe1 100644
--- a/src/test/java/tools/jackson/databind/ext/javatime/deser/MonthDeserializerTest.java
+++ b/src/test/java/tools/jackson/databind/ext/javatime/deser/MonthDeserializerTest.java
@@ -1,6 +1,7 @@
 package tools.jackson.databind.ext.javatime.deser;
 
 import java.time.Month;
+import java.time.format.DateTimeFormatter;
 import java.time.temporal.TemporalAccessor;
 
 import org.junit.jupiter.api.function.Executable;
@@ -8,7 +9,12 @@
 import org.junit.jupiter.params.ParameterizedTest;
 import org.junit.jupiter.params.provider.CsvSource;
 import org.junit.jupiter.params.provider.EnumSource;
+import org.junit.jupiter.params.provider.ValueSource;
 
+import com.fasterxml.jackson.annotation.JsonFormat;
+import com.fasterxml.jackson.annotation.OptBoolean;
+
+import tools.jackson.databind.DeserializationFeature;
 import tools.jackson.databind.MapperFeature;
 import tools.jackson.databind.ObjectMapper;
 import tools.jackson.databind.ObjectReader;
@@ -32,6 +38,11 @@ static class Wrapper {
         public Wrapper() { }
     }
 
+    static class WrapperWithFormat {
+        @JsonFormat(pattern = "MMM", locale = "en")
+        public Month value;
+    }
+
     @ParameterizedTest
     @EnumSource(Month.class)
     public void testDeserializationAsString01_oneBased(Month expectedMonth) throws Exception
@@ -65,11 +76,11 @@ public void testDeserializationAsString02_zeroBased(Month month) throws Exceptio
 
     @ParameterizedTest
     @CsvSource({
-            "notamonth , 'Cannot deserialize value of type `java.time.Month` from String \"notamonth\": not one of the values accepted for Enum class:'",
-            "JANUAR    , 'Cannot deserialize value of type `java.time.Month` from String \"JANUAR\": not one of the values accepted for Enum class:'",
-            "march     , 'Cannot deserialize value of type `java.time.Month` from String \"march\": not one of the values accepted for Enum class:'",
-            "0         , 'Month number 0 not allowed for 1-based Month.'",
-            "13        , 'Month number 13 not allowed for 1-based Month.'",
+            "notamonth , 'Cannot deserialize value of type `java.time.Month` from String \"notamonth\": not one of known `Month` values:'",
+            "JANUAR    , 'Cannot deserialize value of type `java.time.Month` from String \"JANUAR\": not one of known `Month` values:'",
+            "march     , 'Cannot deserialize value of type `java.time.Month` from String \"march\": not one of known `Month` values:'",
+            "0         , 'month number outside 1-12'",
+            "13        , 'month number outside 1-12'",
     })
     public void testBadDeserializationAsString01_oneBased(String monthSpec, String expectedMessage) {
         String value = "\"" + monthSpec + '"';
@@ -197,6 +208,334 @@ public void testDeserializeFromEmptyString() throws Exception
         assertNull(m);
     }
 
+    /*
+    /**********************************************************************
+    /* Tests for numeric int input (VALUE_NUMBER_INT)
+    /**********************************************************************
+     */
+
+    @ParameterizedTest
+    @EnumSource(Month.class)
+    public void testDeserializationAsInt_zeroBased(Month expectedMonth) throws Exception
+    {
+        int monthIndex = expectedMonth.ordinal();
+        assertEquals(expectedMonth, readerForZeroBased().readValue(String.valueOf(monthIndex)));
+    }
+
+    @ParameterizedTest
+    @EnumSource(Month.class)
+    public void testDeserializationAsInt_oneBased(Month expectedMonth) throws Exception
+    {
+        int monthNum = expectedMonth.getValue();
+        assertEquals(expectedMonth, readerForOneBased().readValue(String.valueOf(monthNum)));
+    }
+
+    @ParameterizedTest
+    @ValueSource(ints = {-1, 12, 13, 100})
+    public void testDeserializationAsIntOutOfRange_zeroBased(int invalidValue) throws Exception
+    {
+        assertError(
+            () -> readerForZeroBased().readValue(String.valueOf(invalidValue)),
+            MismatchedInputException.class,
+            "month number outside 0-11 range"
+        );
+    }
+
+    @ParameterizedTest
+    @ValueSource(ints = {0, -1, 13, 100})
+    public void testDeserializationAsIntOutOfRange_oneBased(int invalidValue) throws Exception
+    {
+        assertError(
+            () -> readerForOneBased().readValue(String.valueOf(invalidValue)),
+            MismatchedInputException.class,
+            "month number outside 1-12 range"
+        );
+    }
+
+    /*
+    /**********************************************************************
+    /* Tests for array handling
+    /**********************************************************************
+     */
+
+    @Test
+    public void testDeserializationAsEmptyArray() throws Exception
+    {
+        // Empty array returns null
+        Month result = readerForOneBased().readValue("[]");
+        assertNull(result);
+    }
+
+    @Test
+    public void testDeserializationAsArrayWithIntValue() throws Exception
+    {
+        // Array with single int value (interpreted as 1-based month)
+        Month result = readerForOneBased().readValue("[3]");
+        assertEquals(Month.MARCH, result);
+    }
+
+    @Test
+    public void testDeserializationAsArrayWithIntValue_zeroBased() throws Exception
+    {
+        // Array with single int value (0-based mode still uses Month.of for array)
+        Month result = readerForZeroBased().readValue("[3]");
+        assertEquals(Month.MARCH, result);
+    }
+
+    @Test
+    public void testDeserializationAsArrayWithMoreThanOneElement() throws Exception
+    {
+        assertError(
+            () -> readerForOneBased().readValue("[1, 2]"),
+            MismatchedInputException.class,
+            "Expected array to end"
+        );
+    }
+
+    @Test
+    public void testDeserializationAsArrayWithWrongToken() throws Exception
+    {
+        // Boolean in array without UNWRAP should fail with specific error
+        assertError(
+            () -> readerForOneBased().readValue("[true]"),
+            MismatchedInputException.class,
+            "Expected VALUE_NUMBER_INT"
+        );
+    }
+
+    @Test
+    public void testDeserializationAsArrayWithStringUnwrapDisabled() throws Exception
+    {
+        // String in array without UNWRAP_SINGLE_VALUE_ARRAYS should fail
+        assertError(
+            () -> readerForOneBased().readValue("[\"JANUARY\"]"),
+            MismatchedInputException.class,
+            "Expected VALUE_NUMBER_INT"
+        );
+    }
+
+    @Test
+    public void testDeserializationAsArrayWithFloatUnwrapDisabled() throws Exception
+    {
+        // Float in array without UNWRAP should fail
+        assertError(
+            () -> readerForOneBased().readValue("[1.5]"),
+            MismatchedInputException.class,
+            "Expected VALUE_NUMBER_INT"
+        );
+    }
+
+    @Test
+    public void testDeserializationAsArrayWithObjectUnwrapDisabled() throws Exception
+    {
+        // Object in array without UNWRAP should fail
+        assertError(
+            () -> readerForOneBased().readValue("[{}]"),
+            MismatchedInputException.class,
+            "Expected VALUE_NUMBER_INT"
+        );
+    }
+
+    @Test
+    public void testDeserializationAsArrayWithStringUnwrapEnabled() throws Exception
+    {
+        // String in array with UNWRAP_SINGLE_VALUE_ARRAYS should work
+        Month result = MAPPER.readerFor(Month.class)
+                .with(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)
+                .with(DateTimeFeature.ONE_BASED_MONTHS)
+                .readValue("[\"JANUARY\"]");
+        assertEquals(Month.JANUARY, result);
+    }
+
+    @Test
+    public void testDeserializationAsArrayWithNumericStringUnwrapEnabled() throws Exception
+    {
+        // Numeric string in array with UNWRAP_SINGLE_VALUE_ARRAYS
+        Month result = MAPPER.readerFor(Month.class)
+                .with(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)
+                .with(DateTimeFeature.ONE_BASED_MONTHS)
+                .readValue("[\"5\"]");
+        assertEquals(Month.MAY, result);
+    }
+
+    @Test
+    public void testDeserializationAsArrayWithMoreThanOneString() throws Exception
+    {
+        // More than one string with UNWRAP_SINGLE_VALUE_ARRAYS should fail
+        assertError(
+            () -> MAPPER.readerFor(Month.class)
+                    .with(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)
+                    .readValue("[\"JANUARY\", \"FEBRUARY\"]"),
+            MismatchedInputException.class,
+            "Attempted to unwrap"
+        );
+    }
+
+    /*
+    /**********************************************************************
+    /* Tests for zero-based string parsing edge cases
+    /**********************************************************************
+     */
+
+    @ParameterizedTest
+    @CsvSource({
+            "12  , 'month number outside 0-11'",
+            "-1  , 'month number outside 0-11'",
+            "100 , 'month number outside 0-11'",
+    })
+    public void testBadDeserializationAsString_zeroBasedOutOfRange(String monthSpec, String expectedMessage) {
+        String value = q(monthSpec);
+        assertError(
+            () -> readerForZeroBased().readValue(value),
+            InvalidFormatException.class,
+            expectedMessage
+        );
+    }
+
+    /*
+    /**********************************************************************
+    /* Tests for whitespace handling
+    /**********************************************************************
+     */
+
+    @Test
+    public void testDeserializationWithWhitespace() throws Exception
+    {
+        // Whitespace around month name should be trimmed
+        Month result = readerForOneBased().readValue("\" JANUARY \"");
+        assertEquals(Month.JANUARY, result);
+    }
+
+    @Test
+    public void testDeserializationWithWhitespaceNumeric() throws Exception
+    {
+        // Whitespace around numeric value should be trimmed
+        Month result = readerForOneBased().readValue("\" 6 \"");
+        assertEquals(Month.JUNE, result);
+    }
+
+    /*
+    /**********************************************************************
+    /* Tests for unexpected tokens
+    /**********************************************************************
+     */
+
+    @Test
+    public void testDeserializationFromBoolean() throws Exception
+    {
+        // Bare boolean should be handled as unexpected token
+        assertError(
+            () -> readerForOneBased().readValue("true"),
+            MismatchedInputException.class,
+            "Unexpected token (VALUE_TRUE)"
+        );
+    }
+
+    @Test
+    public void testDeserializationFromFloat() throws Exception
+    {
+        // Bare float should be handled as unexpected token
+        assertError(
+            () -> readerForOneBased().readValue("1.5"),
+            MismatchedInputException.class,
+            "Unexpected token (VALUE_NUMBER_FLOAT)"
+        );
+    }
+
+    @Test
+    public void testDeserializationFromObject() throws Exception
+    {
+        // Object without scalar extraction should fail
+        assertError(
+            () -> readerForOneBased().readValue("{}"),
+            MismatchedInputException.class,
+            "Unexpected token (START_OBJECT)"
+        );
+    }
+
+    /*
+    /**********************************************************************
+    /* Tests for custom DateTimeFormatter
+    /**********************************************************************
+     */
+
+    @Test
+    public void testDeserializationWithCustomFormat() throws Exception
+    {
+        WrapperWithFormat result = MAPPER.readValue("{\"value\":\"Jan\"}", WrapperWithFormat.class);
+        assertEquals(Month.JANUARY, result.value);
+    }
+
+    @Test
+    public void testDeserializationWithCustomFormatMarch() throws Exception
+    {
+        WrapperWithFormat result = MAPPER.readValue("{\"value\":\"Mar\"}", WrapperWithFormat.class);
+        assertEquals(Month.MARCH, result.value);
+    }
+
+    @Test
+    public void testDeserializationWithCustomFormatInvalid() throws Exception
+    {
+        assertError(
+            () -> MAPPER.readValue("{\"value\":\"NotAMonth\"}", WrapperWithFormat.class),
+            InvalidFormatException.class,
+            "could not be parsed"
+        );
+    }
+
+    static class WrapperWithFullMonthFormat {
+        @JsonFormat(pattern = "MMMM", locale = "en")
+        public Month value;
+    }
+
+    @Test
+    public void testDeserializationWithFullMonthFormat() throws Exception
+    {
+        WrapperWithFullMonthFormat result = MAPPER.readValue(
+                "{\"value\":\"January\"}", WrapperWithFullMonthFormat.class);
+        assertEquals(Month.JANUARY, result.value);
+    }
+
+    /*
+    /**********************************************************************
+    /* Tests for leniency settings
+    /**********************************************************************
+     */
+
+    static class WrapperStrict {
+        @JsonFormat(lenient = OptBoolean.FALSE)
+        public Month value;
+    }
+
+    static class WrapperLenient {
+        @JsonFormat(lenient = OptBoolean.TRUE)
+        public Month value;
+    }
+
+    @Test
+    public void testWithLeniencyCreatesNewInstance() throws Exception
+    {
+        MonthDeserializer original = MonthDeserializer.INSTANCE;
+        MonthDeserializer strict = original.withLeniency(false);
+        assertNotSame(original, strict);
+        assertFalse(strict.isLenient());
+    }
+
+    @Test
+    public void testWithDateFormatCreatesNewInstance() throws Exception
+    {
+        MonthDeserializer original = MonthDeserializer.INSTANCE;
+        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("MMM");
+        MonthDeserializer withFormatter = original.withDateFormat(formatter);
+        assertNotSame(original, withFormatter);
+    }
+
+    /*
+    /**********************************************************************
+    /* Helper methods
+    /**********************************************************************
+     */
+
     private ObjectReader readerForZeroBased() {
         return MAPPER
                 .readerFor(Month.class)
diff --git a/src/test/java/tools/jackson/databind/ext/javatime/deser/OffsetTimeDeserTest.java b/src/test/java/tools/jackson/databind/ext/javatime/deser/OffsetTimeDeserTest.java
index 9dd79631b8..7819da5c60 100644
--- a/src/test/java/tools/jackson/databind/ext/javatime/deser/OffsetTimeDeserTest.java
+++ b/src/test/java/tools/jackson/databind/ext/javatime/deser/OffsetTimeDeserTest.java
@@ -10,6 +10,7 @@
 
 import com.fasterxml.jackson.annotation.JsonFormat;
 import com.fasterxml.jackson.annotation.JsonFormat.Feature;
+import com.fasterxml.jackson.annotation.OptBoolean;
 
 import tools.jackson.core.type.TypeReference;
 
@@ -61,6 +62,24 @@ public WrapperWithReadTimestampsAsNanosEnabled() { }
         public WrapperWithReadTimestampsAsNanosEnabled(OffsetTime v) { value = v; }
     }
 
+    // For testing custom format (covers withDateFormat)
+    static class WrapperWithCustomPattern {
+        @JsonFormat(pattern = "HH:mm:ssXXX")
+        public OffsetTime value;
+
+        public WrapperWithCustomPattern() { }
+        public WrapperWithCustomPattern(OffsetTime v) { value = v; }
+    }
+
+    // For testing strict mode with custom format
+    static class StrictWrapper {
+        @JsonFormat(pattern = "HH:mmXXX", lenient = OptBoolean.FALSE)
+        public OffsetTime value;
+
+        public StrictWrapper() { }
+        public StrictWrapper(OffsetTime v) { value = v; }
+    }
+
     private final ObjectMapper MAPPER = newMapper();
     private final ObjectReader READER = MAPPER.readerFor(OffsetTime.class);
 
@@ -347,4 +366,112 @@ public void testStrictDeserializeFromEmptyString() throws Exception {
         String valueFromEmptyStr = mapper.writeValueAsString(asMap(key, ""));
         assertThrows(MismatchedInputException.class, () -> objectReader.readValue(valueFromEmptyStr));
     }
+
+    /*
+    /**********************************************************
+    /* Tests for custom pattern/format (covers withDateFormat)
+    /**********************************************************
+     */
+
+    @Test
+    public void testDeserializationWithCustomPattern() throws Exception
+    {
+        ObjectReader reader = MAPPER.readerFor(WrapperWithCustomPattern.class);
+
+        OffsetTime expected = OffsetTime.of(15, 30, 45, 0, ZoneOffset.ofHours(2));
+        WrapperWithCustomPattern result = reader.readValue(a2q("{'value':'15:30:45+02:00'}"));
+        assertEquals(expected, result.value);
+
+        // Also test with UTC offset
+        expected = OffsetTime.of(10, 15, 30, 0, ZoneOffset.UTC);
+        result = reader.readValue(a2q("{'value':'10:15:30Z'}"));
+        assertEquals(expected, result.value);
+    }
+
+    @Test
+    public void testStrictCustomPatternInvalidFormat() throws Exception
+    {
+        // The strict wrapper expects HH:mmXXX format, so full timestamp should fail
+        assertThrows(MismatchedInputException.class,
+                () -> MAPPER.readValue("{\"value\":\"15:30:45+02:00\"}", StrictWrapper.class));
+    }
+
+    /*
+    /**********************************************************
+    /* Tests for TRUNCATE_TO_MSECS_ON_READ feature
+    /**********************************************************
+     */
+
+    @Test
+    public void testDeserializationTruncateToMillis() throws Exception
+    {
+        ObjectReader reader = MAPPER.readerFor(OffsetTime.class)
+                .with(DateTimeFeature.TRUNCATE_TO_MSECS_ON_READ);
+
+        // From string with nanoseconds
+        OffsetTime result = reader.readValue("\"10:30:45.123456789+02:00\"");
+        assertEquals(123000000, result.getNano(), "Nanoseconds should be truncated to milliseconds");
+        assertEquals(10, result.getHour());
+        assertEquals(30, result.getMinute());
+        assertEquals(45, result.getSecond());
+
+        // From array with nanoseconds
+        result = reader.with(DateTimeFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
+                .readValue("[10,30,45,123456789,\"+02:00\"]");
+        assertEquals(123000000, result.getNano(), "Nanoseconds from array should be truncated to milliseconds");
+    }
+
+    @Test
+    public void testDeserializationTruncateToMillisAlreadyTruncated() throws Exception
+    {
+        ObjectReader reader = MAPPER.readerFor(OffsetTime.class)
+                .with(DateTimeFeature.TRUNCATE_TO_MSECS_ON_READ);
+
+        // Value already at millisecond precision should remain unchanged
+        OffsetTime result = reader.readValue("\"10:30:45.123+02:00\"");
+        assertEquals(123000000, result.getNano());
+    }
+
+    /*
+    /**********************************************************
+    /* Tests for error cases
+    /**********************************************************
+     */
+
+    @Test
+    public void testDeserializationFromIntegerFails() throws Exception
+    {
+        // OffsetTime cannot be deserialized from a standalone integer
+        // (needs timezone info)
+        try {
+            READER.readValue("12345");
+            fail("Should not accept integer for OffsetTime");
+        } catch (MismatchedInputException e) {
+            verifyException(e, "raw timestamp");
+        }
+    }
+
+    @Test
+    public void testDeserializationFromArrayMissingTimeZone() throws Exception
+    {
+        // Array with numeric values but missing timezone string at the end
+        try {
+            READER.readValue("[10,30,45,123]");
+            fail("Should fail when timezone string is missing");
+        } catch (MismatchedInputException e) {
+            verifyException(e, "Expected string for TimeZone");
+        }
+    }
+
+    @Test
+    public void testDeserializationFromArrayMissingTimeZoneMinimal() throws Exception
+    {
+        // Array with just hour and minute but no timezone
+        try {
+            READER.readValue("[10,30]");
+            fail("Should fail when timezone string is missing");
+        } catch (MismatchedInputException e) {
+            verifyException(e, "Expected string for TimeZone");
+        }
+    }
 }
