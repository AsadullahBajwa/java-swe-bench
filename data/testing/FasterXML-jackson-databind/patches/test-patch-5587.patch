diff --git a/src/test/java/tools/jackson/databind/node/ArrayNodeTest.java b/src/test/java/tools/jackson/databind/node/ArrayNodeTest.java
index 5ab2cd7594..bb34b0dc59 100644
--- a/src/test/java/tools/jackson/databind/node/ArrayNodeTest.java
+++ b/src/test/java/tools/jackson/databind/node/ArrayNodeTest.java
@@ -10,6 +10,7 @@
 
 import tools.jackson.core.*;
 import tools.jackson.databind.*;
+import tools.jackson.databind.exc.JsonNodeException;
 import tools.jackson.databind.exc.MismatchedInputException;
 import tools.jackson.databind.testutil.DatabindTestUtil;
 import tools.jackson.databind.util.RawValue;
@@ -128,7 +129,7 @@ public void testDirectCreation2()
         try {
             n.set(2, NODE_F.nullNode());
             fail("Should not pass");
-        } catch (IndexOutOfBoundsException e) {
+        } catch (JsonNodeException e) {
             verifyException(e, "illegal index");
         }
         n.insert(1, (String) null);
@@ -219,11 +220,11 @@ public void testArrayReplace() {
         try {
             array.replace(100, null);
             fail("Should not pass");
-        } catch (IndexOutOfBoundsException e) {
-            ;
+        } catch (JsonNodeException e) {
+            verifyException(e, "Illegal index 100, array size 1");
         }
     }
-    
+
     @Test
     public void testArrayViaMapper()
     {
diff --git a/src/test/java/tools/jackson/databind/node/TreeTraversingParserTest.java b/src/test/java/tools/jackson/databind/node/TreeTraversingParserTest.java
index bfadcd35d7..8483ee5b0f 100644
--- a/src/test/java/tools/jackson/databind/node/TreeTraversingParserTest.java
+++ b/src/test/java/tools/jackson/databind/node/TreeTraversingParserTest.java
@@ -1,5 +1,6 @@
 package tools.jackson.databind.node;
 
+import java.io.ByteArrayOutputStream;
 import java.math.BigInteger;
 import java.util.*;
 
@@ -68,6 +69,9 @@ public void testSimple() throws Exception
         assertEquals("a", p.currentName());
         assertEquals(123, p.getIntValue());
         assertEquals((short) 123, p.getShortValue());
+        assertEquals(123, p.getValueAsInt(-1));
+        assertEquals(123L, p.getValueAsLong(42L));
+        assertEquals(BigInteger.valueOf(123L), p.getBigIntegerValue());
         assertEquals("123", p.getString());
 
         assertToken(JsonToken.PROPERTY_NAME, p.nextToken());
@@ -81,18 +85,55 @@ public void testSimple() throws Exception
         assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());
         assertNull(p.currentName());
         assertEquals(12.25, p.getDoubleValue(), 0);
+        assertEquals(12.25f, p.getFloatValue(), 0);
         assertEquals(NumberType.DOUBLE, p.getNumberType());
         assertEquals(NumberTypeFP.DOUBLE64, p.getNumberTypeFP());
         assertFalse(p.isNaN());
+        try {
+            p.getShortValue();
+            fail("Should not pass");
+        } catch (InputCoercionException e) {
+            verifyException(e, "has fractional part; cannot convert to `short`");
+        }
+        try {
+            p.getIntValue();
+            fail("Should not pass");
+        } catch (InputCoercionException e) {
+            verifyException(e, "has fractional part; cannot convert to `int`");
+        }
+        assertEquals(12, p.getValueAsInt(1));
+        try {
+            p.getLongValue();
+            fail("Should not pass");
+        } catch (InputCoercionException e) {
+            verifyException(e, "has fractional part; cannot convert to `long`");
+        }
+        assertEquals(12L, p.getValueAsLong(2L));
         assertEquals("12.25", p.getString());
 
         assertToken(JsonToken.VALUE_NULL, p.nextToken());
         assertNull(p.currentName());
+        assertNull(p.getNumberType());
+        assertEquals(NumberTypeFP.UNKNOWN, p.getNumberTypeFP());
         assertEquals(JsonToken.VALUE_NULL.asString(), p.getString());
 
         assertToken(JsonToken.VALUE_TRUE, p.nextToken());
         assertNull(p.currentName());
         assertTrue(p.getBooleanValue());
+        try {
+            p.getValueAsInt(1);
+            fail("Should not pass");
+        } catch (InputCoercionException e) {
+            verifyException(e, "Current token (VALUE_TRUE) not numeric, cannot use numeric value accessors");
+        }
+        try {
+            p.getValueAsLong(2L);
+            fail("Should not pass");
+        } catch (InputCoercionException e) {
+            verifyException(e, "Current token (VALUE_TRUE) not numeric, cannot use numeric value accessors");
+        }
+        assertNull(p.getNumberType());
+        assertEquals(NumberTypeFP.UNKNOWN, p.getNumberTypeFP());
         assertEquals(JsonToken.VALUE_TRUE.asString(), p.getString());
 
         assertToken(JsonToken.START_OBJECT, p.nextToken());
@@ -191,16 +232,21 @@ public void testBinaryPojo() throws Exception
     {
         byte[] inputBinary = new byte[] { 1, 2, 100 };
         POJONode n = new POJONode(inputBinary);
-        JsonParser p = n.traverse(ObjectReadContext.empty());
-
-        assertNull(p.currentToken());
-        assertToken(JsonToken.VALUE_EMBEDDED_OBJECT, p.nextToken());
-        byte[] data = p.getBinaryValue();
-        assertNotNull(data);
-        assertArrayEquals(inputBinary, data);
-        Object pojo = p.getEmbeddedObject();
-        assertSame(data, pojo);
-        p.close();
+        try (JsonParser p = n.traverse(ObjectReadContext.empty())) {
+            assertNull(p.currentToken());
+            assertToken(JsonToken.VALUE_EMBEDDED_OBJECT, p.nextToken());
+            byte[] data = p.getBinaryValue();
+            assertNotNull(data);
+            assertArrayEquals(inputBinary, data);
+            Object pojo = p.getEmbeddedObject();
+            assertSame(data, pojo);
+
+            // and for code coverage
+            ByteArrayOutputStream bout = new ByteArrayOutputStream();
+            int count = p.readBinaryValue(Base64Variants.getDefaultVariant(), bout);
+            assertEquals(data.length, count);
+            assertArrayEquals(inputBinary, bout.toByteArray());
+        }
     }
 
     @Test
