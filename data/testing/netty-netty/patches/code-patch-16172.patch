diff --git a/common/src/main/java/io/netty/util/NetUtil.java b/common/src/main/java/io/netty/util/NetUtil.java
index 418dd89fd19..84911e6de83 100644
--- a/common/src/main/java/io/netty/util/NetUtil.java
+++ b/common/src/main/java/io/netty/util/NetUtil.java
@@ -35,8 +35,6 @@
 import java.net.InetSocketAddress;
 import java.net.NetworkInterface;
 import java.net.UnknownHostException;
-import java.security.AccessController;
-import java.security.PrivilegedAction;
 import java.util.Arrays;
 import java.util.Collection;
 
@@ -162,70 +160,65 @@ public final class NetUtil {
         LOOPBACK_IF = loopback.iface();
         LOCALHOST = loopback.address();
 
-        // As a SecurityManager may prevent reading the somaxconn file we wrap this in a privileged block.
-        //
-        // See https://github.com/netty/netty/issues/3680
-        SOMAXCONN = AccessController.doPrivileged(new SoMaxConnAction());
+        SOMAXCONN = getSoMaxConn();
     }
 
-    private static final class SoMaxConnAction implements PrivilegedAction<Integer> {
-        @Override
-        public Integer run() {
-            // Determine the default somaxconn (server socket backlog) value of the platform.
-            // The known defaults:
-            // - Windows NT Server 4.0+: 200
-            // - Mac OS X: 128
-            // - Linux kernel > 5.4 : 4096
-            int somaxconn;
-            if (PlatformDependent.isWindows()) {
-                somaxconn = 200;
-            } else if (PlatformDependent.isOsx()) {
-                somaxconn = 128;
-            } else {
-                somaxconn = 4096;
-            }
-            File file = new File("/proc/sys/net/core/somaxconn");
-            try {
-                // file.exists() may throw a SecurityException if a SecurityManager is used, so execute it in the
-                // try / catch block.
-                // See https://github.com/netty/netty/issues/4936
-                if (file.exists()) {
-                    try (BufferedReader in = new BufferedReader(new InputStreamReader(
-                            new BoundedInputStream(new FileInputStream(file))))) {
-                        somaxconn = Integer.parseInt(in.readLine());
-                        if (logger.isDebugEnabled()) {
-                            logger.debug("{}: {}", file, somaxconn);
-                        }
+    private static int getSoMaxConn() {
+        // Determine the default somaxconn (server socket backlog) value of the platform.
+        // The known defaults:
+        // - Windows NT Server 4.0+: 200
+        // - Mac OS X: 128
+        // - Linux kernel > 5.4 : 4096
+        int somaxconn;
+        if (PlatformDependent.isWindows()) {
+            somaxconn = 200;
+        } else if (PlatformDependent.isOsx()) {
+            somaxconn = 128;
+        } else {
+            somaxconn = 4096;
+        }
+        File file = new File("/proc/sys/net/core/somaxconn");
+        try {
+            // file.exists() may throw a SecurityException if a SecurityManager is used, so execute it in the
+            // try / catch block.
+            // See https://github.com/netty/netty/issues/4936
+            if (file.exists()) {
+                try (BufferedReader in = new BufferedReader(new InputStreamReader(
+                        new BoundedInputStream(new FileInputStream(file))))) {
+                    somaxconn = Integer.parseInt(in.readLine());
+                    if (logger.isDebugEnabled()) {
+                        logger.debug("{}: {}", file, somaxconn);
                     }
-                } else {
-                    // Try to get from sysctl
-                    Integer tmp = null;
-                    if (SystemPropertyUtil.getBoolean("io.netty.net.somaxconn.trySysctl", false)) {
-                        tmp = sysctlGetInt("kern.ipc.somaxconn");
-                        if (tmp == null) {
-                            tmp = sysctlGetInt("kern.ipc.soacceptqueue");
-                            if (tmp != null) {
-                                somaxconn = tmp;
-                            }
-                        } else {
+                }
+            } else {
+                // Try to get from sysctl
+                Integer tmp = null;
+                if (SystemPropertyUtil.getBoolean("io.netty.net.somaxconn.trySysctl", false)) {
+                    tmp = sysctlGetInt("kern.ipc.somaxconn");
+                    if (tmp == null) {
+                        tmp = sysctlGetInt("kern.ipc.soacceptqueue");
+                        if (tmp != null) {
                             somaxconn = tmp;
                         }
-                    }
-
-                    if (tmp == null) {
-                        logger.debug("Failed to get SOMAXCONN from sysctl and file {}. Default: {}", file,
-                                somaxconn);
+                    } else {
+                        somaxconn = tmp;
                     }
                 }
-            } catch (Exception e) {
-                if (logger.isDebugEnabled()) {
-                    logger.debug("Failed to get SOMAXCONN from sysctl and file {}. Default: {}",
-                            file, somaxconn, e);
+
+                if (tmp == null) {
+                    logger.debug("Failed to get SOMAXCONN from sysctl and file {}. Default: {}", file,
+                            somaxconn);
                 }
             }
-            return somaxconn;
+        } catch (Exception e) {
+            if (logger.isDebugEnabled()) {
+                logger.debug("Failed to get SOMAXCONN from sysctl and file {}. Default: {}",
+                        file, somaxconn, e);
+            }
         }
+        return somaxconn;
     }
+
     /**
      * This will execute <a href ="https://www.freebsd.org/cgi/man.cgi?sysctl(8)">sysctl</a> with the {@code sysctlKey}
      * which is expected to return the numeric value for for {@code sysctlKey}.
diff --git a/common/src/main/java/io/netty/util/ThreadDeathWatcher.java b/common/src/main/java/io/netty/util/ThreadDeathWatcher.java
index 09fd506e14c..6c219ccd60a 100644
--- a/common/src/main/java/io/netty/util/ThreadDeathWatcher.java
+++ b/common/src/main/java/io/netty/util/ThreadDeathWatcher.java
@@ -23,8 +23,6 @@
 import io.netty.util.internal.logging.InternalLogger;
 import io.netty.util.internal.logging.InternalLoggerFactory;
 
-import java.security.AccessController;
-import java.security.PrivilegedAction;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Queue;
@@ -107,13 +105,7 @@ private static void schedule(Thread thread, Runnable task, boolean isWatch) {
             // See:
             // - https://github.com/netty/netty/issues/7290
             // - https://bugs.openjdk.java.net/browse/JDK-7008595
-            AccessController.doPrivileged(new PrivilegedAction<Void>() {
-                @Override
-                public Void run() {
-                    watcherThread.setContextClassLoader(null);
-                    return null;
-                }
-            });
+            watcherThread.setContextClassLoader(null);
 
             watcherThread.start();
             ThreadDeathWatcher.watcherThread = watcherThread;
diff --git a/common/src/main/java/io/netty/util/concurrent/EventExecutorGroup.java b/common/src/main/java/io/netty/util/concurrent/EventExecutorGroup.java
index 842f73739a3..224bea13b51 100644
--- a/common/src/main/java/io/netty/util/concurrent/EventExecutorGroup.java
+++ b/common/src/main/java/io/netty/util/concurrent/EventExecutorGroup.java
@@ -19,7 +19,6 @@
 import java.util.concurrent.Callable;
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.Executor;
-import java.util.concurrent.Executors;
 import java.util.concurrent.RejectedExecutionException;
 import java.util.concurrent.TimeUnit;
 
@@ -184,11 +183,6 @@ ScheduledFuture<?> scheduleWithFixedDelay(Runnable command,
      * for a task, you can use constructions of the form
      * {@code result = exec.submit(aCallable).get();}
      *
-     * <p>Note: The {@link Executors} class includes a set of methods
-     * that can convert some other common closure-like objects,
-     * for example, {@link java.security.PrivilegedAction} to
-     * {@link Callable} form so they can be submitted.
-     *
      * @param task the task to submit
      * @param <T> the type of the task's result
      * @return a Future representing pending completion of the task
diff --git a/common/src/main/java/io/netty/util/concurrent/GlobalEventExecutor.java b/common/src/main/java/io/netty/util/concurrent/GlobalEventExecutor.java
index a684249a5df..29629ef2bd6 100644
--- a/common/src/main/java/io/netty/util/concurrent/GlobalEventExecutor.java
+++ b/common/src/main/java/io/netty/util/concurrent/GlobalEventExecutor.java
@@ -21,11 +21,8 @@
 import io.netty.util.internal.ThrowableUtil;
 import io.netty.util.internal.logging.InternalLogger;
 import io.netty.util.internal.logging.InternalLoggerFactory;
-
 import org.jetbrains.annotations.Async.Schedule;
 
-import java.security.AccessController;
-import java.security.PrivilegedAction;
 import java.util.Queue;
 import java.util.concurrent.BlockingQueue;
 import java.util.concurrent.Executors;
@@ -232,14 +229,9 @@ private void execute0(@Schedule Runnable task) {
     private void startThread() {
         if (started.compareAndSet(false, true)) {
             final Thread callingThread = Thread.currentThread();
-            ClassLoader parentCCL = AccessController.doPrivileged(new PrivilegedAction<ClassLoader>() {
-                @Override
-                public ClassLoader run() {
-                    return callingThread.getContextClassLoader();
-                }
-            });
+            ClassLoader parentCCL = callingThread.getContextClassLoader();
             // Avoid calling classloader leaking through Thread.inheritedAccessControlContext.
-            setContextClassLoader(callingThread, null);
+            callingThread.setContextClassLoader(null);
             try {
                 final Thread t = threadFactory.newThread(taskRunner);
                 // Set to null to ensure we not create classloader leaks by holds a strong reference to the inherited
@@ -247,7 +239,7 @@ public ClassLoader run() {
                 // See:
                 // - https://github.com/netty/netty/issues/7290
                 // - https://bugs.openjdk.java.net/browse/JDK-7008595
-                setContextClassLoader(t, null);
+                t.setContextClassLoader(null);
 
                 // Set the thread before starting it as otherwise inEventLoop() may return false and so produce
                 // an assert error.
@@ -255,21 +247,11 @@ public ClassLoader run() {
                 thread = t;
                 t.start();
             } finally {
-                setContextClassLoader(callingThread, parentCCL);
+                callingThread.setContextClassLoader(parentCCL);
             }
         }
     }
 
-    private static void setContextClassLoader(final Thread t, final ClassLoader cl) {
-        AccessController.doPrivileged(new PrivilegedAction<Void>() {
-            @Override
-            public Void run() {
-                t.setContextClassLoader(cl);
-                return null;
-            }
-        });
-    }
-
     final class TaskRunner implements Runnable {
         @Override
         public void run() {
diff --git a/common/src/main/java/io/netty/util/internal/CleanerJava6.java b/common/src/main/java/io/netty/util/internal/CleanerJava6.java
index 93b8b84159b..fc78a996805 100644
--- a/common/src/main/java/io/netty/util/internal/CleanerJava6.java
+++ b/common/src/main/java/io/netty/util/internal/CleanerJava6.java
@@ -21,8 +21,6 @@
 import java.lang.invoke.MethodHandle;
 import java.lang.invoke.MethodHandles;
 import java.nio.ByteBuffer;
-import java.security.AccessController;
-import java.security.PrivilegedAction;
 import java.util.Objects;
 
 import static java.lang.invoke.MethodType.methodType;
@@ -43,43 +41,29 @@ final class CleanerJava6 implements Cleaner {
         Throwable error = null;
         final ByteBuffer direct = ByteBuffer.allocateDirect(1);
         try {
-            Object mayBeCleanerField = AccessController.doPrivileged(new PrivilegedAction<Object>() {
-                @Override
-                public Object run() {
-                    try {
-                        Class<?> cleanerClass = Class.forName("sun.misc.Cleaner");
-                        Class<?> directBufClass = Class.forName("sun.nio.ch.DirectBuffer");
-                        MethodHandles.Lookup lookup = MethodHandles.lookup();
-
-                        // Call clean() on the cleaner
-                        MethodHandle clean = lookup.findVirtual(
-                                cleanerClass, "clean", methodType(void.class));
-                        // But only if the cleaner is non-null
-                        MethodHandle nullTest = lookup.findStatic(
-                                Objects.class, "nonNull", methodType(boolean.class, Object.class));
-                        clean = MethodHandles.guardWithTest(
-                                nullTest.asType(methodType(boolean.class, cleanerClass)),
-                                clean,
-                                nullTest.asType(methodType(void.class, cleanerClass)));
-                        // Change receiver to DirectBuffer, convert DirectBuffer to Cleaner by calling cleaner()
-                        clean = MethodHandles.filterArguments(clean, 0, lookup.findVirtual(
-                                directBufClass,
-                                "cleaner",
-                                methodType(cleanerClass)));
-                        // Change receiver to ByteBuffer, convert using explicit cast to DirectBuffer
-                        clean = MethodHandles.explicitCastArguments(clean,
-                                methodType(void.class, ByteBuffer.class));
-                        return clean;
-                    } catch (Throwable cause) {
-                        return cause;
-                    }
-                }
-            });
-            if (mayBeCleanerField instanceof Throwable) {
-                throw (Throwable) mayBeCleanerField;
-            }
-
-            clean = (MethodHandle) mayBeCleanerField;
+            Class<?> cleanerClass = Class.forName("sun.misc.Cleaner");
+            Class<?> directBufClass = Class.forName("sun.nio.ch.DirectBuffer");
+            MethodHandles.Lookup lookup = MethodHandles.lookup();
+
+            // Call clean() on the cleaner
+            clean = lookup.findVirtual(
+                    cleanerClass, "clean", methodType(void.class));
+            // But only if the cleaner is non-null
+            MethodHandle nullTest = lookup.findStatic(
+                    Objects.class, "nonNull", methodType(boolean.class, Object.class));
+            clean = MethodHandles.guardWithTest(
+                    nullTest.asType(methodType(boolean.class, cleanerClass)),
+                    clean,
+                    nullTest.asType(methodType(void.class, cleanerClass)));
+            // Change receiver to DirectBuffer, convert DirectBuffer to Cleaner by calling cleaner()
+            clean = MethodHandles.filterArguments(clean, 0, lookup.findVirtual(
+                    directBufClass,
+                    "cleaner",
+                    methodType(cleanerClass)));
+            // Change receiver to ByteBuffer, convert using explicit cast to DirectBuffer
+            clean = MethodHandles.explicitCastArguments(clean,
+                    methodType(void.class, ByteBuffer.class));
+
             clean.invokeExact(direct);
         } catch (Throwable t) {
             // We don't have ByteBuffer.cleaner().
@@ -114,30 +98,9 @@ private static void freeDirectBufferStatic(ByteBuffer buffer) {
         if (!buffer.isDirect()) {
             return;
         }
-        if (System.getSecurityManager() == null) {
-            try {
-                freeDirectBuffer0(buffer);
-            } catch (Throwable cause) {
-                PlatformDependent0.throwException(cause);
-            }
-        } else {
-            freeDirectBufferPrivileged(buffer);
-        }
-    }
-
-    private static void freeDirectBufferPrivileged(final ByteBuffer buffer) {
-        Throwable cause = AccessController.doPrivileged(new PrivilegedAction<Throwable>() {
-            @Override
-            public Throwable run() {
-                try {
-                    freeDirectBuffer0(buffer);
-                    return null;
-                } catch (Throwable cause) {
-                    return cause;
-                }
-            }
-        });
-        if (cause != null) {
+        try {
+            freeDirectBuffer0(buffer);
+        } catch (Throwable cause) {
             PlatformDependent0.throwException(cause);
         }
     }
diff --git a/common/src/main/java/io/netty/util/internal/CleanerJava9.java b/common/src/main/java/io/netty/util/internal/CleanerJava9.java
index 24a329a1297..909614acc57 100644
--- a/common/src/main/java/io/netty/util/internal/CleanerJava9.java
+++ b/common/src/main/java/io/netty/util/internal/CleanerJava9.java
@@ -22,8 +22,6 @@
 import java.lang.invoke.MethodHandle;
 import java.lang.invoke.MethodHandles;
 import java.nio.ByteBuffer;
-import java.security.AccessController;
-import java.security.PrivilegedAction;
 
 import static java.lang.invoke.MethodType.methodType;
 
@@ -36,34 +34,23 @@ final class CleanerJava9 implements Cleaner {
     private static final MethodHandle INVOKE_CLEANER;
 
     static {
-        final MethodHandle method;
-        final Throwable error;
+        MethodHandle method;
+        Throwable error;
         if (PlatformDependent0.hasUnsafe()) {
             final ByteBuffer buffer = ByteBuffer.allocateDirect(1);
-            Object maybeInvokeMethod = AccessController.doPrivileged(new PrivilegedAction<Object>() {
-                @Override
-                public Object run() {
-                    try {
-                        // See https://bugs.openjdk.java.net/browse/JDK-8171377
-                        Class<? extends Unsafe> unsafeClass = PlatformDependent0.UNSAFE.getClass();
-                        MethodHandles.Lookup lookup = MethodHandles.lookup();
-                        MethodHandle invokeCleaner = lookup.findVirtual(
-                                unsafeClass, "invokeCleaner", methodType(void.class, ByteBuffer.class));
-                        invokeCleaner = invokeCleaner.bindTo(PlatformDependent0.UNSAFE);
-                        invokeCleaner.invokeExact(buffer);
-                        return invokeCleaner;
-                    } catch (Throwable e) {
-                        return e;
-                    }
-                }
-            });
-
-            if (maybeInvokeMethod instanceof Throwable) {
-                method = null;
-                error = (Throwable) maybeInvokeMethod;
-            } else {
-                method = (MethodHandle) maybeInvokeMethod;
+            try {
+                // See https://bugs.openjdk.java.net/browse/JDK-8171377
+                Class<? extends Unsafe> unsafeClass = PlatformDependent0.UNSAFE.getClass();
+                MethodHandles.Lookup lookup = MethodHandles.lookup();
+                MethodHandle invokeCleaner = lookup.findVirtual(
+                        unsafeClass, "invokeCleaner", methodType(void.class, ByteBuffer.class));
+                invokeCleaner = invokeCleaner.bindTo(PlatformDependent0.UNSAFE);
+                invokeCleaner.invokeExact(buffer);
+                method = invokeCleaner;
                 error = null;
+            } catch (Throwable e) {
+                error = e;
+                method = null;
             }
         } else {
             method = null;
@@ -93,33 +80,10 @@ public void freeDirectBuffer(ByteBuffer buffer) {
     }
 
     private static void freeDirectBufferStatic(ByteBuffer buffer) {
-        // Try to minimize overhead when there is no SecurityManager present.
-        // See https://bugs.openjdk.java.net/browse/JDK-8191053.
-        if (System.getSecurityManager() == null) {
-            try {
-                INVOKE_CLEANER.invokeExact(buffer);
-            } catch (Throwable cause) {
-                PlatformDependent0.throwException(cause);
-            }
-        } else {
-            freeDirectBufferPrivileged(buffer);
-        }
-    }
-
-    private static void freeDirectBufferPrivileged(final ByteBuffer buffer) {
-        Throwable error = AccessController.doPrivileged(new PrivilegedAction<Throwable>() {
-            @Override
-            public Throwable run() {
-                try {
-                    INVOKE_CLEANER.invokeExact(buffer);
-                } catch (Throwable e) {
-                    return e;
-                }
-                return null;
-            }
-        });
-        if (error != null) {
-            PlatformDependent0.throwException(error);
+        try {
+            INVOKE_CLEANER.invokeExact(buffer);
+        } catch (Throwable cause) {
+            PlatformDependent0.throwException(cause);
         }
     }
 
diff --git a/common/src/main/java/io/netty/util/internal/NativeLibraryLoader.java b/common/src/main/java/io/netty/util/internal/NativeLibraryLoader.java
index 1e4dbf3d10f..3743d07976c 100644
--- a/common/src/main/java/io/netty/util/internal/NativeLibraryLoader.java
+++ b/common/src/main/java/io/netty/util/internal/NativeLibraryLoader.java
@@ -30,10 +30,8 @@
 import java.net.URL;
 import java.nio.file.Files;
 import java.nio.file.attribute.PosixFilePermission;
-import java.security.AccessController;
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
-import java.security.PrivilegedAction;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
@@ -410,29 +408,20 @@ private static void loadLibrary(final ClassLoader loader, final String name, fin
 
     private static void loadLibraryByHelper(final Class<?> helper, final String name, final boolean absolute)
             throws UnsatisfiedLinkError {
-        Object ret = AccessController.doPrivileged(new PrivilegedAction<Object>() {
-            @Override
-            public Object run() {
-                try {
-                    // Invoke the helper to load the native library, if it succeeds, then the native
-                    // library belong to the specified ClassLoader.
-                    Method method = helper.getMethod("loadLibrary", String.class, boolean.class);
-                    method.setAccessible(true);
-                    return method.invoke(null, name, absolute);
-                } catch (Exception e) {
-                    return e;
-                }
-            }
-        });
-        if (ret instanceof Throwable) {
-            Throwable t = (Throwable) ret;
-            assert !(t instanceof UnsatisfiedLinkError) : t + " should be a wrapper throwable";
-            Throwable cause = t.getCause();
+        try {
+            // Invoke the helper to load the native library, if it succeeds, then the native
+            // library belong to the specified ClassLoader.
+            Method method = helper.getMethod("loadLibrary", String.class, boolean.class);
+            method.setAccessible(true);
+            method.invoke(null, name, absolute);
+        } catch (Throwable e) {
+            assert !(e instanceof UnsatisfiedLinkError) : e + " should be a wrapper throwable";
+            Throwable cause = e.getCause();
             if (cause instanceof UnsatisfiedLinkError) {
                 throw (UnsatisfiedLinkError) cause;
             }
-            UnsatisfiedLinkError ule = new UnsatisfiedLinkError(t.getMessage());
-            ule.initCause(t);
+            UnsatisfiedLinkError ule = new UnsatisfiedLinkError(e.getMessage());
+            ule.initCause(e);
             throw ule;
         }
     }
@@ -456,22 +445,17 @@ private static Class<?> tryToLoadClass(final ClassLoader loader, final Class<?>
             try {
                 // The helper class is NOT found in target ClassLoader, we have to define the helper class.
                 final byte[] classBinary = classToByteArray(helper);
-                return AccessController.doPrivileged(new PrivilegedAction<Class<?>>() {
-                    @Override
-                    public Class<?> run() {
-                        try {
-                            // Define the helper class in the target ClassLoader,
-                            //  then we can call the helper to load the native library.
-                            Method defineClass = ClassLoader.class.getDeclaredMethod("defineClass", String.class,
-                                    byte[].class, int.class, int.class);
-                            defineClass.setAccessible(true);
-                            return (Class<?>) defineClass.invoke(loader, helper.getName(), classBinary, 0,
-                                    classBinary.length);
-                        } catch (Exception e) {
-                            throw new IllegalStateException("Define class failed!", e);
-                        }
-                    }
-                });
+                try {
+                    // Define the helper class in the target ClassLoader,
+                    //  then we can call the helper to load the native library.
+                    Method defineClass = ClassLoader.class.getDeclaredMethod("defineClass", String.class,
+                            byte[].class, int.class, int.class);
+                    defineClass.setAccessible(true);
+                    return (Class<?>) defineClass.invoke(loader, helper.getName(), classBinary, 0,
+                            classBinary.length);
+                } catch (Exception e) {
+                    throw new IllegalStateException("Define class failed!", e);
+                }
             } catch (ClassNotFoundException | RuntimeException | Error e2) {
                 ThrowableUtil.addSuppressed(e2, e1);
                 throw e2;
diff --git a/common/src/main/java/io/netty/util/internal/ObjectCleaner.java b/common/src/main/java/io/netty/util/internal/ObjectCleaner.java
index 560be5b0ead..a99f7466d74 100644
--- a/common/src/main/java/io/netty/util/internal/ObjectCleaner.java
+++ b/common/src/main/java/io/netty/util/internal/ObjectCleaner.java
@@ -19,8 +19,6 @@
 
 import java.lang.ref.ReferenceQueue;
 import java.lang.ref.WeakReference;
-import java.security.AccessController;
-import java.security.PrivilegedAction;
 import java.util.Set;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.atomic.AtomicBoolean;
@@ -108,16 +106,10 @@ public static void register(Object object, Runnable cleanupTask) {
             // See:
             // - https://github.com/netty/netty/issues/7290
             // - https://bugs.openjdk.java.net/browse/JDK-7008595
-            AccessController.doPrivileged(new PrivilegedAction<Void>() {
-                @Override
-                public Void run() {
-                    cleanupThread.setContextClassLoader(null);
-                    return null;
-                }
-            });
+            cleanupThread.setContextClassLoader(null);
             cleanupThread.setName(CLEANER_THREAD_NAME);
 
-            // Mark this as a daemon thread to ensure that we the JVM can exit if this is the only thread that is
+            // Mark this as a daemon thread to ensure that the JVM can exit if this is the only thread that is
             // running.
             cleanupThread.setDaemon(true);
             cleanupThread.start();
diff --git a/common/src/main/java/io/netty/util/internal/PlatformDependent.java b/common/src/main/java/io/netty/util/internal/PlatformDependent.java
index 1951afbdb31..398fada36b5 100644
--- a/common/src/main/java/io/netty/util/internal/PlatformDependent.java
+++ b/common/src/main/java/io/netty/util/internal/PlatformDependent.java
@@ -47,8 +47,6 @@
 import java.nio.file.Files;
 import java.nio.file.Path;
 import java.nio.file.Paths;
-import java.security.AccessController;
-import java.security.PrivilegedAction;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.Deque;
@@ -303,36 +301,34 @@ static void addFilesystemOsClassifiers(final Set<String> availableClassifiers) {
 
     private static boolean processOsReleaseFile(String osReleaseFileName, Set<String> availableClassifiers) {
         Path file = Paths.get(osReleaseFileName);
-        return AccessController.doPrivileged((PrivilegedAction<Boolean>) () -> {
-            try {
-                if (Files.exists(file)) {
-                    try (BufferedReader reader = new BufferedReader(new InputStreamReader(
-                            new BoundedInputStream(Files.newInputStream(file)), StandardCharsets.UTF_8))) {
-                        String line;
-                        while ((line = reader.readLine()) != null) {
-                            if (line.startsWith(LINUX_ID_PREFIX)) {
-                                String id = normalizeOsReleaseVariableValue(
-                                        line.substring(LINUX_ID_PREFIX.length()));
-                                addClassifier(availableClassifiers, id);
-                            } else if (line.startsWith(LINUX_ID_LIKE_PREFIX)) {
-                                line = normalizeOsReleaseVariableValue(
-                                        line.substring(LINUX_ID_LIKE_PREFIX.length()));
-                                addClassifier(availableClassifiers, line.split(" "));
-                            }
+        try {
+            if (Files.exists(file)) {
+                try (BufferedReader reader = new BufferedReader(new InputStreamReader(
+                        new BoundedInputStream(Files.newInputStream(file)), StandardCharsets.UTF_8))) {
+                    String line;
+                    while ((line = reader.readLine()) != null) {
+                        if (line.startsWith(LINUX_ID_PREFIX)) {
+                            String id = normalizeOsReleaseVariableValue(
+                                    line.substring(LINUX_ID_PREFIX.length()));
+                            addClassifier(availableClassifiers, id);
+                        } else if (line.startsWith(LINUX_ID_LIKE_PREFIX)) {
+                            line = normalizeOsReleaseVariableValue(
+                                    line.substring(LINUX_ID_LIKE_PREFIX.length()));
+                            addClassifier(availableClassifiers, line.split(" "));
                         }
-                    } catch (SecurityException e) {
-                        logger.debug("Unable to read {}", osReleaseFileName, e);
-                    } catch (IOException e) {
-                        logger.debug("Error while reading content of {}", osReleaseFileName, e);
                     }
-                    // specification states we should only fall back if /etc/os-release does not exist
-                    return true;
+                } catch (SecurityException e) {
+                    logger.debug("Unable to read {}", osReleaseFileName, e);
+                } catch (IOException e) {
+                    logger.debug("Error while reading content of {}", osReleaseFileName, e);
                 }
-            } catch (SecurityException e) {
-                logger.debug("Unable to check if {} exists", osReleaseFileName, e);
+                // specification states we should only fall back if /etc/os-release does not exist
+                return true;
             }
-            return false;
-        });
+        } catch (SecurityException e) {
+            logger.debug("Unable to check if {} exists", osReleaseFileName, e);
+        }
+        return false;
     }
 
     static boolean addPropertyOsClassifiers(Set<String> availableClassifiers) {
@@ -1239,16 +1235,8 @@ private static final class Mpsc {
         static {
             Object unsafe = null;
             if (hasUnsafe()) {
-                // jctools goes through its own process of initializing unsafe; of
-                // course, this requires permissions which might not be granted to calling code, so we
-                // must mark this block as privileged too
-                unsafe = AccessController.doPrivileged(new PrivilegedAction<Object>() {
-                    @Override
-                    public Object run() {
-                        // force JCTools to initialize unsafe
-                        return UnsafeAccess.UNSAFE;
-                    }
-                });
+                // force JCTools to initialize unsafe
+                unsafe = UnsafeAccess.UNSAFE;
             }
 
             if (unsafe == null) {
@@ -1349,7 +1337,7 @@ public static ClassLoader getClassLoader(final Class<?> clazz) {
      * Return the context {@link ClassLoader} for the current {@link Thread}.
      */
     public static ClassLoader getContextClassLoader() {
-        return PlatformDependent0.getContextClassLoader();
+        return Thread.currentThread().getContextClassLoader();
     }
 
     /**
diff --git a/common/src/main/java/io/netty/util/internal/PlatformDependent0.java b/common/src/main/java/io/netty/util/internal/PlatformDependent0.java
index 40bb38352b6..f6359c2f97a 100644
--- a/common/src/main/java/io/netty/util/internal/PlatformDependent0.java
+++ b/common/src/main/java/io/netty/util/internal/PlatformDependent0.java
@@ -24,12 +24,9 @@
 import java.lang.invoke.MethodType;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.Field;
-import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 import java.nio.Buffer;
 import java.nio.ByteBuffer;
-import java.security.AccessController;
-import java.security.PrivilegedAction;
 import java.util.concurrent.atomic.AtomicLong;
 
 import static java.lang.invoke.MethodType.methodType;
@@ -100,44 +97,25 @@ final class PlatformDependent0 {
             direct = ByteBuffer.allocateDirect(1);
 
             // attempt to access field Unsafe#theUnsafe
-            final Object maybeUnsafe = AccessController.doPrivileged(new PrivilegedAction<Object>() {
-                @Override
-                public Object run() {
-                    try {
-                        final Field unsafeField = Unsafe.class.getDeclaredField("theUnsafe");
-                        // We always want to try using Unsafe as the access still works on java9 as well and
-                        // we need it for out native-transports and many optimizations.
-                        Throwable cause = ReflectionUtil.trySetAccessible(unsafeField, false);
-                        if (cause != null) {
-                            return cause;
-                        }
-                        // the unsafe instance
-                        return unsafeField.get(null);
-                    } catch (NoSuchFieldException | IllegalAccessException | SecurityException e) {
-                        return e;
-                    } catch (NoClassDefFoundError e) {
-                        // Also catch NoClassDefFoundError in case someone uses for example OSGI and it made
-                        // Unsafe unloadable.
-                        return e;
-                    }
+            try {
+                final Field unsafeField = Unsafe.class.getDeclaredField("theUnsafe");
+                // We always want to try using Unsafe as the access still works on java9 as well and
+                // we need it for out native-transports and many optimizations.
+                Throwable cause = ReflectionUtil.trySetAccessible(unsafeField, false);
+                if (cause != null) {
+                    throw (Throwable) cause;
                 }
-            });
-
-            // the conditional check here can not be replaced with checking that maybeUnsafe
-            // is an instanceof Unsafe and reversing the if and else blocks; this is because an
-            // instanceof check against Unsafe will trigger a class load and we might not have
-            // the runtime permission accessClassInPackage.sun.misc
-            if (maybeUnsafe instanceof Throwable) {
+                // the unsafe instance
+                unsafe = (Unsafe) unsafeField.get(null);
+                logger.debug("sun.misc.Unsafe.theUnsafe: available");
+            } catch (Throwable e) {
                 unsafe = null;
-                unsafeUnavailabilityCause = (Throwable) maybeUnsafe;
+                unsafeUnavailabilityCause = e;
                 if (logger.isTraceEnabled()) {
                     logger.debug("sun.misc.Unsafe.theUnsafe: unavailable", unsafeUnavailabilityCause);
                 } else {
                     logger.debug("sun.misc.Unsafe.theUnsafe: unavailable: {}", unsafeUnavailabilityCause.getMessage());
                 }
-            } else {
-                unsafe = (Unsafe) maybeUnsafe;
-                logger.debug("sun.misc.Unsafe.theUnsafe: available");
             }
 
             // ensure the unsafe supports all necessary methods to work around the mistake in the latest OpenJDK,
@@ -146,61 +124,49 @@ public Object run() {
             // https://www.mail-archive.com/jdk6-dev@openjdk.java.net/msg00698.html
             // https://openjdk.org/jeps/471
             if (unsafe != null) {
-                final Unsafe finalUnsafe = unsafe;
-                final Object maybeException = AccessController.doPrivileged(new PrivilegedAction<Object>() {
-                    @Override
-                    public Object run() {
-                        try {
-                            // Other methods like storeFence() and invokeCleaner() are tested for elsewhere.
-                            Class<? extends Unsafe> cls = finalUnsafe.getClass();
-                            cls.getDeclaredMethod(
-                                    "copyMemory", Object.class, long.class, Object.class, long.class, long.class);
-                            if (javaVersion() > 23) {
-                                cls.getDeclaredMethod("objectFieldOffset", Field.class);
-                                cls.getDeclaredMethod("staticFieldOffset", Field.class);
-                                cls.getDeclaredMethod("staticFieldBase", Field.class);
-                                cls.getDeclaredMethod("arrayBaseOffset", Class.class);
-                                cls.getDeclaredMethod("arrayIndexScale", Class.class);
-                                cls.getDeclaredMethod("allocateMemory", long.class);
-                                cls.getDeclaredMethod("reallocateMemory", long.class, long.class);
-                                cls.getDeclaredMethod("freeMemory", long.class);
-                                cls.getDeclaredMethod("setMemory", long.class, long.class, byte.class);
-                                cls.getDeclaredMethod("setMemory", Object.class, long.class, long.class, byte.class);
-                                cls.getDeclaredMethod("getBoolean", Object.class, long.class);
-                                cls.getDeclaredMethod("getByte", long.class);
-                                cls.getDeclaredMethod("getByte", Object.class, long.class);
-                                cls.getDeclaredMethod("getInt", long.class);
-                                cls.getDeclaredMethod("getInt", Object.class, long.class);
-                                cls.getDeclaredMethod("getLong", long.class);
-                                cls.getDeclaredMethod("getLong", Object.class, long.class);
-                                cls.getDeclaredMethod("putByte", long.class, byte.class);
-                                cls.getDeclaredMethod("putByte", Object.class, long.class, byte.class);
-                                cls.getDeclaredMethod("putInt", long.class, int.class);
-                                cls.getDeclaredMethod("putInt", Object.class, long.class, int.class);
-                                cls.getDeclaredMethod("putLong", long.class, long.class);
-                                cls.getDeclaredMethod("putLong", Object.class, long.class, long.class);
-                                cls.getDeclaredMethod("addressSize");
-                            }
-                            if (javaVersion() >= 23) {
-                                // The following tests the methods are usable.
-                                // Will throw UnsupportedOperationException if unsafe memory access is denied:
-                                long address = finalUnsafe.allocateMemory(8);
-                                finalUnsafe.putLong(address, 42);
-                                finalUnsafe.freeMemory(address);
-                            }
-                            return null;
-                        } catch (UnsupportedOperationException | SecurityException | NoSuchMethodException e) {
-                            return e;
-                        }
+                try {
+                    // Other methods like storeFence() and invokeCleaner() are tested for elsewhere.
+                    Class<? extends Unsafe> cls = unsafe.getClass();
+                    cls.getDeclaredMethod(
+                            "copyMemory", Object.class, long.class, Object.class, long.class, long.class);
+                    if (javaVersion() > 23) {
+                        cls.getDeclaredMethod("objectFieldOffset", Field.class);
+                        cls.getDeclaredMethod("staticFieldOffset", Field.class);
+                        cls.getDeclaredMethod("staticFieldBase", Field.class);
+                        cls.getDeclaredMethod("arrayBaseOffset", Class.class);
+                        cls.getDeclaredMethod("arrayIndexScale", Class.class);
+                        cls.getDeclaredMethod("allocateMemory", long.class);
+                        cls.getDeclaredMethod("reallocateMemory", long.class, long.class);
+                        cls.getDeclaredMethod("freeMemory", long.class);
+                        cls.getDeclaredMethod("setMemory", long.class, long.class, byte.class);
+                        cls.getDeclaredMethod("setMemory", Object.class, long.class, long.class, byte.class);
+                        cls.getDeclaredMethod("getBoolean", Object.class, long.class);
+                        cls.getDeclaredMethod("getByte", long.class);
+                        cls.getDeclaredMethod("getByte", Object.class, long.class);
+                        cls.getDeclaredMethod("getInt", long.class);
+                        cls.getDeclaredMethod("getInt", Object.class, long.class);
+                        cls.getDeclaredMethod("getLong", long.class);
+                        cls.getDeclaredMethod("getLong", Object.class, long.class);
+                        cls.getDeclaredMethod("putByte", long.class, byte.class);
+                        cls.getDeclaredMethod("putByte", Object.class, long.class, byte.class);
+                        cls.getDeclaredMethod("putInt", long.class, int.class);
+                        cls.getDeclaredMethod("putInt", Object.class, long.class, int.class);
+                        cls.getDeclaredMethod("putLong", long.class, long.class);
+                        cls.getDeclaredMethod("putLong", Object.class, long.class, long.class);
+                        cls.getDeclaredMethod("addressSize");
+                    }
+                    if (javaVersion() >= 23) {
+                        // The following tests the methods are usable.
+                        // Will throw UnsupportedOperationException if unsafe memory access is denied:
+                        long address = unsafe.allocateMemory(8);
+                        unsafe.putLong(address, 42);
+                        unsafe.freeMemory(address);
                     }
-                });
-
-                if (maybeException == null) {
                     logger.debug("sun.misc.Unsafe base methods: all available");
-                } else {
-                    // Unsafe.copyMemory(Object, long, Object, long, long) unavailable.
+                } catch (Throwable e) {
+                    // Unsafe.copyMemory(Object, long, Object, long, long) unavailable, etc.
                     unsafe = null;
-                    unsafeUnavailabilityCause = (Throwable) maybeException;
+                    unsafeUnavailabilityCause = e;
                     if (logger.isTraceEnabled()) {
                         logger.debug("sun.misc.Unsafe method unavailable:", unsafeUnavailabilityCause);
                     } else {
@@ -210,40 +176,27 @@ public Object run() {
             }
 
             if (unsafe != null) {
-                final Unsafe finalUnsafe = unsafe;
-
                 // attempt to access field Buffer#address
-                final Object maybeAddressField = AccessController.doPrivileged(new PrivilegedAction<Object>() {
-                    @Override
-                    public Object run() {
-                        try {
-                            final Field field = Buffer.class.getDeclaredField("address");
-                            // Use Unsafe to read value of the address field. This way it will not fail on JDK9+ which
-                            // will forbid changing the access level via reflection.
-                            final long offset = finalUnsafe.objectFieldOffset(field);
-                            final long address = finalUnsafe.getLong(direct, offset);
-
-                            // if direct really is a direct buffer, address will be non-zero
-                            if (address == 0) {
-                                return null;
-                            }
-                            return field;
-                        } catch (NoSuchFieldException | SecurityException e) {
-                            return e;
-                        }
+                try {
+                    final Field field = Buffer.class.getDeclaredField("address");
+                    // Use Unsafe to read value of the address field. This way it will not fail on JDK9+ which
+                    // will forbid changing the access level via reflection.
+                    final long offset = unsafe.objectFieldOffset(field);
+                    final long address = unsafe.getLong(direct, offset);
+
+                    // if direct really is a direct buffer, address will be non-zero
+                    if (address != 0) {
+                        addressField = field;
+                        logger.debug("java.nio.Buffer.address: available");
+                    } else {
+                        throw new UnsupportedOperationException("Address of direct byte buffer was zero");
                     }
-                });
-
-                if (maybeAddressField instanceof Field) {
-                    addressField = (Field) maybeAddressField;
-                    logger.debug("java.nio.Buffer.address: available");
-                } else {
-                    unsafeUnavailabilityCause = (Throwable) maybeAddressField;
+                } catch (Throwable e) {
+                    unsafeUnavailabilityCause = e;
                     if (logger.isTraceEnabled()) {
-                        logger.debug("java.nio.Buffer.address: unavailable", (Throwable) maybeAddressField);
+                        logger.debug("java.nio.Buffer.address: unavailable", e);
                     } else {
-                        logger.debug("java.nio.Buffer.address: unavailable: {}",
-                                ((Throwable) maybeAddressField).getMessage());
+                        logger.debug("java.nio.Buffer.address: unavailable: {}", e.getMessage());
                     }
 
                     // If we cannot access the address of a direct buffer, there's no point of using unsafe.
@@ -281,45 +234,27 @@ public Object run() {
             MethodHandle directBufferConstructor;
             long address = -1;
             try {
-                final Object maybeDirectBufferConstructor =
-                        AccessController.doPrivileged(new PrivilegedAction<Object>() {
-                            @Override
-                            public Object run() {
-                                try {
-                                    Class<? extends ByteBuffer> directClass = direct.getClass();
-                                    final Constructor<?> constructor = javaVersion() >= 21 ?
-                                            directClass.getDeclaredConstructor(long.class, long.class) :
-                                            directClass.getDeclaredConstructor(long.class, int.class);
-                                    Throwable cause = ReflectionUtil.trySetAccessible(constructor, true);
-                                    if (cause != null) {
-                                        return cause;
-                                    }
-                                    return lookup.unreflectConstructor(constructor)
-                                            .asType(methodType(ByteBuffer.class, long.class, int.class));
-                                } catch (Throwable e) {
-                                    return e;
-                                }
-                            }
-                        });
-
-                if (maybeDirectBufferConstructor instanceof MethodHandle) {
+                try {
+                    Class<? extends ByteBuffer> directClass = direct.getClass();
+                    final Constructor<?> constructor = javaVersion() >= 21 ?
+                            directClass.getDeclaredConstructor(long.class, long.class) :
+                            directClass.getDeclaredConstructor(long.class, int.class);
+                    Throwable cause = ReflectionUtil.trySetAccessible(constructor, true);
+                    if (cause != null) {
+                        throw cause;
+                    }
+                    MethodHandle constructorHandle = lookup.unreflectConstructor(constructor)
+                            .asType(methodType(ByteBuffer.class, long.class, int.class));
                     address = UNSAFE.allocateMemory(1);
                     // try to use the constructor now
-                    try {
-                        MethodHandle constructor = (MethodHandle) maybeDirectBufferConstructor;
-                        ByteBuffer ignore = (ByteBuffer) constructor.invokeExact(address, 1);
-                        directBufferConstructor = constructor;
-                        logger.debug("direct buffer constructor: available");
-                    } catch (Throwable e) {
-                        directBufferConstructor = null;
-                    }
-                } else {
+                    ByteBuffer ignore = (ByteBuffer) constructorHandle.invokeExact(address, 1);
+                    directBufferConstructor = constructorHandle;
+                    logger.debug("direct buffer constructor: available");
+                } catch (Throwable e) {
                     if (logger.isTraceEnabled()) {
-                        logger.debug("direct buffer constructor: unavailable",
-                                (Throwable) maybeDirectBufferConstructor);
+                        logger.debug("direct buffer constructor: unavailable", e);
                     } else {
-                        logger.debug("direct buffer constructor: unavailable: {}",
-                                ((Throwable) maybeDirectBufferConstructor).getMessage());
+                        logger.debug("direct buffer constructor: unavailable: {}", e.getMessage());
                     }
                     directBufferConstructor = null;
                 }
@@ -335,200 +270,162 @@ public Object run() {
             INT_ARRAY_INDEX_SCALE = UNSAFE.arrayIndexScale(int[].class);
             LONG_ARRAY_BASE_OFFSET = UNSAFE.arrayBaseOffset(long[].class);
             LONG_ARRAY_INDEX_SCALE = UNSAFE.arrayIndexScale(long[].class);
-            final boolean unaligned;
+            Boolean unaligned = null;
             // using a known type to avoid loading new classes
             final AtomicLong maybeMaxMemory = new AtomicLong(-1);
-            Object maybeUnaligned = AccessController.doPrivileged(new PrivilegedAction<Object>() {
-                @Override
-                public Object run() {
+            try {
+                Class<?> bitsClass =
+                        Class.forName("java.nio.Bits", false, getSystemClassLoader());
+                int version = javaVersion();
+                if (version >= 9) {
+                    // Java9/10 use all lowercase and later versions all uppercase.
+                    String fieldName = version >= 11? "MAX_MEMORY" : "maxMemory";
+                    // On Java9 and later we try to directly access the field as we can do this without
+                    // adjust the accessible levels.
                     try {
-                        Class<?> bitsClass =
-                                Class.forName("java.nio.Bits", false, getSystemClassLoader());
-                        int version = javaVersion();
-                        if (version >= 9) {
-                            // Java9/10 use all lowercase and later versions all uppercase.
-                            String fieldName = version >= 11? "MAX_MEMORY" : "maxMemory";
-                            // On Java9 and later we try to directly access the field as we can do this without
-                            // adjust the accessible levels.
-                            try {
-                                Field maxMemoryField = bitsClass.getDeclaredField(fieldName);
-                                if (maxMemoryField.getType() == long.class) {
-                                    long offset = UNSAFE.staticFieldOffset(maxMemoryField);
-                                    Object object = UNSAFE.staticFieldBase(maxMemoryField);
-                                    maybeMaxMemory.lazySet(UNSAFE.getLong(object, offset));
-                                }
-                            } catch (Throwable ignore) {
-                                // ignore if can't access
-                            }
-                            fieldName = version >= 11? "UNALIGNED" : "unaligned";
-                            try {
-                                Field unalignedField = bitsClass.getDeclaredField(fieldName);
-                                if (unalignedField.getType() == boolean.class) {
-                                    long offset = UNSAFE.staticFieldOffset(unalignedField);
-                                    Object object = UNSAFE.staticFieldBase(unalignedField);
-                                    return UNSAFE.getBoolean(object, offset);
-                                }
-                                // There is something unexpected stored in the field,
-                                // let us fall-back and try to use a reflective method call as last resort.
-                            } catch (NoSuchFieldException ignore) {
-                                // We did not find the field we expected, move on.
-                            }
+                        Field maxMemoryField = bitsClass.getDeclaredField(fieldName);
+                        if (maxMemoryField.getType() == long.class) {
+                            long offset = UNSAFE.staticFieldOffset(maxMemoryField);
+                            Object object = UNSAFE.staticFieldBase(maxMemoryField);
+                            maybeMaxMemory.lazySet(UNSAFE.getLong(object, offset));
                         }
-                        Method unalignedMethod = bitsClass.getDeclaredMethod("unaligned");
-                        Throwable cause = ReflectionUtil.trySetAccessible(unalignedMethod, true);
-                        if (cause != null) {
-                            return cause;
+                    } catch (Throwable ignore) {
+                        // ignore if can't access
+                    }
+                    fieldName = version >= 11? "UNALIGNED" : "unaligned";
+                    try {
+                        Field unalignedField = bitsClass.getDeclaredField(fieldName);
+                        if (unalignedField.getType() == boolean.class) {
+                            long offset = UNSAFE.staticFieldOffset(unalignedField);
+                            Object object = UNSAFE.staticFieldBase(unalignedField);
+                            unaligned = UNSAFE.getBoolean(object, offset);
                         }
-                        return unalignedMethod.invoke(null);
-                    } catch (NoSuchMethodException | SecurityException | IllegalAccessException |
-                             InvocationTargetException | ClassNotFoundException e) {
-                        return e;
+                        // There is something unexpected stored in the field,
+                        // let us fall-back and try to use a reflective method call as last resort.
+                    } catch (NoSuchFieldException ignore) {
+                        // We did not find the field we expected, move on.
                     }
                 }
-            });
-
-            if (maybeUnaligned instanceof Boolean) {
-                unaligned = (Boolean) maybeUnaligned;
+                if (unaligned == null) {
+                    Method unalignedMethod = bitsClass.getDeclaredMethod("unaligned");
+                    Throwable cause = ReflectionUtil.trySetAccessible(unalignedMethod, true);
+                    if (cause != null) {
+                        throw cause;
+                    }
+                    unaligned = (Boolean) unalignedMethod.invoke(null);
+                }
                 logger.debug("java.nio.Bits.unaligned: available, {}", unaligned);
-            } else {
+            } catch (Throwable e) {
                 String arch = SystemPropertyUtil.get("os.arch", "");
                 //noinspection DynamicRegexReplaceableByCompiledPattern
                 unaligned = arch.matches("^(i[3-6]86|x86(_64)?|x64|amd64)$");
-                Throwable t = (Throwable) maybeUnaligned;
                 if (logger.isTraceEnabled()) {
-                    logger.debug("java.nio.Bits.unaligned: unavailable, {}", unaligned, t);
+                    logger.debug("java.nio.Bits.unaligned: unavailable, {}", unaligned, e);
                 } else {
-                    logger.debug("java.nio.Bits.unaligned: unavailable, {}, {}", unaligned, t.getMessage());
+                    logger.debug("java.nio.Bits.unaligned: unavailable, {}, {}", unaligned, e.getMessage());
                 }
             }
 
             UNALIGNED = unaligned;
             BITS_MAX_DIRECT_MEMORY = maybeMaxMemory.get() >= 0? maybeMaxMemory.get() : -1;
 
-            if (javaVersion() >= 9) {
-                Object maybeException = AccessController.doPrivileged(new PrivilegedAction<Object>() {
-                    @Override
-                    public Object run() {
-                        try {
-                            // Java9 has jdk.internal.misc.Unsafe and not all methods are propagated to
-                            // sun.misc.Unsafe
-                            Class<?> cls = getClassLoader(PlatformDependent0.class)
-                                    .loadClass("jdk.internal.misc.Unsafe");
-                            return lookup.findStatic(cls, "getUnsafe", methodType(cls)).invoke();
-                        } catch (Throwable e) {
-                            return e;
-                        }
-                    }
-                });
-                if (!(maybeException instanceof Throwable)) {
-                    final Object finalInternalUnsafe = maybeException;
-                    maybeException = AccessController.doPrivileged(new PrivilegedAction<Object>() {
-                        @Override
-                        public Object run() {
-                            try {
-                                Class<?> finalInternalUnsafeClass = finalInternalUnsafe.getClass();
-                                return lookup.findVirtual(
-                                        finalInternalUnsafeClass,
-                                        "allocateUninitializedArray",
-                                        methodType(Object.class, Class.class, int.class));
-                            } catch (Throwable e) {
-                                return e;
-                            }
-                        }
-                    });
-
-                    if (maybeException instanceof MethodHandle) {
-                        try {
-                            MethodHandle m = (MethodHandle) maybeException;
-                            m = m.bindTo(finalInternalUnsafe);
-                            byte[] bytes = (byte[]) (Object) m.invokeExact(byte.class, 8);
-                            assert bytes.length == 8;
-                            allocateArrayMethod = m;
-                        } catch (Throwable e) {
-                            maybeException = e;
-                        }
-                    }
-                }
-
-                if (maybeException instanceof Throwable) {
-                    if (logger.isTraceEnabled()) {
-                        logger.debug("jdk.internal.misc.Unsafe.allocateUninitializedArray(int): unavailable",
-                                (Throwable) maybeException);
-                    } else {
-                        logger.debug("jdk.internal.misc.Unsafe.allocateUninitializedArray(int): unavailable: {}",
-                                ((Throwable) maybeException).getMessage());
-                    }
+            try {
+                // Java9 and above has jdk.internal.misc.Unsafe and not all methods are propagated to
+                // sun.misc.Unsafe
+                Class<?> cls = getClassLoader(PlatformDependent0.class)
+                        .loadClass("jdk.internal.misc.Unsafe");
+                Object internalUnsafe = lookup.findStatic(cls, "getUnsafe", methodType(cls)).invoke();
+                Class<?> internalUnsafeClass = internalUnsafe.getClass();
+                MethodHandle m = lookup.findVirtual(
+                        internalUnsafeClass,
+                        "allocateUninitializedArray",
+                        methodType(Object.class, Class.class, int.class));
+                m = m.bindTo(internalUnsafe);
+                byte[] bytes = (byte[]) (Object) m.invokeExact(byte.class, 8);
+                assert bytes.length == 8;
+                allocateArrayMethod = m;
+                logger.debug("jdk.internal.misc.Unsafe.allocateUninitializedArray(int): available");
+            } catch (Throwable e) {
+                if (logger.isTraceEnabled()) {
+                    logger.debug("jdk.internal.misc.Unsafe.allocateUninitializedArray(int): unavailable", e);
                 } else {
-                    logger.debug("jdk.internal.misc.Unsafe.allocateUninitializedArray(int): available");
+                    logger.debug("jdk.internal.misc.Unsafe.allocateUninitializedArray(int): unavailable: {}",
+                            e.getMessage());
                 }
-            } else {
-                logger.debug("jdk.internal.misc.Unsafe.allocateUninitializedArray(int): unavailable prior to Java9");
             }
             ALLOCATE_ARRAY_METHOD = allocateArrayMethod;
         }
 
         if (javaVersion() > 9) {
-            ALIGN_SLICE = (MethodHandle) AccessController.doPrivileged(new PrivilegedAction<Object>() {
-                @Override
-                public Object run() {
-                    try {
-                        return MethodHandles.publicLookup().findVirtual(
-                                ByteBuffer.class, "alignedSlice", methodType(ByteBuffer.class, int.class));
-                    } catch (Throwable e) {
-                        return null;
-                    }
+            MethodHandle alignedSlice;
+            try {
+                alignedSlice = MethodHandles.publicLookup().findVirtual(
+                        ByteBuffer.class, "alignedSlice", methodType(ByteBuffer.class, int.class));
+            } catch (Throwable e) {
+                if (logger.isTraceEnabled()) {
+                    logger.debug("ByteBuffer.alignedSlice: unavailable", e);
+                } else {
+                    logger.debug("ByteBuffer.alignedSlice: unavailable");
                 }
-            });
+                alignedSlice = null;
+            }
+            ALIGN_SLICE = alignedSlice;
         } else {
             ALIGN_SLICE = null;
         }
 
         if (javaVersion() >= 13) {
-            OFFSET_SLICE = (MethodHandle) AccessController.doPrivileged(new PrivilegedAction<Object>() {
-                @Override
-                public Object run() {
-                    try {
-                        return MethodHandles.publicLookup().findVirtual(
-                                ByteBuffer.class, "slice", methodType(ByteBuffer.class, int.class, int.class));
-                    } catch (Throwable e) {
-                        return null;
-                    }
+            MethodHandle offsetSlice;
+            try {
+                offsetSlice = MethodHandles.publicLookup().findVirtual(
+                        ByteBuffer.class, "slice", methodType(ByteBuffer.class, int.class, int.class));
+            } catch (Throwable e) {
+                offsetSlice = null;
+                if (logger.isTraceEnabled()) {
+                    logger.debug("ByteBuffer.slice with offset: unavailable", e);
+                } else {
+                    logger.debug("ByteBuffer.slice with offset: unavailable");
                 }
-            });
+            }
+            OFFSET_SLICE = offsetSlice;
         } else {
             OFFSET_SLICE = null;
         }
 
         if (javaVersion() >= 16) {
-            ABSOLUTE_PUT_BUFFER = (MethodHandle) AccessController.doPrivileged(new PrivilegedAction<Object>() {
-                @Override
-                public Object run() {
-                    try {
-                        MethodType type =
-                                methodType(ByteBuffer.class, int.class, ByteBuffer.class, int.class, int.class);
-                        return MethodHandles.publicLookup().findVirtual(ByteBuffer.class, "put", type);
-                    } catch (Throwable e) {
-                        return null;
-                    }
+            MethodHandle absolutePut;
+            try {
+                MethodType type =
+                        methodType(ByteBuffer.class, int.class, ByteBuffer.class, int.class, int.class);
+                absolutePut = MethodHandles.publicLookup().findVirtual(ByteBuffer.class, "put", type);
+            } catch (Throwable e) {
+                absolutePut = null;
+                if (logger.isTraceEnabled()) {
+                    logger.debug("ByteBuffer.put with absolute offsets: unavailable", e);
+                } else {
+                    logger.debug("ByteBuffer.put with absolute offsets: unavailable");
                 }
-            });
+            }
+            ABSOLUTE_PUT_BUFFER = absolutePut;
         } else {
             ABSOLUTE_PUT_BUFFER = null;
         }
 
         if (javaVersion() >= 13) {
-            ABSOLUTE_PUT_ARRAY = (MethodHandle) AccessController.doPrivileged(new PrivilegedAction<Object>() {
-                @Override
-                public Object run() {
-                    try {
-                        MethodType type =
-                                methodType(ByteBuffer.class, int.class, byte[].class, int.class, int.class);
-                        return MethodHandles.publicLookup().findVirtual(ByteBuffer.class, "put", type);
-                    } catch (Throwable e) {
-                        return null;
-                    }
+            MethodHandle absolutePut;
+            try {
+                MethodType type =
+                        methodType(ByteBuffer.class, int.class, byte[].class, int.class, int.class);
+                absolutePut = MethodHandles.publicLookup().findVirtual(ByteBuffer.class, "put", type);
+            } catch (Throwable e) {
+                absolutePut = null;
+                if (logger.isTraceEnabled()) {
+                    logger.debug("ByteBuffer.put array with absolute offsets: unavailable", e);
+                } else {
+                    logger.debug("ByteBuffer.put array with absolute offsets: unavailable");
                 }
-            });
+            }
+            ABSOLUTE_PUT_ARRAY = absolutePut;
         } else {
             ABSOLUTE_PUT_ARRAY = null;
         }
@@ -1070,42 +967,11 @@ static int hashCodeAsciiSanitize(byte value) {
     }
 
     static ClassLoader getClassLoader(final Class<?> clazz) {
-        if (System.getSecurityManager() == null) {
-            return clazz.getClassLoader();
-        } else {
-            return AccessController.doPrivileged(new PrivilegedAction<ClassLoader>() {
-                @Override
-                public ClassLoader run() {
-                    return clazz.getClassLoader();
-                }
-            });
-        }
-    }
-
-    static ClassLoader getContextClassLoader() {
-        if (System.getSecurityManager() == null) {
-            return Thread.currentThread().getContextClassLoader();
-        } else {
-            return AccessController.doPrivileged(new PrivilegedAction<ClassLoader>() {
-                @Override
-                public ClassLoader run() {
-                    return Thread.currentThread().getContextClassLoader();
-                }
-            });
-        }
+        return clazz.getClassLoader();
     }
 
     static ClassLoader getSystemClassLoader() {
-        if (System.getSecurityManager() == null) {
-            return ClassLoader.getSystemClassLoader();
-        } else {
-            return AccessController.doPrivileged(new PrivilegedAction<ClassLoader>() {
-                @Override
-                public ClassLoader run() {
-                    return ClassLoader.getSystemClassLoader();
-                }
-            });
-        }
+        return ClassLoader.getSystemClassLoader();
     }
 
     static int addressSize() {
diff --git a/common/src/main/java/io/netty/util/internal/SocketUtils.java b/common/src/main/java/io/netty/util/internal/SocketUtils.java
index 8404477e0f8..d864d326745 100644
--- a/common/src/main/java/io/netty/util/internal/SocketUtils.java
+++ b/common/src/main/java/io/netty/util/internal/SocketUtils.java
@@ -23,23 +23,15 @@
 import java.net.Socket;
 import java.net.SocketAddress;
 import java.net.SocketException;
-import java.net.SocketPermission;
 import java.net.UnknownHostException;
 import java.nio.channels.DatagramChannel;
 import java.nio.channels.ServerSocketChannel;
 import java.nio.channels.SocketChannel;
-import java.security.AccessController;
-import java.security.PrivilegedAction;
-import java.security.PrivilegedActionException;
-import java.security.PrivilegedExceptionAction;
 import java.util.Collections;
 import java.util.Enumeration;
 
 /**
- * Provides socket operations with privileges enabled. This is necessary for applications that use the
- * {@link SecurityManager} to restrict {@link SocketPermission} to their application. By asserting that these
- * operations are privileged, the operations can proceed even if some code in the calling chain lacks the appropriate
- * {@link SocketPermission}.
+ * Provides socket operations with platform-specific adaptations and bug mitigations.
  */
 public final class SocketUtils {
 
@@ -55,140 +47,49 @@ private static <T> Enumeration<T> empty() {
 
     public static void connect(final Socket socket, final SocketAddress remoteAddress, final int timeout)
             throws IOException {
-        try {
-            AccessController.doPrivileged(new PrivilegedExceptionAction<Void>() {
-                @Override
-                public Void run() throws IOException {
-                    socket.connect(remoteAddress, timeout);
-                    return null;
-                }
-            });
-        } catch (PrivilegedActionException e) {
-            throw (IOException) e.getCause();
-        }
+        socket.connect(remoteAddress, timeout);
     }
 
     public static void bind(final Socket socket, final SocketAddress bindpoint) throws IOException {
-        try {
-            AccessController.doPrivileged(new PrivilegedExceptionAction<Void>() {
-                @Override
-                public Void run() throws IOException {
-                    socket.bind(bindpoint);
-                    return null;
-                }
-            });
-        } catch (PrivilegedActionException e) {
-            throw (IOException) e.getCause();
-        }
+        socket.bind(bindpoint);
     }
 
     public static boolean connect(final SocketChannel socketChannel, final SocketAddress remoteAddress)
             throws IOException {
-        try {
-            return AccessController.doPrivileged(new PrivilegedExceptionAction<Boolean>() {
-                @Override
-                public Boolean run() throws IOException {
-                    return socketChannel.connect(remoteAddress);
-                }
-            });
-        } catch (PrivilegedActionException e) {
-            throw (IOException) e.getCause();
-        }
+        return socketChannel.connect(remoteAddress);
     }
 
     public static void bind(final SocketChannel socketChannel, final SocketAddress address) throws IOException {
-        try {
-            AccessController.doPrivileged(new PrivilegedExceptionAction<Void>() {
-                @Override
-                public Void run() throws IOException {
-                    socketChannel.bind(address);
-                    return null;
-                }
-            });
-        } catch (PrivilegedActionException e) {
-            throw (IOException) e.getCause();
-        }
+        socketChannel.bind(address);
     }
 
     public static SocketChannel accept(final ServerSocketChannel serverSocketChannel) throws IOException {
-        try {
-            return AccessController.doPrivileged(new PrivilegedExceptionAction<SocketChannel>() {
-                @Override
-                public SocketChannel run() throws IOException {
-                    return serverSocketChannel.accept();
-                }
-            });
-        } catch (PrivilegedActionException e) {
-            throw (IOException) e.getCause();
-        }
+        return serverSocketChannel.accept();
     }
 
     public static void bind(final DatagramChannel networkChannel, final SocketAddress address) throws IOException {
-        try {
-            AccessController.doPrivileged(new PrivilegedExceptionAction<Void>() {
-                @Override
-                public Void run() throws IOException {
-                    networkChannel.bind(address);
-                    return null;
-                }
-            });
-        } catch (PrivilegedActionException e) {
-            throw (IOException) e.getCause();
-        }
+        networkChannel.bind(address);
     }
 
     public static SocketAddress localSocketAddress(final ServerSocket socket) {
-        return AccessController.doPrivileged(new PrivilegedAction<SocketAddress>() {
-            @Override
-            public SocketAddress run() {
-                return socket.getLocalSocketAddress();
-            }
-        });
+        return socket.getLocalSocketAddress();
     }
 
     public static InetAddress addressByName(final String hostname) throws UnknownHostException {
-        try {
-            return AccessController.doPrivileged(new PrivilegedExceptionAction<InetAddress>() {
-                @Override
-                public InetAddress run() throws UnknownHostException {
-                    return InetAddress.getByName(hostname);
-                }
-            });
-        } catch (PrivilegedActionException e) {
-            throw (UnknownHostException) e.getCause();
-        }
+        return InetAddress.getByName(hostname);
     }
 
     public static InetAddress[] allAddressesByName(final String hostname) throws UnknownHostException {
-        try {
-            return AccessController.doPrivileged(new PrivilegedExceptionAction<InetAddress[]>() {
-                @Override
-                public InetAddress[] run() throws UnknownHostException {
-                    return InetAddress.getAllByName(hostname);
-                }
-            });
-        } catch (PrivilegedActionException e) {
-            throw (UnknownHostException) e.getCause();
-        }
+        return InetAddress.getAllByName(hostname);
     }
 
     public static InetSocketAddress socketAddress(final String hostname, final int port) {
-        return AccessController.doPrivileged(new PrivilegedAction<InetSocketAddress>() {
-            @Override
-            public InetSocketAddress run() {
-                return new InetSocketAddress(hostname, port);
-            }
-        });
+        return new InetSocketAddress(hostname, port);
     }
 
+    @SuppressWarnings("ConstantValue")
     public static Enumeration<InetAddress> addressesFromNetworkInterface(final NetworkInterface intf) {
-        Enumeration<InetAddress> addresses =
-                AccessController.doPrivileged(new PrivilegedAction<Enumeration<InetAddress>>() {
-            @Override
-            public Enumeration<InetAddress> run() {
-                return intf.getInetAddresses();
-            }
-        });
+        Enumeration<InetAddress> addresses = intf.getInetAddresses();
         // Android seems to sometimes return null even if this is not a valid return value by the api docs.
         // Just return an empty Enumeration in this case.
         // See https://github.com/netty/netty/issues/10045
@@ -199,24 +100,10 @@ public Enumeration<InetAddress> run() {
     }
 
     public static InetAddress loopbackAddress() {
-        return AccessController.doPrivileged(new PrivilegedAction<InetAddress>() {
-            @Override
-            public InetAddress run() {
-                return InetAddress.getLoopbackAddress();
-            }
-        });
+        return InetAddress.getLoopbackAddress();
     }
 
     public static byte[] hardwareAddressFromNetworkInterface(final NetworkInterface intf) throws SocketException {
-        try {
-            return AccessController.doPrivileged(new PrivilegedExceptionAction<byte[]>() {
-                @Override
-                public byte[] run() throws SocketException {
-                    return intf.getHardwareAddress();
-                }
-            });
-        } catch (PrivilegedActionException e) {
-            throw (SocketException) e.getCause();
-        }
+        return intf.getHardwareAddress();
     }
 }
diff --git a/common/src/main/java/io/netty/util/internal/SystemPropertyUtil.java b/common/src/main/java/io/netty/util/internal/SystemPropertyUtil.java
index b1b53234a7a..1fc09fb65e3 100644
--- a/common/src/main/java/io/netty/util/internal/SystemPropertyUtil.java
+++ b/common/src/main/java/io/netty/util/internal/SystemPropertyUtil.java
@@ -15,13 +15,10 @@
  */
 package io.netty.util.internal;
 
-import static io.netty.util.internal.ObjectUtil.checkNonEmpty;
-
 import io.netty.util.internal.logging.InternalLogger;
 import io.netty.util.internal.logging.InternalLoggerFactory;
 
-import java.security.AccessController;
-import java.security.PrivilegedAction;
+import static io.netty.util.internal.ObjectUtil.checkNonEmpty;
 
 /**
  * A collection of utility methods to retrieve and parse the values of the Java system properties.
@@ -60,21 +57,7 @@ public static String get(String key) {
     public static String get(final String key, String def) {
         checkNonEmpty(key, "key");
 
-        String value = null;
-        try {
-            if (System.getSecurityManager() == null) {
-                value = System.getProperty(key);
-            } else {
-                value = AccessController.doPrivileged(new PrivilegedAction<String>() {
-                    @Override
-                    public String run() {
-                        return System.getProperty(key);
-                    }
-                });
-            }
-        } catch (SecurityException e) {
-            logger.warn("Unable to retrieve a system property '{}'; default values will be used.", key, e);
-        }
+        String value = System.getProperty(key);
 
         if (value == null) {
             return def;
diff --git a/common/src/main/java/io/netty/util/internal/logging/Log4J2Logger.java b/common/src/main/java/io/netty/util/internal/logging/Log4J2Logger.java
index cc973206133..cc065312e1c 100644
--- a/common/src/main/java/io/netty/util/internal/logging/Log4J2Logger.java
+++ b/common/src/main/java/io/netty/util/internal/logging/Log4J2Logger.java
@@ -21,9 +21,6 @@
 import org.apache.logging.log4j.spi.ExtendedLogger;
 import org.apache.logging.log4j.spi.ExtendedLoggerWrapper;
 
-import java.security.AccessController;
-import java.security.PrivilegedAction;
-
 import static io.netty.util.internal.logging.AbstractInternalLogger.EXCEPTION_MESSAGE;
 
 class Log4J2Logger extends ExtendedLoggerWrapper implements InternalLogger {
@@ -35,21 +32,20 @@ class Log4J2Logger extends ExtendedLoggerWrapper implements InternalLogger {
         // Older Log4J2 versions have only log methods that takes the format + varargs. So we should not use
         // Log4J2 if the version is too old.
         // See https://github.com/netty/netty/issues/8217
-        VARARGS_ONLY = AccessController.doPrivileged(new PrivilegedAction<Boolean>() {
-            @Override
-            public Boolean run() {
-                try {
-                    Logger.class.getMethod("debug", String.class, Object.class);
-                    return false;
-                } catch (NoSuchMethodException ignore) {
-                    // Log4J2 version too old.
-                    return true;
-                } catch (SecurityException ignore) {
-                    // We could not detect the version so we will use Log4J2 if its on the classpath.
-                    return false;
-                }
-            }
-        });
+        VARARGS_ONLY = isLog4jVarArgsOnly();
+    }
+
+    private static boolean isLog4jVarArgsOnly() {
+        try {
+            Logger.class.getMethod("debug", String.class, Object.class);
+            return false;
+        } catch (NoSuchMethodException ignore) {
+            // Log4J2 version too old.
+            return true;
+        } catch (SecurityException ignore) {
+            // We could not detect the version so we will use Log4J2 if its on the classpath.
+            return false;
+        }
     }
 
     Log4J2Logger(Logger logger) {
diff --git a/handler/src/main/java/io/netty/handler/ssl/OpenSslParametersUtil.java b/handler/src/main/java/io/netty/handler/ssl/OpenSslParametersUtil.java
index efb560dd724..8b6ea73d3fd 100644
--- a/handler/src/main/java/io/netty/handler/ssl/OpenSslParametersUtil.java
+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslParametersUtil.java
@@ -17,12 +17,10 @@
 
 import io.netty.util.internal.PlatformDependent;
 
-import javax.net.ssl.SSLParameters;
 import java.lang.invoke.MethodHandle;
 import java.lang.invoke.MethodHandles;
 import java.lang.invoke.MethodType;
-import java.security.AccessController;
-import java.security.PrivilegedAction;
+import javax.net.ssl.SSLParameters;
 
 final class OpenSslParametersUtil {
 
@@ -45,15 +43,13 @@ final class OpenSslParametersUtil {
 
     private static MethodHandle obtainHandle(final MethodHandles.Lookup lookup,
                                              final String methodName, final MethodType type) {
-        return AccessController.doPrivileged((PrivilegedAction<MethodHandle>) () -> {
-            try {
-                return lookup.findVirtual(SSLParameters.class, methodName, type);
-            } catch (UnsupportedOperationException | SecurityException |
-                     NoSuchMethodException | IllegalAccessException e) {
-                // Just ignore it.
-                return null;
-            }
-        });
+        try {
+            return lookup.findVirtual(SSLParameters.class, methodName, type);
+        } catch (UnsupportedOperationException | SecurityException |
+                 NoSuchMethodException | IllegalAccessException e) {
+            // Just ignore it.
+            return null;
+        }
     }
 
     static String[] getNamesGroups(SSLParameters parameters) {
diff --git a/handler/src/main/java/io/netty/handler/ssl/OpenSslX509TrustManagerWrapper.java b/handler/src/main/java/io/netty/handler/ssl/OpenSslX509TrustManagerWrapper.java
index 99a76b19117..655735f3082 100644
--- a/handler/src/main/java/io/netty/handler/ssl/OpenSslX509TrustManagerWrapper.java
+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslX509TrustManagerWrapper.java
@@ -21,11 +21,9 @@
 import io.netty.util.internal.logging.InternalLoggerFactory;
 
 import java.lang.reflect.Field;
-import java.security.AccessController;
 import java.security.KeyManagementException;
 import java.security.NoSuchAlgorithmException;
 import java.security.NoSuchProviderException;
-import java.security.PrivilegedAction;
 import java.security.cert.CertificateException;
 import java.security.cert.X509Certificate;
 import javax.net.ssl.SSLContext;
@@ -96,43 +94,36 @@ public X509Certificate[] getAcceptedIssuers() {
             if (cause != null) {
                 LOGGER.debug("Unable to access wrapped TrustManager", cause);
             } else {
-                final SSLContext finalContext = context;
-                Object maybeWrapper = AccessController.doPrivileged(new PrivilegedAction<Object>() {
-                    @Override
-                    public Object run() {
-                        try {
-                            Field contextSpiField = SSLContext.class.getDeclaredField("contextSpi");
-                            final long spiOffset = PlatformDependent.objectFieldOffset(contextSpiField);
-                            Object spi = PlatformDependent.getObject(finalContext, spiOffset);
-                            if (spi != null) {
-                                Class<?> clazz = spi.getClass();
-
-                                // Let's cycle through the whole hierarchy until we find what we are looking for or
-                                // there is nothing left in which case we will not wrap at all.
-                                do {
-                                    try {
-                                        Field trustManagerField = clazz.getDeclaredField("trustManager");
-                                        final long tmOffset = PlatformDependent.objectFieldOffset(trustManagerField);
-                                        Object trustManager = PlatformDependent.getObject(spi, tmOffset);
-                                        if (trustManager instanceof X509ExtendedTrustManager) {
-                                            return new UnsafeTrustManagerWrapper(spiOffset, tmOffset);
-                                        }
-                                    } catch (NoSuchFieldException ignore) {
-                                        // try next
-                                    }
-                                    clazz = clazz.getSuperclass();
-                                } while (clazz != null);
+                try {
+                    Field contextSpiField = SSLContext.class.getDeclaredField("contextSpi");
+                    final long spiOffset = PlatformDependent.objectFieldOffset(contextSpiField);
+                    Object spi = PlatformDependent.getObject(context, spiOffset);
+                    boolean success = false;
+                    if (spi != null) {
+                        Class<?> clazz = spi.getClass();
+                        // Let's cycle through the whole hierarchy until we find what we are looking for or
+                        // there is nothing left in which case we will not wrap at all.
+                        do {
+                            try {
+                                Field trustManagerField = clazz.getDeclaredField("trustManager");
+                                final long tmOffset = PlatformDependent.objectFieldOffset(trustManagerField);
+                                Object trustManager = PlatformDependent.getObject(spi, tmOffset);
+                                if (trustManager instanceof X509ExtendedTrustManager) {
+                                    wrapper = new UnsafeTrustManagerWrapper(spiOffset, tmOffset);
+                                    success = true;
+                                    break;
+                                }
+                            } catch (NoSuchFieldException ignore) {
+                                // try next
                             }
-                            throw new NoSuchFieldException();
-                        } catch (NoSuchFieldException | SecurityException e) {
-                            return e;
-                        }
+                            clazz = clazz.getSuperclass();
+                        } while (clazz != null);
+                    }
+                    if (!success) {
+                        throw new NoSuchFieldException();
                     }
-                });
-                if (maybeWrapper instanceof Throwable) {
-                    LOGGER.debug("Unable to access wrapped TrustManager", (Throwable) maybeWrapper);
-                } else {
-                    wrapper = (TrustManagerWrapper) maybeWrapper;
+                } catch (NoSuchFieldException | SecurityException e) {
+                    LOGGER.debug("Unable to access wrapped TrustManager", e);
                 }
             }
         } else {
diff --git a/handler/src/main/java/io/netty/handler/ssl/util/BouncyCastleUtil.java b/handler/src/main/java/io/netty/handler/ssl/util/BouncyCastleUtil.java
index 3dc8805d675..bdb29f4d6db 100644
--- a/handler/src/main/java/io/netty/handler/ssl/util/BouncyCastleUtil.java
+++ b/handler/src/main/java/io/netty/handler/ssl/util/BouncyCastleUtil.java
@@ -19,8 +19,6 @@
 import io.netty.util.internal.logging.InternalLogger;
 import io.netty.util.internal.logging.InternalLoggerFactory;
 
-import java.security.AccessController;
-import java.security.PrivilegedAction;
 import java.security.Provider;
 import java.security.Security;
 import javax.net.ssl.SSLEngine;
@@ -164,72 +162,69 @@ private static void ensureLoaded() {
 
     @SuppressWarnings("unchecked")
     private static void tryLoading() {
-        AccessController.doPrivileged((PrivilegedAction<?>) () -> {
-            try {
-                // Check for bcprov-jdk18on or bc-fips:
-                Provider provider = Security.getProvider(BC_PROVIDER_NAME);
-                if (provider == null) {
-                    provider = Security.getProvider(BC_FIPS_PROVIDER_NAME);
-                }
-                if (provider == null) {
-                    ClassLoader classLoader = BouncyCastleUtil.class.getClassLoader();
-                    Class<Provider> bcProviderClass;
+        try {
+            // Check for bcprov-jdk18on or bc-fips:
+            Provider provider = Security.getProvider(BC_PROVIDER_NAME);
+            if (provider == null) {
+                provider = Security.getProvider(BC_FIPS_PROVIDER_NAME);
+            }
+            if (provider == null) {
+                ClassLoader classLoader = BouncyCastleUtil.class.getClassLoader();
+                Class<Provider> bcProviderClass;
+                try {
+                    bcProviderClass = (Class<Provider>) Class.forName(BC_PROVIDER, true, classLoader);
+                } catch (ClassNotFoundException e) {
                     try {
-                        bcProviderClass = (Class<Provider>) Class.forName(BC_PROVIDER, true, classLoader);
-                    } catch (ClassNotFoundException e) {
-                        try {
-                            bcProviderClass = (Class<Provider>) Class.forName(BC_FIPS_PROVIDER, true, classLoader);
-                        } catch (ClassNotFoundException ex) {
-                            ThrowableUtil.addSuppressed(e, ex);
-                            throw e;
-                        }
+                        bcProviderClass = (Class<Provider>) Class.forName(BC_FIPS_PROVIDER, true, classLoader);
+                    } catch (ClassNotFoundException ex) {
+                        ThrowableUtil.addSuppressed(e, ex);
+                        throw e;
                     }
-                    provider = bcProviderClass.getConstructor().newInstance();
                 }
-                bcProviderJce = provider;
-                logger.debug("Bouncy Castle provider available");
-            } catch (Throwable e) {
-                logger.debug("Cannot load Bouncy Castle provider", e);
-                unavailabilityCauseBcProv = e;
+                provider = bcProviderClass.getConstructor().newInstance();
             }
+            bcProviderJce = provider;
+            logger.debug("Bouncy Castle provider available");
+        } catch (Throwable e) {
+            logger.debug("Cannot load Bouncy Castle provider", e);
+            unavailabilityCauseBcProv = e;
+        }
 
-            try {
-                // Check for bcpkix-jdk18on:
-                ClassLoader classLoader = BouncyCastleUtil.class.getClassLoader();
-                Provider provider = bcProviderJce;
-                if (provider != null) {
-                    // Use provider class loader in case it was loaded by the system loader.
-                    classLoader = provider.getClass().getClassLoader();
-                }
-                Class.forName(BC_PEMPARSER, true, classLoader);
-                logger.debug("Bouncy Castle PKIX available");
-            } catch (Throwable e) {
-                logger.debug("Cannot load Bouncy Castle PKIX", e);
-                unavailabilityCauseBcPkix = e;
+        try {
+            // Check for bcpkix-jdk18on:
+            ClassLoader classLoader = BouncyCastleUtil.class.getClassLoader();
+            Provider provider = bcProviderJce;
+            if (provider != null) {
+                // Use provider class loader in case it was loaded by the system loader.
+                classLoader = provider.getClass().getClassLoader();
             }
+            Class.forName(BC_PEMPARSER, true, classLoader);
+            logger.debug("Bouncy Castle PKIX available");
+        } catch (Throwable e) {
+            logger.debug("Cannot load Bouncy Castle PKIX", e);
+            unavailabilityCauseBcPkix = e;
+        }
 
-            try {
-                // Check for bctls-jdk18on:
-                ClassLoader classLoader = BouncyCastleUtil.class.getClassLoader();
-                Provider provider = Security.getProvider(BC_JSSE_PROVIDER_NAME);
-                if (provider != null) {
-                    // Use provider class loader in case it was loaded by the system loader.
-                    classLoader = provider.getClass().getClassLoader();
-                } else {
-                    Class<?> providerClass = Class.forName(BC_JSSE_PROVIDER, true, classLoader);
-                    provider = (Provider) providerClass.getConstructor().newInstance();
-                }
-                bcSSLEngineClass = (Class<? extends SSLEngine>) Class.forName(BC_JSSE_SSLENGINE, true, classLoader);
-                Class.forName(BC_JSSE_ALPN_SELECTOR, true, classLoader);
-                bcProviderJsse = provider;
-                logger.debug("Bouncy Castle JSSE available");
-            } catch (Throwable e) {
-                logger.debug("Cannot load Bouncy Castle TLS", e);
-                unavailabilityCauseBcTls = e;
+        try {
+            // Check for bctls-jdk18on:
+            ClassLoader classLoader = BouncyCastleUtil.class.getClassLoader();
+            Provider provider = Security.getProvider(BC_JSSE_PROVIDER_NAME);
+            if (provider != null) {
+                // Use provider class loader in case it was loaded by the system loader.
+                classLoader = provider.getClass().getClassLoader();
+            } else {
+                Class<?> providerClass = Class.forName(BC_JSSE_PROVIDER, true, classLoader);
+                provider = (Provider) providerClass.getConstructor().newInstance();
             }
-            attemptedLoading = true;
-            return null;
-        });
+            bcSSLEngineClass = (Class<? extends SSLEngine>) Class.forName(BC_JSSE_SSLENGINE, true, classLoader);
+            Class.forName(BC_JSSE_ALPN_SELECTOR, true, classLoader);
+            bcProviderJsse = provider;
+            logger.debug("Bouncy Castle JSSE available");
+        } catch (Throwable e) {
+            logger.debug("Cannot load Bouncy Castle TLS", e);
+            unavailabilityCauseBcTls = e;
+        }
+        attemptedLoading = true;
     }
 
     private BouncyCastleUtil() {
diff --git a/handler/src/main/java/io/netty/handler/ssl/util/OpenJdkSelfSignedCertGenerator.java b/handler/src/main/java/io/netty/handler/ssl/util/OpenJdkSelfSignedCertGenerator.java
index a8a15fac08e..781e903a914 100644
--- a/handler/src/main/java/io/netty/handler/ssl/util/OpenJdkSelfSignedCertGenerator.java
+++ b/handler/src/main/java/io/netty/handler/ssl/util/OpenJdkSelfSignedCertGenerator.java
@@ -23,17 +23,13 @@
 import java.lang.invoke.MethodHandle;
 import java.lang.invoke.MethodHandles;
 import java.math.BigInteger;
-import java.security.AccessController;
 import java.security.KeyPair;
 import java.security.PrivateKey;
-import java.security.PrivilegedAction;
 import java.security.PublicKey;
 import java.security.SecureRandom;
 import java.security.cert.CertificateException;
 import java.security.cert.X509Certificate;
-import java.util.ArrayList;
 import java.util.Date;
-import java.util.List;
 
 import static io.netty.handler.ssl.util.SelfSignedCertificate.newSelfSignedCertificate;
 import static java.lang.invoke.MethodType.methodType;
@@ -94,167 +90,67 @@ final class OpenJdkSelfSignedCertGenerator {
         MethodHandle algorithmIdGetHandle = null;
 
         try {
-            Object maybeClasses = AccessController.doPrivileged(new PrivilegedAction<Object>() {
-                @Override
-                public Object run() {
-                    try {
-                        List<Class<?>> classes = new ArrayList<>();
-                        classes.add(Class.forName("sun.security.x509.X509CertInfo", false,
-                                PlatformDependent.getClassLoader(OpenJdkSelfSignedCertGenerator.class)));
-                        classes.add(Class.forName("sun.security.x509.X500Name", false,
-                                PlatformDependent.getClassLoader(OpenJdkSelfSignedCertGenerator.class)));
-                        classes.add(Class.forName("sun.security.x509.CertificateIssuerName", false,
-                                PlatformDependent.getClassLoader(OpenJdkSelfSignedCertGenerator.class)));
-                        classes.add(Class.forName("sun.security.x509.X509CertImpl", false,
-                                PlatformDependent.getClassLoader(OpenJdkSelfSignedCertGenerator.class)));
-                        classes.add(Class.forName("sun.security.x509.CertificateVersion", false,
-                                PlatformDependent.getClassLoader(OpenJdkSelfSignedCertGenerator.class)));
-                        classes.add(Class.forName("sun.security.x509.CertificateSubjectName", false,
-                                PlatformDependent.getClassLoader(OpenJdkSelfSignedCertGenerator.class)));
-                        classes.add(Class.forName("sun.security.x509.CertificateSerialNumber", false,
-                                PlatformDependent.getClassLoader(OpenJdkSelfSignedCertGenerator.class)));
-                        classes.add(Class.forName("sun.security.x509.CertificateValidity", false,
-                                PlatformDependent.getClassLoader(OpenJdkSelfSignedCertGenerator.class)));
-                        classes.add(Class.forName("sun.security.x509.CertificateX509Key", false,
-                                PlatformDependent.getClassLoader(OpenJdkSelfSignedCertGenerator.class)));
-                        classes.add(Class.forName("sun.security.x509.AlgorithmId", false,
-                                PlatformDependent.getClassLoader(OpenJdkSelfSignedCertGenerator.class)));
-                        classes.add(Class.forName("sun.security.x509.CertificateAlgorithmId", false,
-                                PlatformDependent.getClassLoader(OpenJdkSelfSignedCertGenerator.class)));
+            x509CertInfoClass = Class.forName("sun.security.x509.X509CertInfo", false,
+                    PlatformDependent.getClassLoader(OpenJdkSelfSignedCertGenerator.class));
+            x500NameClass = Class.forName("sun.security.x509.X500Name", false,
+                    PlatformDependent.getClassLoader(OpenJdkSelfSignedCertGenerator.class));
+            certificateIssuerNameClass = Class.forName("sun.security.x509.CertificateIssuerName", false,
+                    PlatformDependent.getClassLoader(OpenJdkSelfSignedCertGenerator.class));
+            x509CertImplClass = Class.forName("sun.security.x509.X509CertImpl", false,
+                    PlatformDependent.getClassLoader(OpenJdkSelfSignedCertGenerator.class));
+            certificateVersionClass = Class.forName("sun.security.x509.CertificateVersion", false,
+                    PlatformDependent.getClassLoader(OpenJdkSelfSignedCertGenerator.class));
+            certificateSubjectNameClass = Class.forName("sun.security.x509.CertificateSubjectName", false,
+                    PlatformDependent.getClassLoader(OpenJdkSelfSignedCertGenerator.class));
+            certificateSerialNumberClass = Class.forName("sun.security.x509.CertificateSerialNumber", false,
+                    PlatformDependent.getClassLoader(OpenJdkSelfSignedCertGenerator.class));
+            certificateValidityClass = Class.forName("sun.security.x509.CertificateValidity", false,
+                    PlatformDependent.getClassLoader(OpenJdkSelfSignedCertGenerator.class));
+            certificateX509KeyClass = Class.forName("sun.security.x509.CertificateX509Key", false,
+                    PlatformDependent.getClassLoader(OpenJdkSelfSignedCertGenerator.class));
+            algorithmIdClass = Class.forName("sun.security.x509.AlgorithmId", false,
+                    PlatformDependent.getClassLoader(OpenJdkSelfSignedCertGenerator.class));
+            certificateAlgorithmIdClass = Class.forName("sun.security.x509.CertificateAlgorithmId", false,
+                    PlatformDependent.getClassLoader(OpenJdkSelfSignedCertGenerator.class));
+
+            x509CertInfoConstructor = lookup.unreflectConstructor(x509CertInfoClass.getConstructor())
+                            .asType(methodType(x509CertInfoClass));
+            issuerNameConstructor = lookup.unreflectConstructor(
+                    certificateIssuerNameClass.getConstructor(x500NameClass))
+                    .asType(methodType(certificateIssuerNameClass, x500NameClass));
+            certImplConstructor = lookup.unreflectConstructor(x509CertImplClass.getConstructor(x509CertInfoClass))
+                            .asType(methodType(x509CertImplClass, x509CertInfoClass));
+            x500NameConstructor = lookup.unreflectConstructor(x500NameClass.getConstructor(String.class))
+                            .asType(methodType(x500NameClass, String.class));
+            certificateVersionConstructor = lookup.unreflectConstructor(
+                    certificateVersionClass.getConstructor(int.class))
+                    .asType(methodType(certificateVersionClass, int.class));
+            certificateSubjectNameConstructor = lookup.unreflectConstructor(
+                    certificateSubjectNameClass.getConstructor(x500NameClass))
+                    .asType(methodType(certificateSubjectNameClass, x500NameClass));
+            certificateSerialNumberConstructor = lookup.unreflectConstructor(
+                                    certificateSerialNumberClass.getConstructor(BigInteger.class))
+                            .asType(methodType(certificateSerialNumberClass, BigInteger.class));
+            certificateValidityConstructor = lookup.unreflectConstructor(
+                                    certificateValidityClass.getConstructor(Date.class, Date.class))
+                            .asType(methodType(certificateValidityClass, Date.class, Date.class));
+            certificateX509KeyConstructor = lookup.unreflectConstructor(
+                    certificateX509KeyClass.getConstructor(PublicKey.class))
+                    .asType(methodType(certificateX509KeyClass, PublicKey.class));
+
+            certificateAlgorithmIdConstructor = lookup.unreflectConstructor(
+                                    certificateAlgorithmIdClass.getConstructor(algorithmIdClass))
+                            .asType(methodType(certificateAlgorithmIdClass, algorithmIdClass));
+
+            certInfoSetHandle = lookup.findVirtual(x509CertInfoClass, "set",
+                            methodType(void.class, String.class, Object.class));
+            certImplGetHandle = lookup.findVirtual(x509CertImplClass, "get",
+                            methodType(Object.class, String.class));
+            certImplSignHandle = lookup.findVirtual(x509CertImplClass, "sign",
+                            methodType(void.class, PrivateKey.class, String.class));
+            algorithmIdGetHandle = lookup.findStatic(algorithmIdClass, "get",
+                            methodType(algorithmIdClass, String.class));
 
-                        return classes;
-                    } catch (Throwable cause) {
-                        return cause;
-                    }
-                }
-            });
-            if (maybeClasses instanceof List) {
-                @SuppressWarnings("unchecked") List<Class<?>> classes = (List<Class<?>>) maybeClasses;
-                x509CertInfoClass = classes.get(0);
-                x500NameClass = classes.get(1);
-                certificateIssuerNameClass = classes.get(2);
-                x509CertImplClass = classes.get(3);
-                certificateVersionClass = classes.get(4);
-                certificateSubjectNameClass = classes.get(5);
-                certificateSerialNumberClass = classes.get(6);
-                certificateValidityClass = classes.get(7);
-                certificateX509KeyClass = classes.get(8);
-                algorithmIdClass = classes.get(9);
-                certificateAlgorithmIdClass = classes.get(10);
-            } else {
-                throw (Throwable) maybeClasses;
-            }
-
-            Object maybeConstructors = AccessController.doPrivileged(new PrivilegedAction<Object>() {
-                @Override
-                public Object run() {
-                    try {
-                        List<MethodHandle> constructors = new ArrayList<>();
-                        constructors.add(
-                                lookup.unreflectConstructor(x509CertInfoClass.getConstructor())
-                                        .asType(methodType(x509CertInfoClass))
-                        );
-                        constructors.add(
-                                lookup.unreflectConstructor(certificateIssuerNameClass.getConstructor(x500NameClass))
-                                        .asType(methodType(certificateIssuerNameClass, x500NameClass))
-                        );
-                        constructors.add(
-                                lookup.unreflectConstructor(x509CertImplClass.getConstructor(x509CertInfoClass))
-                                        .asType(methodType(x509CertImplClass, x509CertInfoClass))
-                        );
-                        constructors.add(
-                                lookup.unreflectConstructor(x500NameClass.getConstructor(String.class))
-                                        .asType(methodType(x500NameClass, String.class))
-                        );
-                        constructors.add(
-                                lookup.unreflectConstructor(certificateVersionClass.getConstructor(int.class))
-                                        .asType(methodType(certificateVersionClass, int.class))
-                        );
-                        constructors.add(
-                                lookup.unreflectConstructor(certificateSubjectNameClass.getConstructor(x500NameClass))
-                                        .asType(methodType(certificateSubjectNameClass, x500NameClass))
-                        );
-                        constructors.add(
-                                lookup.unreflectConstructor(
-                                        certificateSerialNumberClass.getConstructor(BigInteger.class))
-                                        .asType(methodType(certificateSerialNumberClass, BigInteger.class))
-                        );
-                        constructors.add(
-                                lookup.unreflectConstructor(
-                                        certificateValidityClass.getConstructor(Date.class, Date.class))
-                                        .asType(methodType(certificateValidityClass, Date.class, Date.class))
-                        );
-                        constructors.add(
-                                lookup.unreflectConstructor(certificateX509KeyClass.getConstructor(PublicKey.class))
-                                        .asType(methodType(certificateX509KeyClass, PublicKey.class))
-                        );
-
-                        constructors.add(
-                                lookup.unreflectConstructor(
-                                        certificateAlgorithmIdClass.getConstructor(algorithmIdClass))
-                                        .asType(methodType(certificateAlgorithmIdClass, algorithmIdClass))
-                        );
-                        return constructors;
-                    } catch (Throwable cause) {
-                        return cause;
-                    }
-                }
-            });
-            if (maybeConstructors instanceof List) {
-                @SuppressWarnings("unchecked") List<MethodHandle> constructorList =
-                        (List<MethodHandle>) maybeConstructors;
-                x509CertInfoConstructor = constructorList.get(0);
-                issuerNameConstructor = constructorList.get(1);
-                certImplConstructor = constructorList.get(2);
-                x500NameConstructor = constructorList.get(3);
-                certificateVersionConstructor = constructorList.get(4);
-                certificateSubjectNameConstructor = constructorList.get(5);
-                certificateSerialNumberConstructor = constructorList.get(6);
-                certificateValidityConstructor = constructorList.get(7);
-                certificateX509KeyConstructor = constructorList.get(8);
-                certificateAlgorithmIdConstructor = constructorList.get(9);
-            } else {
-                throw (Throwable) maybeConstructors;
-            }
-
-            Object maybeMethodHandles = AccessController.doPrivileged(new PrivilegedAction<Object>() {
-                @Override
-                public Object run() {
-                    try {
-                        List<MethodHandle> methods = new ArrayList<>();
-                        methods.add(
-                                lookup.findVirtual(x509CertInfoClass, "set",
-                                        methodType(void.class, String.class, Object.class))
-                        );
-                        methods.add(
-                                lookup.findVirtual(x509CertImplClass, "get",
-                                        methodType(Object.class, String.class))
-                        );
-
-                        methods.add(
-                                lookup.findVirtual(x509CertImplClass, "sign",
-                                        methodType(void.class, PrivateKey.class, String.class))
-                        );
-                        methods.add(
-                                lookup.findStatic(algorithmIdClass, "get",
-                                        methodType(algorithmIdClass, String.class))
-                        );
-                        return methods;
-                    } catch (Throwable cause) {
-                        return cause;
-                    }
-                }
-            });
-            if (maybeMethodHandles instanceof List) {
-                @SuppressWarnings("unchecked") List<MethodHandle> methodHandles =
-                        (List<MethodHandle>) maybeMethodHandles;
-                certInfoSetHandle = methodHandles.get(0);
-                certImplGetHandle = methodHandles.get(1);
-                certImplSignHandle = methodHandles.get(2);
-                algorithmIdGetHandle = methodHandles.get(3);
-            } else {
-                throw (Throwable) maybeMethodHandles;
-            }
             supported = true;
         } catch (Throwable cause) {
             supported = false;
diff --git a/microbench/src/main/java/io/netty/microbench/internal/PrivilegedSocketOperationsBenchmark.java b/microbench/src/main/java/io/netty/microbench/internal/PrivilegedSocketOperationsBenchmark.java
deleted file mode 100644
index 9da290da2d3..00000000000
--- a/microbench/src/main/java/io/netty/microbench/internal/PrivilegedSocketOperationsBenchmark.java
+++ /dev/null
@@ -1,193 +0,0 @@
-/*
- * Copyright 2016 The Netty Project
- *
- * The Netty Project licenses this file to you under the Apache License,
- * version 2.0 (the "License"); you may not use this file except in compliance
- * with the License. You may obtain a copy of the License at:
- *
- *   https://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-package io.netty.microbench.internal;
-
-import io.netty.microbench.util.AbstractMicrobenchmark;
-import org.openjdk.jmh.annotations.Benchmark;
-import org.openjdk.jmh.annotations.BenchmarkMode;
-import org.openjdk.jmh.annotations.Mode;
-import org.openjdk.jmh.annotations.OutputTimeUnit;
-import org.openjdk.jmh.annotations.Scope;
-import org.openjdk.jmh.annotations.Setup;
-import org.openjdk.jmh.annotations.State;
-import org.openjdk.jmh.annotations.TearDown;
-
-import java.io.IOException;
-import java.net.URI;
-import java.net.URISyntaxException;
-import java.nio.channels.ServerSocketChannel;
-import java.security.AccessController;
-import java.security.NoSuchAlgorithmException;
-import java.security.Policy;
-import java.security.PrivilegedActionException;
-import java.security.PrivilegedExceptionAction;
-import java.security.URIParameter;
-import java.util.concurrent.TimeUnit;
-
-@BenchmarkMode(Mode.Throughput)
-@OutputTimeUnit(TimeUnit.SECONDS)
-public class PrivilegedSocketOperationsBenchmark extends AbstractMicrobenchmark {
-
-    @State(Scope.Benchmark)
-    public static class SecurityManagerInstalled {
-
-        @Setup
-        public void setup() throws IOException, NoSuchAlgorithmException, URISyntaxException {
-            final URI policyFile = PrivilegedSocketOperationsBenchmark.class.getResource("/jmh-security.policy")
-                    .toURI();
-            Policy.setPolicy(Policy.getInstance("JavaPolicy", new URIParameter(policyFile)));
-            System.setSecurityManager(new SecurityManager());
-        }
-
-        @TearDown
-        public void tearDown() throws IOException {
-            System.setSecurityManager(null);
-        }
-    }
-
-    @State(Scope.Benchmark)
-    public static class SecurityManagerEmpty {
-
-        @Setup
-        public void setup() throws IOException, NoSuchAlgorithmException, URISyntaxException {
-            System.setSecurityManager(null);
-        }
-    }
-
-    @Benchmark
-    public ServerSocketChannel testWithSMNoPrivileged(final SecurityManagerInstalled sm) throws IOException {
-        final ServerSocketChannel ssc = ServerSocketChannel.open();
-        ssc.socket().bind(null);
-        ssc.configureBlocking(false);
-        ssc.accept();
-        ssc.close();
-        return ssc;
-    }
-
-    @Benchmark
-    public ServerSocketChannel testWithSM(final SecurityManagerInstalled sm) throws IOException {
-        try {
-            final ServerSocketChannel ssc = AccessController.doPrivileged(
-                    new PrivilegedExceptionAction<ServerSocketChannel>() {
-                        @Override
-                        public ServerSocketChannel run() throws Exception {
-                            final ServerSocketChannel ssc = ServerSocketChannel.open();
-                            ssc.socket().bind(null);
-                            ssc.configureBlocking(false);
-                            ssc.accept();
-                            return ssc;
-                        }
-                    });
-            ssc.close();
-            return ssc;
-        } catch (final PrivilegedActionException e) {
-            throw (IOException) e.getCause();
-        }
-    }
-
-    @Benchmark
-    public ServerSocketChannel testWithSMWithNullCheck(final SecurityManagerInstalled sm) throws IOException {
-        if (System.getSecurityManager() != null) {
-            try {
-                final ServerSocketChannel ssc = AccessController.doPrivileged(
-                        new PrivilegedExceptionAction<ServerSocketChannel>() {
-                            @Override
-                            public ServerSocketChannel run() throws Exception {
-                                final ServerSocketChannel ssc = ServerSocketChannel.open();
-                                ssc.socket().bind(null);
-                                ssc.configureBlocking(false);
-                                ssc.accept();
-                                return ssc;
-                            }
-                        });
-                ssc.close();
-                return ssc;
-            } catch (final PrivilegedActionException e) {
-                throw (IOException) e.getCause();
-            }
-        } else {
-            // this should never happen during benchmarking, but we write the correct code here
-            final ServerSocketChannel ssc = ServerSocketChannel.open();
-            ssc.socket().bind(null);
-            ssc.configureBlocking(false);
-            ssc.accept();
-            ssc.close();
-            return ssc;
-        }
-    }
-
-    @Benchmark
-    public ServerSocketChannel testWithoutSMNoPrivileged(final SecurityManagerEmpty sm) throws IOException {
-        final ServerSocketChannel ssc = ServerSocketChannel.open();
-        ssc.socket().bind(null);
-        ssc.configureBlocking(false);
-        ssc.accept();
-        ssc.close();
-        return ssc;
-    }
-
-    @Benchmark
-    public ServerSocketChannel testWithoutSM(final SecurityManagerEmpty sm) throws IOException {
-        try {
-            final ServerSocketChannel ssc = AccessController.doPrivileged(
-                    new PrivilegedExceptionAction<ServerSocketChannel>() {
-                        @Override
-                        public ServerSocketChannel run() throws Exception {
-                            final ServerSocketChannel ssc = ServerSocketChannel.open();
-                            ssc.socket().bind(null);
-                            ssc.configureBlocking(false);
-                            ssc.accept();
-                            return ssc;
-                        }
-                    });
-            ssc.close();
-            return ssc;
-        } catch (final PrivilegedActionException e) {
-            throw (IOException) e.getCause();
-        }
-    }
-
-    @Benchmark
-    public ServerSocketChannel testWithoutSMWithNullCheck(final SecurityManagerEmpty sm) throws IOException {
-        if (System.getSecurityManager() != null) {
-            // this should never happen during benchmarking, but we write the correct code here
-            try {
-                final ServerSocketChannel ssc = AccessController.doPrivileged(
-                        new PrivilegedExceptionAction<ServerSocketChannel>() {
-                            @Override
-                            public ServerSocketChannel run() throws Exception {
-                                final ServerSocketChannel ssc = ServerSocketChannel.open();
-                                ssc.socket().bind(null);
-                                ssc.configureBlocking(false);
-                                ssc.accept();
-                                return ssc;
-                            }
-                        });
-                ssc.close();
-                return ssc;
-            } catch (final PrivilegedActionException e) {
-                throw (IOException) e.getCause();
-            }
-        } else {
-            final ServerSocketChannel ssc = ServerSocketChannel.open();
-            ssc.socket().bind(null);
-            ssc.configureBlocking(false);
-            ssc.accept();
-            ssc.close();
-            return ssc;
-        }
-    }
-}
diff --git a/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddressStreamProviders.java b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddressStreamProviders.java
index 1011b5c99f4..ef61689de05 100644
--- a/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddressStreamProviders.java
+++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddressStreamProviders.java
@@ -21,14 +21,13 @@
 
 import java.lang.reflect.Constructor;
 import java.lang.reflect.InvocationTargetException;
-import java.security.AccessController;
-import java.security.PrivilegedAction;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicLong;
 
 /**
  * Utility methods related to {@link DnsServerAddressStreamProvider}.
  */
+@SuppressWarnings("unchecked")
 public final class DnsServerAddressStreamProviders {
 
     private static final InternalLogger LOGGER =
@@ -43,29 +42,14 @@ public final class DnsServerAddressStreamProviders {
             try {
                 // As MacOSDnsServerAddressStreamProvider is contained in another jar which depends on this jar
                 // we use reflection to use it if its on the classpath.
-                Object maybeProvider = AccessController.doPrivileged(new PrivilegedAction<Object>() {
-                    @Override
-                    public Object run() {
-                        try {
-                            return Class.forName(
-                                    MACOS_PROVIDER_CLASS_NAME,
-                                    true,
-                                    DnsServerAddressStreamProviders.class.getClassLoader());
-                        } catch (Throwable cause) {
-                            return cause;
-                        }
-                    }
-                });
-                if (maybeProvider instanceof Class) {
-                    @SuppressWarnings("unchecked")
-                    Class<? extends DnsServerAddressStreamProvider> providerClass =
-                            (Class<? extends DnsServerAddressStreamProvider>) maybeProvider;
-                    constructor = providerClass.getConstructor();
-                    constructor.newInstance();  // ctor ensures availability
-                    LOGGER.debug("{}: available", MACOS_PROVIDER_CLASS_NAME);
-                } else {
-                    throw (Throwable) maybeProvider;
-                }
+                Class<? extends DnsServerAddressStreamProvider> providerClass =
+                        (Class<? extends DnsServerAddressStreamProvider>) Class.forName(
+                                MACOS_PROVIDER_CLASS_NAME,
+                                true,
+                                DnsServerAddressStreamProviders.class.getClassLoader());
+                constructor = providerClass.getConstructor();
+                constructor.newInstance();  // ctor ensures availability
+                LOGGER.debug("{}: available", MACOS_PROVIDER_CLASS_NAME);
             } catch (ClassNotFoundException cause) {
                 LOGGER.warn("Can not find {} in the classpath, fallback to system defaults. This may result in "
                         + "incorrect DNS resolutions on MacOS. Check whether you have a dependency on "
diff --git a/transport/src/main/java/io/netty/channel/nio/NioIoHandler.java b/transport/src/main/java/io/netty/channel/nio/NioIoHandler.java
index be875ce7984..99bf86af46a 100644
--- a/transport/src/main/java/io/netty/channel/nio/NioIoHandler.java
+++ b/transport/src/main/java/io/netty/channel/nio/NioIoHandler.java
@@ -17,9 +17,9 @@
 
 import io.netty.channel.ChannelException;
 import io.netty.channel.DefaultSelectStrategyFactory;
-import io.netty.channel.IoHandlerContext;
 import io.netty.channel.IoHandle;
 import io.netty.channel.IoHandler;
+import io.netty.channel.IoHandlerContext;
 import io.netty.channel.IoHandlerFactory;
 import io.netty.channel.IoOps;
 import io.netty.channel.IoRegistration;
@@ -38,12 +38,9 @@
 import java.io.IOException;
 import java.lang.reflect.Field;
 import java.nio.channels.CancelledKeyException;
-import java.nio.channels.Selector;
 import java.nio.channels.SelectionKey;
-
+import java.nio.channels.Selector;
 import java.nio.channels.spi.SelectorProvider;
-import java.security.AccessController;
-import java.security.PrivilegedAction;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Iterator;
@@ -152,81 +149,60 @@ private SelectorTuple openSelector() {
             return new SelectorTuple(unwrappedSelector);
         }
 
-        Object maybeSelectorImplClass = AccessController.doPrivileged(new PrivilegedAction<Object>() {
-            @Override
-            public Object run() {
-                try {
-                    return Class.forName(
-                            "sun.nio.ch.SelectorImpl",
-                            false,
-                            PlatformDependent.getSystemClassLoader());
-                } catch (Throwable cause) {
-                    return cause;
-                }
-            }
-        });
-
-        if (!(maybeSelectorImplClass instanceof Class) ||
+        final Class<?> selectorImplClass;
+        try {
+            Class<?> cls = Class.forName(
+                    "sun.nio.ch.SelectorImpl",
+                    false,
+                    PlatformDependent.getSystemClassLoader());
+            if (!cls.isAssignableFrom(unwrappedSelector.getClass())) {
                 // ensure the current selector implementation is what we can instrument.
-                !((Class<?>) maybeSelectorImplClass).isAssignableFrom(unwrappedSelector.getClass())) {
-            if (maybeSelectorImplClass instanceof Throwable) {
-                Throwable t = (Throwable) maybeSelectorImplClass;
-                logger.trace("failed to instrument a special java.util.Set into: {}", unwrappedSelector, t);
+                return new SelectorTuple(unwrappedSelector);
             }
+            selectorImplClass = cls;
+        } catch (Throwable cause) {
+            logger.trace("failed to instrument a special java.util.Set into: {}", unwrappedSelector, cause);
             return new SelectorTuple(unwrappedSelector);
         }
 
-        final Class<?> selectorImplClass = (Class<?>) maybeSelectorImplClass;
         final SelectedSelectionKeySet selectedKeySet = new SelectedSelectionKeySet();
-
-        Object maybeException = AccessController.doPrivileged(new PrivilegedAction<Object>() {
-            @Override
-            public Object run() {
-                try {
-                    Field selectedKeysField = selectorImplClass.getDeclaredField("selectedKeys");
-                    Field publicSelectedKeysField = selectorImplClass.getDeclaredField("publicSelectedKeys");
-
-                    if (PlatformDependent.javaVersion() >= 9 && PlatformDependent.hasUnsafe()) {
-                        // Let us try to use sun.misc.Unsafe to replace the SelectionKeySet.
-                        // This allows us to also do this in Java9+ without any extra flags.
-                        long selectedKeysFieldOffset = PlatformDependent.objectFieldOffset(selectedKeysField);
-                        long publicSelectedKeysFieldOffset =
-                                PlatformDependent.objectFieldOffset(publicSelectedKeysField);
-
-                        if (selectedKeysFieldOffset != -1 && publicSelectedKeysFieldOffset != -1) {
-                            PlatformDependent.putObject(
-                                    unwrappedSelector, selectedKeysFieldOffset, selectedKeySet);
-                            PlatformDependent.putObject(
-                                    unwrappedSelector, publicSelectedKeysFieldOffset, selectedKeySet);
-                            return null;
-                        }
-                        // We could not retrieve the offset, lets try reflection as last-resort.
-                    }
-
-                    Throwable cause = ReflectionUtil.trySetAccessible(selectedKeysField, true);
-                    if (cause != null) {
-                        return cause;
-                    }
-                    cause = ReflectionUtil.trySetAccessible(publicSelectedKeysField, true);
-                    if (cause != null) {
-                        return cause;
-                    }
-
-                    selectedKeysField.set(unwrappedSelector, selectedKeySet);
-                    publicSelectedKeysField.set(unwrappedSelector, selectedKeySet);
-                    return null;
-                } catch (NoSuchFieldException | IllegalAccessException e) {
-                    return e;
+        try {
+            Field selectedKeysField = selectorImplClass.getDeclaredField("selectedKeys");
+            Field publicSelectedKeysField = selectorImplClass.getDeclaredField("publicSelectedKeys");
+
+            if (PlatformDependent.javaVersion() >= 9 && PlatformDependent.hasUnsafe()) {
+                // Let us try to use sun.misc.Unsafe to replace the SelectionKeySet.
+                // This allows us to also do this in Java9+ without any extra flags.
+                long selectedKeysFieldOffset = PlatformDependent.objectFieldOffset(selectedKeysField);
+                long publicSelectedKeysFieldOffset =
+                        PlatformDependent.objectFieldOffset(publicSelectedKeysField);
+
+                if (selectedKeysFieldOffset != -1 && publicSelectedKeysFieldOffset != -1) {
+                    PlatformDependent.putObject(
+                            unwrappedSelector, selectedKeysFieldOffset, selectedKeySet);
+                    PlatformDependent.putObject(
+                            unwrappedSelector, publicSelectedKeysFieldOffset, selectedKeySet);
+                }
+            } else {
+                // We could not retrieve the offset, lets try reflection as last-resort.
+                Throwable cause = ReflectionUtil.trySetAccessible(selectedKeysField, true);
+                if (cause != null) {
+                    throw cause;
+                }
+                cause = ReflectionUtil.trySetAccessible(publicSelectedKeysField, true);
+                if (cause != null) {
+                    throw cause;
                 }
-            }
-        });
 
-        if (maybeException instanceof Exception) {
+                selectedKeysField.set(unwrappedSelector, selectedKeySet);
+                publicSelectedKeysField.set(unwrappedSelector, selectedKeySet);
+            }
+        } catch (Throwable throwable) {
             selectedKeys = null;
-            Exception e = (Exception) maybeException;
-            logger.trace("failed to instrument a special java.util.Set into: {}", unwrappedSelector, e);
+            logger.trace("failed to instrument a special java.util.Set into: {}", unwrappedSelector, throwable);
             return new SelectorTuple(unwrappedSelector);
         }
+
         selectedKeys = selectedKeySet;
         logger.trace("instrumented a special java.util.Set into: {}", unwrappedSelector);
         return new SelectorTuple(unwrappedSelector,
