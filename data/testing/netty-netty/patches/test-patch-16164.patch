diff --git a/common/src/test/java/io/netty/util/concurrent/NonStickyEventExecutorGroupTest.java b/common/src/test/java/io/netty/util/concurrent/NonStickyEventExecutorGroupTest.java
deleted file mode 100644
index aafb1f51db1..00000000000
--- a/common/src/test/java/io/netty/util/concurrent/NonStickyEventExecutorGroupTest.java
+++ /dev/null
@@ -1,343 +0,0 @@
-/*
- * Copyright 2016 The Netty Project
- *
- * The Netty Project licenses this file to you under the Apache License,
- * version 2.0 (the "License"); you may not use this file except in compliance
- * with the License. You may obtain a copy of the License at:
- *
- *   https://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-package io.netty.util.concurrent;
-
-import io.netty.util.NettyRuntime;
-import org.junit.jupiter.api.Test;
-import org.junit.jupiter.api.Timeout;
-import org.junit.jupiter.api.function.Executable;
-import org.junit.jupiter.params.ParameterizedTest;
-import org.junit.jupiter.params.provider.MethodSource;
-
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.Iterator;
-import java.util.List;
-import java.util.concurrent.Callable;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.RejectedExecutionException;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicInteger;
-import java.util.concurrent.atomic.AtomicReference;
-
-import static org.junit.jupiter.api.Assertions.assertFalse;
-import static org.junit.jupiter.api.Assertions.assertNotNull;
-import static org.junit.jupiter.api.Assertions.assertThrows;
-import static org.junit.jupiter.api.Assertions.assertTrue;
-
-public class NonStickyEventExecutorGroupTest {
-    private static final String PARAMETERIZED_NAME = "{index}: maxTaskExecutePerRun = {0}";
-
-    @Test
-    public void testInvalidGroup() {
-        final EventExecutorGroup group = new DefaultEventExecutorGroup(1);
-        try {
-            assertThrows(IllegalArgumentException.class, new Executable() {
-                @Override
-                public void execute() {
-                    new NonStickyEventExecutorGroup(group);
-                }
-            });
-        } finally {
-            group.shutdownGracefully();
-        }
-    }
-
-    public static Collection<Object[]> data() throws Exception {
-        List<Object[]> params = new ArrayList<Object[]>();
-        params.add(new Object[] {64});
-        params.add(new Object[] {256});
-        params.add(new Object[] {1024});
-        params.add(new Object[] {Integer.MAX_VALUE});
-        return params;
-    }
-
-    @ParameterizedTest(name = PARAMETERIZED_NAME)
-    @MethodSource("data")
-    @Timeout(value = 10000, unit = TimeUnit.MILLISECONDS)
-    public void testOrdering(int maxTaskExecutePerRun) throws Throwable {
-        final int threads = NettyRuntime.availableProcessors() * 2;
-        final EventExecutorGroup group = new UnorderedThreadPoolEventExecutor(threads);
-        final NonStickyEventExecutorGroup nonStickyGroup = new NonStickyEventExecutorGroup(group, maxTaskExecutePerRun);
-        try {
-            final CountDownLatch startLatch = new CountDownLatch(1);
-            final AtomicReference<Throwable> error = new AtomicReference<Throwable>();
-            List<Thread> threadList = new ArrayList<Thread>(threads);
-            for (int i = 0 ; i < threads; i++) {
-                Thread thread = new Thread(new Runnable() {
-                    @Override
-                    public void run() {
-                        try {
-                            execute(nonStickyGroup, startLatch);
-                        } catch (Throwable cause) {
-                            error.compareAndSet(null, cause);
-                        }
-                    }
-                });
-                threadList.add(thread);
-                thread.start();
-            }
-            startLatch.countDown();
-            for (Thread t: threadList) {
-                t.join();
-            }
-            Throwable cause = error.get();
-            if (cause != null) {
-                throw cause;
-            }
-        } finally {
-            nonStickyGroup.shutdownGracefully();
-        }
-    }
-
-    @ParameterizedTest(name = PARAMETERIZED_NAME)
-    @MethodSource("data")
-    public void testRaceCondition(int maxTaskExecutePerRun) throws InterruptedException {
-        EventExecutorGroup group = new UnorderedThreadPoolEventExecutor(1);
-        NonStickyEventExecutorGroup nonStickyGroup = new NonStickyEventExecutorGroup(group, maxTaskExecutePerRun);
-
-        try {
-            EventExecutor executor = nonStickyGroup.next();
-
-            for (int j = 0; j < 5000; j++) {
-                final CountDownLatch firstCompleted = new CountDownLatch(1);
-                final CountDownLatch latch = new CountDownLatch(2);
-                for (int i = 0; i < 2; i++) {
-                    executor.execute(new Runnable() {
-                        @Override
-                        public void run() {
-                            firstCompleted.countDown();
-                            latch.countDown();
-                        }
-                    });
-                    assertTrue(firstCompleted.await(1, TimeUnit.SECONDS));
-                }
-
-                assertTrue(latch.await(5, TimeUnit.SECONDS));
-            }
-        } finally {
-            nonStickyGroup.shutdownGracefully();
-        }
-    }
-
-    @Test
-    public void testInEventLoopAfterReschedulingFailure() throws Exception {
-        final UnorderedThreadPoolEventExecutor underlying = new UnorderedThreadPoolEventExecutor(1);
-        final AtomicInteger executeCount = new AtomicInteger();
-
-        final EventExecutorGroup wrapper = new AbstractEventExecutorGroup() {
-
-            private final EventExecutor executor = new AbstractEventExecutor(this) {
-                @Override
-                public boolean inEventLoop(Thread thread) {
-                    return underlying.inEventLoop(thread);
-                }
-
-                @Override
-                public void execute(Runnable command) {
-                    // Reject the 2nd execute() call (the reschedule attempt)
-                    // 1st call: initial task submission
-                    // 2nd call: reschedule after maxTaskExecutePerRun
-                    if (executeCount.incrementAndGet() == 2) {
-                        throw new RejectedExecutionException("Simulated queue full");
-                    }
-                    underlying.execute(command);
-                }
-
-                @Override
-                public boolean isShuttingDown() {
-                    return underlying.isShuttingDown();
-                }
-
-                @Override
-                public Future<?> shutdownGracefully(long quietPeriod, long timeout, TimeUnit unit) {
-                    return underlying.shutdownGracefully(quietPeriod, timeout, unit);
-                }
-
-                @Override
-                public Future<?> terminationFuture() {
-                    return underlying.terminationFuture();
-                }
-
-                @Override
-                public boolean isShutdown() {
-                    return underlying.isShutdown();
-                }
-
-                @Override
-                public boolean isTerminated() {
-                    return underlying.isTerminated();
-                }
-
-                @Override
-                public boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException {
-                    return underlying.awaitTermination(timeout, unit);
-                }
-
-                @Override
-                public ScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit) {
-                    return underlying.schedule(command, delay, unit);
-                }
-
-                @Override
-                public <V> ScheduledFuture<V> schedule(Callable<V> callable, long delay, TimeUnit unit) {
-                    return underlying.schedule(callable, delay, unit);
-                }
-
-                @Override
-                public ScheduledFuture<?> scheduleAtFixedRate(
-                        Runnable command, long initialDelay, long period, TimeUnit unit) {
-                    return underlying.scheduleAtFixedRate(command, initialDelay, period, unit);
-                }
-
-                @Override
-                public ScheduledFuture<?> scheduleWithFixedDelay(
-                        Runnable command, long initialDelay, long delay, TimeUnit unit) {
-                    return underlying.scheduleWithFixedDelay(command, initialDelay, delay, unit);
-                }
-            };
-
-            @Override
-            public EventExecutor next() {
-                return executor;
-            }
-
-            @Override
-            public Iterator<EventExecutor> iterator() {
-                return Collections.singletonList(executor).iterator();
-            }
-
-            @Override
-            public boolean isShuttingDown() {
-                return underlying.isShuttingDown();
-            }
-
-            @Override
-            public Future<?> shutdownGracefully(long quietPeriod, long timeout, TimeUnit unit) {
-                return underlying.shutdownGracefully(quietPeriod, timeout, unit);
-            }
-
-            @Override
-            public Future<?> terminationFuture() {
-                return underlying.terminationFuture();
-            }
-
-            @Override
-            public boolean isShutdown() {
-                return underlying.isShutdown();
-            }
-
-            @Override
-            public boolean isTerminated() {
-                return underlying.isTerminated();
-            }
-
-            @Override
-            public boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException {
-                return underlying.awaitTermination(timeout, unit);
-            }
-        };
-
-        // Use maxTaskExecutePerRun=1 so reschedule happens after first task
-        NonStickyEventExecutorGroup nonStickyGroup = new NonStickyEventExecutorGroup(wrapper, 1);
-
-        try {
-            final EventExecutor executor = nonStickyGroup.next();
-
-            final CountDownLatch latch = new CountDownLatch(1);
-            final AtomicReference<Boolean> inEventLoopResult = new AtomicReference<Boolean>();
-
-            // Submit 2 tasks:
-            // Task 1: completes, triggers reschedule which will be rejected
-            // Task 2: verifies inEventLoop() still works after failed reschedule
-            executor.execute(new Runnable() {
-                @Override
-                public void run() {
-                    // First task - will trigger reschedule attempt that fails
-                }
-            });
-
-            executor.execute(new Runnable() {
-                @Override
-                public void run() {
-                    // This runs AFTER the failed rescheduling
-                    // WITHOUT line 262 fix: executingThread is null, inEventLoop() returns false
-                    // WITH line 262 fix: executingThread restored, inEventLoop() returns true
-                    inEventLoopResult.set(executor.inEventLoop());
-                    latch.countDown();
-                }
-            });
-
-            assertTrue(latch.await(5, TimeUnit.SECONDS), "Tasks should complete");
-            Boolean result = inEventLoopResult.get();
-            assertNotNull(result, "inEventLoop() should have been called");
-            assertTrue(result,
-                "inEventLoop() should return true even after failed reschedule attempt. " +
-                "This indicates executingThread was properly restored in the exception handler.");
-        } finally {
-            nonStickyGroup.shutdownGracefully();
-            underlying.shutdownGracefully();
-        }
-    }
-
-    private static void execute(EventExecutorGroup group, CountDownLatch startLatch) throws Throwable {
-        final EventExecutor executor = group.next();
-        assertTrue(executor instanceof OrderedEventExecutor);
-        final AtomicReference<Throwable> cause = new AtomicReference<Throwable>();
-        final AtomicInteger last = new AtomicInteger();
-        int tasks = 10000;
-        List<Future<?>> futures = new ArrayList<Future<?>>(tasks);
-        final CountDownLatch latch = new CountDownLatch(tasks);
-        startLatch.await();
-
-        for (int i = 1 ; i <= tasks; i++) {
-            final int id = i;
-            assertFalse(executor.inEventLoop());
-            assertFalse(executor.inEventLoop(Thread.currentThread()));
-            futures.add(executor.submit(new Runnable() {
-                @Override
-                public void run() {
-                    try {
-                        assertTrue(executor.inEventLoop(Thread.currentThread()));
-                        assertTrue(executor.inEventLoop());
-
-                        if (cause.get() == null) {
-                            int lastId = last.get();
-                            if (lastId >= id) {
-                                cause.compareAndSet(null, new AssertionError(
-                                        "Out of order execution id(" + id + ") >= lastId(" + lastId + ')'));
-                            }
-                            if (!last.compareAndSet(lastId, id)) {
-                                cause.compareAndSet(null, new AssertionError("Concurrent execution of tasks"));
-                            }
-                        }
-                    } finally {
-                        latch.countDown();
-                    }
-                }
-            }));
-        }
-        latch.await();
-        for (Future<?> future: futures) {
-            future.syncUninterruptibly();
-        }
-        Throwable error = cause.get();
-        if (error != null) {
-            throw error;
-        }
-    }
-}
diff --git a/common/src/test/java/io/netty/util/concurrent/UnorderedThreadPoolEventExecutorTest.java b/common/src/test/java/io/netty/util/concurrent/UnorderedThreadPoolEventExecutorTest.java
deleted file mode 100644
index ad522e6d37f..00000000000
--- a/common/src/test/java/io/netty/util/concurrent/UnorderedThreadPoolEventExecutorTest.java
+++ /dev/null
@@ -1,141 +0,0 @@
-/*
- * Copyright 2017 The Netty Project
- *
- * The Netty Project licenses this file to you under the Apache License,
- * version 2.0 (the "License"); you may not use this file except in compliance
- * with the License. You may obtain a copy of the License at:
- *
- *   https://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-package io.netty.util.concurrent;
-
-import org.junit.jupiter.api.Test;
-import org.junit.jupiter.api.Timeout;
-
-import java.util.concurrent.Callable;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.Exchanger;
-import java.util.concurrent.TimeUnit;
-
-import static org.junit.jupiter.api.Assertions.assertEquals;
-import static org.junit.jupiter.api.Assertions.assertSame;
-import static org.junit.jupiter.api.Assertions.assertTrue;
-
-public class UnorderedThreadPoolEventExecutorTest {
-
-    // See https://github.com/netty/netty/issues/6507
-    @Test
-    public void testNotEndlessExecute() throws Exception {
-        UnorderedThreadPoolEventExecutor executor = new UnorderedThreadPoolEventExecutor(1);
-
-        try {
-            // Having the first task wait on an exchanger allow us to make sure that the lister on the second task
-            // is not added *after* the promise completes. We need to do this to prevent a race where the second task
-            // and listener are completed before the DefaultPromise.NotifyListeners task get to run, which means our
-            // queue inspection might observe this task after the CountDownLatch opens.
-            final Exchanger<Void> exchanger = new Exchanger<Void>();
-            final CountDownLatch latch = new CountDownLatch(3);
-            Runnable task = new Runnable() {
-                @Override
-                public void run() {
-                    try {
-                        exchanger.exchange(null);
-                    } catch (InterruptedException e) {
-                        throw new RuntimeException(e);
-                    }
-                    latch.countDown();
-                }
-            };
-            executor.execute(task);
-            Future<?> future = executor.submit(new Runnable() {
-                @Override
-                public void run() {
-                    latch.countDown();
-                }
-            }).addListener((FutureListener<Object>) f -> latch.countDown());
-            exchanger.exchange(null);
-            latch.await();
-            future.syncUninterruptibly();
-
-            // Now just check if the queue stays empty multiple times. This is needed as the submit to execute(...)
-            // by DefaultPromise may happen in an async fashion
-            for (int i = 0; i < 10000; i++) {
-                assertTrue(executor.getQueue().isEmpty());
-            }
-        } finally {
-            executor.shutdownGracefully();
-        }
-    }
-
-    @Test
-    @Timeout(value = 10000, unit = TimeUnit.MILLISECONDS)
-    public void scheduledAtFixedRateMustRunTaskRepeatedly() throws InterruptedException {
-        UnorderedThreadPoolEventExecutor executor = new UnorderedThreadPoolEventExecutor(1);
-        final CountDownLatch latch = new CountDownLatch(3);
-        Future<?> future = executor.scheduleAtFixedRate(new Runnable() {
-            @Override
-            public void run() {
-                latch.countDown();
-            }
-        }, 1, 1, TimeUnit.MILLISECONDS);
-        try {
-            latch.await();
-        } finally {
-            future.cancel(true);
-            executor.shutdownGracefully();
-        }
-    }
-
-    @Test
-    public void testGetReturnsCorrectValueOnSuccess() throws Exception {
-        UnorderedThreadPoolEventExecutor executor = new UnorderedThreadPoolEventExecutor(1);
-        try {
-            final String expected = "expected";
-            Future<String> f = executor.submit(new Callable<String>() {
-                @Override
-                public String call() {
-                    return expected;
-                }
-            });
-
-            assertEquals(expected, f.get());
-        } finally {
-            executor.shutdownGracefully();
-        }
-    }
-
-    @Test
-    public void testGetReturnsCorrectValueOnFailure() throws Exception {
-        UnorderedThreadPoolEventExecutor executor = new UnorderedThreadPoolEventExecutor(1);
-        try {
-            final RuntimeException cause = new RuntimeException();
-            Future<String> f = executor.submit(new Callable<String>() {
-                @Override
-                public String call() {
-                    throw cause;
-                }
-            });
-
-            assertSame(cause, f.await().cause());
-        } finally {
-            executor.shutdownGracefully();
-        }
-    }
-
-    @Test
-    void tasksRunningInUnorderedExecutorAreInEventLoop() throws Exception {
-        UnorderedThreadPoolEventExecutor executor = new UnorderedThreadPoolEventExecutor(1);
-        try {
-            Future<Boolean> future = executor.submit(() -> executor.inEventLoop());
-            assertTrue(future.get());
-        } finally {
-            executor.shutdownGracefully();
-        }
-    }
-}
