[ {
  "instance_id" : "netty-netty-PR-16195",
  "repo" : "netty/netty",
  "base_commit" : "dc7bc7f607b1950d6db0c41a7a4f4e8b967155e4",
  "patch" : "diff --git a/buffer/src/main/java/io/netty/buffer/ReadOnlyAbstractByteBuf.java b/buffer/src/main/java/io/netty/buffer/ReadOnlyAbstractByteBuf.java\nindex ca3b709e420..8dacab67983 100644\n--- a/buffer/src/main/java/io/netty/buffer/ReadOnlyAbstractByteBuf.java\n+++ b/buffer/src/main/java/io/netty/buffer/ReadOnlyAbstractByteBuf.java\n@@ -23,6 +23,7 @@ final class ReadOnlyAbstractByteBuf extends ReadOnlyByteBuf {\n \n     ReadOnlyAbstractByteBuf(AbstractByteBuf buffer) {\n         super(buffer);\n+        assert buffer.unwrap() == null || buffer.unwrap() instanceof AbstractByteBuf;\n     }\n \n     @Override\ndiff --git a/buffer/src/main/java/io/netty/buffer/Unpooled.java b/buffer/src/main/java/io/netty/buffer/Unpooled.java\nindex 708aaa35efa..a388b1816a6 100644\n--- a/buffer/src/main/java/io/netty/buffer/Unpooled.java\n+++ b/buffer/src/main/java/io/netty/buffer/Unpooled.java\n@@ -702,7 +702,10 @@ public static ByteBuf unmodifiableBuffer(ByteBuf buffer) {\n     }\n \n     private static ReadOnlyByteBuf newReadyOnlyBuffer(ByteBuf buffer) {\n-        return buffer instanceof AbstractByteBuf ?\n+        // We can only use ReadOnlyAbstractByteBuf if we either have nothing to unwrap or the unwrapped buffer is of\n+        // type AbstractByteBuf. Otherwise we will produce a CCE later.\n+        return buffer instanceof AbstractByteBuf && (\n+                buffer.unwrap() == null || buffer.unwrap() instanceof AbstractByteBuf) ?\n                 new ReadOnlyAbstractByteBuf((AbstractByteBuf) buffer) :\n                 new ReadOnlyByteBuf(buffer);\n     }\n",
  "test_patch" : "diff --git a/buffer/src/test/java/io/netty/buffer/ReadOnlyByteBufTest.java b/buffer/src/test/java/io/netty/buffer/ReadOnlyByteBufTest.java\nindex a1f663b1cf4..187be34c121 100644\n--- a/buffer/src/test/java/io/netty/buffer/ReadOnlyByteBufTest.java\n+++ b/buffer/src/test/java/io/netty/buffer/ReadOnlyByteBufTest.java\n@@ -61,6 +61,11 @@ public void testUnmodifiableBuffer() {\n         assertThat(unmodifiableBuffer(buffer(1))).isInstanceOf(ReadOnlyByteBuf.class);\n     }\n \n+    @Test\n+    public void testUnmodifiableBufferDoesNotThrowClassCastException() {\n+        unmodifiableBuffer(new DuplicatedByteBuf(mock(ByteBuf.class)));\n+    }\n+\n     @Test\n     public void testUnwrap() {\n         ByteBuf buf = buffer(1);\n",
  "problem_statement" : "Fix possible ClassCastException when using ReadOnlyAbstractByteBuf (#16188)\n\nMotivation:\n\nhttps://github.com/netty/netty/pull/15413 introduced a change that\nreduced bound checks. Unfortunally this change also introduced a bug\nthat can cause ClassCastExceptions in some rare-cases (mostly when\npeople write their own ByteBuf implementation.\n\nModifications:\n\n- Ensure the wrapped buffer will really be of type AbstractByteBuf\n- Add unit test\n\nResult:\n\nFixes rare ClassCastException",
  "hints_text" : null,
  "created_at" : "Wed Jan 28 23:58:09 CET 2026",
  "version" : null,
  "FAIL_TO_PASS" : [ "ReadOnlyByteBufTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -pl buffer -Dtest=ReadOnlyByteBufTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 16195,
  "metadata" : null
}, {
  "instance_id" : "netty-netty-PR-16193",
  "repo" : "netty/netty",
  "base_commit" : "dc7bc7f607b1950d6db0c41a7a4f4e8b967155e4",
  "patch" : "diff --git a/handler/src/main/java/io/netty/handler/ssl/BouncyCastleAlpnSslUtils.java b/handler/src/main/java/io/netty/handler/ssl/BouncyCastleAlpnSslUtils.java\nindex 21cb85571c4..911e7d84aa8 100644\n--- a/handler/src/main/java/io/netty/handler/ssl/BouncyCastleAlpnSslUtils.java\n+++ b/handler/src/main/java/io/netty/handler/ssl/BouncyCastleAlpnSslUtils.java\n@@ -17,7 +17,6 @@\n \n import io.netty.handler.ssl.util.BouncyCastleUtil;\n import io.netty.util.internal.EmptyArrays;\n-import io.netty.util.internal.PlatformDependent;\n import io.netty.util.internal.logging.InternalLogger;\n import io.netty.util.internal.logging.InternalLoggerFactory;\n \n@@ -173,9 +172,10 @@ static void setApplicationProtocols(SSLEngine engine, List<String> supportedProt\n         } catch (Exception ex) {\n             throw new IllegalStateException(ex);\n         }\n-        if (PlatformDependent.javaVersion() >= 9) {\n-            JdkAlpnSslUtils.setApplicationProtocols(engine, supportedProtocols);\n-        }\n+        String[] protocolArray1 = supportedProtocols.toArray(EmptyArrays.EMPTY_STRINGS);\n+        SSLParameters parameters = engine.getSSLParameters();\n+        parameters.setApplicationProtocols(protocolArray1);\n+        engine.setSSLParameters(parameters);\n     }\n \n     static String getHandshakeApplicationProtocol(SSLEngine sslEngine) {\ndiff --git a/handler/src/main/java/io/netty/handler/ssl/JdkAlpnApplicationProtocolNegotiator.java b/handler/src/main/java/io/netty/handler/ssl/JdkAlpnApplicationProtocolNegotiator.java\nindex cae4a63a776..8739a6d15f4 100644\n--- a/handler/src/main/java/io/netty/handler/ssl/JdkAlpnApplicationProtocolNegotiator.java\n+++ b/handler/src/main/java/io/netty/handler/ssl/JdkAlpnApplicationProtocolNegotiator.java\n@@ -27,11 +27,7 @@\n  */\n @Deprecated\n public final class JdkAlpnApplicationProtocolNegotiator extends JdkBaseApplicationProtocolNegotiator {\n-    private static final boolean AVAILABLE = Conscrypt.isAvailable() ||\n-                                             JdkAlpnSslUtils.supportsAlpn() ||\n-            (BouncyCastleUtil.isBcTlsAvailable() && BouncyCastleAlpnSslUtils.isAlpnSupported());\n-\n-    private static final SslEngineWrapperFactory ALPN_WRAPPER = AVAILABLE ? new AlpnWrapper() : new FailureWrapper();\n+    private static final SslEngineWrapperFactory ALPN_WRAPPER = new AlpnWrapper();\n \n     /**\n      * Create a new instance.\n@@ -135,19 +131,11 @@ public SSLEngine wrapSslEngine(SSLEngine engine, ByteBufAllocator alloc,\n             if (BouncyCastleUtil.isBcJsseInUse(engine) && BouncyCastleAlpnSslUtils.isAlpnSupported()) {\n                 return new BouncyCastleAlpnSslEngine(engine, applicationNegotiator, isServer);\n             }\n-            // ALPN support was recently backported to Java8 as\n-            // https://bugs.java.com/bugdatabase/view_bug.do?bug_id=8230977.\n-            // Because of this lets not do a Java version runtime check but just depend on if the required methods are\n-            // present\n-            if (JdkAlpnSslUtils.supportsAlpn()) {\n-                return new JdkAlpnSslEngine(engine, applicationNegotiator, isServer);\n-            }\n-            throw new UnsupportedOperationException(\"ALPN not supported. Unable to wrap SSLEngine of type '\"\n-                    + engine.getClass().getName() + \"')\");\n+            return new JdkAlpnSslEngine(engine, applicationNegotiator, isServer);\n         }\n     }\n \n     static boolean isAlpnSupported() {\n-        return AVAILABLE;\n+        return true;\n     }\n }\ndiff --git a/handler/src/main/java/io/netty/handler/ssl/JdkAlpnSslEngine.java b/handler/src/main/java/io/netty/handler/ssl/JdkAlpnSslEngine.java\nindex 2f25a19e6a3..d4a6ae22abd 100644\n--- a/handler/src/main/java/io/netty/handler/ssl/JdkAlpnSslEngine.java\n+++ b/handler/src/main/java/io/netty/handler/ssl/JdkAlpnSslEngine.java\n@@ -15,6 +15,7 @@\n  */\n package io.netty.handler.ssl;\n \n+import io.netty.util.internal.EmptyArrays;\n import io.netty.util.internal.StringUtil;\n \n import java.nio.ByteBuffer;\n@@ -25,6 +26,7 @@\n import javax.net.ssl.SSLEngine;\n import javax.net.ssl.SSLEngineResult;\n import javax.net.ssl.SSLException;\n+import javax.net.ssl.SSLParameters;\n \n import static io.netty.handler.ssl.JdkApplicationProtocolNegotiator.ProtocolSelectionListener;\n import static io.netty.handler.ssl.JdkApplicationProtocolNegotiator.ProtocolSelector;\n@@ -102,13 +104,16 @@ void checkUnsupported() {\n                new BiConsumer<SSLEngine, AlpnSelector>() {\n                    @Override\n                    public void accept(SSLEngine e, AlpnSelector s) {\n-                       JdkAlpnSslUtils.setHandshakeApplicationProtocolSelector(e, s);\n+                       e.setHandshakeApplicationProtocolSelector(s);\n                    }\n                },\n                new BiConsumer<SSLEngine, List<String>>() {\n                    @Override\n                    public void accept(SSLEngine e, List<String> p) {\n-                       JdkAlpnSslUtils.setApplicationProtocols(e, p);\n+                       String[] protocolArray = p.toArray(EmptyArrays.EMPTY_STRINGS);\n+                       SSLParameters parameters = e.getSSLParameters();\n+                       parameters.setApplicationProtocols(protocolArray);\n+                       e.setSSLParameters(parameters);\n                    }\n                });\n     }\n@@ -188,21 +193,22 @@ public String getNegotiatedApplicationProtocol() {\n     // java8 version we don't use @Override annotations here.\n     @SuppressWarnings(\"override\")\n     public String getApplicationProtocol() {\n-        return JdkAlpnSslUtils.getApplicationProtocol(getWrappedEngine());\n+        return getWrappedEngine().getApplicationProtocol();\n     }\n \n     @SuppressWarnings(\"override\")\n     public String getHandshakeApplicationProtocol() {\n-        return JdkAlpnSslUtils.getHandshakeApplicationProtocol(getWrappedEngine());\n+        return getWrappedEngine().getHandshakeApplicationProtocol();\n     }\n \n     @SuppressWarnings(\"override\")\n     public void setHandshakeApplicationProtocolSelector(BiFunction<SSLEngine, List<String>, String> selector) {\n-        JdkAlpnSslUtils.setHandshakeApplicationProtocolSelector(getWrappedEngine(), selector);\n+        SSLEngine engine = getWrappedEngine();\n+        engine.setHandshakeApplicationProtocolSelector(selector);\n     }\n \n     @SuppressWarnings(\"override\")\n     public BiFunction<SSLEngine, List<String>, String> getHandshakeApplicationProtocolSelector() {\n-        return JdkAlpnSslUtils.getHandshakeApplicationProtocolSelector(getWrappedEngine());\n+        return getWrappedEngine().getHandshakeApplicationProtocolSelector();\n     }\n }\ndiff --git a/handler/src/main/java/io/netty/handler/ssl/JdkAlpnSslUtils.java b/handler/src/main/java/io/netty/handler/ssl/JdkAlpnSslUtils.java\ndeleted file mode 100644\nindex eb28c0f661a..00000000000\n--- a/handler/src/main/java/io/netty/handler/ssl/JdkAlpnSslUtils.java\n+++ /dev/null\n@@ -1,178 +0,0 @@\n-/*\n- * Copyright 2017 The Netty Project\n- *\n- * The Netty Project licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package io.netty.handler.ssl;\n-\n-import io.netty.util.internal.EmptyArrays;\n-import io.netty.util.internal.PlatformDependent;\n-import io.netty.util.internal.logging.InternalLogger;\n-import io.netty.util.internal.logging.InternalLoggerFactory;\n-\n-import java.lang.reflect.Method;\n-import java.security.AccessController;\n-import java.security.PrivilegedExceptionAction;\n-import java.util.List;\n-import java.util.function.BiFunction;\n-import javax.net.ssl.SSLContext;\n-import javax.net.ssl.SSLEngine;\n-import javax.net.ssl.SSLParameters;\n-\n-final class JdkAlpnSslUtils {\n-    private static final InternalLogger logger = InternalLoggerFactory.getInstance(JdkAlpnSslUtils.class);\n-    private static final Method SET_APPLICATION_PROTOCOLS;\n-    private static final Method GET_APPLICATION_PROTOCOL;\n-    private static final Method GET_HANDSHAKE_APPLICATION_PROTOCOL;\n-    private static final Method SET_HANDSHAKE_APPLICATION_PROTOCOL_SELECTOR;\n-    private static final Method GET_HANDSHAKE_APPLICATION_PROTOCOL_SELECTOR;\n-\n-    static {\n-        Method getHandshakeApplicationProtocol;\n-        Method getApplicationProtocol;\n-        Method setApplicationProtocols;\n-        Method setHandshakeApplicationProtocolSelector;\n-        Method getHandshakeApplicationProtocolSelector;\n-\n-        try {\n-            SSLContext context = SSLContext.getInstance(JdkSslContext.PROTOCOL);\n-            context.init(null, null, null);\n-            SSLEngine engine = context.createSSLEngine();\n-            getHandshakeApplicationProtocol = AccessController.doPrivileged(new PrivilegedExceptionAction<Method>() {\n-                @Override\n-                public Method run() throws Exception {\n-                    return SSLEngine.class.getMethod(\"getHandshakeApplicationProtocol\");\n-                }\n-            });\n-            getHandshakeApplicationProtocol.invoke(engine);\n-            getApplicationProtocol = AccessController.doPrivileged(new PrivilegedExceptionAction<Method>() {\n-                @Override\n-                public Method run() throws Exception {\n-                    return SSLEngine.class.getMethod(\"getApplicationProtocol\");\n-                }\n-            });\n-            getApplicationProtocol.invoke(engine);\n-\n-            setApplicationProtocols = AccessController.doPrivileged(new PrivilegedExceptionAction<Method>() {\n-                @Override\n-                public Method run() throws Exception {\n-                    return SSLParameters.class.getMethod(\"setApplicationProtocols\", String[].class);\n-                }\n-            });\n-            setApplicationProtocols.invoke(engine.getSSLParameters(), new Object[]{EmptyArrays.EMPTY_STRINGS});\n-\n-            setHandshakeApplicationProtocolSelector =\n-                    AccessController.doPrivileged(new PrivilegedExceptionAction<Method>() {\n-                @Override\n-                public Method run() throws Exception {\n-                    return SSLEngine.class.getMethod(\"setHandshakeApplicationProtocolSelector\", BiFunction.class);\n-                }\n-            });\n-            setHandshakeApplicationProtocolSelector.invoke(engine, new BiFunction<SSLEngine, List<String>, String>() {\n-                @Override\n-                public String apply(SSLEngine sslEngine, List<String> strings) {\n-                    return null;\n-                }\n-            });\n-\n-            getHandshakeApplicationProtocolSelector =\n-                    AccessController.doPrivileged(new PrivilegedExceptionAction<Method>() {\n-                @Override\n-                public Method run() throws Exception {\n-                    return SSLEngine.class.getMethod(\"getHandshakeApplicationProtocolSelector\");\n-                }\n-            });\n-            getHandshakeApplicationProtocolSelector.invoke(engine);\n-        } catch (Throwable t) {\n-            int version = PlatformDependent.javaVersion();\n-            if (version >= 9) {\n-                // We only log when run on java9+ as this is expected on some earlier java8 versions\n-                logger.error(\"Unable to initialize JdkAlpnSslUtils, but the detected java version was: {}\", version, t);\n-            }\n-            getHandshakeApplicationProtocol = null;\n-            getApplicationProtocol = null;\n-            setApplicationProtocols = null;\n-            setHandshakeApplicationProtocolSelector = null;\n-            getHandshakeApplicationProtocolSelector = null;\n-        }\n-        GET_HANDSHAKE_APPLICATION_PROTOCOL = getHandshakeApplicationProtocol;\n-        GET_APPLICATION_PROTOCOL = getApplicationProtocol;\n-        SET_APPLICATION_PROTOCOLS = setApplicationProtocols;\n-        SET_HANDSHAKE_APPLICATION_PROTOCOL_SELECTOR = setHandshakeApplicationProtocolSelector;\n-        GET_HANDSHAKE_APPLICATION_PROTOCOL_SELECTOR = getHandshakeApplicationProtocolSelector;\n-    }\n-\n-    private JdkAlpnSslUtils() {\n-    }\n-\n-    static boolean supportsAlpn() {\n-        return GET_APPLICATION_PROTOCOL != null;\n-    }\n-\n-    static String getApplicationProtocol(SSLEngine sslEngine) {\n-        try {\n-            return (String) GET_APPLICATION_PROTOCOL.invoke(sslEngine);\n-        } catch (UnsupportedOperationException ex) {\n-            throw ex;\n-        } catch (Exception ex) {\n-            throw new IllegalStateException(ex);\n-        }\n-    }\n-\n-    static String getHandshakeApplicationProtocol(SSLEngine sslEngine) {\n-        try {\n-            return (String) GET_HANDSHAKE_APPLICATION_PROTOCOL.invoke(sslEngine);\n-        } catch (UnsupportedOperationException ex) {\n-            throw ex;\n-        } catch (Exception ex) {\n-            throw new IllegalStateException(ex);\n-        }\n-    }\n-\n-    static void setApplicationProtocols(SSLEngine engine, List<String> supportedProtocols) {\n-        SSLParameters parameters = engine.getSSLParameters();\n-\n-        String[] protocolArray = supportedProtocols.toArray(EmptyArrays.EMPTY_STRINGS);\n-        try {\n-            SET_APPLICATION_PROTOCOLS.invoke(parameters, new Object[]{protocolArray});\n-        } catch (UnsupportedOperationException ex) {\n-            throw ex;\n-        } catch (Exception ex) {\n-            throw new IllegalStateException(ex);\n-        }\n-        engine.setSSLParameters(parameters);\n-    }\n-\n-    static void setHandshakeApplicationProtocolSelector(\n-            SSLEngine engine, BiFunction<SSLEngine, List<String>, String> selector) {\n-        try {\n-            SET_HANDSHAKE_APPLICATION_PROTOCOL_SELECTOR.invoke(engine, selector);\n-        } catch (UnsupportedOperationException ex) {\n-            throw ex;\n-        } catch (Exception ex) {\n-            throw new IllegalStateException(ex);\n-        }\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    static BiFunction<SSLEngine, List<String>, String> getHandshakeApplicationProtocolSelector(SSLEngine engine) {\n-        try {\n-            return (BiFunction<SSLEngine, List<String>, String>)\n-                    GET_HANDSHAKE_APPLICATION_PROTOCOL_SELECTOR.invoke(engine);\n-        } catch (UnsupportedOperationException ex) {\n-            throw ex;\n-        } catch (Exception ex) {\n-            throw new IllegalStateException(ex);\n-        }\n-    }\n-}\n",
  "test_patch" : "diff --git a/handler/src/test/java/io/netty/handler/ssl/JdkSslEngineTest.java b/handler/src/test/java/io/netty/handler/ssl/JdkSslEngineTest.java\nindex 5d1a7f13816..38a14e1ec0b 100644\n--- a/handler/src/test/java/io/netty/handler/ssl/JdkSslEngineTest.java\n+++ b/handler/src/test/java/io/netty/handler/ssl/JdkSslEngineTest.java\n@@ -46,7 +46,7 @@ public enum ProviderType {\n         ALPN_JAVA {\n             @Override\n             boolean isAvailable() {\n-                return JdkAlpnSslUtils.supportsAlpn();\n+                return true;\n             }\n \n             @Override\ndiff --git a/handler/src/test/java/io/netty/handler/ssl/OpenSslErrorStackAssertSSLEngine.java b/handler/src/test/java/io/netty/handler/ssl/OpenSslErrorStackAssertSSLEngine.java\nindex 916395086b2..35ce39521eb 100644\n--- a/handler/src/test/java/io/netty/handler/ssl/OpenSslErrorStackAssertSSLEngine.java\n+++ b/handler/src/test/java/io/netty/handler/ssl/OpenSslErrorStackAssertSSLEngine.java\n@@ -340,7 +340,7 @@ public void setSSLParameters(SSLParameters params) {\n     public String getApplicationProtocol() {\n         if (PlatformDependent.javaVersion() >= 9) {\n             try {\n-                return JdkAlpnSslUtils.getApplicationProtocol(getWrappedEngine());\n+            return getWrappedEngine().getApplicationProtocol();\n             } finally {\n                 assertErrorStackEmpty();\n             }\n@@ -351,7 +351,7 @@ public String getApplicationProtocol() {\n     public String getHandshakeApplicationProtocol() {\n         if (PlatformDependent.javaVersion() >= 9) {\n             try {\n-                return JdkAlpnSslUtils.getHandshakeApplicationProtocol(getWrappedEngine());\n+            return getWrappedEngine().getHandshakeApplicationProtocol();\n             } finally {\n                 assertErrorStackEmpty();\n             }\n@@ -362,7 +362,8 @@ public String getHandshakeApplicationProtocol() {\n     public void setHandshakeApplicationProtocolSelector(BiFunction<SSLEngine, List<String>, String> selector) {\n         if (PlatformDependent.javaVersion() >= 9) {\n             try {\n-                JdkAlpnSslUtils.setHandshakeApplicationProtocolSelector(getWrappedEngine(), selector);\n+            SSLEngine engine = getWrappedEngine();\n+            engine.setHandshakeApplicationProtocolSelector(selector);\n             } finally {\n                 assertErrorStackEmpty();\n             }\n@@ -373,7 +374,7 @@ public void setHandshakeApplicationProtocolSelector(BiFunction<SSLEngine, List<S\n     public BiFunction<SSLEngine, List<String>, String> getHandshakeApplicationProtocolSelector() {\n         if (PlatformDependent.javaVersion() >= 9) {\n             try {\n-                return JdkAlpnSslUtils.getHandshakeApplicationProtocolSelector(getWrappedEngine());\n+            return getWrappedEngine().getHandshakeApplicationProtocolSelector();\n             } finally {\n                 assertErrorStackEmpty();\n             }\n",
  "problem_statement" : "Remove JdkAlpnSslUtils\n\nMotivation:\r\nNetty 5 require at least Java 25 where all of these methods are available, and we no longer need to use reflection to use ALPN with the JDK SSLEngine.\r\n\r\nModification:\r\nCall the SSLEngine methods directly and remove the reflective method calls and lookups.\r\n\r\nResult:\r\nCleaner code.\r\n",
  "hints_text" : null,
  "created_at" : "Wed Jan 28 23:34:03 CET 2026",
  "version" : null,
  "FAIL_TO_PASS" : [ "JdkSslEngineTest", "OpenSslErrorStackAssertSSLEngine" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -pl handler -Dtest=JdkSslEngineTest,OpenSslErrorStackAssertSSLEngine",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 16193,
  "metadata" : null
}, {
  "instance_id" : "netty-netty-PR-16188",
  "repo" : "netty/netty",
  "base_commit" : "ccc5570a25ede657182895a59c978d568f7d2846",
  "patch" : "diff --git a/buffer/src/main/java/io/netty/buffer/ReadOnlyAbstractByteBuf.java b/buffer/src/main/java/io/netty/buffer/ReadOnlyAbstractByteBuf.java\nindex ca3b709e420..8dacab67983 100644\n--- a/buffer/src/main/java/io/netty/buffer/ReadOnlyAbstractByteBuf.java\n+++ b/buffer/src/main/java/io/netty/buffer/ReadOnlyAbstractByteBuf.java\n@@ -23,6 +23,7 @@ final class ReadOnlyAbstractByteBuf extends ReadOnlyByteBuf {\n \n     ReadOnlyAbstractByteBuf(AbstractByteBuf buffer) {\n         super(buffer);\n+        assert buffer.unwrap() == null || buffer.unwrap() instanceof AbstractByteBuf;\n     }\n \n     @Override\ndiff --git a/buffer/src/main/java/io/netty/buffer/Unpooled.java b/buffer/src/main/java/io/netty/buffer/Unpooled.java\nindex 708aaa35efa..a388b1816a6 100644\n--- a/buffer/src/main/java/io/netty/buffer/Unpooled.java\n+++ b/buffer/src/main/java/io/netty/buffer/Unpooled.java\n@@ -702,7 +702,10 @@ public static ByteBuf unmodifiableBuffer(ByteBuf buffer) {\n     }\n \n     private static ReadOnlyByteBuf newReadyOnlyBuffer(ByteBuf buffer) {\n-        return buffer instanceof AbstractByteBuf ?\n+        // We can only use ReadOnlyAbstractByteBuf if we either have nothing to unwrap or the unwrapped buffer is of\n+        // type AbstractByteBuf. Otherwise we will produce a CCE later.\n+        return buffer instanceof AbstractByteBuf && (\n+                buffer.unwrap() == null || buffer.unwrap() instanceof AbstractByteBuf) ?\n                 new ReadOnlyAbstractByteBuf((AbstractByteBuf) buffer) :\n                 new ReadOnlyByteBuf(buffer);\n     }\n",
  "test_patch" : "diff --git a/buffer/src/test/java/io/netty/buffer/ReadOnlyByteBufTest.java b/buffer/src/test/java/io/netty/buffer/ReadOnlyByteBufTest.java\nindex a1f663b1cf4..187be34c121 100644\n--- a/buffer/src/test/java/io/netty/buffer/ReadOnlyByteBufTest.java\n+++ b/buffer/src/test/java/io/netty/buffer/ReadOnlyByteBufTest.java\n@@ -61,6 +61,11 @@ public void testUnmodifiableBuffer() {\n         assertThat(unmodifiableBuffer(buffer(1))).isInstanceOf(ReadOnlyByteBuf.class);\n     }\n \n+    @Test\n+    public void testUnmodifiableBufferDoesNotThrowClassCastException() {\n+        unmodifiableBuffer(new DuplicatedByteBuf(mock(ByteBuf.class)));\n+    }\n+\n     @Test\n     public void testUnwrap() {\n         ByteBuf buf = buffer(1);\n",
  "problem_statement" : "Fix possible ClassCastException when using ReadOnlyAbstractByteBuf\n\nMotivation:\n\nhttps://github.com/netty/netty/pull/15413 introduced a change that reduced bound checks. Unfortunally this change also introduced a bug that can cause ClassCastExceptions in some rare-cases (mostly when people write their own ByteBuf implementation.\n\nModifications:\n\n- Ensure the wrapped buffer will really be of type AbstractByteBuf\n- Add unit test\n\nResult:\n\nFixes rare ClassCastException\n",
  "hints_text" : null,
  "created_at" : "Tue Jan 27 16:47:28 CET 2026",
  "version" : null,
  "FAIL_TO_PASS" : [ "ReadOnlyByteBufTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -pl buffer -Dtest=ReadOnlyByteBufTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 16188,
  "metadata" : null
}, {
  "instance_id" : "netty-netty-PR-16172",
  "repo" : "netty/netty",
  "base_commit" : "2af3d1391dc64a1ae739003eab2d2fa2c1d7a8e6",
  "patch" : "diff --git a/common/src/main/java/io/netty/util/NetUtil.java b/common/src/main/java/io/netty/util/NetUtil.java\nindex 418dd89fd19..84911e6de83 100644\n--- a/common/src/main/java/io/netty/util/NetUtil.java\n+++ b/common/src/main/java/io/netty/util/NetUtil.java\n@@ -35,8 +35,6 @@\n import java.net.InetSocketAddress;\n import java.net.NetworkInterface;\n import java.net.UnknownHostException;\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n import java.util.Arrays;\n import java.util.Collection;\n \n@@ -162,70 +160,65 @@ public final class NetUtil {\n         LOOPBACK_IF = loopback.iface();\n         LOCALHOST = loopback.address();\n \n-        // As a SecurityManager may prevent reading the somaxconn file we wrap this in a privileged block.\n-        //\n-        // See https://github.com/netty/netty/issues/3680\n-        SOMAXCONN = AccessController.doPrivileged(new SoMaxConnAction());\n+        SOMAXCONN = getSoMaxConn();\n     }\n \n-    private static final class SoMaxConnAction implements PrivilegedAction<Integer> {\n-        @Override\n-        public Integer run() {\n-            // Determine the default somaxconn (server socket backlog) value of the platform.\n-            // The known defaults:\n-            // - Windows NT Server 4.0+: 200\n-            // - Mac OS X: 128\n-            // - Linux kernel > 5.4 : 4096\n-            int somaxconn;\n-            if (PlatformDependent.isWindows()) {\n-                somaxconn = 200;\n-            } else if (PlatformDependent.isOsx()) {\n-                somaxconn = 128;\n-            } else {\n-                somaxconn = 4096;\n-            }\n-            File file = new File(\"/proc/sys/net/core/somaxconn\");\n-            try {\n-                // file.exists() may throw a SecurityException if a SecurityManager is used, so execute it in the\n-                // try / catch block.\n-                // See https://github.com/netty/netty/issues/4936\n-                if (file.exists()) {\n-                    try (BufferedReader in = new BufferedReader(new InputStreamReader(\n-                            new BoundedInputStream(new FileInputStream(file))))) {\n-                        somaxconn = Integer.parseInt(in.readLine());\n-                        if (logger.isDebugEnabled()) {\n-                            logger.debug(\"{}: {}\", file, somaxconn);\n-                        }\n+    private static int getSoMaxConn() {\n+        // Determine the default somaxconn (server socket backlog) value of the platform.\n+        // The known defaults:\n+        // - Windows NT Server 4.0+: 200\n+        // - Mac OS X: 128\n+        // - Linux kernel > 5.4 : 4096\n+        int somaxconn;\n+        if (PlatformDependent.isWindows()) {\n+            somaxconn = 200;\n+        } else if (PlatformDependent.isOsx()) {\n+            somaxconn = 128;\n+        } else {\n+            somaxconn = 4096;\n+        }\n+        File file = new File(\"/proc/sys/net/core/somaxconn\");\n+        try {\n+            // file.exists() may throw a SecurityException if a SecurityManager is used, so execute it in the\n+            // try / catch block.\n+            // See https://github.com/netty/netty/issues/4936\n+            if (file.exists()) {\n+                try (BufferedReader in = new BufferedReader(new InputStreamReader(\n+                        new BoundedInputStream(new FileInputStream(file))))) {\n+                    somaxconn = Integer.parseInt(in.readLine());\n+                    if (logger.isDebugEnabled()) {\n+                        logger.debug(\"{}: {}\", file, somaxconn);\n                     }\n-                } else {\n-                    // Try to get from sysctl\n-                    Integer tmp = null;\n-                    if (SystemPropertyUtil.getBoolean(\"io.netty.net.somaxconn.trySysctl\", false)) {\n-                        tmp = sysctlGetInt(\"kern.ipc.somaxconn\");\n-                        if (tmp == null) {\n-                            tmp = sysctlGetInt(\"kern.ipc.soacceptqueue\");\n-                            if (tmp != null) {\n-                                somaxconn = tmp;\n-                            }\n-                        } else {\n+                }\n+            } else {\n+                // Try to get from sysctl\n+                Integer tmp = null;\n+                if (SystemPropertyUtil.getBoolean(\"io.netty.net.somaxconn.trySysctl\", false)) {\n+                    tmp = sysctlGetInt(\"kern.ipc.somaxconn\");\n+                    if (tmp == null) {\n+                        tmp = sysctlGetInt(\"kern.ipc.soacceptqueue\");\n+                        if (tmp != null) {\n                             somaxconn = tmp;\n                         }\n-                    }\n-\n-                    if (tmp == null) {\n-                        logger.debug(\"Failed to get SOMAXCONN from sysctl and file {}. Default: {}\", file,\n-                                somaxconn);\n+                    } else {\n+                        somaxconn = tmp;\n                     }\n                 }\n-            } catch (Exception e) {\n-                if (logger.isDebugEnabled()) {\n-                    logger.debug(\"Failed to get SOMAXCONN from sysctl and file {}. Default: {}\",\n-                            file, somaxconn, e);\n+\n+                if (tmp == null) {\n+                    logger.debug(\"Failed to get SOMAXCONN from sysctl and file {}. Default: {}\", file,\n+                            somaxconn);\n                 }\n             }\n-            return somaxconn;\n+        } catch (Exception e) {\n+            if (logger.isDebugEnabled()) {\n+                logger.debug(\"Failed to get SOMAXCONN from sysctl and file {}. Default: {}\",\n+                        file, somaxconn, e);\n+            }\n         }\n+        return somaxconn;\n     }\n+\n     /**\n      * This will execute <a href =\"https://www.freebsd.org/cgi/man.cgi?sysctl(8)\">sysctl</a> with the {@code sysctlKey}\n      * which is expected to return the numeric value for for {@code sysctlKey}.\ndiff --git a/common/src/main/java/io/netty/util/ThreadDeathWatcher.java b/common/src/main/java/io/netty/util/ThreadDeathWatcher.java\nindex 09fd506e14c..6c219ccd60a 100644\n--- a/common/src/main/java/io/netty/util/ThreadDeathWatcher.java\n+++ b/common/src/main/java/io/netty/util/ThreadDeathWatcher.java\n@@ -23,8 +23,6 @@\n import io.netty.util.internal.logging.InternalLogger;\n import io.netty.util.internal.logging.InternalLoggerFactory;\n \n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n import java.util.ArrayList;\n import java.util.List;\n import java.util.Queue;\n@@ -107,13 +105,7 @@ private static void schedule(Thread thread, Runnable task, boolean isWatch) {\n             // See:\n             // - https://github.com/netty/netty/issues/7290\n             // - https://bugs.openjdk.java.net/browse/JDK-7008595\n-            AccessController.doPrivileged(new PrivilegedAction<Void>() {\n-                @Override\n-                public Void run() {\n-                    watcherThread.setContextClassLoader(null);\n-                    return null;\n-                }\n-            });\n+            watcherThread.setContextClassLoader(null);\n \n             watcherThread.start();\n             ThreadDeathWatcher.watcherThread = watcherThread;\ndiff --git a/common/src/main/java/io/netty/util/concurrent/EventExecutorGroup.java b/common/src/main/java/io/netty/util/concurrent/EventExecutorGroup.java\nindex 842f73739a3..224bea13b51 100644\n--- a/common/src/main/java/io/netty/util/concurrent/EventExecutorGroup.java\n+++ b/common/src/main/java/io/netty/util/concurrent/EventExecutorGroup.java\n@@ -19,7 +19,6 @@\n import java.util.concurrent.Callable;\n import java.util.concurrent.ExecutionException;\n import java.util.concurrent.Executor;\n-import java.util.concurrent.Executors;\n import java.util.concurrent.RejectedExecutionException;\n import java.util.concurrent.TimeUnit;\n \n@@ -184,11 +183,6 @@ ScheduledFuture<?> scheduleWithFixedDelay(Runnable command,\n      * for a task, you can use constructions of the form\n      * {@code result = exec.submit(aCallable).get();}\n      *\n-     * <p>Note: The {@link Executors} class includes a set of methods\n-     * that can convert some other common closure-like objects,\n-     * for example, {@link java.security.PrivilegedAction} to\n-     * {@link Callable} form so they can be submitted.\n-     *\n      * @param task the task to submit\n      * @param <T> the type of the task's result\n      * @return a Future representing pending completion of the task\ndiff --git a/common/src/main/java/io/netty/util/concurrent/GlobalEventExecutor.java b/common/src/main/java/io/netty/util/concurrent/GlobalEventExecutor.java\nindex a684249a5df..29629ef2bd6 100644\n--- a/common/src/main/java/io/netty/util/concurrent/GlobalEventExecutor.java\n+++ b/common/src/main/java/io/netty/util/concurrent/GlobalEventExecutor.java\n@@ -21,11 +21,8 @@\n import io.netty.util.internal.ThrowableUtil;\n import io.netty.util.internal.logging.InternalLogger;\n import io.netty.util.internal.logging.InternalLoggerFactory;\n-\n import org.jetbrains.annotations.Async.Schedule;\n \n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n import java.util.Queue;\n import java.util.concurrent.BlockingQueue;\n import java.util.concurrent.Executors;\n@@ -232,14 +229,9 @@ private void execute0(@Schedule Runnable task) {\n     private void startThread() {\n         if (started.compareAndSet(false, true)) {\n             final Thread callingThread = Thread.currentThread();\n-            ClassLoader parentCCL = AccessController.doPrivileged(new PrivilegedAction<ClassLoader>() {\n-                @Override\n-                public ClassLoader run() {\n-                    return callingThread.getContextClassLoader();\n-                }\n-            });\n+            ClassLoader parentCCL = callingThread.getContextClassLoader();\n             // Avoid calling classloader leaking through Thread.inheritedAccessControlContext.\n-            setContextClassLoader(callingThread, null);\n+            callingThread.setContextClassLoader(null);\n             try {\n                 final Thread t = threadFactory.newThread(taskRunner);\n                 // Set to null to ensure we not create classloader leaks by holds a strong reference to the inherited\n@@ -247,7 +239,7 @@ public ClassLoader run() {\n                 // See:\n                 // - https://github.com/netty/netty/issues/7290\n                 // - https://bugs.openjdk.java.net/browse/JDK-7008595\n-                setContextClassLoader(t, null);\n+                t.setContextClassLoader(null);\n \n                 // Set the thread before starting it as otherwise inEventLoop() may return false and so produce\n                 // an assert error.\n@@ -255,21 +247,11 @@ public ClassLoader run() {\n                 thread = t;\n                 t.start();\n             } finally {\n-                setContextClassLoader(callingThread, parentCCL);\n+                callingThread.setContextClassLoader(parentCCL);\n             }\n         }\n     }\n \n-    private static void setContextClassLoader(final Thread t, final ClassLoader cl) {\n-        AccessController.doPrivileged(new PrivilegedAction<Void>() {\n-            @Override\n-            public Void run() {\n-                t.setContextClassLoader(cl);\n-                return null;\n-            }\n-        });\n-    }\n-\n     final class TaskRunner implements Runnable {\n         @Override\n         public void run() {\ndiff --git a/common/src/main/java/io/netty/util/internal/CleanerJava6.java b/common/src/main/java/io/netty/util/internal/CleanerJava6.java\nindex 93b8b84159b..fc78a996805 100644\n--- a/common/src/main/java/io/netty/util/internal/CleanerJava6.java\n+++ b/common/src/main/java/io/netty/util/internal/CleanerJava6.java\n@@ -21,8 +21,6 @@\n import java.lang.invoke.MethodHandle;\n import java.lang.invoke.MethodHandles;\n import java.nio.ByteBuffer;\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n import java.util.Objects;\n \n import static java.lang.invoke.MethodType.methodType;\n@@ -43,43 +41,29 @@ final class CleanerJava6 implements Cleaner {\n         Throwable error = null;\n         final ByteBuffer direct = ByteBuffer.allocateDirect(1);\n         try {\n-            Object mayBeCleanerField = AccessController.doPrivileged(new PrivilegedAction<Object>() {\n-                @Override\n-                public Object run() {\n-                    try {\n-                        Class<?> cleanerClass = Class.forName(\"sun.misc.Cleaner\");\n-                        Class<?> directBufClass = Class.forName(\"sun.nio.ch.DirectBuffer\");\n-                        MethodHandles.Lookup lookup = MethodHandles.lookup();\n-\n-                        // Call clean() on the cleaner\n-                        MethodHandle clean = lookup.findVirtual(\n-                                cleanerClass, \"clean\", methodType(void.class));\n-                        // But only if the cleaner is non-null\n-                        MethodHandle nullTest = lookup.findStatic(\n-                                Objects.class, \"nonNull\", methodType(boolean.class, Object.class));\n-                        clean = MethodHandles.guardWithTest(\n-                                nullTest.asType(methodType(boolean.class, cleanerClass)),\n-                                clean,\n-                                nullTest.asType(methodType(void.class, cleanerClass)));\n-                        // Change receiver to DirectBuffer, convert DirectBuffer to Cleaner by calling cleaner()\n-                        clean = MethodHandles.filterArguments(clean, 0, lookup.findVirtual(\n-                                directBufClass,\n-                                \"cleaner\",\n-                                methodType(cleanerClass)));\n-                        // Change receiver to ByteBuffer, convert using explicit cast to DirectBuffer\n-                        clean = MethodHandles.explicitCastArguments(clean,\n-                                methodType(void.class, ByteBuffer.class));\n-                        return clean;\n-                    } catch (Throwable cause) {\n-                        return cause;\n-                    }\n-                }\n-            });\n-            if (mayBeCleanerField instanceof Throwable) {\n-                throw (Throwable) mayBeCleanerField;\n-            }\n-\n-            clean = (MethodHandle) mayBeCleanerField;\n+            Class<?> cleanerClass = Class.forName(\"sun.misc.Cleaner\");\n+            Class<?> directBufClass = Class.forName(\"sun.nio.ch.DirectBuffer\");\n+            MethodHandles.Lookup lookup = MethodHandles.lookup();\n+\n+            // Call clean() on the cleaner\n+            clean = lookup.findVirtual(\n+                    cleanerClass, \"clean\", methodType(void.class));\n+            // But only if the cleaner is non-null\n+            MethodHandle nullTest = lookup.findStatic(\n+                    Objects.class, \"nonNull\", methodType(boolean.class, Object.class));\n+            clean = MethodHandles.guardWithTest(\n+                    nullTest.asType(methodType(boolean.class, cleanerClass)),\n+                    clean,\n+                    nullTest.asType(methodType(void.class, cleanerClass)));\n+            // Change receiver to DirectBuffer, convert DirectBuffer to Cleaner by calling cleaner()\n+            clean = MethodHandles.filterArguments(clean, 0, lookup.findVirtual(\n+                    directBufClass,\n+                    \"cleaner\",\n+                    methodType(cleanerClass)));\n+            // Change receiver to ByteBuffer, convert using explicit cast to DirectBuffer\n+            clean = MethodHandles.explicitCastArguments(clean,\n+                    methodType(void.class, ByteBuffer.class));\n+\n             clean.invokeExact(direct);\n         } catch (Throwable t) {\n             // We don't have ByteBuffer.cleaner().\n@@ -114,30 +98,9 @@ private static void freeDirectBufferStatic(ByteBuffer buffer) {\n         if (!buffer.isDirect()) {\n             return;\n         }\n-        if (System.getSecurityManager() == null) {\n-            try {\n-                freeDirectBuffer0(buffer);\n-            } catch (Throwable cause) {\n-                PlatformDependent0.throwException(cause);\n-            }\n-        } else {\n-            freeDirectBufferPrivileged(buffer);\n-        }\n-    }\n-\n-    private static void freeDirectBufferPrivileged(final ByteBuffer buffer) {\n-        Throwable cause = AccessController.doPrivileged(new PrivilegedAction<Throwable>() {\n-            @Override\n-            public Throwable run() {\n-                try {\n-                    freeDirectBuffer0(buffer);\n-                    return null;\n-                } catch (Throwable cause) {\n-                    return cause;\n-                }\n-            }\n-        });\n-        if (cause != null) {\n+        try {\n+            freeDirectBuffer0(buffer);\n+        } catch (Throwable cause) {\n             PlatformDependent0.throwException(cause);\n         }\n     }\ndiff --git a/common/src/main/java/io/netty/util/internal/CleanerJava9.java b/common/src/main/java/io/netty/util/internal/CleanerJava9.java\nindex 24a329a1297..909614acc57 100644\n--- a/common/src/main/java/io/netty/util/internal/CleanerJava9.java\n+++ b/common/src/main/java/io/netty/util/internal/CleanerJava9.java\n@@ -22,8 +22,6 @@\n import java.lang.invoke.MethodHandle;\n import java.lang.invoke.MethodHandles;\n import java.nio.ByteBuffer;\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n \n import static java.lang.invoke.MethodType.methodType;\n \n@@ -36,34 +34,23 @@ final class CleanerJava9 implements Cleaner {\n     private static final MethodHandle INVOKE_CLEANER;\n \n     static {\n-        final MethodHandle method;\n-        final Throwable error;\n+        MethodHandle method;\n+        Throwable error;\n         if (PlatformDependent0.hasUnsafe()) {\n             final ByteBuffer buffer = ByteBuffer.allocateDirect(1);\n-            Object maybeInvokeMethod = AccessController.doPrivileged(new PrivilegedAction<Object>() {\n-                @Override\n-                public Object run() {\n-                    try {\n-                        // See https://bugs.openjdk.java.net/browse/JDK-8171377\n-                        Class<? extends Unsafe> unsafeClass = PlatformDependent0.UNSAFE.getClass();\n-                        MethodHandles.Lookup lookup = MethodHandles.lookup();\n-                        MethodHandle invokeCleaner = lookup.findVirtual(\n-                                unsafeClass, \"invokeCleaner\", methodType(void.class, ByteBuffer.class));\n-                        invokeCleaner = invokeCleaner.bindTo(PlatformDependent0.UNSAFE);\n-                        invokeCleaner.invokeExact(buffer);\n-                        return invokeCleaner;\n-                    } catch (Throwable e) {\n-                        return e;\n-                    }\n-                }\n-            });\n-\n-            if (maybeInvokeMethod instanceof Throwable) {\n-                method = null;\n-                error = (Throwable) maybeInvokeMethod;\n-            } else {\n-                method = (MethodHandle) maybeInvokeMethod;\n+            try {\n+                // See https://bugs.openjdk.java.net/browse/JDK-8171377\n+                Class<? extends Unsafe> unsafeClass = PlatformDependent0.UNSAFE.getClass();\n+                MethodHandles.Lookup lookup = MethodHandles.lookup();\n+                MethodHandle invokeCleaner = lookup.findVirtual(\n+                        unsafeClass, \"invokeCleaner\", methodType(void.class, ByteBuffer.class));\n+                invokeCleaner = invokeCleaner.bindTo(PlatformDependent0.UNSAFE);\n+                invokeCleaner.invokeExact(buffer);\n+                method = invokeCleaner;\n                 error = null;\n+            } catch (Throwable e) {\n+                error = e;\n+                method = null;\n             }\n         } else {\n             method = null;\n@@ -93,33 +80,10 @@ public void freeDirectBuffer(ByteBuffer buffer) {\n     }\n \n     private static void freeDirectBufferStatic(ByteBuffer buffer) {\n-        // Try to minimize overhead when there is no SecurityManager present.\n-        // See https://bugs.openjdk.java.net/browse/JDK-8191053.\n-        if (System.getSecurityManager() == null) {\n-            try {\n-                INVOKE_CLEANER.invokeExact(buffer);\n-            } catch (Throwable cause) {\n-                PlatformDependent0.throwException(cause);\n-            }\n-        } else {\n-            freeDirectBufferPrivileged(buffer);\n-        }\n-    }\n-\n-    private static void freeDirectBufferPrivileged(final ByteBuffer buffer) {\n-        Throwable error = AccessController.doPrivileged(new PrivilegedAction<Throwable>() {\n-            @Override\n-            public Throwable run() {\n-                try {\n-                    INVOKE_CLEANER.invokeExact(buffer);\n-                } catch (Throwable e) {\n-                    return e;\n-                }\n-                return null;\n-            }\n-        });\n-        if (error != null) {\n-            PlatformDependent0.throwException(error);\n+        try {\n+            INVOKE_CLEANER.invokeExact(buffer);\n+        } catch (Throwable cause) {\n+            PlatformDependent0.throwException(cause);\n         }\n     }\n \ndiff --git a/common/src/main/java/io/netty/util/internal/NativeLibraryLoader.java b/common/src/main/java/io/netty/util/internal/NativeLibraryLoader.java\nindex 1e4dbf3d10f..3743d07976c 100644\n--- a/common/src/main/java/io/netty/util/internal/NativeLibraryLoader.java\n+++ b/common/src/main/java/io/netty/util/internal/NativeLibraryLoader.java\n@@ -30,10 +30,8 @@\n import java.net.URL;\n import java.nio.file.Files;\n import java.nio.file.attribute.PosixFilePermission;\n-import java.security.AccessController;\n import java.security.MessageDigest;\n import java.security.NoSuchAlgorithmException;\n-import java.security.PrivilegedAction;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collections;\n@@ -410,29 +408,20 @@ private static void loadLibrary(final ClassLoader loader, final String name, fin\n \n     private static void loadLibraryByHelper(final Class<?> helper, final String name, final boolean absolute)\n             throws UnsatisfiedLinkError {\n-        Object ret = AccessController.doPrivileged(new PrivilegedAction<Object>() {\n-            @Override\n-            public Object run() {\n-                try {\n-                    // Invoke the helper to load the native library, if it succeeds, then the native\n-                    // library belong to the specified ClassLoader.\n-                    Method method = helper.getMethod(\"loadLibrary\", String.class, boolean.class);\n-                    method.setAccessible(true);\n-                    return method.invoke(null, name, absolute);\n-                } catch (Exception e) {\n-                    return e;\n-                }\n-            }\n-        });\n-        if (ret instanceof Throwable) {\n-            Throwable t = (Throwable) ret;\n-            assert !(t instanceof UnsatisfiedLinkError) : t + \" should be a wrapper throwable\";\n-            Throwable cause = t.getCause();\n+        try {\n+            // Invoke the helper to load the native library, if it succeeds, then the native\n+            // library belong to the specified ClassLoader.\n+            Method method = helper.getMethod(\"loadLibrary\", String.class, boolean.class);\n+            method.setAccessible(true);\n+            method.invoke(null, name, absolute);\n+        } catch (Throwable e) {\n+            assert !(e instanceof UnsatisfiedLinkError) : e + \" should be a wrapper throwable\";\n+            Throwable cause = e.getCause();\n             if (cause instanceof UnsatisfiedLinkError) {\n                 throw (UnsatisfiedLinkError) cause;\n             }\n-            UnsatisfiedLinkError ule = new UnsatisfiedLinkError(t.getMessage());\n-            ule.initCause(t);\n+            UnsatisfiedLinkError ule = new UnsatisfiedLinkError(e.getMessage());\n+            ule.initCause(e);\n             throw ule;\n         }\n     }\n@@ -456,22 +445,17 @@ private static Class<?> tryToLoadClass(final ClassLoader loader, final Class<?>\n             try {\n                 // The helper class is NOT found in target ClassLoader, we have to define the helper class.\n                 final byte[] classBinary = classToByteArray(helper);\n-                return AccessController.doPrivileged(new PrivilegedAction<Class<?>>() {\n-                    @Override\n-                    public Class<?> run() {\n-                        try {\n-                            // Define the helper class in the target ClassLoader,\n-                            //  then we can call the helper to load the native library.\n-                            Method defineClass = ClassLoader.class.getDeclaredMethod(\"defineClass\", String.class,\n-                                    byte[].class, int.class, int.class);\n-                            defineClass.setAccessible(true);\n-                            return (Class<?>) defineClass.invoke(loader, helper.getName(), classBinary, 0,\n-                                    classBinary.length);\n-                        } catch (Exception e) {\n-                            throw new IllegalStateException(\"Define class failed!\", e);\n-                        }\n-                    }\n-                });\n+                try {\n+                    // Define the helper class in the target ClassLoader,\n+                    //  then we can call the helper to load the native library.\n+                    Method defineClass = ClassLoader.class.getDeclaredMethod(\"defineClass\", String.class,\n+                            byte[].class, int.class, int.class);\n+                    defineClass.setAccessible(true);\n+                    return (Class<?>) defineClass.invoke(loader, helper.getName(), classBinary, 0,\n+                            classBinary.length);\n+                } catch (Exception e) {\n+                    throw new IllegalStateException(\"Define class failed!\", e);\n+                }\n             } catch (ClassNotFoundException | RuntimeException | Error e2) {\n                 ThrowableUtil.addSuppressed(e2, e1);\n                 throw e2;\ndiff --git a/common/src/main/java/io/netty/util/internal/ObjectCleaner.java b/common/src/main/java/io/netty/util/internal/ObjectCleaner.java\nindex 560be5b0ead..a99f7466d74 100644\n--- a/common/src/main/java/io/netty/util/internal/ObjectCleaner.java\n+++ b/common/src/main/java/io/netty/util/internal/ObjectCleaner.java\n@@ -19,8 +19,6 @@\n \n import java.lang.ref.ReferenceQueue;\n import java.lang.ref.WeakReference;\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n import java.util.Set;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.atomic.AtomicBoolean;\n@@ -108,16 +106,10 @@ public static void register(Object object, Runnable cleanupTask) {\n             // See:\n             // - https://github.com/netty/netty/issues/7290\n             // - https://bugs.openjdk.java.net/browse/JDK-7008595\n-            AccessController.doPrivileged(new PrivilegedAction<Void>() {\n-                @Override\n-                public Void run() {\n-                    cleanupThread.setContextClassLoader(null);\n-                    return null;\n-                }\n-            });\n+            cleanupThread.setContextClassLoader(null);\n             cleanupThread.setName(CLEANER_THREAD_NAME);\n \n-            // Mark this as a daemon thread to ensure that we the JVM can exit if this is the only thread that is\n+            // Mark this as a daemon thread to ensure that the JVM can exit if this is the only thread that is\n             // running.\n             cleanupThread.setDaemon(true);\n             cleanupThread.start();\ndiff --git a/common/src/main/java/io/netty/util/internal/PlatformDependent.java b/common/src/main/java/io/netty/util/internal/PlatformDependent.java\nindex 1951afbdb31..398fada36b5 100644\n--- a/common/src/main/java/io/netty/util/internal/PlatformDependent.java\n+++ b/common/src/main/java/io/netty/util/internal/PlatformDependent.java\n@@ -47,8 +47,6 @@\n import java.nio.file.Files;\n import java.nio.file.Path;\n import java.nio.file.Paths;\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n import java.util.Arrays;\n import java.util.Collections;\n import java.util.Deque;\n@@ -303,36 +301,34 @@ static void addFilesystemOsClassifiers(final Set<String> availableClassifiers) {\n \n     private static boolean processOsReleaseFile(String osReleaseFileName, Set<String> availableClassifiers) {\n         Path file = Paths.get(osReleaseFileName);\n-        return AccessController.doPrivileged((PrivilegedAction<Boolean>) () -> {\n-            try {\n-                if (Files.exists(file)) {\n-                    try (BufferedReader reader = new BufferedReader(new InputStreamReader(\n-                            new BoundedInputStream(Files.newInputStream(file)), StandardCharsets.UTF_8))) {\n-                        String line;\n-                        while ((line = reader.readLine()) != null) {\n-                            if (line.startsWith(LINUX_ID_PREFIX)) {\n-                                String id = normalizeOsReleaseVariableValue(\n-                                        line.substring(LINUX_ID_PREFIX.length()));\n-                                addClassifier(availableClassifiers, id);\n-                            } else if (line.startsWith(LINUX_ID_LIKE_PREFIX)) {\n-                                line = normalizeOsReleaseVariableValue(\n-                                        line.substring(LINUX_ID_LIKE_PREFIX.length()));\n-                                addClassifier(availableClassifiers, line.split(\" \"));\n-                            }\n+        try {\n+            if (Files.exists(file)) {\n+                try (BufferedReader reader = new BufferedReader(new InputStreamReader(\n+                        new BoundedInputStream(Files.newInputStream(file)), StandardCharsets.UTF_8))) {\n+                    String line;\n+                    while ((line = reader.readLine()) != null) {\n+                        if (line.startsWith(LINUX_ID_PREFIX)) {\n+                            String id = normalizeOsReleaseVariableValue(\n+                                    line.substring(LINUX_ID_PREFIX.length()));\n+                            addClassifier(availableClassifiers, id);\n+                        } else if (line.startsWith(LINUX_ID_LIKE_PREFIX)) {\n+                            line = normalizeOsReleaseVariableValue(\n+                                    line.substring(LINUX_ID_LIKE_PREFIX.length()));\n+                            addClassifier(availableClassifiers, line.split(\" \"));\n                         }\n-                    } catch (SecurityException e) {\n-                        logger.debug(\"Unable to read {}\", osReleaseFileName, e);\n-                    } catch (IOException e) {\n-                        logger.debug(\"Error while reading content of {}\", osReleaseFileName, e);\n                     }\n-                    // specification states we should only fall back if /etc/os-release does not exist\n-                    return true;\n+                } catch (SecurityException e) {\n+                    logger.debug(\"Unable to read {}\", osReleaseFileName, e);\n+                } catch (IOException e) {\n+                    logger.debug(\"Error while reading content of {}\", osReleaseFileName, e);\n                 }\n-            } catch (SecurityException e) {\n-                logger.debug(\"Unable to check if {} exists\", osReleaseFileName, e);\n+                // specification states we should only fall back if /etc/os-release does not exist\n+                return true;\n             }\n-            return false;\n-        });\n+        } catch (SecurityException e) {\n+            logger.debug(\"Unable to check if {} exists\", osReleaseFileName, e);\n+        }\n+        return false;\n     }\n \n     static boolean addPropertyOsClassifiers(Set<String> availableClassifiers) {\n@@ -1239,16 +1235,8 @@ private static final class Mpsc {\n         static {\n             Object unsafe = null;\n             if (hasUnsafe()) {\n-                // jctools goes through its own process of initializing unsafe; of\n-                // course, this requires permissions which might not be granted to calling code, so we\n-                // must mark this block as privileged too\n-                unsafe = AccessController.doPrivileged(new PrivilegedAction<Object>() {\n-                    @Override\n-                    public Object run() {\n-                        // force JCTools to initialize unsafe\n-                        return UnsafeAccess.UNSAFE;\n-                    }\n-                });\n+                // force JCTools to initialize unsafe\n+                unsafe = UnsafeAccess.UNSAFE;\n             }\n \n             if (unsafe == null) {\n@@ -1349,7 +1337,7 @@ public static ClassLoader getClassLoader(final Class<?> clazz) {\n      * Return the context {@link ClassLoader} for the current {@link Thread}.\n      */\n     public static ClassLoader getContextClassLoader() {\n-        return PlatformDependent0.getContextClassLoader();\n+        return Thread.currentThread().getContextClassLoader();\n     }\n \n     /**\ndiff --git a/common/src/main/java/io/netty/util/internal/PlatformDependent0.java b/common/src/main/java/io/netty/util/internal/PlatformDependent0.java\nindex 40bb38352b6..f6359c2f97a 100644\n--- a/common/src/main/java/io/netty/util/internal/PlatformDependent0.java\n+++ b/common/src/main/java/io/netty/util/internal/PlatformDependent0.java\n@@ -24,12 +24,9 @@\n import java.lang.invoke.MethodType;\n import java.lang.reflect.Constructor;\n import java.lang.reflect.Field;\n-import java.lang.reflect.InvocationTargetException;\n import java.lang.reflect.Method;\n import java.nio.Buffer;\n import java.nio.ByteBuffer;\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n import java.util.concurrent.atomic.AtomicLong;\n \n import static java.lang.invoke.MethodType.methodType;\n@@ -100,44 +97,25 @@ final class PlatformDependent0 {\n             direct = ByteBuffer.allocateDirect(1);\n \n             // attempt to access field Unsafe#theUnsafe\n-            final Object maybeUnsafe = AccessController.doPrivileged(new PrivilegedAction<Object>() {\n-                @Override\n-                public Object run() {\n-                    try {\n-                        final Field unsafeField = Unsafe.class.getDeclaredField(\"theUnsafe\");\n-                        // We always want to try using Unsafe as the access still works on java9 as well and\n-                        // we need it for out native-transports and many optimizations.\n-                        Throwable cause = ReflectionUtil.trySetAccessible(unsafeField, false);\n-                        if (cause != null) {\n-                            return cause;\n-                        }\n-                        // the unsafe instance\n-                        return unsafeField.get(null);\n-                    } catch (NoSuchFieldException | IllegalAccessException | SecurityException e) {\n-                        return e;\n-                    } catch (NoClassDefFoundError e) {\n-                        // Also catch NoClassDefFoundError in case someone uses for example OSGI and it made\n-                        // Unsafe unloadable.\n-                        return e;\n-                    }\n+            try {\n+                final Field unsafeField = Unsafe.class.getDeclaredField(\"theUnsafe\");\n+                // We always want to try using Unsafe as the access still works on java9 as well and\n+                // we need it for out native-transports and many optimizations.\n+                Throwable cause = ReflectionUtil.trySetAccessible(unsafeField, false);\n+                if (cause != null) {\n+                    throw (Throwable) cause;\n                 }\n-            });\n-\n-            // the conditional check here can not be replaced with checking that maybeUnsafe\n-            // is an instanceof Unsafe and reversing the if and else blocks; this is because an\n-            // instanceof check against Unsafe will trigger a class load and we might not have\n-            // the runtime permission accessClassInPackage.sun.misc\n-            if (maybeUnsafe instanceof Throwable) {\n+                // the unsafe instance\n+                unsafe = (Unsafe) unsafeField.get(null);\n+                logger.debug(\"sun.misc.Unsafe.theUnsafe: available\");\n+            } catch (Throwable e) {\n                 unsafe = null;\n-                unsafeUnavailabilityCause = (Throwable) maybeUnsafe;\n+                unsafeUnavailabilityCause = e;\n                 if (logger.isTraceEnabled()) {\n                     logger.debug(\"sun.misc.Unsafe.theUnsafe: unavailable\", unsafeUnavailabilityCause);\n                 } else {\n                     logger.debug(\"sun.misc.Unsafe.theUnsafe: unavailable: {}\", unsafeUnavailabilityCause.getMessage());\n                 }\n-            } else {\n-                unsafe = (Unsafe) maybeUnsafe;\n-                logger.debug(\"sun.misc.Unsafe.theUnsafe: available\");\n             }\n \n             // ensure the unsafe supports all necessary methods to work around the mistake in the latest OpenJDK,\n@@ -146,61 +124,49 @@ public Object run() {\n             // https://www.mail-archive.com/jdk6-dev@openjdk.java.net/msg00698.html\n             // https://openjdk.org/jeps/471\n             if (unsafe != null) {\n-                final Unsafe finalUnsafe = unsafe;\n-                final Object maybeException = AccessController.doPrivileged(new PrivilegedAction<Object>() {\n-                    @Override\n-                    public Object run() {\n-                        try {\n-                            // Other methods like storeFence() and invokeCleaner() are tested for elsewhere.\n-                            Class<? extends Unsafe> cls = finalUnsafe.getClass();\n-                            cls.getDeclaredMethod(\n-                                    \"copyMemory\", Object.class, long.class, Object.class, long.class, long.class);\n-                            if (javaVersion() > 23) {\n-                                cls.getDeclaredMethod(\"objectFieldOffset\", Field.class);\n-                                cls.getDeclaredMethod(\"staticFieldOffset\", Field.class);\n-                                cls.getDeclaredMethod(\"staticFieldBase\", Field.class);\n-                                cls.getDeclaredMethod(\"arrayBaseOffset\", Class.class);\n-                                cls.getDeclaredMethod(\"arrayIndexScale\", Class.class);\n-                                cls.getDeclaredMethod(\"allocateMemory\", long.class);\n-                                cls.getDeclaredMethod(\"reallocateMemory\", long.class, long.class);\n-                                cls.getDeclaredMethod(\"freeMemory\", long.class);\n-                                cls.getDeclaredMethod(\"setMemory\", long.class, long.class, byte.class);\n-                                cls.getDeclaredMethod(\"setMemory\", Object.class, long.class, long.class, byte.class);\n-                                cls.getDeclaredMethod(\"getBoolean\", Object.class, long.class);\n-                                cls.getDeclaredMethod(\"getByte\", long.class);\n-                                cls.getDeclaredMethod(\"getByte\", Object.class, long.class);\n-                                cls.getDeclaredMethod(\"getInt\", long.class);\n-                                cls.getDeclaredMethod(\"getInt\", Object.class, long.class);\n-                                cls.getDeclaredMethod(\"getLong\", long.class);\n-                                cls.getDeclaredMethod(\"getLong\", Object.class, long.class);\n-                                cls.getDeclaredMethod(\"putByte\", long.class, byte.class);\n-                                cls.getDeclaredMethod(\"putByte\", Object.class, long.class, byte.class);\n-                                cls.getDeclaredMethod(\"putInt\", long.class, int.class);\n-                                cls.getDeclaredMethod(\"putInt\", Object.class, long.class, int.class);\n-                                cls.getDeclaredMethod(\"putLong\", long.class, long.class);\n-                                cls.getDeclaredMethod(\"putLong\", Object.class, long.class, long.class);\n-                                cls.getDeclaredMethod(\"addressSize\");\n-                            }\n-                            if (javaVersion() >= 23) {\n-                                // The following tests the methods are usable.\n-                                // Will throw UnsupportedOperationException if unsafe memory access is denied:\n-                                long address = finalUnsafe.allocateMemory(8);\n-                                finalUnsafe.putLong(address, 42);\n-                                finalUnsafe.freeMemory(address);\n-                            }\n-                            return null;\n-                        } catch (UnsupportedOperationException | SecurityException | NoSuchMethodException e) {\n-                            return e;\n-                        }\n+                try {\n+                    // Other methods like storeFence() and invokeCleaner() are tested for elsewhere.\n+                    Class<? extends Unsafe> cls = unsafe.getClass();\n+                    cls.getDeclaredMethod(\n+                            \"copyMemory\", Object.class, long.class, Object.class, long.class, long.class);\n+                    if (javaVersion() > 23) {\n+                        cls.getDeclaredMethod(\"objectFieldOffset\", Field.class);\n+                        cls.getDeclaredMethod(\"staticFieldOffset\", Field.class);\n+                        cls.getDeclaredMethod(\"staticFieldBase\", Field.class);\n+                        cls.getDeclaredMethod(\"arrayBaseOffset\", Class.class);\n+                        cls.getDeclaredMethod(\"arrayIndexScale\", Class.class);\n+                        cls.getDeclaredMethod(\"allocateMemory\", long.class);\n+                        cls.getDeclaredMethod(\"reallocateMemory\", long.class, long.class);\n+                        cls.getDeclaredMethod(\"freeMemory\", long.class);\n+                        cls.getDeclaredMethod(\"setMemory\", long.class, long.class, byte.class);\n+                        cls.getDeclaredMethod(\"setMemory\", Object.class, long.class, long.class, byte.class);\n+                        cls.getDeclaredMethod(\"getBoolean\", Object.class, long.class);\n+                        cls.getDeclaredMethod(\"getByte\", long.class);\n+                        cls.getDeclaredMethod(\"getByte\", Object.class, long.class);\n+                        cls.getDeclaredMethod(\"getInt\", long.class);\n+                        cls.getDeclaredMethod(\"getInt\", Object.class, long.class);\n+                        cls.getDeclaredMethod(\"getLong\", long.class);\n+                        cls.getDeclaredMethod(\"getLong\", Object.class, long.class);\n+                        cls.getDeclaredMethod(\"putByte\", long.class, byte.class);\n+                        cls.getDeclaredMethod(\"putByte\", Object.class, long.class, byte.class);\n+                        cls.getDeclaredMethod(\"putInt\", long.class, int.class);\n+                        cls.getDeclaredMethod(\"putInt\", Object.class, long.class, int.class);\n+                        cls.getDeclaredMethod(\"putLong\", long.class, long.class);\n+                        cls.getDeclaredMethod(\"putLong\", Object.class, long.class, long.class);\n+                        cls.getDeclaredMethod(\"addressSize\");\n+                    }\n+                    if (javaVersion() >= 23) {\n+                        // The following tests the methods are usable.\n+                        // Will throw UnsupportedOperationException if unsafe memory access is denied:\n+                        long address = unsafe.allocateMemory(8);\n+                        unsafe.putLong(address, 42);\n+                        unsafe.freeMemory(address);\n                     }\n-                });\n-\n-                if (maybeException == null) {\n                     logger.debug(\"sun.misc.Unsafe base methods: all available\");\n-                } else {\n-                    // Unsafe.copyMemory(Object, long, Object, long, long) unavailable.\n+                } catch (Throwable e) {\n+                    // Unsafe.copyMemory(Object, long, Object, long, long) unavailable, etc.\n                     unsafe = null;\n-                    unsafeUnavailabilityCause = (Throwable) maybeException;\n+                    unsafeUnavailabilityCause = e;\n                     if (logger.isTraceEnabled()) {\n                         logger.debug(\"sun.misc.Unsafe method unavailable:\", unsafeUnavailabilityCause);\n                     } else {\n@@ -210,40 +176,27 @@ public Object run() {\n             }\n \n             if (unsafe != null) {\n-                final Unsafe finalUnsafe = unsafe;\n-\n                 // attempt to access field Buffer#address\n-                final Object maybeAddressField = AccessController.doPrivileged(new PrivilegedAction<Object>() {\n-                    @Override\n-                    public Object run() {\n-                        try {\n-                            final Field field = Buffer.class.getDeclaredField(\"address\");\n-                            // Use Unsafe to read value of the address field. This way it will not fail on JDK9+ which\n-                            // will forbid changing the access level via reflection.\n-                            final long offset = finalUnsafe.objectFieldOffset(field);\n-                            final long address = finalUnsafe.getLong(direct, offset);\n-\n-                            // if direct really is a direct buffer, address will be non-zero\n-                            if (address == 0) {\n-                                return null;\n-                            }\n-                            return field;\n-                        } catch (NoSuchFieldException | SecurityException e) {\n-                            return e;\n-                        }\n+                try {\n+                    final Field field = Buffer.class.getDeclaredField(\"address\");\n+                    // Use Unsafe to read value of the address field. This way it will not fail on JDK9+ which\n+                    // will forbid changing the access level via reflection.\n+                    final long offset = unsafe.objectFieldOffset(field);\n+                    final long address = unsafe.getLong(direct, offset);\n+\n+                    // if direct really is a direct buffer, address will be non-zero\n+                    if (address != 0) {\n+                        addressField = field;\n+                        logger.debug(\"java.nio.Buffer.address: available\");\n+                    } else {\n+                        throw new UnsupportedOperationException(\"Address of direct byte buffer was zero\");\n                     }\n-                });\n-\n-                if (maybeAddressField instanceof Field) {\n-                    addressField = (Field) maybeAddressField;\n-                    logger.debug(\"java.nio.Buffer.address: available\");\n-                } else {\n-                    unsafeUnavailabilityCause = (Throwable) maybeAddressField;\n+                } catch (Throwable e) {\n+                    unsafeUnavailabilityCause = e;\n                     if (logger.isTraceEnabled()) {\n-                        logger.debug(\"java.nio.Buffer.address: unavailable\", (Throwable) maybeAddressField);\n+                        logger.debug(\"java.nio.Buffer.address: unavailable\", e);\n                     } else {\n-                        logger.debug(\"java.nio.Buffer.address: unavailable: {}\",\n-                                ((Throwable) maybeAddressField).getMessage());\n+                        logger.debug(\"java.nio.Buffer.address: unavailable: {}\", e.getMessage());\n                     }\n \n                     // If we cannot access the address of a direct buffer, there's no point of using unsafe.\n@@ -281,45 +234,27 @@ public Object run() {\n             MethodHandle directBufferConstructor;\n             long address = -1;\n             try {\n-                final Object maybeDirectBufferConstructor =\n-                        AccessController.doPrivileged(new PrivilegedAction<Object>() {\n-                            @Override\n-                            public Object run() {\n-                                try {\n-                                    Class<? extends ByteBuffer> directClass = direct.getClass();\n-                                    final Constructor<?> constructor = javaVersion() >= 21 ?\n-                                            directClass.getDeclaredConstructor(long.class, long.class) :\n-                                            directClass.getDeclaredConstructor(long.class, int.class);\n-                                    Throwable cause = ReflectionUtil.trySetAccessible(constructor, true);\n-                                    if (cause != null) {\n-                                        return cause;\n-                                    }\n-                                    return lookup.unreflectConstructor(constructor)\n-                                            .asType(methodType(ByteBuffer.class, long.class, int.class));\n-                                } catch (Throwable e) {\n-                                    return e;\n-                                }\n-                            }\n-                        });\n-\n-                if (maybeDirectBufferConstructor instanceof MethodHandle) {\n+                try {\n+                    Class<? extends ByteBuffer> directClass = direct.getClass();\n+                    final Constructor<?> constructor = javaVersion() >= 21 ?\n+                            directClass.getDeclaredConstructor(long.class, long.class) :\n+                            directClass.getDeclaredConstructor(long.class, int.class);\n+                    Throwable cause = ReflectionUtil.trySetAccessible(constructor, true);\n+                    if (cause != null) {\n+                        throw cause;\n+                    }\n+                    MethodHandle constructorHandle = lookup.unreflectConstructor(constructor)\n+                            .asType(methodType(ByteBuffer.class, long.class, int.class));\n                     address = UNSAFE.allocateMemory(1);\n                     // try to use the constructor now\n-                    try {\n-                        MethodHandle constructor = (MethodHandle) maybeDirectBufferConstructor;\n-                        ByteBuffer ignore = (ByteBuffer) constructor.invokeExact(address, 1);\n-                        directBufferConstructor = constructor;\n-                        logger.debug(\"direct buffer constructor: available\");\n-                    } catch (Throwable e) {\n-                        directBufferConstructor = null;\n-                    }\n-                } else {\n+                    ByteBuffer ignore = (ByteBuffer) constructorHandle.invokeExact(address, 1);\n+                    directBufferConstructor = constructorHandle;\n+                    logger.debug(\"direct buffer constructor: available\");\n+                } catch (Throwable e) {\n                     if (logger.isTraceEnabled()) {\n-                        logger.debug(\"direct buffer constructor: unavailable\",\n-                                (Throwable) maybeDirectBufferConstructor);\n+                        logger.debug(\"direct buffer constructor: unavailable\", e);\n                     } else {\n-                        logger.debug(\"direct buffer constructor: unavailable: {}\",\n-                                ((Throwable) maybeDirectBufferConstructor).getMessage());\n+                        logger.debug(\"direct buffer constructor: unavailable: {}\", e.getMessage());\n                     }\n                     directBufferConstructor = null;\n                 }\n@@ -335,200 +270,162 @@ public Object run() {\n             INT_ARRAY_INDEX_SCALE = UNSAFE.arrayIndexScale(int[].class);\n             LONG_ARRAY_BASE_OFFSET = UNSAFE.arrayBaseOffset(long[].class);\n             LONG_ARRAY_INDEX_SCALE = UNSAFE.arrayIndexScale(long[].class);\n-            final boolean unaligned;\n+            Boolean unaligned = null;\n             // using a known type to avoid loading new classes\n             final AtomicLong maybeMaxMemory = new AtomicLong(-1);\n-            Object maybeUnaligned = AccessController.doPrivileged(new PrivilegedAction<Object>() {\n-                @Override\n-                public Object run() {\n+            try {\n+                Class<?> bitsClass =\n+                        Class.forName(\"java.nio.Bits\", false, getSystemClassLoader());\n+                int version = javaVersion();\n+                if (version >= 9) {\n+                    // Java9/10 use all lowercase and later versions all uppercase.\n+                    String fieldName = version >= 11? \"MAX_MEMORY\" : \"maxMemory\";\n+                    // On Java9 and later we try to directly access the field as we can do this without\n+                    // adjust the accessible levels.\n                     try {\n-                        Class<?> bitsClass =\n-                                Class.forName(\"java.nio.Bits\", false, getSystemClassLoader());\n-                        int version = javaVersion();\n-                        if (version >= 9) {\n-                            // Java9/10 use all lowercase and later versions all uppercase.\n-                            String fieldName = version >= 11? \"MAX_MEMORY\" : \"maxMemory\";\n-                            // On Java9 and later we try to directly access the field as we can do this without\n-                            // adjust the accessible levels.\n-                            try {\n-                                Field maxMemoryField = bitsClass.getDeclaredField(fieldName);\n-                                if (maxMemoryField.getType() == long.class) {\n-                                    long offset = UNSAFE.staticFieldOffset(maxMemoryField);\n-                                    Object object = UNSAFE.staticFieldBase(maxMemoryField);\n-                                    maybeMaxMemory.lazySet(UNSAFE.getLong(object, offset));\n-                                }\n-                            } catch (Throwable ignore) {\n-                                // ignore if can't access\n-                            }\n-                            fieldName = version >= 11? \"UNALIGNED\" : \"unaligned\";\n-                            try {\n-                                Field unalignedField = bitsClass.getDeclaredField(fieldName);\n-                                if (unalignedField.getType() == boolean.class) {\n-                                    long offset = UNSAFE.staticFieldOffset(unalignedField);\n-                                    Object object = UNSAFE.staticFieldBase(unalignedField);\n-                                    return UNSAFE.getBoolean(object, offset);\n-                                }\n-                                // There is something unexpected stored in the field,\n-                                // let us fall-back and try to use a reflective method call as last resort.\n-                            } catch (NoSuchFieldException ignore) {\n-                                // We did not find the field we expected, move on.\n-                            }\n+                        Field maxMemoryField = bitsClass.getDeclaredField(fieldName);\n+                        if (maxMemoryField.getType() == long.class) {\n+                            long offset = UNSAFE.staticFieldOffset(maxMemoryField);\n+                            Object object = UNSAFE.staticFieldBase(maxMemoryField);\n+                            maybeMaxMemory.lazySet(UNSAFE.getLong(object, offset));\n                         }\n-                        Method unalignedMethod = bitsClass.getDeclaredMethod(\"unaligned\");\n-                        Throwable cause = ReflectionUtil.trySetAccessible(unalignedMethod, true);\n-                        if (cause != null) {\n-                            return cause;\n+                    } catch (Throwable ignore) {\n+                        // ignore if can't access\n+                    }\n+                    fieldName = version >= 11? \"UNALIGNED\" : \"unaligned\";\n+                    try {\n+                        Field unalignedField = bitsClass.getDeclaredField(fieldName);\n+                        if (unalignedField.getType() == boolean.class) {\n+                            long offset = UNSAFE.staticFieldOffset(unalignedField);\n+                            Object object = UNSAFE.staticFieldBase(unalignedField);\n+                            unaligned = UNSAFE.getBoolean(object, offset);\n                         }\n-                        return unalignedMethod.invoke(null);\n-                    } catch (NoSuchMethodException | SecurityException | IllegalAccessException |\n-                             InvocationTargetException | ClassNotFoundException e) {\n-                        return e;\n+                        // There is something unexpected stored in the field,\n+                        // let us fall-back and try to use a reflective method call as last resort.\n+                    } catch (NoSuchFieldException ignore) {\n+                        // We did not find the field we expected, move on.\n                     }\n                 }\n-            });\n-\n-            if (maybeUnaligned instanceof Boolean) {\n-                unaligned = (Boolean) maybeUnaligned;\n+                if (unaligned == null) {\n+                    Method unalignedMethod = bitsClass.getDeclaredMethod(\"unaligned\");\n+                    Throwable cause = ReflectionUtil.trySetAccessible(unalignedMethod, true);\n+                    if (cause != null) {\n+                        throw cause;\n+                    }\n+                    unaligned = (Boolean) unalignedMethod.invoke(null);\n+                }\n                 logger.debug(\"java.nio.Bits.unaligned: available, {}\", unaligned);\n-            } else {\n+            } catch (Throwable e) {\n                 String arch = SystemPropertyUtil.get(\"os.arch\", \"\");\n                 //noinspection DynamicRegexReplaceableByCompiledPattern\n                 unaligned = arch.matches(\"^(i[3-6]86|x86(_64)?|x64|amd64)$\");\n-                Throwable t = (Throwable) maybeUnaligned;\n                 if (logger.isTraceEnabled()) {\n-                    logger.debug(\"java.nio.Bits.unaligned: unavailable, {}\", unaligned, t);\n+                    logger.debug(\"java.nio.Bits.unaligned: unavailable, {}\", unaligned, e);\n                 } else {\n-                    logger.debug(\"java.nio.Bits.unaligned: unavailable, {}, {}\", unaligned, t.getMessage());\n+                    logger.debug(\"java.nio.Bits.unaligned: unavailable, {}, {}\", unaligned, e.getMessage());\n                 }\n             }\n \n             UNALIGNED = unaligned;\n             BITS_MAX_DIRECT_MEMORY = maybeMaxMemory.get() >= 0? maybeMaxMemory.get() : -1;\n \n-            if (javaVersion() >= 9) {\n-                Object maybeException = AccessController.doPrivileged(new PrivilegedAction<Object>() {\n-                    @Override\n-                    public Object run() {\n-                        try {\n-                            // Java9 has jdk.internal.misc.Unsafe and not all methods are propagated to\n-                            // sun.misc.Unsafe\n-                            Class<?> cls = getClassLoader(PlatformDependent0.class)\n-                                    .loadClass(\"jdk.internal.misc.Unsafe\");\n-                            return lookup.findStatic(cls, \"getUnsafe\", methodType(cls)).invoke();\n-                        } catch (Throwable e) {\n-                            return e;\n-                        }\n-                    }\n-                });\n-                if (!(maybeException instanceof Throwable)) {\n-                    final Object finalInternalUnsafe = maybeException;\n-                    maybeException = AccessController.doPrivileged(new PrivilegedAction<Object>() {\n-                        @Override\n-                        public Object run() {\n-                            try {\n-                                Class<?> finalInternalUnsafeClass = finalInternalUnsafe.getClass();\n-                                return lookup.findVirtual(\n-                                        finalInternalUnsafeClass,\n-                                        \"allocateUninitializedArray\",\n-                                        methodType(Object.class, Class.class, int.class));\n-                            } catch (Throwable e) {\n-                                return e;\n-                            }\n-                        }\n-                    });\n-\n-                    if (maybeException instanceof MethodHandle) {\n-                        try {\n-                            MethodHandle m = (MethodHandle) maybeException;\n-                            m = m.bindTo(finalInternalUnsafe);\n-                            byte[] bytes = (byte[]) (Object) m.invokeExact(byte.class, 8);\n-                            assert bytes.length == 8;\n-                            allocateArrayMethod = m;\n-                        } catch (Throwable e) {\n-                            maybeException = e;\n-                        }\n-                    }\n-                }\n-\n-                if (maybeException instanceof Throwable) {\n-                    if (logger.isTraceEnabled()) {\n-                        logger.debug(\"jdk.internal.misc.Unsafe.allocateUninitializedArray(int): unavailable\",\n-                                (Throwable) maybeException);\n-                    } else {\n-                        logger.debug(\"jdk.internal.misc.Unsafe.allocateUninitializedArray(int): unavailable: {}\",\n-                                ((Throwable) maybeException).getMessage());\n-                    }\n+            try {\n+                // Java9 and above has jdk.internal.misc.Unsafe and not all methods are propagated to\n+                // sun.misc.Unsafe\n+                Class<?> cls = getClassLoader(PlatformDependent0.class)\n+                        .loadClass(\"jdk.internal.misc.Unsafe\");\n+                Object internalUnsafe = lookup.findStatic(cls, \"getUnsafe\", methodType(cls)).invoke();\n+                Class<?> internalUnsafeClass = internalUnsafe.getClass();\n+                MethodHandle m = lookup.findVirtual(\n+                        internalUnsafeClass,\n+                        \"allocateUninitializedArray\",\n+                        methodType(Object.class, Class.class, int.class));\n+                m = m.bindTo(internalUnsafe);\n+                byte[] bytes = (byte[]) (Object) m.invokeExact(byte.class, 8);\n+                assert bytes.length == 8;\n+                allocateArrayMethod = m;\n+                logger.debug(\"jdk.internal.misc.Unsafe.allocateUninitializedArray(int): available\");\n+            } catch (Throwable e) {\n+                if (logger.isTraceEnabled()) {\n+                    logger.debug(\"jdk.internal.misc.Unsafe.allocateUninitializedArray(int): unavailable\", e);\n                 } else {\n-                    logger.debug(\"jdk.internal.misc.Unsafe.allocateUninitializedArray(int): available\");\n+                    logger.debug(\"jdk.internal.misc.Unsafe.allocateUninitializedArray(int): unavailable: {}\",\n+                            e.getMessage());\n                 }\n-            } else {\n-                logger.debug(\"jdk.internal.misc.Unsafe.allocateUninitializedArray(int): unavailable prior to Java9\");\n             }\n             ALLOCATE_ARRAY_METHOD = allocateArrayMethod;\n         }\n \n         if (javaVersion() > 9) {\n-            ALIGN_SLICE = (MethodHandle) AccessController.doPrivileged(new PrivilegedAction<Object>() {\n-                @Override\n-                public Object run() {\n-                    try {\n-                        return MethodHandles.publicLookup().findVirtual(\n-                                ByteBuffer.class, \"alignedSlice\", methodType(ByteBuffer.class, int.class));\n-                    } catch (Throwable e) {\n-                        return null;\n-                    }\n+            MethodHandle alignedSlice;\n+            try {\n+                alignedSlice = MethodHandles.publicLookup().findVirtual(\n+                        ByteBuffer.class, \"alignedSlice\", methodType(ByteBuffer.class, int.class));\n+            } catch (Throwable e) {\n+                if (logger.isTraceEnabled()) {\n+                    logger.debug(\"ByteBuffer.alignedSlice: unavailable\", e);\n+                } else {\n+                    logger.debug(\"ByteBuffer.alignedSlice: unavailable\");\n                 }\n-            });\n+                alignedSlice = null;\n+            }\n+            ALIGN_SLICE = alignedSlice;\n         } else {\n             ALIGN_SLICE = null;\n         }\n \n         if (javaVersion() >= 13) {\n-            OFFSET_SLICE = (MethodHandle) AccessController.doPrivileged(new PrivilegedAction<Object>() {\n-                @Override\n-                public Object run() {\n-                    try {\n-                        return MethodHandles.publicLookup().findVirtual(\n-                                ByteBuffer.class, \"slice\", methodType(ByteBuffer.class, int.class, int.class));\n-                    } catch (Throwable e) {\n-                        return null;\n-                    }\n+            MethodHandle offsetSlice;\n+            try {\n+                offsetSlice = MethodHandles.publicLookup().findVirtual(\n+                        ByteBuffer.class, \"slice\", methodType(ByteBuffer.class, int.class, int.class));\n+            } catch (Throwable e) {\n+                offsetSlice = null;\n+                if (logger.isTraceEnabled()) {\n+                    logger.debug(\"ByteBuffer.slice with offset: unavailable\", e);\n+                } else {\n+                    logger.debug(\"ByteBuffer.slice with offset: unavailable\");\n                 }\n-            });\n+            }\n+            OFFSET_SLICE = offsetSlice;\n         } else {\n             OFFSET_SLICE = null;\n         }\n \n         if (javaVersion() >= 16) {\n-            ABSOLUTE_PUT_BUFFER = (MethodHandle) AccessController.doPrivileged(new PrivilegedAction<Object>() {\n-                @Override\n-                public Object run() {\n-                    try {\n-                        MethodType type =\n-                                methodType(ByteBuffer.class, int.class, ByteBuffer.class, int.class, int.class);\n-                        return MethodHandles.publicLookup().findVirtual(ByteBuffer.class, \"put\", type);\n-                    } catch (Throwable e) {\n-                        return null;\n-                    }\n+            MethodHandle absolutePut;\n+            try {\n+                MethodType type =\n+                        methodType(ByteBuffer.class, int.class, ByteBuffer.class, int.class, int.class);\n+                absolutePut = MethodHandles.publicLookup().findVirtual(ByteBuffer.class, \"put\", type);\n+            } catch (Throwable e) {\n+                absolutePut = null;\n+                if (logger.isTraceEnabled()) {\n+                    logger.debug(\"ByteBuffer.put with absolute offsets: unavailable\", e);\n+                } else {\n+                    logger.debug(\"ByteBuffer.put with absolute offsets: unavailable\");\n                 }\n-            });\n+            }\n+            ABSOLUTE_PUT_BUFFER = absolutePut;\n         } else {\n             ABSOLUTE_PUT_BUFFER = null;\n         }\n \n         if (javaVersion() >= 13) {\n-            ABSOLUTE_PUT_ARRAY = (MethodHandle) AccessController.doPrivileged(new PrivilegedAction<Object>() {\n-                @Override\n-                public Object run() {\n-                    try {\n-                        MethodType type =\n-                                methodType(ByteBuffer.class, int.class, byte[].class, int.class, int.class);\n-                        return MethodHandles.publicLookup().findVirtual(ByteBuffer.class, \"put\", type);\n-                    } catch (Throwable e) {\n-                        return null;\n-                    }\n+            MethodHandle absolutePut;\n+            try {\n+                MethodType type =\n+                        methodType(ByteBuffer.class, int.class, byte[].class, int.class, int.class);\n+                absolutePut = MethodHandles.publicLookup().findVirtual(ByteBuffer.class, \"put\", type);\n+            } catch (Throwable e) {\n+                absolutePut = null;\n+                if (logger.isTraceEnabled()) {\n+                    logger.debug(\"ByteBuffer.put array with absolute offsets: unavailable\", e);\n+                } else {\n+                    logger.debug(\"ByteBuffer.put array with absolute offsets: unavailable\");\n                 }\n-            });\n+            }\n+            ABSOLUTE_PUT_ARRAY = absolutePut;\n         } else {\n             ABSOLUTE_PUT_ARRAY = null;\n         }\n@@ -1070,42 +967,11 @@ static int hashCodeAsciiSanitize(byte value) {\n     }\n \n     static ClassLoader getClassLoader(final Class<?> clazz) {\n-        if (System.getSecurityManager() == null) {\n-            return clazz.getClassLoader();\n-        } else {\n-            return AccessController.doPrivileged(new PrivilegedAction<ClassLoader>() {\n-                @Override\n-                public ClassLoader run() {\n-                    return clazz.getClassLoader();\n-                }\n-            });\n-        }\n-    }\n-\n-    static ClassLoader getContextClassLoader() {\n-        if (System.getSecurityManager() == null) {\n-            return Thread.currentThread().getContextClassLoader();\n-        } else {\n-            return AccessController.doPrivileged(new PrivilegedAction<ClassLoader>() {\n-                @Override\n-                public ClassLoader run() {\n-                    return Thread.currentThread().getContextClassLoader();\n-                }\n-            });\n-        }\n+        return clazz.getClassLoader();\n     }\n \n     static ClassLoader getSystemClassLoader() {\n-        if (System.getSecurityManager() == null) {\n-            return ClassLoader.getSystemClassLoader();\n-        } else {\n-            return AccessController.doPrivileged(new PrivilegedAction<ClassLoader>() {\n-                @Override\n-                public ClassLoader run() {\n-                    return ClassLoader.getSystemClassLoader();\n-                }\n-            });\n-        }\n+        return ClassLoader.getSystemClassLoader();\n     }\n \n     static int addressSize() {\ndiff --git a/common/src/main/java/io/netty/util/internal/SocketUtils.java b/common/src/main/java/io/netty/util/internal/SocketUtils.java\nindex 8404477e0f8..d864d326745 100644\n--- a/common/src/main/java/io/netty/util/internal/SocketUtils.java\n+++ b/common/src/main/java/io/netty/util/internal/SocketUtils.java\n@@ -23,23 +23,15 @@\n import java.net.Socket;\n import java.net.SocketAddress;\n import java.net.SocketException;\n-import java.net.SocketPermission;\n import java.net.UnknownHostException;\n import java.nio.channels.DatagramChannel;\n import java.nio.channels.ServerSocketChannel;\n import java.nio.channels.SocketChannel;\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n-import java.security.PrivilegedActionException;\n-import java.security.PrivilegedExceptionAction;\n import java.util.Collections;\n import java.util.Enumeration;\n \n /**\n- * Provides socket operations with privileges enabled. This is necessary for applications that use the\n- * {@link SecurityManager} to restrict {@link SocketPermission} to their application. By asserting that these\n- * operations are privileged, the operations can proceed even if some code in the calling chain lacks the appropriate\n- * {@link SocketPermission}.\n+ * Provides socket operations with platform-specific adaptations and bug mitigations.\n  */\n public final class SocketUtils {\n \n@@ -55,140 +47,49 @@ private static <T> Enumeration<T> empty() {\n \n     public static void connect(final Socket socket, final SocketAddress remoteAddress, final int timeout)\n             throws IOException {\n-        try {\n-            AccessController.doPrivileged(new PrivilegedExceptionAction<Void>() {\n-                @Override\n-                public Void run() throws IOException {\n-                    socket.connect(remoteAddress, timeout);\n-                    return null;\n-                }\n-            });\n-        } catch (PrivilegedActionException e) {\n-            throw (IOException) e.getCause();\n-        }\n+        socket.connect(remoteAddress, timeout);\n     }\n \n     public static void bind(final Socket socket, final SocketAddress bindpoint) throws IOException {\n-        try {\n-            AccessController.doPrivileged(new PrivilegedExceptionAction<Void>() {\n-                @Override\n-                public Void run() throws IOException {\n-                    socket.bind(bindpoint);\n-                    return null;\n-                }\n-            });\n-        } catch (PrivilegedActionException e) {\n-            throw (IOException) e.getCause();\n-        }\n+        socket.bind(bindpoint);\n     }\n \n     public static boolean connect(final SocketChannel socketChannel, final SocketAddress remoteAddress)\n             throws IOException {\n-        try {\n-            return AccessController.doPrivileged(new PrivilegedExceptionAction<Boolean>() {\n-                @Override\n-                public Boolean run() throws IOException {\n-                    return socketChannel.connect(remoteAddress);\n-                }\n-            });\n-        } catch (PrivilegedActionException e) {\n-            throw (IOException) e.getCause();\n-        }\n+        return socketChannel.connect(remoteAddress);\n     }\n \n     public static void bind(final SocketChannel socketChannel, final SocketAddress address) throws IOException {\n-        try {\n-            AccessController.doPrivileged(new PrivilegedExceptionAction<Void>() {\n-                @Override\n-                public Void run() throws IOException {\n-                    socketChannel.bind(address);\n-                    return null;\n-                }\n-            });\n-        } catch (PrivilegedActionException e) {\n-            throw (IOException) e.getCause();\n-        }\n+        socketChannel.bind(address);\n     }\n \n     public static SocketChannel accept(final ServerSocketChannel serverSocketChannel) throws IOException {\n-        try {\n-            return AccessController.doPrivileged(new PrivilegedExceptionAction<SocketChannel>() {\n-                @Override\n-                public SocketChannel run() throws IOException {\n-                    return serverSocketChannel.accept();\n-                }\n-            });\n-        } catch (PrivilegedActionException e) {\n-            throw (IOException) e.getCause();\n-        }\n+        return serverSocketChannel.accept();\n     }\n \n     public static void bind(final DatagramChannel networkChannel, final SocketAddress address) throws IOException {\n-        try {\n-            AccessController.doPrivileged(new PrivilegedExceptionAction<Void>() {\n-                @Override\n-                public Void run() throws IOException {\n-                    networkChannel.bind(address);\n-                    return null;\n-                }\n-            });\n-        } catch (PrivilegedActionException e) {\n-            throw (IOException) e.getCause();\n-        }\n+        networkChannel.bind(address);\n     }\n \n     public static SocketAddress localSocketAddress(final ServerSocket socket) {\n-        return AccessController.doPrivileged(new PrivilegedAction<SocketAddress>() {\n-            @Override\n-            public SocketAddress run() {\n-                return socket.getLocalSocketAddress();\n-            }\n-        });\n+        return socket.getLocalSocketAddress();\n     }\n \n     public static InetAddress addressByName(final String hostname) throws UnknownHostException {\n-        try {\n-            return AccessController.doPrivileged(new PrivilegedExceptionAction<InetAddress>() {\n-                @Override\n-                public InetAddress run() throws UnknownHostException {\n-                    return InetAddress.getByName(hostname);\n-                }\n-            });\n-        } catch (PrivilegedActionException e) {\n-            throw (UnknownHostException) e.getCause();\n-        }\n+        return InetAddress.getByName(hostname);\n     }\n \n     public static InetAddress[] allAddressesByName(final String hostname) throws UnknownHostException {\n-        try {\n-            return AccessController.doPrivileged(new PrivilegedExceptionAction<InetAddress[]>() {\n-                @Override\n-                public InetAddress[] run() throws UnknownHostException {\n-                    return InetAddress.getAllByName(hostname);\n-                }\n-            });\n-        } catch (PrivilegedActionException e) {\n-            throw (UnknownHostException) e.getCause();\n-        }\n+        return InetAddress.getAllByName(hostname);\n     }\n \n     public static InetSocketAddress socketAddress(final String hostname, final int port) {\n-        return AccessController.doPrivileged(new PrivilegedAction<InetSocketAddress>() {\n-            @Override\n-            public InetSocketAddress run() {\n-                return new InetSocketAddress(hostname, port);\n-            }\n-        });\n+        return new InetSocketAddress(hostname, port);\n     }\n \n+    @SuppressWarnings(\"ConstantValue\")\n     public static Enumeration<InetAddress> addressesFromNetworkInterface(final NetworkInterface intf) {\n-        Enumeration<InetAddress> addresses =\n-                AccessController.doPrivileged(new PrivilegedAction<Enumeration<InetAddress>>() {\n-            @Override\n-            public Enumeration<InetAddress> run() {\n-                return intf.getInetAddresses();\n-            }\n-        });\n+        Enumeration<InetAddress> addresses = intf.getInetAddresses();\n         // Android seems to sometimes return null even if this is not a valid return value by the api docs.\n         // Just return an empty Enumeration in this case.\n         // See https://github.com/netty/netty/issues/10045\n@@ -199,24 +100,10 @@ public Enumeration<InetAddress> run() {\n     }\n \n     public static InetAddress loopbackAddress() {\n-        return AccessController.doPrivileged(new PrivilegedAction<InetAddress>() {\n-            @Override\n-            public InetAddress run() {\n-                return InetAddress.getLoopbackAddress();\n-            }\n-        });\n+        return InetAddress.getLoopbackAddress();\n     }\n \n     public static byte[] hardwareAddressFromNetworkInterface(final NetworkInterface intf) throws SocketException {\n-        try {\n-            return AccessController.doPrivileged(new PrivilegedExceptionAction<byte[]>() {\n-                @Override\n-                public byte[] run() throws SocketException {\n-                    return intf.getHardwareAddress();\n-                }\n-            });\n-        } catch (PrivilegedActionException e) {\n-            throw (SocketException) e.getCause();\n-        }\n+        return intf.getHardwareAddress();\n     }\n }\ndiff --git a/common/src/main/java/io/netty/util/internal/SystemPropertyUtil.java b/common/src/main/java/io/netty/util/internal/SystemPropertyUtil.java\nindex b1b53234a7a..1fc09fb65e3 100644\n--- a/common/src/main/java/io/netty/util/internal/SystemPropertyUtil.java\n+++ b/common/src/main/java/io/netty/util/internal/SystemPropertyUtil.java\n@@ -15,13 +15,10 @@\n  */\n package io.netty.util.internal;\n \n-import static io.netty.util.internal.ObjectUtil.checkNonEmpty;\n-\n import io.netty.util.internal.logging.InternalLogger;\n import io.netty.util.internal.logging.InternalLoggerFactory;\n \n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n+import static io.netty.util.internal.ObjectUtil.checkNonEmpty;\n \n /**\n  * A collection of utility methods to retrieve and parse the values of the Java system properties.\n@@ -60,21 +57,7 @@ public static String get(String key) {\n     public static String get(final String key, String def) {\n         checkNonEmpty(key, \"key\");\n \n-        String value = null;\n-        try {\n-            if (System.getSecurityManager() == null) {\n-                value = System.getProperty(key);\n-            } else {\n-                value = AccessController.doPrivileged(new PrivilegedAction<String>() {\n-                    @Override\n-                    public String run() {\n-                        return System.getProperty(key);\n-                    }\n-                });\n-            }\n-        } catch (SecurityException e) {\n-            logger.warn(\"Unable to retrieve a system property '{}'; default values will be used.\", key, e);\n-        }\n+        String value = System.getProperty(key);\n \n         if (value == null) {\n             return def;\ndiff --git a/common/src/main/java/io/netty/util/internal/logging/Log4J2Logger.java b/common/src/main/java/io/netty/util/internal/logging/Log4J2Logger.java\nindex cc973206133..cc065312e1c 100644\n--- a/common/src/main/java/io/netty/util/internal/logging/Log4J2Logger.java\n+++ b/common/src/main/java/io/netty/util/internal/logging/Log4J2Logger.java\n@@ -21,9 +21,6 @@\n import org.apache.logging.log4j.spi.ExtendedLogger;\n import org.apache.logging.log4j.spi.ExtendedLoggerWrapper;\n \n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n-\n import static io.netty.util.internal.logging.AbstractInternalLogger.EXCEPTION_MESSAGE;\n \n class Log4J2Logger extends ExtendedLoggerWrapper implements InternalLogger {\n@@ -35,21 +32,20 @@ class Log4J2Logger extends ExtendedLoggerWrapper implements InternalLogger {\n         // Older Log4J2 versions have only log methods that takes the format + varargs. So we should not use\n         // Log4J2 if the version is too old.\n         // See https://github.com/netty/netty/issues/8217\n-        VARARGS_ONLY = AccessController.doPrivileged(new PrivilegedAction<Boolean>() {\n-            @Override\n-            public Boolean run() {\n-                try {\n-                    Logger.class.getMethod(\"debug\", String.class, Object.class);\n-                    return false;\n-                } catch (NoSuchMethodException ignore) {\n-                    // Log4J2 version too old.\n-                    return true;\n-                } catch (SecurityException ignore) {\n-                    // We could not detect the version so we will use Log4J2 if its on the classpath.\n-                    return false;\n-                }\n-            }\n-        });\n+        VARARGS_ONLY = isLog4jVarArgsOnly();\n+    }\n+\n+    private static boolean isLog4jVarArgsOnly() {\n+        try {\n+            Logger.class.getMethod(\"debug\", String.class, Object.class);\n+            return false;\n+        } catch (NoSuchMethodException ignore) {\n+            // Log4J2 version too old.\n+            return true;\n+        } catch (SecurityException ignore) {\n+            // We could not detect the version so we will use Log4J2 if its on the classpath.\n+            return false;\n+        }\n     }\n \n     Log4J2Logger(Logger logger) {\ndiff --git a/handler/src/main/java/io/netty/handler/ssl/OpenSslParametersUtil.java b/handler/src/main/java/io/netty/handler/ssl/OpenSslParametersUtil.java\nindex efb560dd724..8b6ea73d3fd 100644\n--- a/handler/src/main/java/io/netty/handler/ssl/OpenSslParametersUtil.java\n+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslParametersUtil.java\n@@ -17,12 +17,10 @@\n \n import io.netty.util.internal.PlatformDependent;\n \n-import javax.net.ssl.SSLParameters;\n import java.lang.invoke.MethodHandle;\n import java.lang.invoke.MethodHandles;\n import java.lang.invoke.MethodType;\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n+import javax.net.ssl.SSLParameters;\n \n final class OpenSslParametersUtil {\n \n@@ -45,15 +43,13 @@ final class OpenSslParametersUtil {\n \n     private static MethodHandle obtainHandle(final MethodHandles.Lookup lookup,\n                                              final String methodName, final MethodType type) {\n-        return AccessController.doPrivileged((PrivilegedAction<MethodHandle>) () -> {\n-            try {\n-                return lookup.findVirtual(SSLParameters.class, methodName, type);\n-            } catch (UnsupportedOperationException | SecurityException |\n-                     NoSuchMethodException | IllegalAccessException e) {\n-                // Just ignore it.\n-                return null;\n-            }\n-        });\n+        try {\n+            return lookup.findVirtual(SSLParameters.class, methodName, type);\n+        } catch (UnsupportedOperationException | SecurityException |\n+                 NoSuchMethodException | IllegalAccessException e) {\n+            // Just ignore it.\n+            return null;\n+        }\n     }\n \n     static String[] getNamesGroups(SSLParameters parameters) {\ndiff --git a/handler/src/main/java/io/netty/handler/ssl/OpenSslX509TrustManagerWrapper.java b/handler/src/main/java/io/netty/handler/ssl/OpenSslX509TrustManagerWrapper.java\nindex 99a76b19117..655735f3082 100644\n--- a/handler/src/main/java/io/netty/handler/ssl/OpenSslX509TrustManagerWrapper.java\n+++ b/handler/src/main/java/io/netty/handler/ssl/OpenSslX509TrustManagerWrapper.java\n@@ -21,11 +21,9 @@\n import io.netty.util.internal.logging.InternalLoggerFactory;\n \n import java.lang.reflect.Field;\n-import java.security.AccessController;\n import java.security.KeyManagementException;\n import java.security.NoSuchAlgorithmException;\n import java.security.NoSuchProviderException;\n-import java.security.PrivilegedAction;\n import java.security.cert.CertificateException;\n import java.security.cert.X509Certificate;\n import javax.net.ssl.SSLContext;\n@@ -96,43 +94,36 @@ public X509Certificate[] getAcceptedIssuers() {\n             if (cause != null) {\n                 LOGGER.debug(\"Unable to access wrapped TrustManager\", cause);\n             } else {\n-                final SSLContext finalContext = context;\n-                Object maybeWrapper = AccessController.doPrivileged(new PrivilegedAction<Object>() {\n-                    @Override\n-                    public Object run() {\n-                        try {\n-                            Field contextSpiField = SSLContext.class.getDeclaredField(\"contextSpi\");\n-                            final long spiOffset = PlatformDependent.objectFieldOffset(contextSpiField);\n-                            Object spi = PlatformDependent.getObject(finalContext, spiOffset);\n-                            if (spi != null) {\n-                                Class<?> clazz = spi.getClass();\n-\n-                                // Let's cycle through the whole hierarchy until we find what we are looking for or\n-                                // there is nothing left in which case we will not wrap at all.\n-                                do {\n-                                    try {\n-                                        Field trustManagerField = clazz.getDeclaredField(\"trustManager\");\n-                                        final long tmOffset = PlatformDependent.objectFieldOffset(trustManagerField);\n-                                        Object trustManager = PlatformDependent.getObject(spi, tmOffset);\n-                                        if (trustManager instanceof X509ExtendedTrustManager) {\n-                                            return new UnsafeTrustManagerWrapper(spiOffset, tmOffset);\n-                                        }\n-                                    } catch (NoSuchFieldException ignore) {\n-                                        // try next\n-                                    }\n-                                    clazz = clazz.getSuperclass();\n-                                } while (clazz != null);\n+                try {\n+                    Field contextSpiField = SSLContext.class.getDeclaredField(\"contextSpi\");\n+                    final long spiOffset = PlatformDependent.objectFieldOffset(contextSpiField);\n+                    Object spi = PlatformDependent.getObject(context, spiOffset);\n+                    boolean success = false;\n+                    if (spi != null) {\n+                        Class<?> clazz = spi.getClass();\n+                        // Let's cycle through the whole hierarchy until we find what we are looking for or\n+                        // there is nothing left in which case we will not wrap at all.\n+                        do {\n+                            try {\n+                                Field trustManagerField = clazz.getDeclaredField(\"trustManager\");\n+                                final long tmOffset = PlatformDependent.objectFieldOffset(trustManagerField);\n+                                Object trustManager = PlatformDependent.getObject(spi, tmOffset);\n+                                if (trustManager instanceof X509ExtendedTrustManager) {\n+                                    wrapper = new UnsafeTrustManagerWrapper(spiOffset, tmOffset);\n+                                    success = true;\n+                                    break;\n+                                }\n+                            } catch (NoSuchFieldException ignore) {\n+                                // try next\n                             }\n-                            throw new NoSuchFieldException();\n-                        } catch (NoSuchFieldException | SecurityException e) {\n-                            return e;\n-                        }\n+                            clazz = clazz.getSuperclass();\n+                        } while (clazz != null);\n+                    }\n+                    if (!success) {\n+                        throw new NoSuchFieldException();\n                     }\n-                });\n-                if (maybeWrapper instanceof Throwable) {\n-                    LOGGER.debug(\"Unable to access wrapped TrustManager\", (Throwable) maybeWrapper);\n-                } else {\n-                    wrapper = (TrustManagerWrapper) maybeWrapper;\n+                } catch (NoSuchFieldException | SecurityException e) {\n+                    LOGGER.debug(\"Unable to access wrapped TrustManager\", e);\n                 }\n             }\n         } else {\ndiff --git a/handler/src/main/java/io/netty/handler/ssl/util/BouncyCastleUtil.java b/handler/src/main/java/io/netty/handler/ssl/util/BouncyCastleUtil.java\nindex 3dc8805d675..bdb29f4d6db 100644\n--- a/handler/src/main/java/io/netty/handler/ssl/util/BouncyCastleUtil.java\n+++ b/handler/src/main/java/io/netty/handler/ssl/util/BouncyCastleUtil.java\n@@ -19,8 +19,6 @@\n import io.netty.util.internal.logging.InternalLogger;\n import io.netty.util.internal.logging.InternalLoggerFactory;\n \n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n import java.security.Provider;\n import java.security.Security;\n import javax.net.ssl.SSLEngine;\n@@ -164,72 +162,69 @@ private static void ensureLoaded() {\n \n     @SuppressWarnings(\"unchecked\")\n     private static void tryLoading() {\n-        AccessController.doPrivileged((PrivilegedAction<?>) () -> {\n-            try {\n-                // Check for bcprov-jdk18on or bc-fips:\n-                Provider provider = Security.getProvider(BC_PROVIDER_NAME);\n-                if (provider == null) {\n-                    provider = Security.getProvider(BC_FIPS_PROVIDER_NAME);\n-                }\n-                if (provider == null) {\n-                    ClassLoader classLoader = BouncyCastleUtil.class.getClassLoader();\n-                    Class<Provider> bcProviderClass;\n+        try {\n+            // Check for bcprov-jdk18on or bc-fips:\n+            Provider provider = Security.getProvider(BC_PROVIDER_NAME);\n+            if (provider == null) {\n+                provider = Security.getProvider(BC_FIPS_PROVIDER_NAME);\n+            }\n+            if (provider == null) {\n+                ClassLoader classLoader = BouncyCastleUtil.class.getClassLoader();\n+                Class<Provider> bcProviderClass;\n+                try {\n+                    bcProviderClass = (Class<Provider>) Class.forName(BC_PROVIDER, true, classLoader);\n+                } catch (ClassNotFoundException e) {\n                     try {\n-                        bcProviderClass = (Class<Provider>) Class.forName(BC_PROVIDER, true, classLoader);\n-                    } catch (ClassNotFoundException e) {\n-                        try {\n-                            bcProviderClass = (Class<Provider>) Class.forName(BC_FIPS_PROVIDER, true, classLoader);\n-                        } catch (ClassNotFoundException ex) {\n-                            ThrowableUtil.addSuppressed(e, ex);\n-                            throw e;\n-                        }\n+                        bcProviderClass = (Class<Provider>) Class.forName(BC_FIPS_PROVIDER, true, classLoader);\n+                    } catch (ClassNotFoundException ex) {\n+                        ThrowableUtil.addSuppressed(e, ex);\n+                        throw e;\n                     }\n-                    provider = bcProviderClass.getConstructor().newInstance();\n                 }\n-                bcProviderJce = provider;\n-                logger.debug(\"Bouncy Castle provider available\");\n-            } catch (Throwable e) {\n-                logger.debug(\"Cannot load Bouncy Castle provider\", e);\n-                unavailabilityCauseBcProv = e;\n+                provider = bcProviderClass.getConstructor().newInstance();\n             }\n+            bcProviderJce = provider;\n+            logger.debug(\"Bouncy Castle provider available\");\n+        } catch (Throwable e) {\n+            logger.debug(\"Cannot load Bouncy Castle provider\", e);\n+            unavailabilityCauseBcProv = e;\n+        }\n \n-            try {\n-                // Check for bcpkix-jdk18on:\n-                ClassLoader classLoader = BouncyCastleUtil.class.getClassLoader();\n-                Provider provider = bcProviderJce;\n-                if (provider != null) {\n-                    // Use provider class loader in case it was loaded by the system loader.\n-                    classLoader = provider.getClass().getClassLoader();\n-                }\n-                Class.forName(BC_PEMPARSER, true, classLoader);\n-                logger.debug(\"Bouncy Castle PKIX available\");\n-            } catch (Throwable e) {\n-                logger.debug(\"Cannot load Bouncy Castle PKIX\", e);\n-                unavailabilityCauseBcPkix = e;\n+        try {\n+            // Check for bcpkix-jdk18on:\n+            ClassLoader classLoader = BouncyCastleUtil.class.getClassLoader();\n+            Provider provider = bcProviderJce;\n+            if (provider != null) {\n+                // Use provider class loader in case it was loaded by the system loader.\n+                classLoader = provider.getClass().getClassLoader();\n             }\n+            Class.forName(BC_PEMPARSER, true, classLoader);\n+            logger.debug(\"Bouncy Castle PKIX available\");\n+        } catch (Throwable e) {\n+            logger.debug(\"Cannot load Bouncy Castle PKIX\", e);\n+            unavailabilityCauseBcPkix = e;\n+        }\n \n-            try {\n-                // Check for bctls-jdk18on:\n-                ClassLoader classLoader = BouncyCastleUtil.class.getClassLoader();\n-                Provider provider = Security.getProvider(BC_JSSE_PROVIDER_NAME);\n-                if (provider != null) {\n-                    // Use provider class loader in case it was loaded by the system loader.\n-                    classLoader = provider.getClass().getClassLoader();\n-                } else {\n-                    Class<?> providerClass = Class.forName(BC_JSSE_PROVIDER, true, classLoader);\n-                    provider = (Provider) providerClass.getConstructor().newInstance();\n-                }\n-                bcSSLEngineClass = (Class<? extends SSLEngine>) Class.forName(BC_JSSE_SSLENGINE, true, classLoader);\n-                Class.forName(BC_JSSE_ALPN_SELECTOR, true, classLoader);\n-                bcProviderJsse = provider;\n-                logger.debug(\"Bouncy Castle JSSE available\");\n-            } catch (Throwable e) {\n-                logger.debug(\"Cannot load Bouncy Castle TLS\", e);\n-                unavailabilityCauseBcTls = e;\n+        try {\n+            // Check for bctls-jdk18on:\n+            ClassLoader classLoader = BouncyCastleUtil.class.getClassLoader();\n+            Provider provider = Security.getProvider(BC_JSSE_PROVIDER_NAME);\n+            if (provider != null) {\n+                // Use provider class loader in case it was loaded by the system loader.\n+                classLoader = provider.getClass().getClassLoader();\n+            } else {\n+                Class<?> providerClass = Class.forName(BC_JSSE_PROVIDER, true, classLoader);\n+                provider = (Provider) providerClass.getConstructor().newInstance();\n             }\n-            attemptedLoading = true;\n-            return null;\n-        });\n+            bcSSLEngineClass = (Class<? extends SSLEngine>) Class.forName(BC_JSSE_SSLENGINE, true, classLoader);\n+            Class.forName(BC_JSSE_ALPN_SELECTOR, true, classLoader);\n+            bcProviderJsse = provider;\n+            logger.debug(\"Bouncy Castle JSSE available\");\n+        } catch (Throwable e) {\n+            logger.debug(\"Cannot load Bouncy Castle TLS\", e);\n+            unavailabilityCauseBcTls = e;\n+        }\n+        attemptedLoading = true;\n     }\n \n     private BouncyCastleUtil() {\ndiff --git a/handler/src/main/java/io/netty/handler/ssl/util/OpenJdkSelfSignedCertGenerator.java b/handler/src/main/java/io/netty/handler/ssl/util/OpenJdkSelfSignedCertGenerator.java\nindex a8a15fac08e..781e903a914 100644\n--- a/handler/src/main/java/io/netty/handler/ssl/util/OpenJdkSelfSignedCertGenerator.java\n+++ b/handler/src/main/java/io/netty/handler/ssl/util/OpenJdkSelfSignedCertGenerator.java\n@@ -23,17 +23,13 @@\n import java.lang.invoke.MethodHandle;\n import java.lang.invoke.MethodHandles;\n import java.math.BigInteger;\n-import java.security.AccessController;\n import java.security.KeyPair;\n import java.security.PrivateKey;\n-import java.security.PrivilegedAction;\n import java.security.PublicKey;\n import java.security.SecureRandom;\n import java.security.cert.CertificateException;\n import java.security.cert.X509Certificate;\n-import java.util.ArrayList;\n import java.util.Date;\n-import java.util.List;\n \n import static io.netty.handler.ssl.util.SelfSignedCertificate.newSelfSignedCertificate;\n import static java.lang.invoke.MethodType.methodType;\n@@ -94,167 +90,67 @@ final class OpenJdkSelfSignedCertGenerator {\n         MethodHandle algorithmIdGetHandle = null;\n \n         try {\n-            Object maybeClasses = AccessController.doPrivileged(new PrivilegedAction<Object>() {\n-                @Override\n-                public Object run() {\n-                    try {\n-                        List<Class<?>> classes = new ArrayList<>();\n-                        classes.add(Class.forName(\"sun.security.x509.X509CertInfo\", false,\n-                                PlatformDependent.getClassLoader(OpenJdkSelfSignedCertGenerator.class)));\n-                        classes.add(Class.forName(\"sun.security.x509.X500Name\", false,\n-                                PlatformDependent.getClassLoader(OpenJdkSelfSignedCertGenerator.class)));\n-                        classes.add(Class.forName(\"sun.security.x509.CertificateIssuerName\", false,\n-                                PlatformDependent.getClassLoader(OpenJdkSelfSignedCertGenerator.class)));\n-                        classes.add(Class.forName(\"sun.security.x509.X509CertImpl\", false,\n-                                PlatformDependent.getClassLoader(OpenJdkSelfSignedCertGenerator.class)));\n-                        classes.add(Class.forName(\"sun.security.x509.CertificateVersion\", false,\n-                                PlatformDependent.getClassLoader(OpenJdkSelfSignedCertGenerator.class)));\n-                        classes.add(Class.forName(\"sun.security.x509.CertificateSubjectName\", false,\n-                                PlatformDependent.getClassLoader(OpenJdkSelfSignedCertGenerator.class)));\n-                        classes.add(Class.forName(\"sun.security.x509.CertificateSerialNumber\", false,\n-                                PlatformDependent.getClassLoader(OpenJdkSelfSignedCertGenerator.class)));\n-                        classes.add(Class.forName(\"sun.security.x509.CertificateValidity\", false,\n-                                PlatformDependent.getClassLoader(OpenJdkSelfSignedCertGenerator.class)));\n-                        classes.add(Class.forName(\"sun.security.x509.CertificateX509Key\", false,\n-                                PlatformDependent.getClassLoader(OpenJdkSelfSignedCertGenerator.class)));\n-                        classes.add(Class.forName(\"sun.security.x509.AlgorithmId\", false,\n-                                PlatformDependent.getClassLoader(OpenJdkSelfSignedCertGenerator.class)));\n-                        classes.add(Class.forName(\"sun.security.x509.CertificateAlgorithmId\", false,\n-                                PlatformDependent.getClassLoader(OpenJdkSelfSignedCertGenerator.class)));\n+            x509CertInfoClass = Class.forName(\"sun.security.x509.X509CertInfo\", false,\n+                    PlatformDependent.getClassLoader(OpenJdkSelfSignedCertGenerator.class));\n+            x500NameClass = Class.forName(\"sun.security.x509.X500Name\", false,\n+                    PlatformDependent.getClassLoader(OpenJdkSelfSignedCertGenerator.class));\n+            certificateIssuerNameClass = Class.forName(\"sun.security.x509.CertificateIssuerName\", false,\n+                    PlatformDependent.getClassLoader(OpenJdkSelfSignedCertGenerator.class));\n+            x509CertImplClass = Class.forName(\"sun.security.x509.X509CertImpl\", false,\n+                    PlatformDependent.getClassLoader(OpenJdkSelfSignedCertGenerator.class));\n+            certificateVersionClass = Class.forName(\"sun.security.x509.CertificateVersion\", false,\n+                    PlatformDependent.getClassLoader(OpenJdkSelfSignedCertGenerator.class));\n+            certificateSubjectNameClass = Class.forName(\"sun.security.x509.CertificateSubjectName\", false,\n+                    PlatformDependent.getClassLoader(OpenJdkSelfSignedCertGenerator.class));\n+            certificateSerialNumberClass = Class.forName(\"sun.security.x509.CertificateSerialNumber\", false,\n+                    PlatformDependent.getClassLoader(OpenJdkSelfSignedCertGenerator.class));\n+            certificateValidityClass = Class.forName(\"sun.security.x509.CertificateValidity\", false,\n+                    PlatformDependent.getClassLoader(OpenJdkSelfSignedCertGenerator.class));\n+            certificateX509KeyClass = Class.forName(\"sun.security.x509.CertificateX509Key\", false,\n+                    PlatformDependent.getClassLoader(OpenJdkSelfSignedCertGenerator.class));\n+            algorithmIdClass = Class.forName(\"sun.security.x509.AlgorithmId\", false,\n+                    PlatformDependent.getClassLoader(OpenJdkSelfSignedCertGenerator.class));\n+            certificateAlgorithmIdClass = Class.forName(\"sun.security.x509.CertificateAlgorithmId\", false,\n+                    PlatformDependent.getClassLoader(OpenJdkSelfSignedCertGenerator.class));\n+\n+            x509CertInfoConstructor = lookup.unreflectConstructor(x509CertInfoClass.getConstructor())\n+                            .asType(methodType(x509CertInfoClass));\n+            issuerNameConstructor = lookup.unreflectConstructor(\n+                    certificateIssuerNameClass.getConstructor(x500NameClass))\n+                    .asType(methodType(certificateIssuerNameClass, x500NameClass));\n+            certImplConstructor = lookup.unreflectConstructor(x509CertImplClass.getConstructor(x509CertInfoClass))\n+                            .asType(methodType(x509CertImplClass, x509CertInfoClass));\n+            x500NameConstructor = lookup.unreflectConstructor(x500NameClass.getConstructor(String.class))\n+                            .asType(methodType(x500NameClass, String.class));\n+            certificateVersionConstructor = lookup.unreflectConstructor(\n+                    certificateVersionClass.getConstructor(int.class))\n+                    .asType(methodType(certificateVersionClass, int.class));\n+            certificateSubjectNameConstructor = lookup.unreflectConstructor(\n+                    certificateSubjectNameClass.getConstructor(x500NameClass))\n+                    .asType(methodType(certificateSubjectNameClass, x500NameClass));\n+            certificateSerialNumberConstructor = lookup.unreflectConstructor(\n+                                    certificateSerialNumberClass.getConstructor(BigInteger.class))\n+                            .asType(methodType(certificateSerialNumberClass, BigInteger.class));\n+            certificateValidityConstructor = lookup.unreflectConstructor(\n+                                    certificateValidityClass.getConstructor(Date.class, Date.class))\n+                            .asType(methodType(certificateValidityClass, Date.class, Date.class));\n+            certificateX509KeyConstructor = lookup.unreflectConstructor(\n+                    certificateX509KeyClass.getConstructor(PublicKey.class))\n+                    .asType(methodType(certificateX509KeyClass, PublicKey.class));\n+\n+            certificateAlgorithmIdConstructor = lookup.unreflectConstructor(\n+                                    certificateAlgorithmIdClass.getConstructor(algorithmIdClass))\n+                            .asType(methodType(certificateAlgorithmIdClass, algorithmIdClass));\n+\n+            certInfoSetHandle = lookup.findVirtual(x509CertInfoClass, \"set\",\n+                            methodType(void.class, String.class, Object.class));\n+            certImplGetHandle = lookup.findVirtual(x509CertImplClass, \"get\",\n+                            methodType(Object.class, String.class));\n+            certImplSignHandle = lookup.findVirtual(x509CertImplClass, \"sign\",\n+                            methodType(void.class, PrivateKey.class, String.class));\n+            algorithmIdGetHandle = lookup.findStatic(algorithmIdClass, \"get\",\n+                            methodType(algorithmIdClass, String.class));\n \n-                        return classes;\n-                    } catch (Throwable cause) {\n-                        return cause;\n-                    }\n-                }\n-            });\n-            if (maybeClasses instanceof List) {\n-                @SuppressWarnings(\"unchecked\") List<Class<?>> classes = (List<Class<?>>) maybeClasses;\n-                x509CertInfoClass = classes.get(0);\n-                x500NameClass = classes.get(1);\n-                certificateIssuerNameClass = classes.get(2);\n-                x509CertImplClass = classes.get(3);\n-                certificateVersionClass = classes.get(4);\n-                certificateSubjectNameClass = classes.get(5);\n-                certificateSerialNumberClass = classes.get(6);\n-                certificateValidityClass = classes.get(7);\n-                certificateX509KeyClass = classes.get(8);\n-                algorithmIdClass = classes.get(9);\n-                certificateAlgorithmIdClass = classes.get(10);\n-            } else {\n-                throw (Throwable) maybeClasses;\n-            }\n-\n-            Object maybeConstructors = AccessController.doPrivileged(new PrivilegedAction<Object>() {\n-                @Override\n-                public Object run() {\n-                    try {\n-                        List<MethodHandle> constructors = new ArrayList<>();\n-                        constructors.add(\n-                                lookup.unreflectConstructor(x509CertInfoClass.getConstructor())\n-                                        .asType(methodType(x509CertInfoClass))\n-                        );\n-                        constructors.add(\n-                                lookup.unreflectConstructor(certificateIssuerNameClass.getConstructor(x500NameClass))\n-                                        .asType(methodType(certificateIssuerNameClass, x500NameClass))\n-                        );\n-                        constructors.add(\n-                                lookup.unreflectConstructor(x509CertImplClass.getConstructor(x509CertInfoClass))\n-                                        .asType(methodType(x509CertImplClass, x509CertInfoClass))\n-                        );\n-                        constructors.add(\n-                                lookup.unreflectConstructor(x500NameClass.getConstructor(String.class))\n-                                        .asType(methodType(x500NameClass, String.class))\n-                        );\n-                        constructors.add(\n-                                lookup.unreflectConstructor(certificateVersionClass.getConstructor(int.class))\n-                                        .asType(methodType(certificateVersionClass, int.class))\n-                        );\n-                        constructors.add(\n-                                lookup.unreflectConstructor(certificateSubjectNameClass.getConstructor(x500NameClass))\n-                                        .asType(methodType(certificateSubjectNameClass, x500NameClass))\n-                        );\n-                        constructors.add(\n-                                lookup.unreflectConstructor(\n-                                        certificateSerialNumberClass.getConstructor(BigInteger.class))\n-                                        .asType(methodType(certificateSerialNumberClass, BigInteger.class))\n-                        );\n-                        constructors.add(\n-                                lookup.unreflectConstructor(\n-                                        certificateValidityClass.getConstructor(Date.class, Date.class))\n-                                        .asType(methodType(certificateValidityClass, Date.class, Date.class))\n-                        );\n-                        constructors.add(\n-                                lookup.unreflectConstructor(certificateX509KeyClass.getConstructor(PublicKey.class))\n-                                        .asType(methodType(certificateX509KeyClass, PublicKey.class))\n-                        );\n-\n-                        constructors.add(\n-                                lookup.unreflectConstructor(\n-                                        certificateAlgorithmIdClass.getConstructor(algorithmIdClass))\n-                                        .asType(methodType(certificateAlgorithmIdClass, algorithmIdClass))\n-                        );\n-                        return constructors;\n-                    } catch (Throwable cause) {\n-                        return cause;\n-                    }\n-                }\n-            });\n-            if (maybeConstructors instanceof List) {\n-                @SuppressWarnings(\"unchecked\") List<MethodHandle> constructorList =\n-                        (List<MethodHandle>) maybeConstructors;\n-                x509CertInfoConstructor = constructorList.get(0);\n-                issuerNameConstructor = constructorList.get(1);\n-                certImplConstructor = constructorList.get(2);\n-                x500NameConstructor = constructorList.get(3);\n-                certificateVersionConstructor = constructorList.get(4);\n-                certificateSubjectNameConstructor = constructorList.get(5);\n-                certificateSerialNumberConstructor = constructorList.get(6);\n-                certificateValidityConstructor = constructorList.get(7);\n-                certificateX509KeyConstructor = constructorList.get(8);\n-                certificateAlgorithmIdConstructor = constructorList.get(9);\n-            } else {\n-                throw (Throwable) maybeConstructors;\n-            }\n-\n-            Object maybeMethodHandles = AccessController.doPrivileged(new PrivilegedAction<Object>() {\n-                @Override\n-                public Object run() {\n-                    try {\n-                        List<MethodHandle> methods = new ArrayList<>();\n-                        methods.add(\n-                                lookup.findVirtual(x509CertInfoClass, \"set\",\n-                                        methodType(void.class, String.class, Object.class))\n-                        );\n-                        methods.add(\n-                                lookup.findVirtual(x509CertImplClass, \"get\",\n-                                        methodType(Object.class, String.class))\n-                        );\n-\n-                        methods.add(\n-                                lookup.findVirtual(x509CertImplClass, \"sign\",\n-                                        methodType(void.class, PrivateKey.class, String.class))\n-                        );\n-                        methods.add(\n-                                lookup.findStatic(algorithmIdClass, \"get\",\n-                                        methodType(algorithmIdClass, String.class))\n-                        );\n-                        return methods;\n-                    } catch (Throwable cause) {\n-                        return cause;\n-                    }\n-                }\n-            });\n-            if (maybeMethodHandles instanceof List) {\n-                @SuppressWarnings(\"unchecked\") List<MethodHandle> methodHandles =\n-                        (List<MethodHandle>) maybeMethodHandles;\n-                certInfoSetHandle = methodHandles.get(0);\n-                certImplGetHandle = methodHandles.get(1);\n-                certImplSignHandle = methodHandles.get(2);\n-                algorithmIdGetHandle = methodHandles.get(3);\n-            } else {\n-                throw (Throwable) maybeMethodHandles;\n-            }\n             supported = true;\n         } catch (Throwable cause) {\n             supported = false;\ndiff --git a/microbench/src/main/java/io/netty/microbench/internal/PrivilegedSocketOperationsBenchmark.java b/microbench/src/main/java/io/netty/microbench/internal/PrivilegedSocketOperationsBenchmark.java\ndeleted file mode 100644\nindex 9da290da2d3..00000000000\n--- a/microbench/src/main/java/io/netty/microbench/internal/PrivilegedSocketOperationsBenchmark.java\n+++ /dev/null\n@@ -1,193 +0,0 @@\n-/*\n- * Copyright 2016 The Netty Project\n- *\n- * The Netty Project licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package io.netty.microbench.internal;\n-\n-import io.netty.microbench.util.AbstractMicrobenchmark;\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.Scope;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.TearDown;\n-\n-import java.io.IOException;\n-import java.net.URI;\n-import java.net.URISyntaxException;\n-import java.nio.channels.ServerSocketChannel;\n-import java.security.AccessController;\n-import java.security.NoSuchAlgorithmException;\n-import java.security.Policy;\n-import java.security.PrivilegedActionException;\n-import java.security.PrivilegedExceptionAction;\n-import java.security.URIParameter;\n-import java.util.concurrent.TimeUnit;\n-\n-@BenchmarkMode(Mode.Throughput)\n-@OutputTimeUnit(TimeUnit.SECONDS)\n-public class PrivilegedSocketOperationsBenchmark extends AbstractMicrobenchmark {\n-\n-    @State(Scope.Benchmark)\n-    public static class SecurityManagerInstalled {\n-\n-        @Setup\n-        public void setup() throws IOException, NoSuchAlgorithmException, URISyntaxException {\n-            final URI policyFile = PrivilegedSocketOperationsBenchmark.class.getResource(\"/jmh-security.policy\")\n-                    .toURI();\n-            Policy.setPolicy(Policy.getInstance(\"JavaPolicy\", new URIParameter(policyFile)));\n-            System.setSecurityManager(new SecurityManager());\n-        }\n-\n-        @TearDown\n-        public void tearDown() throws IOException {\n-            System.setSecurityManager(null);\n-        }\n-    }\n-\n-    @State(Scope.Benchmark)\n-    public static class SecurityManagerEmpty {\n-\n-        @Setup\n-        public void setup() throws IOException, NoSuchAlgorithmException, URISyntaxException {\n-            System.setSecurityManager(null);\n-        }\n-    }\n-\n-    @Benchmark\n-    public ServerSocketChannel testWithSMNoPrivileged(final SecurityManagerInstalled sm) throws IOException {\n-        final ServerSocketChannel ssc = ServerSocketChannel.open();\n-        ssc.socket().bind(null);\n-        ssc.configureBlocking(false);\n-        ssc.accept();\n-        ssc.close();\n-        return ssc;\n-    }\n-\n-    @Benchmark\n-    public ServerSocketChannel testWithSM(final SecurityManagerInstalled sm) throws IOException {\n-        try {\n-            final ServerSocketChannel ssc = AccessController.doPrivileged(\n-                    new PrivilegedExceptionAction<ServerSocketChannel>() {\n-                        @Override\n-                        public ServerSocketChannel run() throws Exception {\n-                            final ServerSocketChannel ssc = ServerSocketChannel.open();\n-                            ssc.socket().bind(null);\n-                            ssc.configureBlocking(false);\n-                            ssc.accept();\n-                            return ssc;\n-                        }\n-                    });\n-            ssc.close();\n-            return ssc;\n-        } catch (final PrivilegedActionException e) {\n-            throw (IOException) e.getCause();\n-        }\n-    }\n-\n-    @Benchmark\n-    public ServerSocketChannel testWithSMWithNullCheck(final SecurityManagerInstalled sm) throws IOException {\n-        if (System.getSecurityManager() != null) {\n-            try {\n-                final ServerSocketChannel ssc = AccessController.doPrivileged(\n-                        new PrivilegedExceptionAction<ServerSocketChannel>() {\n-                            @Override\n-                            public ServerSocketChannel run() throws Exception {\n-                                final ServerSocketChannel ssc = ServerSocketChannel.open();\n-                                ssc.socket().bind(null);\n-                                ssc.configureBlocking(false);\n-                                ssc.accept();\n-                                return ssc;\n-                            }\n-                        });\n-                ssc.close();\n-                return ssc;\n-            } catch (final PrivilegedActionException e) {\n-                throw (IOException) e.getCause();\n-            }\n-        } else {\n-            // this should never happen during benchmarking, but we write the correct code here\n-            final ServerSocketChannel ssc = ServerSocketChannel.open();\n-            ssc.socket().bind(null);\n-            ssc.configureBlocking(false);\n-            ssc.accept();\n-            ssc.close();\n-            return ssc;\n-        }\n-    }\n-\n-    @Benchmark\n-    public ServerSocketChannel testWithoutSMNoPrivileged(final SecurityManagerEmpty sm) throws IOException {\n-        final ServerSocketChannel ssc = ServerSocketChannel.open();\n-        ssc.socket().bind(null);\n-        ssc.configureBlocking(false);\n-        ssc.accept();\n-        ssc.close();\n-        return ssc;\n-    }\n-\n-    @Benchmark\n-    public ServerSocketChannel testWithoutSM(final SecurityManagerEmpty sm) throws IOException {\n-        try {\n-            final ServerSocketChannel ssc = AccessController.doPrivileged(\n-                    new PrivilegedExceptionAction<ServerSocketChannel>() {\n-                        @Override\n-                        public ServerSocketChannel run() throws Exception {\n-                            final ServerSocketChannel ssc = ServerSocketChannel.open();\n-                            ssc.socket().bind(null);\n-                            ssc.configureBlocking(false);\n-                            ssc.accept();\n-                            return ssc;\n-                        }\n-                    });\n-            ssc.close();\n-            return ssc;\n-        } catch (final PrivilegedActionException e) {\n-            throw (IOException) e.getCause();\n-        }\n-    }\n-\n-    @Benchmark\n-    public ServerSocketChannel testWithoutSMWithNullCheck(final SecurityManagerEmpty sm) throws IOException {\n-        if (System.getSecurityManager() != null) {\n-            // this should never happen during benchmarking, but we write the correct code here\n-            try {\n-                final ServerSocketChannel ssc = AccessController.doPrivileged(\n-                        new PrivilegedExceptionAction<ServerSocketChannel>() {\n-                            @Override\n-                            public ServerSocketChannel run() throws Exception {\n-                                final ServerSocketChannel ssc = ServerSocketChannel.open();\n-                                ssc.socket().bind(null);\n-                                ssc.configureBlocking(false);\n-                                ssc.accept();\n-                                return ssc;\n-                            }\n-                        });\n-                ssc.close();\n-                return ssc;\n-            } catch (final PrivilegedActionException e) {\n-                throw (IOException) e.getCause();\n-            }\n-        } else {\n-            final ServerSocketChannel ssc = ServerSocketChannel.open();\n-            ssc.socket().bind(null);\n-            ssc.configureBlocking(false);\n-            ssc.accept();\n-            ssc.close();\n-            return ssc;\n-        }\n-    }\n-}\ndiff --git a/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddressStreamProviders.java b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddressStreamProviders.java\nindex 1011b5c99f4..ef61689de05 100644\n--- a/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddressStreamProviders.java\n+++ b/resolver-dns/src/main/java/io/netty/resolver/dns/DnsServerAddressStreamProviders.java\n@@ -21,14 +21,13 @@\n \n import java.lang.reflect.Constructor;\n import java.lang.reflect.InvocationTargetException;\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicLong;\n \n /**\n  * Utility methods related to {@link DnsServerAddressStreamProvider}.\n  */\n+@SuppressWarnings(\"unchecked\")\n public final class DnsServerAddressStreamProviders {\n \n     private static final InternalLogger LOGGER =\n@@ -43,29 +42,14 @@ public final class DnsServerAddressStreamProviders {\n             try {\n                 // As MacOSDnsServerAddressStreamProvider is contained in another jar which depends on this jar\n                 // we use reflection to use it if its on the classpath.\n-                Object maybeProvider = AccessController.doPrivileged(new PrivilegedAction<Object>() {\n-                    @Override\n-                    public Object run() {\n-                        try {\n-                            return Class.forName(\n-                                    MACOS_PROVIDER_CLASS_NAME,\n-                                    true,\n-                                    DnsServerAddressStreamProviders.class.getClassLoader());\n-                        } catch (Throwable cause) {\n-                            return cause;\n-                        }\n-                    }\n-                });\n-                if (maybeProvider instanceof Class) {\n-                    @SuppressWarnings(\"unchecked\")\n-                    Class<? extends DnsServerAddressStreamProvider> providerClass =\n-                            (Class<? extends DnsServerAddressStreamProvider>) maybeProvider;\n-                    constructor = providerClass.getConstructor();\n-                    constructor.newInstance();  // ctor ensures availability\n-                    LOGGER.debug(\"{}: available\", MACOS_PROVIDER_CLASS_NAME);\n-                } else {\n-                    throw (Throwable) maybeProvider;\n-                }\n+                Class<? extends DnsServerAddressStreamProvider> providerClass =\n+                        (Class<? extends DnsServerAddressStreamProvider>) Class.forName(\n+                                MACOS_PROVIDER_CLASS_NAME,\n+                                true,\n+                                DnsServerAddressStreamProviders.class.getClassLoader());\n+                constructor = providerClass.getConstructor();\n+                constructor.newInstance();  // ctor ensures availability\n+                LOGGER.debug(\"{}: available\", MACOS_PROVIDER_CLASS_NAME);\n             } catch (ClassNotFoundException cause) {\n                 LOGGER.warn(\"Can not find {} in the classpath, fallback to system defaults. This may result in \"\n                         + \"incorrect DNS resolutions on MacOS. Check whether you have a dependency on \"\ndiff --git a/transport/src/main/java/io/netty/channel/nio/NioIoHandler.java b/transport/src/main/java/io/netty/channel/nio/NioIoHandler.java\nindex be875ce7984..99bf86af46a 100644\n--- a/transport/src/main/java/io/netty/channel/nio/NioIoHandler.java\n+++ b/transport/src/main/java/io/netty/channel/nio/NioIoHandler.java\n@@ -17,9 +17,9 @@\n \n import io.netty.channel.ChannelException;\n import io.netty.channel.DefaultSelectStrategyFactory;\n-import io.netty.channel.IoHandlerContext;\n import io.netty.channel.IoHandle;\n import io.netty.channel.IoHandler;\n+import io.netty.channel.IoHandlerContext;\n import io.netty.channel.IoHandlerFactory;\n import io.netty.channel.IoOps;\n import io.netty.channel.IoRegistration;\n@@ -38,12 +38,9 @@\n import java.io.IOException;\n import java.lang.reflect.Field;\n import java.nio.channels.CancelledKeyException;\n-import java.nio.channels.Selector;\n import java.nio.channels.SelectionKey;\n-\n+import java.nio.channels.Selector;\n import java.nio.channels.spi.SelectorProvider;\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Iterator;\n@@ -152,81 +149,60 @@ private SelectorTuple openSelector() {\n             return new SelectorTuple(unwrappedSelector);\n         }\n \n-        Object maybeSelectorImplClass = AccessController.doPrivileged(new PrivilegedAction<Object>() {\n-            @Override\n-            public Object run() {\n-                try {\n-                    return Class.forName(\n-                            \"sun.nio.ch.SelectorImpl\",\n-                            false,\n-                            PlatformDependent.getSystemClassLoader());\n-                } catch (Throwable cause) {\n-                    return cause;\n-                }\n-            }\n-        });\n-\n-        if (!(maybeSelectorImplClass instanceof Class) ||\n+        final Class<?> selectorImplClass;\n+        try {\n+            Class<?> cls = Class.forName(\n+                    \"sun.nio.ch.SelectorImpl\",\n+                    false,\n+                    PlatformDependent.getSystemClassLoader());\n+            if (!cls.isAssignableFrom(unwrappedSelector.getClass())) {\n                 // ensure the current selector implementation is what we can instrument.\n-                !((Class<?>) maybeSelectorImplClass).isAssignableFrom(unwrappedSelector.getClass())) {\n-            if (maybeSelectorImplClass instanceof Throwable) {\n-                Throwable t = (Throwable) maybeSelectorImplClass;\n-                logger.trace(\"failed to instrument a special java.util.Set into: {}\", unwrappedSelector, t);\n+                return new SelectorTuple(unwrappedSelector);\n             }\n+            selectorImplClass = cls;\n+        } catch (Throwable cause) {\n+            logger.trace(\"failed to instrument a special java.util.Set into: {}\", unwrappedSelector, cause);\n             return new SelectorTuple(unwrappedSelector);\n         }\n \n-        final Class<?> selectorImplClass = (Class<?>) maybeSelectorImplClass;\n         final SelectedSelectionKeySet selectedKeySet = new SelectedSelectionKeySet();\n-\n-        Object maybeException = AccessController.doPrivileged(new PrivilegedAction<Object>() {\n-            @Override\n-            public Object run() {\n-                try {\n-                    Field selectedKeysField = selectorImplClass.getDeclaredField(\"selectedKeys\");\n-                    Field publicSelectedKeysField = selectorImplClass.getDeclaredField(\"publicSelectedKeys\");\n-\n-                    if (PlatformDependent.javaVersion() >= 9 && PlatformDependent.hasUnsafe()) {\n-                        // Let us try to use sun.misc.Unsafe to replace the SelectionKeySet.\n-                        // This allows us to also do this in Java9+ without any extra flags.\n-                        long selectedKeysFieldOffset = PlatformDependent.objectFieldOffset(selectedKeysField);\n-                        long publicSelectedKeysFieldOffset =\n-                                PlatformDependent.objectFieldOffset(publicSelectedKeysField);\n-\n-                        if (selectedKeysFieldOffset != -1 && publicSelectedKeysFieldOffset != -1) {\n-                            PlatformDependent.putObject(\n-                                    unwrappedSelector, selectedKeysFieldOffset, selectedKeySet);\n-                            PlatformDependent.putObject(\n-                                    unwrappedSelector, publicSelectedKeysFieldOffset, selectedKeySet);\n-                            return null;\n-                        }\n-                        // We could not retrieve the offset, lets try reflection as last-resort.\n-                    }\n-\n-                    Throwable cause = ReflectionUtil.trySetAccessible(selectedKeysField, true);\n-                    if (cause != null) {\n-                        return cause;\n-                    }\n-                    cause = ReflectionUtil.trySetAccessible(publicSelectedKeysField, true);\n-                    if (cause != null) {\n-                        return cause;\n-                    }\n-\n-                    selectedKeysField.set(unwrappedSelector, selectedKeySet);\n-                    publicSelectedKeysField.set(unwrappedSelector, selectedKeySet);\n-                    return null;\n-                } catch (NoSuchFieldException | IllegalAccessException e) {\n-                    return e;\n+        try {\n+            Field selectedKeysField = selectorImplClass.getDeclaredField(\"selectedKeys\");\n+            Field publicSelectedKeysField = selectorImplClass.getDeclaredField(\"publicSelectedKeys\");\n+\n+            if (PlatformDependent.javaVersion() >= 9 && PlatformDependent.hasUnsafe()) {\n+                // Let us try to use sun.misc.Unsafe to replace the SelectionKeySet.\n+                // This allows us to also do this in Java9+ without any extra flags.\n+                long selectedKeysFieldOffset = PlatformDependent.objectFieldOffset(selectedKeysField);\n+                long publicSelectedKeysFieldOffset =\n+                        PlatformDependent.objectFieldOffset(publicSelectedKeysField);\n+\n+                if (selectedKeysFieldOffset != -1 && publicSelectedKeysFieldOffset != -1) {\n+                    PlatformDependent.putObject(\n+                            unwrappedSelector, selectedKeysFieldOffset, selectedKeySet);\n+                    PlatformDependent.putObject(\n+                            unwrappedSelector, publicSelectedKeysFieldOffset, selectedKeySet);\n+                }\n+            } else {\n+                // We could not retrieve the offset, lets try reflection as last-resort.\n+                Throwable cause = ReflectionUtil.trySetAccessible(selectedKeysField, true);\n+                if (cause != null) {\n+                    throw cause;\n+                }\n+                cause = ReflectionUtil.trySetAccessible(publicSelectedKeysField, true);\n+                if (cause != null) {\n+                    throw cause;\n                 }\n-            }\n-        });\n \n-        if (maybeException instanceof Exception) {\n+                selectedKeysField.set(unwrappedSelector, selectedKeySet);\n+                publicSelectedKeysField.set(unwrappedSelector, selectedKeySet);\n+            }\n+        } catch (Throwable throwable) {\n             selectedKeys = null;\n-            Exception e = (Exception) maybeException;\n-            logger.trace(\"failed to instrument a special java.util.Set into: {}\", unwrappedSelector, e);\n+            logger.trace(\"failed to instrument a special java.util.Set into: {}\", unwrappedSelector, throwable);\n             return new SelectorTuple(unwrappedSelector);\n         }\n+\n         selectedKeys = selectedKeySet;\n         logger.trace(\"instrumented a special java.util.Set into: {}\", unwrappedSelector);\n         return new SelectorTuple(unwrappedSelector,\n",
  "test_patch" : "diff --git a/common/src/test/java/io/netty/util/concurrent/DefaultThreadFactoryTest.java b/common/src/test/java/io/netty/util/concurrent/DefaultThreadFactoryTest.java\nindex 3d2ae6023c5..43c2a00156f 100644\n--- a/common/src/test/java/io/netty/util/concurrent/DefaultThreadFactoryTest.java\n+++ b/common/src/test/java/io/netty/util/concurrent/DefaultThreadFactoryTest.java\n@@ -16,14 +16,11 @@\n \n package io.netty.util.concurrent;\n \n-import org.junit.jupiter.api.Assumptions;\n import org.junit.jupiter.api.Test;\n import org.junit.jupiter.api.Timeout;\n \n-import java.security.Permission;\n import java.util.concurrent.Callable;\n import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicInteger;\n import java.util.concurrent.atomic.AtomicReference;\n \n import static org.junit.jupiter.api.Assertions.assertEquals;\n@@ -31,101 +28,6 @@\n \n public class DefaultThreadFactoryTest {\n \n-    @Test\n-    @Timeout(value = 2000, unit = TimeUnit.MILLISECONDS)\n-    public void testDescendantThreadGroups() throws InterruptedException {\n-        final SecurityManager current = System.getSecurityManager();\n-\n-        boolean securityManagerSet = false;\n-        try {\n-            try {\n-                // install security manager that only allows parent thread groups to mess with descendant thread groups\n-                System.setSecurityManager(new SecurityManager() {\n-                    @Override\n-                    public void checkAccess(ThreadGroup g) {\n-                        final ThreadGroup source = Thread.currentThread().getThreadGroup();\n-\n-                        if (source != null) {\n-                            if (!source.parentOf(g)) {\n-                                throw new SecurityException(\"source group is not an ancestor of the target group\");\n-                            }\n-                            super.checkAccess(g);\n-                        }\n-                    }\n-\n-                    // so we can restore the security manager at the end of the test\n-                    @Override\n-                    public void checkPermission(Permission perm) {\n-                    }\n-                });\n-            } catch (UnsupportedOperationException e) {\n-                Assumptions.assumeFalse(true, \"Setting SecurityManager not supported\");\n-            }\n-            securityManagerSet = true;\n-\n-            // holder for the thread factory, plays the role of a global singleton\n-            final AtomicReference<DefaultThreadFactory> factory = new AtomicReference<DefaultThreadFactory>();\n-            final AtomicInteger counter = new AtomicInteger();\n-            final Runnable task = new Runnable() {\n-                @Override\n-                public void run() {\n-                    counter.incrementAndGet();\n-                }\n-            };\n-\n-            final AtomicReference<Throwable> interrupted = new AtomicReference<Throwable>();\n-\n-            // create the thread factory, since we are running the thread group brother, the thread\n-            // factory will now forever be tied to that group\n-            // we then create a thread from the factory to run a \"task\" for us\n-            final Thread first = new Thread(new ThreadGroup(\"brother\"), new Runnable() {\n-                @Override\n-                public void run() {\n-                    factory.set(new DefaultThreadFactory(\"test\", false, Thread.NORM_PRIORITY, null));\n-                    final Thread t = factory.get().newThread(task);\n-                    t.start();\n-                    try {\n-                        t.join();\n-                    } catch (InterruptedException e) {\n-                        interrupted.set(e);\n-                        Thread.currentThread().interrupt();\n-                    }\n-                }\n-            });\n-            first.start();\n-            first.join();\n-\n-            assertNull(interrupted.get());\n-\n-            // now we will use factory again, this time from a sibling thread group sister\n-            // if DefaultThreadFactory is \"sticky\" about thread groups, a security manager\n-            // that forbids sibling thread groups from messing with each other will strike this down\n-            final Thread second = new Thread(new ThreadGroup(\"sister\"), new Runnable() {\n-                @Override\n-                public void run() {\n-                    final Thread t = factory.get().newThread(task);\n-                    t.start();\n-                    try {\n-                        t.join();\n-                    } catch (InterruptedException e) {\n-                        interrupted.set(e);\n-                        Thread.currentThread().interrupt();\n-                    }\n-                }\n-            });\n-            second.start();\n-            second.join();\n-\n-            assertNull(interrupted.get());\n-\n-            assertEquals(2, counter.get());\n-        } finally {\n-            if (securityManagerSet) {\n-                System.setSecurityManager(current);\n-            }\n-        }\n-    }\n-\n     // test that when DefaultThreadFactory is constructed with a sticky thread group, threads\n     // created by it have the sticky thread group\n     @Test\n@@ -142,48 +44,6 @@ public DefaultThreadFactory call() throws Exception {\n                 sticky);\n     }\n \n-    // test that when a security manager is installed that provides a ThreadGroup, DefaultThreadFactory inherits from\n-    // the security manager\n-    @Test\n-    @Timeout(value = 2000, unit = TimeUnit.MILLISECONDS)\n-    public void testDefaultThreadFactoryInheritsThreadGroupFromSecurityManager() throws InterruptedException {\n-        final SecurityManager current = System.getSecurityManager();\n-\n-        boolean securityManagerSet = false;\n-        try {\n-            final ThreadGroup sticky = new ThreadGroup(\"sticky\");\n-            try {\n-                System.setSecurityManager(new SecurityManager() {\n-                    @Override\n-                    public ThreadGroup getThreadGroup() {\n-                        return sticky;\n-                    }\n-\n-                    // so we can restore the security manager at the end of the test\n-                    @Override\n-                    public void checkPermission(Permission perm) {\n-                    }\n-                });\n-            } catch (UnsupportedOperationException e) {\n-                Assumptions.assumeFalse(true, \"Setting SecurityManager not supported\");\n-            }\n-            securityManagerSet = true;\n-\n-            runStickyThreadGroupTest(\n-                    new Callable<DefaultThreadFactory>() {\n-                        @Override\n-                        public DefaultThreadFactory call() throws Exception {\n-                            return new DefaultThreadFactory(\"test\");\n-                        }\n-                    },\n-                    sticky);\n-        } finally {\n-            if (securityManagerSet) {\n-                System.setSecurityManager(current);\n-            }\n-        }\n-    }\n-\n     private static void runStickyThreadGroupTest(\n             final Callable<DefaultThreadFactory> callable,\n             final ThreadGroup expected) throws InterruptedException {\n@@ -292,6 +152,6 @@ public void run() {\n             }\n         });\n         second.join();\n-        assertEquals(currentThreadGroup, currentThreadGroup);\n+        assertEquals(currentThreadGroup, second.getThreadGroup());\n     }\n }\ndiff --git a/common/src/test/java/io/netty/util/internal/PlatformDependent0Test.java b/common/src/test/java/io/netty/util/internal/PlatformDependent0Test.java\nindex 8899fa045fa..d42e79712ca 100644\n--- a/common/src/test/java/io/netty/util/internal/PlatformDependent0Test.java\n+++ b/common/src/test/java/io/netty/util/internal/PlatformDependent0Test.java\n@@ -19,7 +19,6 @@\n import org.junit.jupiter.api.Test;\n \n import java.nio.ByteBuffer;\n-import java.security.Permission;\n \n import static org.junit.jupiter.api.Assertions.assertEquals;\n import static org.junit.jupiter.api.Assumptions.assumeTrue;\n@@ -56,32 +55,6 @@ private static void testNewDirectBufferMemoryAddress(long address) {\n         assertEquals(capacity, buffer.capacity());\n     }\n \n-    @Test\n-    public void testMajorVersionFromJavaSpecificationVersion() {\n-        final SecurityManager current = System.getSecurityManager();\n-\n-        try {\n-            System.setSecurityManager(new SecurityManager() {\n-                @Override\n-                public void checkPropertyAccess(String key) {\n-                    if (key.equals(\"java.specification.version\")) {\n-                        // deny\n-                        throw new SecurityException(key);\n-                    }\n-                }\n-\n-                // so we can restore the security manager\n-                @Override\n-                public void checkPermission(Permission perm) {\n-                }\n-            });\n-\n-            assertEquals(6, PlatformDependent0.majorVersionFromJavaSpecificationVersion());\n-        } finally {\n-            System.setSecurityManager(current);\n-        }\n-    }\n-\n     @Test\n     public void testMajorVersion() {\n         assertEquals(6, PlatformDependent0.majorVersion(\"1.6\"));\n",
  "problem_statement" : "Remove all usage of PrivilegedAction\n\nMotivation:\r\nThe SecurityManager and surrounding mechanism like AccessController and PrivilegedAction are deprecated for removal.\r\n\r\nModification:\r\nRemove all usages of these APIs.\r\n\r\nResult:\r\nMore future-proof code.",
  "hints_text" : null,
  "created_at" : "Fri Jan 23 00:09:18 CET 2026",
  "version" : null,
  "FAIL_TO_PASS" : [ "DefaultThreadFactoryTest", "PlatformDependent0Test" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -pl common -Dtest=DefaultThreadFactoryTest,PlatformDependent0Test",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 16172,
  "metadata" : null
}, {
  "instance_id" : "netty-netty-PR-16170",
  "repo" : "netty/netty",
  "base_commit" : "c9b74c3eb7bc84e623db0381d9e987f2503cb2e3",
  "patch" : "diff --git a/codec-classes-quic/src/main/java/io/netty/handler/codec/quic/QuicheQuicCodec.java b/codec-classes-quic/src/main/java/io/netty/handler/codec/quic/QuicheQuicCodec.java\nindex 51dabbaec2a..19c8f2dfe39 100644\n--- a/codec-classes-quic/src/main/java/io/netty/handler/codec/quic/QuicheQuicCodec.java\n+++ b/codec-classes-quic/src/main/java/io/netty/handler/codec/quic/QuicheQuicCodec.java\n@@ -82,7 +82,7 @@ protected final QuicheQuicChannel getChannel(ByteBuffer key) {\n \n     private void addMapping(QuicheQuicChannel channel, ByteBuffer id) {\n         QuicheQuicChannel ch = connectionIdToChannel.put(id, channel);\n-        assert ch == null;\n+        assert ch == null || ch == channel;\n     }\n \n     private void removeMapping(QuicheQuicChannel channel, ByteBuffer id) {\n",
  "test_patch" : "diff --git a/codec-native-quic/src/test/java/io/netty/handler/codec/quic/QuicChannelConnectTest.java b/codec-native-quic/src/test/java/io/netty/handler/codec/quic/QuicChannelConnectTest.java\nindex 1f20a699ff4..7697b183dae 100644\n--- a/codec-native-quic/src/test/java/io/netty/handler/codec/quic/QuicChannelConnectTest.java\n+++ b/codec-native-quic/src/test/java/io/netty/handler/codec/quic/QuicChannelConnectTest.java\n@@ -1800,6 +1800,92 @@ public void channelInactive(ChannelHandlerContext ctx) {\n         }\n     }\n \n+    @ParameterizedTest\n+    @MethodSource(\"newSslTaskExecutors\")\n+    public void testConnectWithActiveConnectionIdLimit(Executor executor) throws Throwable {\n+        int numBytes = 8;\n+\n+        class ExceptionHandler implements ChannelInboundHandler {\n+\n+            private final AtomicReference<Throwable> causeRef = new AtomicReference<>();\n+            @Override\n+            public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n+                causeRef.compareAndSet(null, cause);\n+            }\n+\n+            void assertNoException() throws Throwable {\n+                Throwable t = causeRef.get();\n+                if (t != null) {\n+                    fail(t);\n+                }\n+            }\n+        }\n+\n+        ExceptionHandler serverExceptionHandler = new ExceptionHandler();\n+        ExceptionHandler clientExceptionHandler = new ExceptionHandler();\n+\n+        ChannelActiveVerifyHandler serverQuicChannelHandler = new ChannelActiveVerifyHandler();\n+\n+        CountDownLatch serverLatch = new CountDownLatch(1);\n+        CountDownLatch clientLatch = new CountDownLatch(1);\n+\n+        // Disable token validation\n+        Channel server = QuicTestUtils.newServer(\n+                QuicTestUtils.newQuicServerBuilder(executor).activeConnectionIdLimit(4), NoQuicTokenHandler.INSTANCE,\n+                serverQuicChannelHandler, new BytesCountingHandler(serverLatch, numBytes));\n+        server.pipeline().addLast(serverExceptionHandler);\n+        InetSocketAddress address = (InetSocketAddress) server.localAddress();\n+        Channel channel = QuicTestUtils.newClient(\n+                QuicTestUtils.newQuicClientBuilder(executor).activeConnectionIdLimit(4));\n+        channel.pipeline().addLast(clientExceptionHandler);\n+        try {\n+            ChannelActiveVerifyHandler clientQuicChannelHandler = new ChannelActiveVerifyHandler();\n+            QuicChannel quicChannel = QuicTestUtils.newQuicChannelBootstrap(channel)\n+                    .handler(clientQuicChannelHandler)\n+                    .streamHandler(new ChannelInboundHandler() { })\n+                    .remoteAddress(address)\n+                    .connect()\n+                    .get();\n+            QuicConnectionAddress localAddress = (QuicConnectionAddress) quicChannel.localAddress();\n+            QuicConnectionAddress remoteAddress = (QuicConnectionAddress) quicChannel.remoteAddress();\n+            assertNotNull(localAddress);\n+            assertNotNull(remoteAddress);\n+\n+            QuicStreamChannel stream = quicChannel.createStream(QuicStreamType.BIDIRECTIONAL,\n+                    new BytesCountingHandler(clientLatch, numBytes)).get();\n+            stream.writeAndFlush(Unpooled.directBuffer().writeZero(numBytes)).sync();\n+            clientLatch.await();\n+\n+            QuicheQuicSslEngine quicheQuicSslEngine = (QuicheQuicSslEngine) quicChannel.sslEngine();\n+            assertNotNull(quicheQuicSslEngine);\n+            assertEquals(QuicTestUtils.PROTOS[0],\n+                    // Just do the cast as getApplicationProtocol() only exists in SSLEngine itself since Java9+ and\n+                    // we may run on an earlier version\n+                    quicheQuicSslEngine.getApplicationProtocol());\n+            stream.close().sync();\n+            quicChannel.close().sync();\n+            Future<Void> closeFuture = quicChannel.closeFuture().await();\n+            assertTrue(closeFuture.isSuccess());\n+\n+            clientQuicChannelHandler.assertState();\n+            serverQuicChannelHandler.assertState();\n+\n+            assertEquals(serverQuicChannelHandler.localAddress(), remoteAddress);\n+            assertEquals(serverQuicChannelHandler.remoteAddress(), localAddress);\n+\n+            serverExceptionHandler.assertNoException();\n+            clientExceptionHandler.assertNoException();\n+        } finally {\n+            serverLatch.await();\n+\n+            server.close().sync();\n+            // Close the parent Datagram channel as well.\n+            channel.close().sync();\n+\n+            shutdown(executor);\n+        }\n+    }\n+\n     private static final class ChannelActiveVerifyHandler extends QuicChannelValidationHandler {\n         private final BlockingQueue<Integer> states = new LinkedBlockingQueue<>();\n \n",
  "problem_statement" : "Fix incorrect assert when handling id to channel mappings (#16163)\n\nMotivation:\n\nWe had an incorrect / incomplete assert that could cause exceptions when\nhandling id to channel mappings.\n\nModifications:\n\n- Fix assert\n- Add unit test\n\nResult:\n\nCorrectly handle id to channel mappings in all cases. Port of\nhttps://github.com/netty/netty-incubator-codec-quic/pull/844",
  "hints_text" : null,
  "created_at" : "Thu Jan 22 16:15:01 CET 2026",
  "version" : null,
  "FAIL_TO_PASS" : [ "QuicChannelConnectTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -pl codec-classes-quic -Dtest=QuicChannelConnectTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 16170,
  "metadata" : null
}, {
  "instance_id" : "netty-netty-PR-16169",
  "repo" : "netty/netty",
  "base_commit" : "c9b74c3eb7bc84e623db0381d9e987f2503cb2e3",
  "patch" : "diff --git a/codec-native-quic/src/main/c/netty_quic_quiche.c b/codec-native-quic/src/main/c/netty_quic_quiche.c\nindex c7d02e280d4..443e3e0aaed 100644\n--- a/codec-native-quic/src/main/c/netty_quic_quiche.c\n+++ b/codec-native-quic/src/main/c/netty_quic_quiche.c\n@@ -578,7 +578,8 @@ static jlongArray netty_quiche_conn_peer_transport_params(JNIEnv* env, jclass cl\n         (jlong)params.peer_initial_max_streams_bidi,\n         (jlong)params.peer_initial_max_streams_uni,\n         (jlong)params.peer_ack_delay_exponent,\n-        (jlong)params.peer_disable_active_migration ? 1: 0,\n+        (jlong)params.peer_max_ack_delay,\n+        (jlong)(params.peer_disable_active_migration == true ? 1: 0),\n         (jlong)params.peer_active_conn_id_limit,\n         (jlong)params.peer_max_datagram_frame_size\n     };\n",
  "test_patch" : "diff --git a/codec-native-quic/src/test/java/io/netty/handler/codec/quic/QuicTransportParametersTest.java b/codec-native-quic/src/test/java/io/netty/handler/codec/quic/QuicTransportParametersTest.java\nindex 131b806443c..cdd316aeab4 100644\n--- a/codec-native-quic/src/test/java/io/netty/handler/codec/quic/QuicTransportParametersTest.java\n+++ b/codec-native-quic/src/test/java/io/netty/handler/codec/quic/QuicTransportParametersTest.java\n@@ -88,7 +88,8 @@ private static void assertTransportParameters(@Nullable QuicTransportParameters\n         assertThat(parameters.ackDelayExponent()).isGreaterThanOrEqualTo(1L);\n         assertThat(parameters.maxAckDelay()).isGreaterThanOrEqualTo(1L);\n         assertFalse(parameters.disableActiveMigration());\n-        assertThat(parameters.activeConnIdLimit()).isGreaterThanOrEqualTo(1L);\n+        // -1 is the max value for an uint64_t that is converted to int64_t.\n+        assertThat(parameters.activeConnIdLimit()).isEqualTo(-1L);\n         assertThat(parameters.maxDatagramFrameSize()).isGreaterThanOrEqualTo(0L);\n     }\n }\n",
  "problem_statement" : "Correctly return all TransportParameters (#16162)\n\nMotivation:\n\nWe did miss to also include the peer_max_ack_delay in the returned\nparams.\n\nModifications:\n\n- Correctly return peer_max_ack_delay as well\n- Adjust test\n\nResult:\n\nNo more test-failures. Port of\nhttps://github.com/netty/netty-incubator-codec-quic/pull/843",
  "hints_text" : null,
  "created_at" : "Thu Jan 22 16:14:25 CET 2026",
  "version" : null,
  "FAIL_TO_PASS" : [ "QuicTransportParametersTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -pl codec-native-quic -Dtest=QuicTransportParametersTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 16169,
  "metadata" : null
}, {
  "instance_id" : "netty-netty-PR-16164",
  "repo" : "netty/netty",
  "base_commit" : "c9b74c3eb7bc84e623db0381d9e987f2503cb2e3",
  "patch" : "diff --git a/common/src/main/java/io/netty/util/concurrent/NonStickyEventExecutorGroup.java b/common/src/main/java/io/netty/util/concurrent/NonStickyEventExecutorGroup.java\ndeleted file mode 100644\nindex 5f76fa05531..00000000000\n--- a/common/src/main/java/io/netty/util/concurrent/NonStickyEventExecutorGroup.java\n+++ /dev/null\n@@ -1,325 +0,0 @@\n-/*\n- * Copyright 2016 The Netty Project\n- *\n- * The Netty Project licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package io.netty.util.concurrent;\n-\n-import io.netty.util.internal.ObjectUtil;\n-import io.netty.util.internal.PlatformDependent;\n-import io.netty.util.internal.UnstableApi;\n-\n-import java.util.Iterator;\n-import java.util.Queue;\n-import java.util.concurrent.Callable;\n-import java.util.concurrent.RejectedExecutionException;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicInteger;\n-import java.util.concurrent.atomic.AtomicReference;\n-\n-/**\n- * {@link EventExecutorGroup} which will preserve {@link Runnable} execution order but makes no guarantees about what\n- * {@link EventExecutor} (and therefore {@link Thread}) will be used to execute the {@link Runnable}s.\n- *\n- * <p>The {@link EventExecutorGroup#next()} for the wrapped {@link EventExecutorGroup} must <strong>NOT</strong> return\n- * executors of type {@link OrderedEventExecutor}.\n- */\n-@UnstableApi\n-public final class NonStickyEventExecutorGroup implements EventExecutorGroup {\n-    private final EventExecutorGroup group;\n-    private final int maxTaskExecutePerRun;\n-\n-    /**\n-     * Creates a new instance. Be aware that the given {@link EventExecutorGroup} <strong>MUST NOT</strong> contain\n-     * any {@link OrderedEventExecutor}s.\n-     */\n-    public NonStickyEventExecutorGroup(EventExecutorGroup group) {\n-        this(group, 1024);\n-    }\n-\n-    /**\n-     * Creates a new instance. Be aware that the given {@link EventExecutorGroup} <strong>MUST NOT</strong> contain\n-     * any {@link OrderedEventExecutor}s.\n-     */\n-    public NonStickyEventExecutorGroup(EventExecutorGroup group, int maxTaskExecutePerRun) {\n-        this.group = verify(group);\n-        this.maxTaskExecutePerRun = ObjectUtil.checkPositive(maxTaskExecutePerRun, \"maxTaskExecutePerRun\");\n-    }\n-\n-    private static EventExecutorGroup verify(EventExecutorGroup group) {\n-        Iterator<EventExecutor> executors = ObjectUtil.checkNotNull(group, \"group\").iterator();\n-        while (executors.hasNext()) {\n-            EventExecutor executor = executors.next();\n-            if (executor instanceof OrderedEventExecutor) {\n-                throw new IllegalArgumentException(\"EventExecutorGroup \" + group\n-                        + \" contains OrderedEventExecutors: \" + executor);\n-            }\n-        }\n-        return group;\n-    }\n-\n-    private NonStickyOrderedEventExecutor newExecutor(EventExecutor executor) {\n-        return new NonStickyOrderedEventExecutor(executor, maxTaskExecutePerRun);\n-    }\n-\n-    @Override\n-    public boolean isShuttingDown() {\n-        return group.isShuttingDown();\n-    }\n-\n-    @Override\n-    public Future<?> shutdownGracefully() {\n-        return group.shutdownGracefully();\n-    }\n-\n-    @Override\n-    public Future<?> shutdownGracefully(long quietPeriod, long timeout, TimeUnit unit) {\n-        return group.shutdownGracefully(quietPeriod, timeout, unit);\n-    }\n-\n-    @Override\n-    public Future<?> terminationFuture() {\n-        return group.terminationFuture();\n-    }\n-\n-    @Override\n-    public EventExecutor next() {\n-        return newExecutor(group.next());\n-    }\n-\n-    @Override\n-    public Iterator<EventExecutor> iterator() {\n-        final Iterator<EventExecutor> itr = group.iterator();\n-        return new Iterator<EventExecutor>() {\n-            @Override\n-            public boolean hasNext() {\n-                return itr.hasNext();\n-            }\n-\n-            @Override\n-            public EventExecutor next() {\n-                return newExecutor(itr.next());\n-            }\n-\n-            @Override\n-            public void remove() {\n-                itr.remove();\n-            }\n-        };\n-    }\n-\n-    @Override\n-    public Future<?> submit(Runnable task) {\n-        return group.submit(task);\n-    }\n-\n-    @Override\n-    public <T> Future<T> submit(Runnable task, T result) {\n-        return group.submit(task, result);\n-    }\n-\n-    @Override\n-    public <T> Future<T> submit(Callable<T> task) {\n-        return group.submit(task);\n-    }\n-\n-    @Override\n-    public ScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit) {\n-        return group.schedule(command, delay, unit);\n-    }\n-\n-    @Override\n-    public <V> ScheduledFuture<V> schedule(Callable<V> callable, long delay, TimeUnit unit) {\n-        return group.schedule(callable, delay, unit);\n-    }\n-\n-    @Override\n-    public ScheduledFuture<?> scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit) {\n-        return group.scheduleAtFixedRate(command, initialDelay, period, unit);\n-    }\n-\n-    @Override\n-    public ScheduledFuture<?> scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit) {\n-        return group.scheduleWithFixedDelay(command, initialDelay, delay, unit);\n-    }\n-\n-    @Override\n-    public boolean isShutdown() {\n-        return group.isShutdown();\n-    }\n-\n-    @Override\n-    public boolean isTerminated() {\n-        return group.isTerminated();\n-    }\n-\n-    @Override\n-    public boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException {\n-        return group.awaitTermination(timeout, unit);\n-    }\n-\n-    @Override\n-    public void execute(Runnable command) {\n-        group.execute(command);\n-    }\n-\n-    private static final class NonStickyOrderedEventExecutor extends AbstractEventExecutor\n-            implements Runnable, OrderedEventExecutor {\n-        private final EventExecutor executor;\n-        private final Queue<Runnable> tasks = PlatformDependent.newMpscQueue();\n-\n-        private static final int NONE = 0;\n-        private static final int SUBMITTED = 1;\n-        private static final int RUNNING = 2;\n-\n-        private final AtomicInteger state = new AtomicInteger();\n-        private final int maxTaskExecutePerRun;\n-\n-        private final AtomicReference<Thread> executingThread = new AtomicReference<Thread>();\n-\n-        NonStickyOrderedEventExecutor(EventExecutor executor, int maxTaskExecutePerRun) {\n-            super(executor);\n-            this.executor = executor;\n-            this.maxTaskExecutePerRun = maxTaskExecutePerRun;\n-        }\n-\n-        @Override\n-        public void run() {\n-            if (!state.compareAndSet(SUBMITTED, RUNNING)) {\n-                return;\n-            }\n-            Thread current = Thread.currentThread();\n-            executingThread.set(current);\n-            for (;;) {\n-                int i = 0;\n-                try {\n-                    for (; i < maxTaskExecutePerRun; i++) {\n-                        Runnable task = tasks.poll();\n-                        if (task == null) {\n-                            break;\n-                        }\n-                        safeExecute(task);\n-                    }\n-                } finally {\n-                    if (i == maxTaskExecutePerRun) {\n-                        try {\n-                            state.set(SUBMITTED);\n-                            // Only set executingThread to null if no other thread did update it yet.\n-                            executingThread.compareAndSet(current, null);\n-                            executor.execute(this);\n-                            return; // done\n-                        } catch (Throwable ignore) {\n-                            // Restore executingThread since we're continuing to execute tasks.\n-                            executingThread.set(current);\n-                            // Reset the state back to running as we will keep on executing tasks.\n-                            state.set(RUNNING);\n-                            // if an error happened we should just ignore it and let the loop run again as there is not\n-                            // much else we can do. Most likely this was triggered by a full task queue. In this case\n-                            // we just will run more tasks and try again later.\n-                        }\n-                    } else {\n-                        state.set(NONE);\n-                        // After setting the state to NONE, look at the tasks queue one more time.\n-                        // If it is empty, then we can return from this method.\n-                        // Otherwise, it means the producer thread has called execute(Runnable)\n-                        // and enqueued a task in between the tasks.poll() above and the state.set(NONE) here.\n-                        // There are two possible scenarios when this happens\n-                        //\n-                        // 1. The producer thread sees state == NONE, hence the compareAndSet(NONE, SUBMITTED)\n-                        //    is successfully setting the state to SUBMITTED. This mean the producer\n-                        //    will call / has called executor.execute(this). In this case, we can just return.\n-                        // 2. The producer thread don't see the state change, hence the compareAndSet(NONE, SUBMITTED)\n-                        //    returns false. In this case, the producer thread won't call executor.execute.\n-                        //    In this case, we need to change the state to RUNNING and keeps running.\n-                        //\n-                        // The above cases can be distinguished by performing a\n-                        // compareAndSet(NONE, RUNNING). If it returns \"false\", it is case 1; otherwise it is case 2.\n-                        if (tasks.isEmpty() || !state.compareAndSet(NONE, RUNNING)) {\n-                            // Only set executingThread to null if no other thread did update it yet.\n-                            executingThread.compareAndSet(current, null);\n-                            return; // done\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-\n-        @Override\n-        public boolean inEventLoop(Thread thread) {\n-            return executingThread.get() == thread;\n-        }\n-\n-        @Override\n-        public boolean isShuttingDown() {\n-            return executor.isShutdown();\n-        }\n-\n-        @Override\n-        public Future<?> shutdownGracefully(long quietPeriod, long timeout, TimeUnit unit) {\n-            return executor.shutdownGracefully(quietPeriod, timeout, unit);\n-        }\n-\n-        @Override\n-        public Future<?> terminationFuture() {\n-            return executor.terminationFuture();\n-        }\n-\n-        @Override\n-        public boolean isShutdown() {\n-            return executor.isShutdown();\n-        }\n-\n-        @Override\n-        public boolean isTerminated() {\n-            return executor.isTerminated();\n-        }\n-\n-        @Override\n-        public boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException {\n-            return executor.awaitTermination(timeout, unit);\n-        }\n-\n-        @Override\n-        public void execute(Runnable command) {\n-            if (!tasks.offer(command)) {\n-                throw new RejectedExecutionException();\n-            }\n-            if (state.compareAndSet(NONE, SUBMITTED)) {\n-                // Actually it could happen that the runnable was picked up in between but we not care to much and just\n-                // execute ourself. At worst this will be a NOOP when run() is called.\n-                executor.execute(this);\n-            }\n-        }\n-\n-        @Override\n-        public ScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit) {\n-            return newFailedScheduledFuture(new UnsupportedOperationException());\n-        }\n-\n-        @Override\n-        public <V> ScheduledFuture<V> schedule(Callable<V> callable, long delay, TimeUnit unit) {\n-            return newFailedScheduledFuture(new UnsupportedOperationException());\n-        }\n-\n-        @Override\n-        public ScheduledFuture<?> scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit) {\n-            return newFailedScheduledFuture(new UnsupportedOperationException());\n-        }\n-\n-        @Override\n-        public ScheduledFuture<?> scheduleWithFixedDelay(\n-                Runnable command, long initialDelay, long delay, TimeUnit unit) {\n-            return newFailedScheduledFuture(new UnsupportedOperationException());\n-        }\n-    }\n-}\ndiff --git a/common/src/main/java/io/netty/util/concurrent/UnorderedThreadPoolEventExecutor.java b/common/src/main/java/io/netty/util/concurrent/UnorderedThreadPoolEventExecutor.java\ndeleted file mode 100644\nindex c869da0886b..00000000000\n--- a/common/src/main/java/io/netty/util/concurrent/UnorderedThreadPoolEventExecutor.java\n+++ /dev/null\n@@ -1,328 +0,0 @@\n-/*\n- * Copyright 2016 The Netty Project\n- *\n- * The Netty Project licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package io.netty.util.concurrent;\n-\n-import io.netty.util.internal.logging.InternalLogger;\n-import io.netty.util.internal.logging.InternalLoggerFactory;\n-import org.jetbrains.annotations.NotNull;\n-\n-import java.util.Collections;\n-import java.util.Iterator;\n-import java.util.List;\n-import java.util.Set;\n-import java.util.concurrent.Callable;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.Delayed;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.RejectedExecutionHandler;\n-import java.util.concurrent.RunnableScheduledFuture;\n-import java.util.concurrent.ScheduledThreadPoolExecutor;\n-import java.util.concurrent.ThreadFactory;\n-import java.util.concurrent.TimeUnit;\n-\n-import static java.util.concurrent.TimeUnit.NANOSECONDS;\n-\n-/**\n- * {@link EventExecutor} implementation which makes no guarantees about the ordering of task execution that\n- * are submitted because there may be multiple threads executing these tasks.\n- * This implementation is most useful for protocols that do not need strict ordering.\n- * <p>\n- * <strong>Because it provides no ordering, care should be taken when using it!</strong>\n- *\n- * @deprecated The behavior of this event executor deviates from the typical Netty execution model\n- * and can cause subtle issues as a result.\n- * Applications that wish to process messages with greater parallelism, should instead do explicit\n- * off-loading to their own thread-pools.\n- */\n-@Deprecated\n-public final class UnorderedThreadPoolEventExecutor extends ScheduledThreadPoolExecutor implements EventExecutor {\n-    private static final InternalLogger logger = InternalLoggerFactory.getInstance(\n-            UnorderedThreadPoolEventExecutor.class);\n-\n-    private final Promise<?> terminationFuture = GlobalEventExecutor.INSTANCE.newPromise();\n-    private final Set<EventExecutor> executorSet = Collections.singleton(this);\n-    private final Set<Thread> eventLoopThreads = ConcurrentHashMap.newKeySet();\n-\n-    /**\n-     * Calls {@link UnorderedThreadPoolEventExecutor#UnorderedThreadPoolEventExecutor(int, ThreadFactory)}\n-     * using {@link DefaultThreadFactory}.\n-     */\n-    public UnorderedThreadPoolEventExecutor(int corePoolSize) {\n-        this(corePoolSize, new DefaultThreadFactory(UnorderedThreadPoolEventExecutor.class));\n-    }\n-\n-    /**\n-     * See {@link ScheduledThreadPoolExecutor#ScheduledThreadPoolExecutor(int, ThreadFactory)}\n-     */\n-    public UnorderedThreadPoolEventExecutor(int corePoolSize, ThreadFactory threadFactory) {\n-        super(corePoolSize, threadFactory);\n-        setThreadFactory(new AccountingThreadFactory(threadFactory, eventLoopThreads));\n-    }\n-\n-    /**\n-     * Calls {@link UnorderedThreadPoolEventExecutor#UnorderedThreadPoolEventExecutor(int,\n-     * ThreadFactory, java.util.concurrent.RejectedExecutionHandler)} using {@link DefaultThreadFactory}.\n-     */\n-    public UnorderedThreadPoolEventExecutor(int corePoolSize, RejectedExecutionHandler handler) {\n-        this(corePoolSize, new DefaultThreadFactory(UnorderedThreadPoolEventExecutor.class), handler);\n-    }\n-\n-    /**\n-     * See {@link ScheduledThreadPoolExecutor#ScheduledThreadPoolExecutor(int, ThreadFactory, RejectedExecutionHandler)}\n-     */\n-    public UnorderedThreadPoolEventExecutor(int corePoolSize, ThreadFactory threadFactory,\n-                                            RejectedExecutionHandler handler) {\n-        super(corePoolSize, threadFactory, handler);\n-        setThreadFactory(new AccountingThreadFactory(threadFactory, eventLoopThreads));\n-    }\n-\n-    @Override\n-    public EventExecutor next() {\n-        return this;\n-    }\n-\n-    @Override\n-    public EventExecutorGroup parent() {\n-        return this;\n-    }\n-\n-    @Override\n-    public boolean inEventLoop() {\n-        return inEventLoop(Thread.currentThread());\n-    }\n-\n-    @Override\n-    public boolean inEventLoop(Thread thread) {\n-        return eventLoopThreads.contains(thread);\n-    }\n-\n-    @Override\n-    public <V> Promise<V> newPromise() {\n-        return new DefaultPromise<V>(this);\n-    }\n-\n-    @Override\n-    public <V> Future<V> newSucceededFuture(V result) {\n-        return new SucceededFuture<V>(this, result);\n-    }\n-\n-    @Override\n-    public <V> Future<V> newFailedFuture(Throwable cause) {\n-        return new FailedFuture<V>(this, cause);\n-    }\n-\n-    @Override\n-    public boolean isShuttingDown() {\n-        return isShutdown();\n-    }\n-\n-    @Override\n-    public List<Runnable> shutdownNow() {\n-        List<Runnable> tasks = super.shutdownNow();\n-        terminationFuture.trySuccess(null);\n-        return tasks;\n-    }\n-\n-    @Override\n-    public void shutdown() {\n-        super.shutdown();\n-        terminationFuture.trySuccess(null);\n-    }\n-\n-    @Override\n-    public Future<?> shutdownGracefully() {\n-        return shutdownGracefully(2, 15, TimeUnit.SECONDS);\n-    }\n-\n-    @Override\n-    public Future<?> shutdownGracefully(long quietPeriod, long timeout, TimeUnit unit) {\n-        // TODO: At the moment this just calls shutdown but we may be able to do something more smart here which\n-        //       respects the quietPeriod and timeout.\n-        shutdown();\n-        return terminationFuture();\n-    }\n-\n-    @Override\n-    public Future<?> terminationFuture() {\n-        return terminationFuture;\n-    }\n-\n-    @Override\n-    public Iterator<EventExecutor> iterator() {\n-        return executorSet.iterator();\n-    }\n-\n-    @Override\n-    protected <V> RunnableScheduledFuture<V> decorateTask(Runnable runnable, RunnableScheduledFuture<V> task) {\n-        return runnable instanceof NonNotifyRunnable ?\n-                task : new RunnableScheduledFutureTask<V>(this, task, false);\n-    }\n-\n-    @Override\n-    protected <V> RunnableScheduledFuture<V> decorateTask(Callable<V> callable, RunnableScheduledFuture<V> task) {\n-        return new RunnableScheduledFutureTask<V>(this, task, true);\n-    }\n-\n-    @Override\n-    public ScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit) {\n-        return (ScheduledFuture<?>) super.schedule(command, delay, unit);\n-    }\n-\n-    @Override\n-    public <V> ScheduledFuture<V> schedule(Callable<V> callable, long delay, TimeUnit unit) {\n-        return (ScheduledFuture<V>) super.schedule(callable, delay, unit);\n-    }\n-\n-    @Override\n-    public ScheduledFuture<?> scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit) {\n-        return (ScheduledFuture<?>) super.scheduleAtFixedRate(command, initialDelay, period, unit);\n-    }\n-\n-    @Override\n-    public ScheduledFuture<?> scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit) {\n-        return (ScheduledFuture<?>) super.scheduleWithFixedDelay(command, initialDelay, delay, unit);\n-    }\n-\n-    @Override\n-    public Future<?> submit(Runnable task) {\n-        return (Future<?>) super.submit(task);\n-    }\n-\n-    @Override\n-    public <T> Future<T> submit(Runnable task, T result) {\n-        return (Future<T>) super.submit(task, result);\n-    }\n-\n-    @Override\n-    public <T> Future<T> submit(Callable<T> task) {\n-        return (Future<T>) super.submit(task);\n-    }\n-\n-    @Override\n-    public void execute(Runnable command) {\n-        super.schedule(new NonNotifyRunnable(command), 0, NANOSECONDS);\n-    }\n-\n-    private static final class RunnableScheduledFutureTask<V> extends PromiseTask<V>\n-            implements RunnableScheduledFuture<V>, ScheduledFuture<V> {\n-        private final RunnableScheduledFuture<V> future;\n-        private final boolean wasCallable;\n-\n-        RunnableScheduledFutureTask(EventExecutor executor, RunnableScheduledFuture<V> future, boolean wasCallable) {\n-            super(executor, future);\n-            this.future = future;\n-            this.wasCallable = wasCallable;\n-        }\n-\n-        @Override\n-        boolean isCancellationSupported() {\n-            return true;\n-        }\n-\n-        @Override\n-        V runTask() throws Throwable {\n-            V result =  super.runTask();\n-            if (result == null && wasCallable) {\n-                // If this RunnableScheduledFutureTask wraps a RunnableScheduledFuture that wraps a Callable we need\n-                // to ensure that we return the correct result by calling future.get().\n-                //\n-                // See https://github.com/netty/netty/issues/11072\n-                assert future.isDone();\n-                try {\n-                    return future.get();\n-                } catch (ExecutionException e) {\n-                    // unwrap exception.\n-                    throw e.getCause();\n-                }\n-            }\n-            return result;\n-        }\n-\n-        @Override\n-        public void run() {\n-            if (!isPeriodic()) {\n-                super.run();\n-            } else if (!isDone()) {\n-                try {\n-                    // Its a periodic task so we need to ignore the return value\n-                    runTask();\n-                } catch (Throwable cause) {\n-                    if (!tryFailureInternal(cause)) {\n-                        logger.warn(\"Failure during execution of task\", cause);\n-                    }\n-                }\n-            }\n-        }\n-\n-        @Override\n-        public boolean isPeriodic() {\n-            return future.isPeriodic();\n-        }\n-\n-        @Override\n-        public long getDelay(TimeUnit unit) {\n-            return future.getDelay(unit);\n-        }\n-\n-        @Override\n-        public int compareTo(Delayed o) {\n-            return future.compareTo(o);\n-        }\n-    }\n-\n-    // This is a special wrapper which we will be used in execute(...) to wrap the submitted Runnable. This is needed as\n-    // ScheduledThreadPoolExecutor.execute(...) will delegate to submit(...) which will then use decorateTask(...).\n-    // The problem with this is that decorateTask(...) needs to ensure we only do our own decoration if we not call\n-    // from execute(...) as otherwise we may end up creating an endless loop because DefaultPromise will call\n-    // EventExecutor.execute(...) when notify the listeners of the promise.\n-    //\n-    // See https://github.com/netty/netty/issues/6507\n-    private static final class NonNotifyRunnable implements Runnable {\n-\n-        private final Runnable task;\n-\n-        NonNotifyRunnable(Runnable task) {\n-            this.task = task;\n-        }\n-\n-        @Override\n-        public void run() {\n-            task.run();\n-        }\n-    }\n-\n-    private static final class AccountingThreadFactory implements ThreadFactory {\n-        private final ThreadFactory delegate;\n-        private final Set<Thread> threads;\n-\n-        private AccountingThreadFactory(ThreadFactory delegate, Set<Thread> threads) {\n-            this.delegate = delegate;\n-            this.threads = threads;\n-        }\n-\n-        @Override\n-        public Thread newThread(@NotNull Runnable r) {\n-            return delegate.newThread(() -> {\n-                threads.add(Thread.currentThread());\n-                try {\n-                    r.run();\n-                } finally {\n-                    threads.remove(Thread.currentThread());\n-                }\n-            });\n-        }\n-    }\n-}\n",
  "test_patch" : "diff --git a/common/src/test/java/io/netty/util/concurrent/NonStickyEventExecutorGroupTest.java b/common/src/test/java/io/netty/util/concurrent/NonStickyEventExecutorGroupTest.java\ndeleted file mode 100644\nindex aafb1f51db1..00000000000\n--- a/common/src/test/java/io/netty/util/concurrent/NonStickyEventExecutorGroupTest.java\n+++ /dev/null\n@@ -1,343 +0,0 @@\n-/*\n- * Copyright 2016 The Netty Project\n- *\n- * The Netty Project licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package io.netty.util.concurrent;\n-\n-import io.netty.util.NettyRuntime;\n-import org.junit.jupiter.api.Test;\n-import org.junit.jupiter.api.Timeout;\n-import org.junit.jupiter.api.function.Executable;\n-import org.junit.jupiter.params.ParameterizedTest;\n-import org.junit.jupiter.params.provider.MethodSource;\n-\n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.Collections;\n-import java.util.Iterator;\n-import java.util.List;\n-import java.util.concurrent.Callable;\n-import java.util.concurrent.CountDownLatch;\n-import java.util.concurrent.RejectedExecutionException;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicInteger;\n-import java.util.concurrent.atomic.AtomicReference;\n-\n-import static org.junit.jupiter.api.Assertions.assertFalse;\n-import static org.junit.jupiter.api.Assertions.assertNotNull;\n-import static org.junit.jupiter.api.Assertions.assertThrows;\n-import static org.junit.jupiter.api.Assertions.assertTrue;\n-\n-public class NonStickyEventExecutorGroupTest {\n-    private static final String PARAMETERIZED_NAME = \"{index}: maxTaskExecutePerRun = {0}\";\n-\n-    @Test\n-    public void testInvalidGroup() {\n-        final EventExecutorGroup group = new DefaultEventExecutorGroup(1);\n-        try {\n-            assertThrows(IllegalArgumentException.class, new Executable() {\n-                @Override\n-                public void execute() {\n-                    new NonStickyEventExecutorGroup(group);\n-                }\n-            });\n-        } finally {\n-            group.shutdownGracefully();\n-        }\n-    }\n-\n-    public static Collection<Object[]> data() throws Exception {\n-        List<Object[]> params = new ArrayList<Object[]>();\n-        params.add(new Object[] {64});\n-        params.add(new Object[] {256});\n-        params.add(new Object[] {1024});\n-        params.add(new Object[] {Integer.MAX_VALUE});\n-        return params;\n-    }\n-\n-    @ParameterizedTest(name = PARAMETERIZED_NAME)\n-    @MethodSource(\"data\")\n-    @Timeout(value = 10000, unit = TimeUnit.MILLISECONDS)\n-    public void testOrdering(int maxTaskExecutePerRun) throws Throwable {\n-        final int threads = NettyRuntime.availableProcessors() * 2;\n-        final EventExecutorGroup group = new UnorderedThreadPoolEventExecutor(threads);\n-        final NonStickyEventExecutorGroup nonStickyGroup = new NonStickyEventExecutorGroup(group, maxTaskExecutePerRun);\n-        try {\n-            final CountDownLatch startLatch = new CountDownLatch(1);\n-            final AtomicReference<Throwable> error = new AtomicReference<Throwable>();\n-            List<Thread> threadList = new ArrayList<Thread>(threads);\n-            for (int i = 0 ; i < threads; i++) {\n-                Thread thread = new Thread(new Runnable() {\n-                    @Override\n-                    public void run() {\n-                        try {\n-                            execute(nonStickyGroup, startLatch);\n-                        } catch (Throwable cause) {\n-                            error.compareAndSet(null, cause);\n-                        }\n-                    }\n-                });\n-                threadList.add(thread);\n-                thread.start();\n-            }\n-            startLatch.countDown();\n-            for (Thread t: threadList) {\n-                t.join();\n-            }\n-            Throwable cause = error.get();\n-            if (cause != null) {\n-                throw cause;\n-            }\n-        } finally {\n-            nonStickyGroup.shutdownGracefully();\n-        }\n-    }\n-\n-    @ParameterizedTest(name = PARAMETERIZED_NAME)\n-    @MethodSource(\"data\")\n-    public void testRaceCondition(int maxTaskExecutePerRun) throws InterruptedException {\n-        EventExecutorGroup group = new UnorderedThreadPoolEventExecutor(1);\n-        NonStickyEventExecutorGroup nonStickyGroup = new NonStickyEventExecutorGroup(group, maxTaskExecutePerRun);\n-\n-        try {\n-            EventExecutor executor = nonStickyGroup.next();\n-\n-            for (int j = 0; j < 5000; j++) {\n-                final CountDownLatch firstCompleted = new CountDownLatch(1);\n-                final CountDownLatch latch = new CountDownLatch(2);\n-                for (int i = 0; i < 2; i++) {\n-                    executor.execute(new Runnable() {\n-                        @Override\n-                        public void run() {\n-                            firstCompleted.countDown();\n-                            latch.countDown();\n-                        }\n-                    });\n-                    assertTrue(firstCompleted.await(1, TimeUnit.SECONDS));\n-                }\n-\n-                assertTrue(latch.await(5, TimeUnit.SECONDS));\n-            }\n-        } finally {\n-            nonStickyGroup.shutdownGracefully();\n-        }\n-    }\n-\n-    @Test\n-    public void testInEventLoopAfterReschedulingFailure() throws Exception {\n-        final UnorderedThreadPoolEventExecutor underlying = new UnorderedThreadPoolEventExecutor(1);\n-        final AtomicInteger executeCount = new AtomicInteger();\n-\n-        final EventExecutorGroup wrapper = new AbstractEventExecutorGroup() {\n-\n-            private final EventExecutor executor = new AbstractEventExecutor(this) {\n-                @Override\n-                public boolean inEventLoop(Thread thread) {\n-                    return underlying.inEventLoop(thread);\n-                }\n-\n-                @Override\n-                public void execute(Runnable command) {\n-                    // Reject the 2nd execute() call (the reschedule attempt)\n-                    // 1st call: initial task submission\n-                    // 2nd call: reschedule after maxTaskExecutePerRun\n-                    if (executeCount.incrementAndGet() == 2) {\n-                        throw new RejectedExecutionException(\"Simulated queue full\");\n-                    }\n-                    underlying.execute(command);\n-                }\n-\n-                @Override\n-                public boolean isShuttingDown() {\n-                    return underlying.isShuttingDown();\n-                }\n-\n-                @Override\n-                public Future<?> shutdownGracefully(long quietPeriod, long timeout, TimeUnit unit) {\n-                    return underlying.shutdownGracefully(quietPeriod, timeout, unit);\n-                }\n-\n-                @Override\n-                public Future<?> terminationFuture() {\n-                    return underlying.terminationFuture();\n-                }\n-\n-                @Override\n-                public boolean isShutdown() {\n-                    return underlying.isShutdown();\n-                }\n-\n-                @Override\n-                public boolean isTerminated() {\n-                    return underlying.isTerminated();\n-                }\n-\n-                @Override\n-                public boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException {\n-                    return underlying.awaitTermination(timeout, unit);\n-                }\n-\n-                @Override\n-                public ScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit) {\n-                    return underlying.schedule(command, delay, unit);\n-                }\n-\n-                @Override\n-                public <V> ScheduledFuture<V> schedule(Callable<V> callable, long delay, TimeUnit unit) {\n-                    return underlying.schedule(callable, delay, unit);\n-                }\n-\n-                @Override\n-                public ScheduledFuture<?> scheduleAtFixedRate(\n-                        Runnable command, long initialDelay, long period, TimeUnit unit) {\n-                    return underlying.scheduleAtFixedRate(command, initialDelay, period, unit);\n-                }\n-\n-                @Override\n-                public ScheduledFuture<?> scheduleWithFixedDelay(\n-                        Runnable command, long initialDelay, long delay, TimeUnit unit) {\n-                    return underlying.scheduleWithFixedDelay(command, initialDelay, delay, unit);\n-                }\n-            };\n-\n-            @Override\n-            public EventExecutor next() {\n-                return executor;\n-            }\n-\n-            @Override\n-            public Iterator<EventExecutor> iterator() {\n-                return Collections.singletonList(executor).iterator();\n-            }\n-\n-            @Override\n-            public boolean isShuttingDown() {\n-                return underlying.isShuttingDown();\n-            }\n-\n-            @Override\n-            public Future<?> shutdownGracefully(long quietPeriod, long timeout, TimeUnit unit) {\n-                return underlying.shutdownGracefully(quietPeriod, timeout, unit);\n-            }\n-\n-            @Override\n-            public Future<?> terminationFuture() {\n-                return underlying.terminationFuture();\n-            }\n-\n-            @Override\n-            public boolean isShutdown() {\n-                return underlying.isShutdown();\n-            }\n-\n-            @Override\n-            public boolean isTerminated() {\n-                return underlying.isTerminated();\n-            }\n-\n-            @Override\n-            public boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException {\n-                return underlying.awaitTermination(timeout, unit);\n-            }\n-        };\n-\n-        // Use maxTaskExecutePerRun=1 so reschedule happens after first task\n-        NonStickyEventExecutorGroup nonStickyGroup = new NonStickyEventExecutorGroup(wrapper, 1);\n-\n-        try {\n-            final EventExecutor executor = nonStickyGroup.next();\n-\n-            final CountDownLatch latch = new CountDownLatch(1);\n-            final AtomicReference<Boolean> inEventLoopResult = new AtomicReference<Boolean>();\n-\n-            // Submit 2 tasks:\n-            // Task 1: completes, triggers reschedule which will be rejected\n-            // Task 2: verifies inEventLoop() still works after failed reschedule\n-            executor.execute(new Runnable() {\n-                @Override\n-                public void run() {\n-                    // First task - will trigger reschedule attempt that fails\n-                }\n-            });\n-\n-            executor.execute(new Runnable() {\n-                @Override\n-                public void run() {\n-                    // This runs AFTER the failed rescheduling\n-                    // WITHOUT line 262 fix: executingThread is null, inEventLoop() returns false\n-                    // WITH line 262 fix: executingThread restored, inEventLoop() returns true\n-                    inEventLoopResult.set(executor.inEventLoop());\n-                    latch.countDown();\n-                }\n-            });\n-\n-            assertTrue(latch.await(5, TimeUnit.SECONDS), \"Tasks should complete\");\n-            Boolean result = inEventLoopResult.get();\n-            assertNotNull(result, \"inEventLoop() should have been called\");\n-            assertTrue(result,\n-                \"inEventLoop() should return true even after failed reschedule attempt. \" +\n-                \"This indicates executingThread was properly restored in the exception handler.\");\n-        } finally {\n-            nonStickyGroup.shutdownGracefully();\n-            underlying.shutdownGracefully();\n-        }\n-    }\n-\n-    private static void execute(EventExecutorGroup group, CountDownLatch startLatch) throws Throwable {\n-        final EventExecutor executor = group.next();\n-        assertTrue(executor instanceof OrderedEventExecutor);\n-        final AtomicReference<Throwable> cause = new AtomicReference<Throwable>();\n-        final AtomicInteger last = new AtomicInteger();\n-        int tasks = 10000;\n-        List<Future<?>> futures = new ArrayList<Future<?>>(tasks);\n-        final CountDownLatch latch = new CountDownLatch(tasks);\n-        startLatch.await();\n-\n-        for (int i = 1 ; i <= tasks; i++) {\n-            final int id = i;\n-            assertFalse(executor.inEventLoop());\n-            assertFalse(executor.inEventLoop(Thread.currentThread()));\n-            futures.add(executor.submit(new Runnable() {\n-                @Override\n-                public void run() {\n-                    try {\n-                        assertTrue(executor.inEventLoop(Thread.currentThread()));\n-                        assertTrue(executor.inEventLoop());\n-\n-                        if (cause.get() == null) {\n-                            int lastId = last.get();\n-                            if (lastId >= id) {\n-                                cause.compareAndSet(null, new AssertionError(\n-                                        \"Out of order execution id(\" + id + \") >= lastId(\" + lastId + ')'));\n-                            }\n-                            if (!last.compareAndSet(lastId, id)) {\n-                                cause.compareAndSet(null, new AssertionError(\"Concurrent execution of tasks\"));\n-                            }\n-                        }\n-                    } finally {\n-                        latch.countDown();\n-                    }\n-                }\n-            }));\n-        }\n-        latch.await();\n-        for (Future<?> future: futures) {\n-            future.syncUninterruptibly();\n-        }\n-        Throwable error = cause.get();\n-        if (error != null) {\n-            throw error;\n-        }\n-    }\n-}\ndiff --git a/common/src/test/java/io/netty/util/concurrent/UnorderedThreadPoolEventExecutorTest.java b/common/src/test/java/io/netty/util/concurrent/UnorderedThreadPoolEventExecutorTest.java\ndeleted file mode 100644\nindex ad522e6d37f..00000000000\n--- a/common/src/test/java/io/netty/util/concurrent/UnorderedThreadPoolEventExecutorTest.java\n+++ /dev/null\n@@ -1,141 +0,0 @@\n-/*\n- * Copyright 2017 The Netty Project\n- *\n- * The Netty Project licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package io.netty.util.concurrent;\n-\n-import org.junit.jupiter.api.Test;\n-import org.junit.jupiter.api.Timeout;\n-\n-import java.util.concurrent.Callable;\n-import java.util.concurrent.CountDownLatch;\n-import java.util.concurrent.Exchanger;\n-import java.util.concurrent.TimeUnit;\n-\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n-import static org.junit.jupiter.api.Assertions.assertSame;\n-import static org.junit.jupiter.api.Assertions.assertTrue;\n-\n-public class UnorderedThreadPoolEventExecutorTest {\n-\n-    // See https://github.com/netty/netty/issues/6507\n-    @Test\n-    public void testNotEndlessExecute() throws Exception {\n-        UnorderedThreadPoolEventExecutor executor = new UnorderedThreadPoolEventExecutor(1);\n-\n-        try {\n-            // Having the first task wait on an exchanger allow us to make sure that the lister on the second task\n-            // is not added *after* the promise completes. We need to do this to prevent a race where the second task\n-            // and listener are completed before the DefaultPromise.NotifyListeners task get to run, which means our\n-            // queue inspection might observe this task after the CountDownLatch opens.\n-            final Exchanger<Void> exchanger = new Exchanger<Void>();\n-            final CountDownLatch latch = new CountDownLatch(3);\n-            Runnable task = new Runnable() {\n-                @Override\n-                public void run() {\n-                    try {\n-                        exchanger.exchange(null);\n-                    } catch (InterruptedException e) {\n-                        throw new RuntimeException(e);\n-                    }\n-                    latch.countDown();\n-                }\n-            };\n-            executor.execute(task);\n-            Future<?> future = executor.submit(new Runnable() {\n-                @Override\n-                public void run() {\n-                    latch.countDown();\n-                }\n-            }).addListener((FutureListener<Object>) f -> latch.countDown());\n-            exchanger.exchange(null);\n-            latch.await();\n-            future.syncUninterruptibly();\n-\n-            // Now just check if the queue stays empty multiple times. This is needed as the submit to execute(...)\n-            // by DefaultPromise may happen in an async fashion\n-            for (int i = 0; i < 10000; i++) {\n-                assertTrue(executor.getQueue().isEmpty());\n-            }\n-        } finally {\n-            executor.shutdownGracefully();\n-        }\n-    }\n-\n-    @Test\n-    @Timeout(value = 10000, unit = TimeUnit.MILLISECONDS)\n-    public void scheduledAtFixedRateMustRunTaskRepeatedly() throws InterruptedException {\n-        UnorderedThreadPoolEventExecutor executor = new UnorderedThreadPoolEventExecutor(1);\n-        final CountDownLatch latch = new CountDownLatch(3);\n-        Future<?> future = executor.scheduleAtFixedRate(new Runnable() {\n-            @Override\n-            public void run() {\n-                latch.countDown();\n-            }\n-        }, 1, 1, TimeUnit.MILLISECONDS);\n-        try {\n-            latch.await();\n-        } finally {\n-            future.cancel(true);\n-            executor.shutdownGracefully();\n-        }\n-    }\n-\n-    @Test\n-    public void testGetReturnsCorrectValueOnSuccess() throws Exception {\n-        UnorderedThreadPoolEventExecutor executor = new UnorderedThreadPoolEventExecutor(1);\n-        try {\n-            final String expected = \"expected\";\n-            Future<String> f = executor.submit(new Callable<String>() {\n-                @Override\n-                public String call() {\n-                    return expected;\n-                }\n-            });\n-\n-            assertEquals(expected, f.get());\n-        } finally {\n-            executor.shutdownGracefully();\n-        }\n-    }\n-\n-    @Test\n-    public void testGetReturnsCorrectValueOnFailure() throws Exception {\n-        UnorderedThreadPoolEventExecutor executor = new UnorderedThreadPoolEventExecutor(1);\n-        try {\n-            final RuntimeException cause = new RuntimeException();\n-            Future<String> f = executor.submit(new Callable<String>() {\n-                @Override\n-                public String call() {\n-                    throw cause;\n-                }\n-            });\n-\n-            assertSame(cause, f.await().cause());\n-        } finally {\n-            executor.shutdownGracefully();\n-        }\n-    }\n-\n-    @Test\n-    void tasksRunningInUnorderedExecutorAreInEventLoop() throws Exception {\n-        UnorderedThreadPoolEventExecutor executor = new UnorderedThreadPoolEventExecutor(1);\n-        try {\n-            Future<Boolean> future = executor.submit(() -> executor.inEventLoop());\n-            assertTrue(future.get());\n-        } finally {\n-            executor.shutdownGracefully();\n-        }\n-    }\n-}\n",
  "problem_statement" : "Remove unordered and non-sticky event executors\n\nMotivation:\r\nThese give a non-standard execution model that deviates from the threading-model of the Netty pipelines. They are almost never used, and they should never be used.\r\n\r\nModification:\r\nRemove the `UnorderedThreadPoolEventExecutor` and its companion `NonStickyEventExecutorGroup`. Also remove their tests.\r\n\r\nResult:\r\nCleaner code with less deprecated features.",
  "hints_text" : null,
  "created_at" : "Wed Jan 21 20:17:26 CET 2026",
  "version" : null,
  "FAIL_TO_PASS" : [ "NonStickyEventExecutorGroupTest", "UnorderedThreadPoolEventExecutorTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -pl common -Dtest=NonStickyEventExecutorGroupTest,UnorderedThreadPoolEventExecutorTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 16164,
  "metadata" : null
}, {
  "instance_id" : "netty-netty-PR-16163",
  "repo" : "netty/netty",
  "base_commit" : "26fadc1cf5d80de06909758ea186a1d0ce46ab10",
  "patch" : "diff --git a/codec-classes-quic/src/main/java/io/netty/handler/codec/quic/QuicheQuicCodec.java b/codec-classes-quic/src/main/java/io/netty/handler/codec/quic/QuicheQuicCodec.java\nindex 1184f4fc676..37eb341cf7d 100644\n--- a/codec-classes-quic/src/main/java/io/netty/handler/codec/quic/QuicheQuicCodec.java\n+++ b/codec-classes-quic/src/main/java/io/netty/handler/codec/quic/QuicheQuicCodec.java\n@@ -81,7 +81,7 @@ protected final QuicheQuicChannel getChannel(ByteBuffer key) {\n \n     private void addMapping(QuicheQuicChannel channel, ByteBuffer id) {\n         QuicheQuicChannel ch = connectionIdToChannel.put(id, channel);\n-        assert ch == null;\n+        assert ch == null || ch == channel;\n     }\n \n     private void removeMapping(QuicheQuicChannel channel, ByteBuffer id) {\n",
  "test_patch" : "diff --git a/codec-native-quic/src/test/java/io/netty/handler/codec/quic/QuicChannelConnectTest.java b/codec-native-quic/src/test/java/io/netty/handler/codec/quic/QuicChannelConnectTest.java\nindex 05fcdb87a89..7565f133535 100644\n--- a/codec-native-quic/src/test/java/io/netty/handler/codec/quic/QuicChannelConnectTest.java\n+++ b/codec-native-quic/src/test/java/io/netty/handler/codec/quic/QuicChannelConnectTest.java\n@@ -1801,6 +1801,92 @@ public void channelInactive(ChannelHandlerContext ctx) {\n         }\n     }\n \n+    @ParameterizedTest\n+    @MethodSource(\"newSslTaskExecutors\")\n+    public void testConnectWithActiveConnectionIdLimit(Executor executor) throws Throwable {\n+        int numBytes = 8;\n+\n+        class ExceptionHandler extends ChannelInboundHandlerAdapter {\n+\n+            private final AtomicReference<Throwable> causeRef = new AtomicReference<>();\n+            @Override\n+            public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n+                causeRef.compareAndSet(null, cause);\n+            }\n+\n+            void assertNoException() throws Throwable {\n+                Throwable t = causeRef.get();\n+                if (t != null) {\n+                    fail(t);\n+                }\n+            }\n+        }\n+\n+        ExceptionHandler serverExceptionHandler = new ExceptionHandler();\n+        ExceptionHandler clientExceptionHandler = new ExceptionHandler();\n+\n+        ChannelActiveVerifyHandler serverQuicChannelHandler = new ChannelActiveVerifyHandler();\n+\n+        CountDownLatch serverLatch = new CountDownLatch(1);\n+        CountDownLatch clientLatch = new CountDownLatch(1);\n+\n+        // Disable token validation\n+        Channel server = QuicTestUtils.newServer(\n+                QuicTestUtils.newQuicServerBuilder(executor).activeConnectionIdLimit(4), NoQuicTokenHandler.INSTANCE,\n+                serverQuicChannelHandler, new BytesCountingHandler(serverLatch, numBytes));\n+        server.pipeline().addLast(serverExceptionHandler);\n+        InetSocketAddress address = (InetSocketAddress) server.localAddress();\n+        Channel channel = QuicTestUtils.newClient(\n+                QuicTestUtils.newQuicClientBuilder(executor).activeConnectionIdLimit(4));\n+        channel.pipeline().addLast(clientExceptionHandler);\n+        try {\n+            ChannelActiveVerifyHandler clientQuicChannelHandler = new ChannelActiveVerifyHandler();\n+            QuicChannel quicChannel = QuicTestUtils.newQuicChannelBootstrap(channel)\n+                    .handler(clientQuicChannelHandler)\n+                    .streamHandler(new ChannelInboundHandlerAdapter())\n+                    .remoteAddress(address)\n+                    .connect()\n+                    .get();\n+            QuicConnectionAddress localAddress = (QuicConnectionAddress) quicChannel.localAddress();\n+            QuicConnectionAddress remoteAddress = (QuicConnectionAddress) quicChannel.remoteAddress();\n+            assertNotNull(localAddress);\n+            assertNotNull(remoteAddress);\n+\n+            QuicStreamChannel stream = quicChannel.createStream(QuicStreamType.BIDIRECTIONAL,\n+                    new BytesCountingHandler(clientLatch, numBytes)).get();\n+            stream.writeAndFlush(Unpooled.directBuffer().writeZero(numBytes)).sync();\n+            clientLatch.await();\n+\n+            QuicheQuicSslEngine quicheQuicSslEngine = (QuicheQuicSslEngine) quicChannel.sslEngine();\n+            assertNotNull(quicheQuicSslEngine);\n+            assertEquals(QuicTestUtils.PROTOS[0],\n+                    // Just do the cast as getApplicationProtocol() only exists in SSLEngine itself since Java9+ and\n+                    // we may run on an earlier version\n+                    quicheQuicSslEngine.getApplicationProtocol());\n+            stream.close().sync();\n+            quicChannel.close().sync();\n+            ChannelFuture closeFuture = quicChannel.closeFuture().await();\n+            assertTrue(closeFuture.isSuccess());\n+\n+            clientQuicChannelHandler.assertState();\n+            serverQuicChannelHandler.assertState();\n+\n+            assertEquals(serverQuicChannelHandler.localAddress(), remoteAddress);\n+            assertEquals(serverQuicChannelHandler.remoteAddress(), localAddress);\n+\n+            serverExceptionHandler.assertNoException();\n+            clientExceptionHandler.assertNoException();\n+        } finally {\n+            serverLatch.await();\n+\n+            server.close().sync();\n+            // Close the parent Datagram channel as well.\n+            channel.close().sync();\n+\n+            shutdown(executor);\n+        }\n+    }\n+\n     private static final class ChannelActiveVerifyHandler extends QuicChannelValidationHandler {\n         private final BlockingQueue<Integer> states = new LinkedBlockingQueue<>();\n \n",
  "problem_statement" : "Fix incorrect assert when handling id to channel mappings\n\nMotivation:\r\n\r\nWe had an incorrect / incomplete assert that could cause exceptions when handling id to channel mappings.\r\n\r\nModifications:\r\n\r\n- Fix assert\r\n- Add unit test\r\n\r\nResult:\r\n\r\nCorrectly handle id to channel mappings in all cases. Port of https://github.com/netty/netty-incubator-codec-quic/pull/844",
  "hints_text" : null,
  "created_at" : "Wed Jan 21 18:22:27 CET 2026",
  "version" : null,
  "FAIL_TO_PASS" : [ "QuicChannelConnectTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -pl codec-classes-quic -Dtest=QuicChannelConnectTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 16163,
  "metadata" : null
}, {
  "instance_id" : "netty-netty-PR-16162",
  "repo" : "netty/netty",
  "base_commit" : "26fadc1cf5d80de06909758ea186a1d0ce46ab10",
  "patch" : "diff --git a/codec-native-quic/src/main/c/netty_quic_quiche.c b/codec-native-quic/src/main/c/netty_quic_quiche.c\nindex c7d02e280d4..443e3e0aaed 100644\n--- a/codec-native-quic/src/main/c/netty_quic_quiche.c\n+++ b/codec-native-quic/src/main/c/netty_quic_quiche.c\n@@ -578,7 +578,8 @@ static jlongArray netty_quiche_conn_peer_transport_params(JNIEnv* env, jclass cl\n         (jlong)params.peer_initial_max_streams_bidi,\n         (jlong)params.peer_initial_max_streams_uni,\n         (jlong)params.peer_ack_delay_exponent,\n-        (jlong)params.peer_disable_active_migration ? 1: 0,\n+        (jlong)params.peer_max_ack_delay,\n+        (jlong)(params.peer_disable_active_migration == true ? 1: 0),\n         (jlong)params.peer_active_conn_id_limit,\n         (jlong)params.peer_max_datagram_frame_size\n     };\n",
  "test_patch" : "diff --git a/codec-native-quic/src/test/java/io/netty/handler/codec/quic/QuicTransportParametersTest.java b/codec-native-quic/src/test/java/io/netty/handler/codec/quic/QuicTransportParametersTest.java\nindex 3c6ea0b1a54..34a611ab32b 100644\n--- a/codec-native-quic/src/test/java/io/netty/handler/codec/quic/QuicTransportParametersTest.java\n+++ b/codec-native-quic/src/test/java/io/netty/handler/codec/quic/QuicTransportParametersTest.java\n@@ -88,7 +88,8 @@ private static void assertTransportParameters(@Nullable QuicTransportParameters\n         assertThat(parameters.ackDelayExponent()).isGreaterThanOrEqualTo(1L);\n         assertThat(parameters.maxAckDelay()).isGreaterThanOrEqualTo(1L);\n         assertFalse(parameters.disableActiveMigration());\n-        assertThat(parameters.activeConnIdLimit()).isGreaterThanOrEqualTo(1L);\n+        // -1 is the max value for an uint64_t that is converted to int64_t.\n+        assertThat(parameters.activeConnIdLimit()).isEqualTo(-1L);\n         assertThat(parameters.maxDatagramFrameSize()).isGreaterThanOrEqualTo(0L);\n     }\n }\n",
  "problem_statement" : "Correctly return all TransportParameters\n\nMotivation:\r\n\r\nWe did miss to also include the peer_max_ack_delay in the returned params.\r\n\r\nModifications:\r\n\r\n- Correctly return peer_max_ack_delay as well\r\n- Adjust test\r\n\r\nResult:\r\n\r\nNo more test-failures. Port of https://github.com/netty/netty-incubator-codec-quic/pull/843",
  "hints_text" : null,
  "created_at" : "Wed Jan 21 10:06:04 CET 2026",
  "version" : null,
  "FAIL_TO_PASS" : [ "QuicTransportParametersTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -pl codec-native-quic -Dtest=QuicTransportParametersTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 16162,
  "metadata" : null
}, {
  "instance_id" : "netty-netty-PR-16157",
  "repo" : "netty/netty",
  "base_commit" : "6008169575ddc86ad2be37a6a8da3c9e54b19ce5",
  "patch" : "diff --git a/common/src/main/java/io/netty/util/concurrent/AbstractEventExecutor.java b/common/src/main/java/io/netty/util/concurrent/AbstractEventExecutor.java\nindex aabcd15b521..aa5dd345259 100644\n--- a/common/src/main/java/io/netty/util/concurrent/AbstractEventExecutor.java\n+++ b/common/src/main/java/io/netty/util/concurrent/AbstractEventExecutor.java\n@@ -24,16 +24,16 @@\n import java.util.Collection;\n import java.util.Collections;\n import java.util.Iterator;\n-import java.util.List;\n-import java.util.concurrent.AbstractExecutorService;\n+import java.util.Objects;\n import java.util.concurrent.Callable;\n+import java.util.concurrent.RejectedExecutionException;\n import java.util.concurrent.RunnableFuture;\n import java.util.concurrent.TimeUnit;\n \n /**\n  * Abstract base class for {@link EventExecutor} implementations.\n  */\n-public abstract class AbstractEventExecutor extends AbstractExecutorService implements EventExecutor {\n+public abstract class AbstractEventExecutor implements EventExecutor {\n     private static final InternalLogger logger = InternalLoggerFactory.getInstance(AbstractEventExecutor.class);\n \n     static final long DEFAULT_SHUTDOWN_QUIET_PERIOD = 2;\n@@ -72,69 +72,44 @@ public Future<?> shutdownGracefully() {\n         return shutdownGracefully(DEFAULT_SHUTDOWN_QUIET_PERIOD, DEFAULT_SHUTDOWN_TIMEOUT, TimeUnit.SECONDS);\n     }\n \n-    /**\n-     * @deprecated {@link #shutdownGracefully(long, long, TimeUnit)} or {@link #shutdownGracefully()} instead.\n-     */\n-    @Override\n-    @Deprecated\n-    public abstract void shutdown();\n-\n-    /**\n-     * @deprecated {@link #shutdownGracefully(long, long, TimeUnit)} or {@link #shutdownGracefully()} instead.\n-     */\n-    @Override\n-    @Deprecated\n-    public List<Runnable> shutdownNow() {\n-        shutdown();\n-        return Collections.emptyList();\n-    }\n-\n     @Override\n-    public Future<?> submit(Runnable task) {\n-        return (Future<?>) super.submit(task);\n+    public final Future<?> submit(Runnable task) {\n+        Objects.requireNonNull(task, \"task\");\n+        RunnableFuture<Void> ftask = newTaskFor(task, null);\n+        execute(ftask);\n+        return (Future<?>) ftask;\n     }\n \n     @Override\n-    public <T> Future<T> submit(Runnable task, T result) {\n-        return (Future<T>) super.submit(task, result);\n+    @SuppressWarnings(\"unchecked\")\n+    public final <T> Future<T> submit(Runnable task, T result) {\n+        Objects.requireNonNull(task, \"task\");\n+        RunnableFuture<T> ftask = newTaskFor(task, result);\n+        execute(ftask);\n+        return (Future<T>) ftask;\n     }\n \n+    /**\n+     * @throws RejectedExecutionException {@inheritDoc}\n+     * @throws NullPointerException       {@inheritDoc}\n+     */\n     @Override\n-    public <T> Future<T> submit(Callable<T> task) {\n-        return (Future<T>) super.submit(task);\n+    @SuppressWarnings(\"unchecked\")\n+    public final <T> Future<T> submit(Callable<T> task) {\n+        Objects.requireNonNull(task, \"task\");\n+        RunnableFuture<T> ftask = newTaskFor(task);\n+        execute(ftask);\n+        return (Future<T>) ftask;\n     }\n \n-    @Override\n     protected final <T> RunnableFuture<T> newTaskFor(Runnable runnable, T value) {\n         return new PromiseTask<T>(this, runnable, value);\n     }\n \n-    @Override\n     protected final <T> RunnableFuture<T> newTaskFor(Callable<T> callable) {\n         return new PromiseTask<T>(this, callable);\n     }\n \n-    @Override\n-    public ScheduledFuture<?> schedule(Runnable command, long delay,\n-                                       TimeUnit unit) {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    @Override\n-    public <V> ScheduledFuture<V> schedule(Callable<V> callable, long delay, TimeUnit unit) {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    @Override\n-    public ScheduledFuture<?> scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit) {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    @Override\n-    public ScheduledFuture<?> scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit) {\n-        throw new UnsupportedOperationException();\n-    }\n-\n     @SuppressWarnings(\"unchecked\")\n     @Override\n     public <V> Future<V> newSucceededFuture(V result) {\n@@ -144,6 +119,10 @@ public <V> Future<V> newSucceededFuture(V result) {\n         return EventExecutor.super.newSucceededFuture(result);\n     }\n \n+    protected final <T> ScheduledFuture<T> newFailedScheduledFuture(Throwable cause) {\n+        return new FailedScheduledFuture<>(this, cause);\n+    }\n+\n     /**\n      * Try to execute the given {@link Runnable} and just log if it throws a {@link Throwable}.\n      */\ndiff --git a/common/src/main/java/io/netty/util/concurrent/AbstractEventExecutorGroup.java b/common/src/main/java/io/netty/util/concurrent/AbstractEventExecutorGroup.java\nindex abcfb7087f4..024166da644 100644\n--- a/common/src/main/java/io/netty/util/concurrent/AbstractEventExecutorGroup.java\n+++ b/common/src/main/java/io/netty/util/concurrent/AbstractEventExecutorGroup.java\n@@ -70,46 +70,6 @@ public Future<?> shutdownGracefully() {\n         return shutdownGracefully(DEFAULT_SHUTDOWN_QUIET_PERIOD, DEFAULT_SHUTDOWN_TIMEOUT, TimeUnit.SECONDS);\n     }\n \n-    /**\n-     * @deprecated {@link #shutdownGracefully(long, long, TimeUnit)} or {@link #shutdownGracefully()} instead.\n-     */\n-    @Override\n-    @Deprecated\n-    public abstract void shutdown();\n-\n-    /**\n-     * @deprecated {@link #shutdownGracefully(long, long, TimeUnit)} or {@link #shutdownGracefully()} instead.\n-     */\n-    @Override\n-    @Deprecated\n-    public List<Runnable> shutdownNow() {\n-        shutdown();\n-        return Collections.emptyList();\n-    }\n-\n-    @Override\n-    public <T> List<java.util.concurrent.Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)\n-            throws InterruptedException {\n-        return next().invokeAll(tasks);\n-    }\n-\n-    @Override\n-    public <T> List<java.util.concurrent.Future<T>> invokeAll(\n-            Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit) throws InterruptedException {\n-        return next().invokeAll(tasks, timeout, unit);\n-    }\n-\n-    @Override\n-    public <T> T invokeAny(Collection<? extends Callable<T>> tasks) throws InterruptedException, ExecutionException {\n-        return next().invokeAny(tasks);\n-    }\n-\n-    @Override\n-    public <T> T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n-            throws InterruptedException, ExecutionException, TimeoutException {\n-        return next().invokeAny(tasks, timeout, unit);\n-    }\n-\n     @Override\n     public void execute(Runnable command) {\n         next().execute(command);\ndiff --git a/common/src/main/java/io/netty/util/concurrent/EventExecutorGroup.java b/common/src/main/java/io/netty/util/concurrent/EventExecutorGroup.java\nindex 421e70b5794..842f73739a3 100644\n--- a/common/src/main/java/io/netty/util/concurrent/EventExecutorGroup.java\n+++ b/common/src/main/java/io/netty/util/concurrent/EventExecutorGroup.java\n@@ -16,9 +16,11 @@\n package io.netty.util.concurrent;\n \n import java.util.Iterator;\n-import java.util.List;\n import java.util.concurrent.Callable;\n-import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.RejectedExecutionException;\n import java.util.concurrent.TimeUnit;\n \n /**\n@@ -27,7 +29,202 @@\n  * life-cycle and allows shutting them down in a global fashion.\n  *\n  */\n-public interface EventExecutorGroup extends ScheduledExecutorService, Iterable<EventExecutor> {\n+public interface EventExecutorGroup extends Executor, Iterable<EventExecutor> {\n+\n+    /**\n+     * Submits a one-shot task that becomes enabled after the given delay.\n+     *\n+     * @param command the task to execute\n+     * @param delay the time from now to delay execution\n+     * @param unit the time unit of the delay parameter\n+     * @return a ScheduledFuture representing pending completion of\n+     *         the task and whose {@code get()} method will return\n+     *         {@code null} upon completion\n+     * @throws RejectedExecutionException if the task cannot be\n+     *         scheduled for execution\n+     * @throws NullPointerException if command or unit is null\n+     */\n+    ScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit);\n+\n+    /**\n+     * Submits a value-returning one-shot task that becomes enabled\n+     * after the given delay.\n+     *\n+     * @param callable the function to execute\n+     * @param delay the time from now to delay execution\n+     * @param unit the time unit of the delay parameter\n+     * @param <V> the type of the callable's result\n+     * @return a ScheduledFuture that can be used to extract result or cancel\n+     * @throws RejectedExecutionException if the task cannot be\n+     *         scheduled for execution\n+     * @throws NullPointerException if callable or unit is null\n+     */\n+     <V> ScheduledFuture<V> schedule(Callable<V> callable,\n+                                     long delay, TimeUnit unit);\n+\n+    /**\n+     * Submits a periodic action that becomes enabled first after the\n+     * given initial delay, and subsequently with the given period;\n+     * that is, executions will commence after\n+     * {@code initialDelay}, then {@code initialDelay + period}, then\n+     * {@code initialDelay + 2 * period}, and so on.\n+     *\n+     * <p>The sequence of task executions continues indefinitely until\n+     * one of the following exceptional completions occur:\n+     * <ul>\n+     * <li>The task is {@linkplain java.util.concurrent.Future#cancel explicitly cancelled}\n+     * via the returned future.\n+     * <li>The executor terminates, also resulting in task cancellation.\n+     * <li>An execution of the task throws an exception.  In this case\n+     * calling {@link java.util.concurrent.Future#get() get} on the returned future will throw\n+     * {@link ExecutionException}, holding the exception as its cause.\n+     * </ul>\n+     * Subsequent executions are suppressed.  Subsequent calls to\n+     * {@link java.util.concurrent.Future#isDone isDone()} on the returned future will\n+     * return {@code true}.\n+     *\n+     * <p>If any execution of this task takes longer than its period, then\n+     * subsequent executions may start late, but will not concurrently\n+     * execute.\n+     *\n+     * @param command the task to execute\n+     * @param initialDelay the time to delay first execution\n+     * @param period the period between successive executions\n+     * @param unit the time unit of the initialDelay and period parameters\n+     * @return a ScheduledFuture representing pending completion of\n+     *         the series of repeated tasks.  The future's {@link\n+     *         java.util.concurrent.Future#get() get()} method will never return normally,\n+     *         and will throw an exception upon task cancellation or\n+     *         abnormal termination of a task execution.\n+     * @throws RejectedExecutionException if the task cannot be\n+     *         scheduled for execution\n+     * @throws NullPointerException if command or unit is null\n+     * @throws IllegalArgumentException if period less than or equal to zero\n+     */\n+    ScheduledFuture<?> scheduleAtFixedRate(Runnable command, long initialDelay,\n+                                           long period, TimeUnit unit);\n+\n+    /**\n+     * Submits a periodic action that becomes enabled first after the\n+     * given initial delay, and subsequently with the given delay\n+     * between the termination of one execution and the commencement of\n+     * the next.\n+     *\n+     * <p>The sequence of task executions continues indefinitely until\n+     * one of the following exceptional completions occur:\n+     * <ul>\n+     * <li>The task is {@linkplain java.util.concurrent.Future#cancel explicitly cancelled}\n+     * via the returned future.\n+     * <li>The executor terminates, also resulting in task cancellation.\n+     * <li>An execution of the task throws an exception.  In this case\n+     * calling {@link java.util.concurrent.Future#get() get} on the returned future will throw\n+     * {@link ExecutionException}, holding the exception as its cause.\n+     * </ul>\n+     * Subsequent executions are suppressed.  Subsequent calls to\n+     * {@link java.util.concurrent.Future#isDone isDone()} on the returned future will\n+     * return {@code true}.\n+     *\n+     * @param command the task to execute\n+     * @param initialDelay the time to delay first execution\n+     * @param delay the delay between the termination of one\n+     * execution and the commencement of the next\n+     * @param unit the time unit of the initialDelay and delay parameters\n+     * @return a ScheduledFuture representing pending completion of\n+     *         the series of repeated tasks.  The future's {@link\n+     *         java.util.concurrent.Future#get() get()} method will never return normally,\n+     *         and will throw an exception upon task cancellation or\n+     *         abnormal termination of a task execution.\n+     * @throws RejectedExecutionException if the task cannot be\n+     *         scheduled for execution\n+     * @throws NullPointerException if command or unit is null\n+     * @throws IllegalArgumentException if delay less than or equal to zero\n+     */\n+    ScheduledFuture<?> scheduleWithFixedDelay(Runnable command,\n+                                              long initialDelay,\n+                                              long delay,\n+                                              TimeUnit unit);\n+\n+    /**\n+     * Returns {@code true} if this executor has been shut down.\n+     *\n+     * @return {@code true} if this executor has been shut down\n+     */\n+    boolean isShutdown();\n+\n+    /**\n+     * Returns {@code true} if all tasks have completed following shut down.\n+     * Note that {@code isTerminated} is never {@code true} unless\n+     * either {@code shutdown} or {@code shutdownNow} was called first.\n+     *\n+     * @return {@code true} if all tasks have completed following shut down\n+     */\n+    boolean isTerminated();\n+\n+    /**\n+     * Blocks until all tasks have completed execution after a shutdown\n+     * request, or the timeout occurs, or the current thread is\n+     * interrupted, whichever happens first.\n+     *\n+     * @param timeout the maximum time to wait\n+     * @param unit the time unit of the timeout argument\n+     * @return {@code true} if this executor terminated and\n+     *         {@code false} if the timeout elapsed before termination\n+     * @throws InterruptedException if interrupted while waiting\n+     */\n+    boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException;\n+\n+    /**\n+     * Submits a value-returning task for execution and returns a\n+     * Future representing the pending results of the task. The\n+     * Future's {@code get} method will return the task's result upon\n+     * successful completion.\n+     *\n+     * <p>\n+     * If you would like to immediately block waiting\n+     * for a task, you can use constructions of the form\n+     * {@code result = exec.submit(aCallable).get();}\n+     *\n+     * <p>Note: The {@link Executors} class includes a set of methods\n+     * that can convert some other common closure-like objects,\n+     * for example, {@link java.security.PrivilegedAction} to\n+     * {@link Callable} form so they can be submitted.\n+     *\n+     * @param task the task to submit\n+     * @param <T> the type of the task's result\n+     * @return a Future representing pending completion of the task\n+     * @throws RejectedExecutionException if the task cannot be\n+     *         scheduled for execution\n+     * @throws NullPointerException if the task is null\n+     */\n+    <T> Future<T> submit(Callable<T> task);\n+\n+    /**\n+     * Submits a Runnable task for execution and returns a Future\n+     * representing that task. The Future's {@code get} method will\n+     * return the given result upon successful completion.\n+     *\n+     * @param task the task to submit\n+     * @param result the result to return\n+     * @param <T> the type of the result\n+     * @return a Future representing pending completion of the task\n+     * @throws RejectedExecutionException if the task cannot be\n+     *         scheduled for execution\n+     * @throws NullPointerException if the task is null\n+     */\n+    <T> Future<T> submit(Runnable task, T result);\n+\n+    /**\n+     * Submits a Runnable task for execution and returns a Future\n+     * representing that task. The Future's {@code get} method will\n+     * return {@code null} upon <em>successful</em> completion.\n+     *\n+     * @param task the task to submit\n+     * @return a Future representing pending completion of the task\n+     * @throws RejectedExecutionException if the task cannot be\n+     *         scheduled for execution\n+     * @throws NullPointerException if the task is null\n+     */\n+    Future<?> submit(Runnable task);\n \n     /**\n      * Returns {@code true} if and only if all {@link EventExecutor}s managed by this {@link EventExecutorGroup}\n@@ -45,12 +242,11 @@ public interface EventExecutorGroup extends ScheduledExecutorService, Iterable<E\n     /**\n      * Signals this executor that the caller wants the executor to be shut down.  Once this method is called,\n      * {@link #isShuttingDown()} starts to return {@code true}, and the executor prepares to shut itself down.\n-     * Unlike {@link #shutdown()}, graceful shutdown ensures that no tasks are submitted for <i>'the quiet period'</i>\n-     * (usually a couple seconds) before it shuts itself down.  If a task is submitted during the quiet period,\n+     * If a task is submitted during the quiet period,\n      * it is guaranteed to be accepted and the quiet period will start over.\n      *\n      * @param quietPeriod the quiet period as described in the documentation\n-     * @param timeout     the maximum amount of time to wait until the executor is {@linkplain #shutdown()}\n+     * @param timeout     the maximum amount of time to wait until the executor is shutdown\n      *                    regardless if a task was submitted during the quiet period\n      * @param unit        the unit of {@code quietPeriod} and {@code timeout}\n      *\n@@ -63,21 +259,6 @@ public interface EventExecutorGroup extends ScheduledExecutorService, Iterable<E\n      * {@link EventExecutorGroup} have been terminated.\n      */\n     Future<?> terminationFuture();\n-\n-    /**\n-     * @deprecated {@link #shutdownGracefully(long, long, TimeUnit)} or {@link #shutdownGracefully()} instead.\n-     */\n-    @Override\n-    @Deprecated\n-    void shutdown();\n-\n-    /**\n-     * @deprecated {@link #shutdownGracefully(long, long, TimeUnit)} or {@link #shutdownGracefully()} instead.\n-     */\n-    @Override\n-    @Deprecated\n-    List<Runnable> shutdownNow();\n-\n     /**\n      * Returns one of the {@link EventExecutor}s managed by this {@link EventExecutorGroup}.\n      */\n@@ -86,15 +267,6 @@ public interface EventExecutorGroup extends ScheduledExecutorService, Iterable<E\n     @Override\n     Iterator<EventExecutor> iterator();\n \n-    @Override\n-    Future<?> submit(Runnable task);\n-\n-    @Override\n-    <T> Future<T> submit(Runnable task, T result);\n-\n-    @Override\n-    <T> Future<T> submit(Callable<T> task);\n-\n     /**\n      * The ticker for this executor. Usually the {@link #schedule} methods will follow the\n      * {@link Ticker#systemTicker() system ticker} (i.e. {@link System#nanoTime()}), but especially for testing it is\n@@ -107,16 +279,4 @@ public interface EventExecutorGroup extends ScheduledExecutorService, Iterable<E\n     default Ticker ticker() {\n         return Ticker.systemTicker();\n     }\n-\n-    @Override\n-    ScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit);\n-\n-    @Override\n-    <V> ScheduledFuture<V> schedule(Callable<V> callable, long delay, TimeUnit unit);\n-\n-    @Override\n-    ScheduledFuture<?> scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit);\n-\n-    @Override\n-    ScheduledFuture<?> scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit);\n }\ndiff --git a/common/src/main/java/io/netty/util/concurrent/FailedFuture.java b/common/src/main/java/io/netty/util/concurrent/FailedFuture.java\nindex 1e6035931d6..fe6584e8a35 100644\n--- a/common/src/main/java/io/netty/util/concurrent/FailedFuture.java\n+++ b/common/src/main/java/io/netty/util/concurrent/FailedFuture.java\n@@ -23,7 +23,7 @@\n  * recommended to use {@link EventExecutor#newFailedFuture(Throwable)}\n  * instead of calling the constructor of this future.\n  */\n-public final class FailedFuture<V> extends CompleteFuture<V> {\n+public class FailedFuture<V> extends CompleteFuture<V> {\n \n     private final Throwable cause;\n \ndiff --git a/common/src/main/java/io/netty/util/concurrent/FailedScheduledFuture.java b/common/src/main/java/io/netty/util/concurrent/FailedScheduledFuture.java\nnew file mode 100644\nindex 00000000000..de7df6bad6a\n--- /dev/null\n+++ b/common/src/main/java/io/netty/util/concurrent/FailedScheduledFuture.java\n@@ -0,0 +1,38 @@\n+/*\n+ * Copyright 2026 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.util.concurrent;\n+\n+import org.jetbrains.annotations.NotNull;\n+\n+import java.util.concurrent.Delayed;\n+import java.util.concurrent.TimeUnit;\n+\n+final class FailedScheduledFuture<V> extends FailedFuture<V> implements ScheduledFuture<V> {\n+\n+    FailedScheduledFuture(EventExecutor executor, Throwable cause) {\n+        super(executor, cause);\n+    }\n+\n+    @Override\n+    public long getDelay(@NotNull TimeUnit unit) {\n+        return 0;\n+    }\n+\n+    @Override\n+    public int compareTo(@NotNull Delayed o) {\n+        return Long.compare(0L, o.getDelay(TimeUnit.NANOSECONDS));\n+    }\n+}\ndiff --git a/common/src/main/java/io/netty/util/concurrent/GlobalEventExecutor.java b/common/src/main/java/io/netty/util/concurrent/GlobalEventExecutor.java\nindex fc630dd394c..a684249a5df 100644\n--- a/common/src/main/java/io/netty/util/concurrent/GlobalEventExecutor.java\n+++ b/common/src/main/java/io/netty/util/concurrent/GlobalEventExecutor.java\n@@ -178,12 +178,6 @@ public Future<?> terminationFuture() {\n         return terminationFuture;\n     }\n \n-    @Override\n-    @Deprecated\n-    public void shutdown() {\n-        throw new UnsupportedOperationException();\n-    }\n-\n     @Override\n     public boolean isShuttingDown() {\n         return false;\ndiff --git a/common/src/main/java/io/netty/util/concurrent/ImmediateEventExecutor.java b/common/src/main/java/io/netty/util/concurrent/ImmediateEventExecutor.java\nindex c3d0edec1b5..f4c50971255 100644\n--- a/common/src/main/java/io/netty/util/concurrent/ImmediateEventExecutor.java\n+++ b/common/src/main/java/io/netty/util/concurrent/ImmediateEventExecutor.java\n@@ -21,6 +21,7 @@\n \n import java.util.ArrayDeque;\n import java.util.Queue;\n+import java.util.concurrent.Callable;\n import java.util.concurrent.TimeUnit;\n \n /**\n@@ -77,10 +78,6 @@ public Future<?> terminationFuture() {\n         return terminationFuture;\n     }\n \n-    @Override\n-    @Deprecated\n-    public void shutdown() { }\n-\n     @Override\n     public boolean isShuttingDown() {\n         return false;\n@@ -127,6 +124,26 @@ public void execute(Runnable command) {\n         }\n     }\n \n+    @Override\n+    public ScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit) {\n+        return newFailedScheduledFuture(new UnsupportedOperationException());\n+    }\n+\n+    @Override\n+    public <V> ScheduledFuture<V> schedule(Callable<V> callable, long delay, TimeUnit unit) {\n+        return newFailedScheduledFuture(new UnsupportedOperationException());\n+    }\n+\n+    @Override\n+    public ScheduledFuture<?> scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit) {\n+        return newFailedScheduledFuture(new UnsupportedOperationException());\n+    }\n+\n+    @Override\n+    public ScheduledFuture<?> scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit) {\n+        return newFailedScheduledFuture(new UnsupportedOperationException());\n+    }\n+\n     @Override\n     public <V> Promise<V> newPromise() {\n         return new ImmediatePromise<V>(this);\ndiff --git a/common/src/main/java/io/netty/util/concurrent/MultithreadEventExecutorGroup.java b/common/src/main/java/io/netty/util/concurrent/MultithreadEventExecutorGroup.java\nindex e5f5becc35a..d751429553f 100644\n--- a/common/src/main/java/io/netty/util/concurrent/MultithreadEventExecutorGroup.java\n+++ b/common/src/main/java/io/netty/util/concurrent/MultithreadEventExecutorGroup.java\n@@ -198,14 +198,6 @@ public Future<?> terminationFuture() {\n         return terminationFuture;\n     }\n \n-    @Override\n-    @Deprecated\n-    public void shutdown() {\n-        for (EventExecutor l: children) {\n-            l.shutdown();\n-        }\n-    }\n-\n     @Override\n     public boolean isShuttingDown() {\n         for (EventExecutor l: children) {\ndiff --git a/common/src/main/java/io/netty/util/concurrent/NonStickyEventExecutorGroup.java b/common/src/main/java/io/netty/util/concurrent/NonStickyEventExecutorGroup.java\nindex b316ab621ed..5f76fa05531 100644\n--- a/common/src/main/java/io/netty/util/concurrent/NonStickyEventExecutorGroup.java\n+++ b/common/src/main/java/io/netty/util/concurrent/NonStickyEventExecutorGroup.java\n@@ -19,15 +19,11 @@\n import io.netty.util.internal.PlatformDependent;\n import io.netty.util.internal.UnstableApi;\n \n-import java.util.Collection;\n import java.util.Iterator;\n-import java.util.List;\n import java.util.Queue;\n import java.util.concurrent.Callable;\n-import java.util.concurrent.ExecutionException;\n import java.util.concurrent.RejectedExecutionException;\n import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.TimeoutException;\n import java.util.concurrent.atomic.AtomicInteger;\n import java.util.concurrent.atomic.AtomicReference;\n \n@@ -96,18 +92,6 @@ public Future<?> terminationFuture() {\n         return group.terminationFuture();\n     }\n \n-    @SuppressWarnings(\"deprecation\")\n-    @Override\n-    public void shutdown() {\n-        group.shutdown();\n-    }\n-\n-    @SuppressWarnings(\"deprecation\")\n-    @Override\n-    public List<Runnable> shutdownNow() {\n-        return group.shutdownNow();\n-    }\n-\n     @Override\n     public EventExecutor next() {\n         return newExecutor(group.next());\n@@ -184,29 +168,6 @@ public boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedE\n         return group.awaitTermination(timeout, unit);\n     }\n \n-    @Override\n-    public <T> List<java.util.concurrent.Future<T>> invokeAll(\n-            Collection<? extends Callable<T>> tasks) throws InterruptedException {\n-        return group.invokeAll(tasks);\n-    }\n-\n-    @Override\n-    public <T> List<java.util.concurrent.Future<T>> invokeAll(\n-            Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit) throws InterruptedException {\n-        return group.invokeAll(tasks, timeout, unit);\n-    }\n-\n-    @Override\n-    public <T> T invokeAny(Collection<? extends Callable<T>> tasks) throws InterruptedException, ExecutionException {\n-        return group.invokeAny(tasks);\n-    }\n-\n-    @Override\n-    public <T> T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n-            throws InterruptedException, ExecutionException, TimeoutException {\n-        return group.invokeAny(tasks, timeout, unit);\n-    }\n-\n     @Override\n     public void execute(Runnable command) {\n         group.execute(command);\n@@ -313,11 +274,6 @@ public Future<?> terminationFuture() {\n             return executor.terminationFuture();\n         }\n \n-        @Override\n-        public void shutdown() {\n-            executor.shutdown();\n-        }\n-\n         @Override\n         public boolean isShutdown() {\n             return executor.isShutdown();\n@@ -344,5 +300,26 @@ public void execute(Runnable command) {\n                 executor.execute(this);\n             }\n         }\n+\n+        @Override\n+        public ScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit) {\n+            return newFailedScheduledFuture(new UnsupportedOperationException());\n+        }\n+\n+        @Override\n+        public <V> ScheduledFuture<V> schedule(Callable<V> callable, long delay, TimeUnit unit) {\n+            return newFailedScheduledFuture(new UnsupportedOperationException());\n+        }\n+\n+        @Override\n+        public ScheduledFuture<?> scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit) {\n+            return newFailedScheduledFuture(new UnsupportedOperationException());\n+        }\n+\n+        @Override\n+        public ScheduledFuture<?> scheduleWithFixedDelay(\n+                Runnable command, long initialDelay, long delay, TimeUnit unit) {\n+            return newFailedScheduledFuture(new UnsupportedOperationException());\n+        }\n     }\n }\ndiff --git a/common/src/main/java/io/netty/util/concurrent/SingleThreadEventExecutor.java b/common/src/main/java/io/netty/util/concurrent/SingleThreadEventExecutor.java\nindex b568d17690c..14fec47acac 100644\n--- a/common/src/main/java/io/netty/util/concurrent/SingleThreadEventExecutor.java\n+++ b/common/src/main/java/io/netty/util/concurrent/SingleThreadEventExecutor.java\n@@ -25,24 +25,18 @@\n \n import java.lang.Thread.State;\n import java.util.ArrayList;\n-import java.util.Collection;\n import java.util.LinkedHashSet;\n import java.util.List;\n import java.util.Queue;\n import java.util.Set;\n import java.util.concurrent.BlockingQueue;\n-import java.util.concurrent.Callable;\n import java.util.concurrent.CountDownLatch;\n-import java.util.concurrent.ExecutionException;\n import java.util.concurrent.Executor;\n import java.util.concurrent.LinkedBlockingQueue;\n import java.util.concurrent.RejectedExecutionException;\n import java.util.concurrent.ThreadFactory;\n import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.TimeoutException;\n-import java.util.concurrent.atomic.AtomicInteger;\n import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n-import java.util.concurrent.atomic.AtomicLong;\n import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n import java.util.concurrent.locks.Lock;\n@@ -841,12 +835,6 @@ public Future<?> terminationFuture() {\n         return terminationFuture;\n     }\n \n-    @Override\n-    @Deprecated\n-    public void shutdown() {\n-        shutdown0(-1, -1, ST_SHUTDOWN);\n-    }\n-\n     @Override\n     public boolean isShuttingDown() {\n         return state >= ST_SHUTTING_DOWN;\n@@ -1049,39 +1037,6 @@ private void execute(Runnable task, boolean immediate) {\n         }\n     }\n \n-    @Override\n-    public <T> T invokeAny(Collection<? extends Callable<T>> tasks) throws InterruptedException, ExecutionException {\n-        throwIfInEventLoop(\"invokeAny\");\n-        return super.invokeAny(tasks);\n-    }\n-\n-    @Override\n-    public <T> T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n-            throws InterruptedException, ExecutionException, TimeoutException {\n-        throwIfInEventLoop(\"invokeAny\");\n-        return super.invokeAny(tasks, timeout, unit);\n-    }\n-\n-    @Override\n-    public <T> List<java.util.concurrent.Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)\n-            throws InterruptedException {\n-        throwIfInEventLoop(\"invokeAll\");\n-        return super.invokeAll(tasks);\n-    }\n-\n-    @Override\n-    public <T> List<java.util.concurrent.Future<T>> invokeAll(\n-            Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit) throws InterruptedException {\n-        throwIfInEventLoop(\"invokeAll\");\n-        return super.invokeAll(tasks, timeout, unit);\n-    }\n-\n-    private void throwIfInEventLoop(String method) {\n-        if (inEventLoop()) {\n-            throw new RejectedExecutionException(\"Calling \" + method + \" from within the EventLoop is not allowed\");\n-        }\n-    }\n-\n     /**\n      * Returns the {@link ThreadProperties} of the {@link Thread} that powers the {@link SingleThreadEventExecutor}.\n      * If the {@link SingleThreadEventExecutor} is not started yet, this operation will start it and block until\ndiff --git a/handler/src/main/java/io/netty/handler/traffic/GlobalChannelTrafficCounter.java b/handler/src/main/java/io/netty/handler/traffic/GlobalChannelTrafficCounter.java\nindex aa0ec578087..60a73cfe73c 100644\n--- a/handler/src/main/java/io/netty/handler/traffic/GlobalChannelTrafficCounter.java\n+++ b/handler/src/main/java/io/netty/handler/traffic/GlobalChannelTrafficCounter.java\n@@ -18,6 +18,7 @@\n import static io.netty.util.internal.ObjectUtil.checkNotNullWithIAE;\n \n import io.netty.handler.traffic.GlobalChannelTrafficShapingHandler.PerChannel;\n+import io.netty.util.concurrent.EventExecutor;\n \n import java.util.concurrent.ScheduledExecutorService;\n import java.util.concurrent.TimeUnit;\n@@ -36,7 +37,7 @@ public class GlobalChannelTrafficCounter extends TrafficCounter {\n      * @param checkInterval the checkInterval in millisecond between two computations.\n      */\n     public GlobalChannelTrafficCounter(GlobalChannelTrafficShapingHandler trafficShapingHandler,\n-            ScheduledExecutorService executor, String name, long checkInterval) {\n+                                       EventExecutor executor, String name, long checkInterval) {\n         super(trafficShapingHandler, executor, name, checkInterval);\n         checkNotNullWithIAE(executor, \"executor\");\n     }\ndiff --git a/handler/src/main/java/io/netty/handler/traffic/GlobalChannelTrafficShapingHandler.java b/handler/src/main/java/io/netty/handler/traffic/GlobalChannelTrafficShapingHandler.java\nindex b981cf13ce0..93196030826 100644\n--- a/handler/src/main/java/io/netty/handler/traffic/GlobalChannelTrafficShapingHandler.java\n+++ b/handler/src/main/java/io/netty/handler/traffic/GlobalChannelTrafficShapingHandler.java\n@@ -35,7 +35,6 @@\n import java.util.Iterator;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.ConcurrentMap;\n-import java.util.concurrent.ScheduledExecutorService;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicLong;\n \n@@ -146,7 +145,7 @@ static final class PerChannel {\n     /**\n      * Create the global TrafficCounter\n      */\n-    void createGlobalTrafficCounter(ScheduledExecutorService executor) {\n+    void createGlobalTrafficCounter(EventExecutor executor) {\n         // Default\n         setMaxDeviation(DEFAULT_DEVIATION, DEFAULT_SLOWDOWN, DEFAULT_ACCELERATION);\n         checkNotNullWithIAE(executor, \"executor\");\n@@ -164,7 +163,7 @@ protected int userDefinedWritabilityIndex() {\n      * Create a new instance.\n      *\n      * @param executor\n-     *            the {@link ScheduledExecutorService} to use for the {@link TrafficCounter}.\n+     *            the {@link EventExecutor} to use for the {@link TrafficCounter}.\n      * @param writeGlobalLimit\n      *            0 or a limit in bytes/s\n      * @param readGlobalLimit\n@@ -179,7 +178,7 @@ protected int userDefinedWritabilityIndex() {\n      * @param maxTime\n      *            The maximum delay to wait in case of traffic excess.\n      */\n-    public GlobalChannelTrafficShapingHandler(ScheduledExecutorService executor,\n+    public GlobalChannelTrafficShapingHandler(EventExecutor executor,\n             long writeGlobalLimit, long readGlobalLimit,\n             long writeChannelLimit, long readChannelLimit,\n             long checkInterval, long maxTime) {\n@@ -193,7 +192,7 @@ public GlobalChannelTrafficShapingHandler(ScheduledExecutorService executor,\n      * Create a new instance.\n      *\n      * @param executor\n-     *          the {@link ScheduledExecutorService} to use for the {@link TrafficCounter}.\n+     *          the {@link EventExecutor} to use for the {@link TrafficCounter}.\n      * @param writeGlobalLimit\n      *            0 or a limit in bytes/s\n      * @param readGlobalLimit\n@@ -206,7 +205,7 @@ public GlobalChannelTrafficShapingHandler(ScheduledExecutorService executor,\n      *          The delay between two computations of performances for\n      *            channels or 0 if no stats are to be computed.\n      */\n-    public GlobalChannelTrafficShapingHandler(ScheduledExecutorService executor,\n+    public GlobalChannelTrafficShapingHandler(EventExecutor executor,\n             long writeGlobalLimit, long readGlobalLimit,\n             long writeChannelLimit, long readChannelLimit,\n             long checkInterval) {\n@@ -220,7 +219,7 @@ public GlobalChannelTrafficShapingHandler(ScheduledExecutorService executor,\n      * Create a new instance.\n      *\n      * @param executor\n-     *          the {@link ScheduledExecutorService} to use for the {@link TrafficCounter}.\n+     *          the {@link EventExecutor} to use for the {@link TrafficCounter}.\n      * @param writeGlobalLimit\n      *            0 or a limit in bytes/s\n      * @param readGlobalLimit\n@@ -230,7 +229,7 @@ public GlobalChannelTrafficShapingHandler(ScheduledExecutorService executor,\n      * @param readChannelLimit\n      *            0 or a limit in bytes/s\n      */\n-    public GlobalChannelTrafficShapingHandler(ScheduledExecutorService executor,\n+    public GlobalChannelTrafficShapingHandler(EventExecutor executor,\n             long writeGlobalLimit, long readGlobalLimit,\n             long writeChannelLimit, long readChannelLimit) {\n         super(writeGlobalLimit, readGlobalLimit);\n@@ -243,12 +242,12 @@ public GlobalChannelTrafficShapingHandler(ScheduledExecutorService executor,\n      * Create a new instance.\n      *\n      * @param executor\n-     *          the {@link ScheduledExecutorService} to use for the {@link TrafficCounter}.\n+     *          the {@link EventExecutor} to use for the {@link TrafficCounter}.\n      * @param checkInterval\n      *          The delay between two computations of performances for\n      *            channels or 0 if no stats are to be computed.\n      */\n-    public GlobalChannelTrafficShapingHandler(ScheduledExecutorService executor, long checkInterval) {\n+    public GlobalChannelTrafficShapingHandler(EventExecutor executor, long checkInterval) {\n         super(checkInterval);\n         createGlobalTrafficCounter(executor);\n     }\n@@ -257,9 +256,9 @@ public GlobalChannelTrafficShapingHandler(ScheduledExecutorService executor, lon\n      * Create a new instance.\n      *\n      * @param executor\n-     *          the {@link ScheduledExecutorService} to use for the {@link TrafficCounter}.\n+     *          the {@link EventExecutor} to use for the {@link TrafficCounter}.\n      */\n-    public GlobalChannelTrafficShapingHandler(ScheduledExecutorService executor) {\n+    public GlobalChannelTrafficShapingHandler(EventExecutor executor) {\n         createGlobalTrafficCounter(executor);\n     }\n \ndiff --git a/handler/src/main/java/io/netty/handler/traffic/GlobalTrafficShapingHandler.java b/handler/src/main/java/io/netty/handler/traffic/GlobalTrafficShapingHandler.java\nindex da9f3978e8e..ea8af6e429a 100644\n--- a/handler/src/main/java/io/netty/handler/traffic/GlobalTrafficShapingHandler.java\n+++ b/handler/src/main/java/io/netty/handler/traffic/GlobalTrafficShapingHandler.java\n@@ -101,7 +101,7 @@ private static final class PerChannel {\n     /**\n      * Create the global TrafficCounter.\n      */\n-    void createGlobalTrafficCounter(ScheduledExecutorService executor) {\n+    void createGlobalTrafficCounter(EventExecutor executor) {\n         TrafficCounter tc = new TrafficCounter(this,\n                 ObjectUtil.checkNotNull(executor, \"executor\"),\n                 \"GlobalTC\",\n@@ -120,7 +120,7 @@ protected int userDefinedWritabilityIndex() {\n      * Create a new instance.\n      *\n      * @param executor\n-     *            the {@link ScheduledExecutorService} to use for the {@link TrafficCounter}.\n+     *            the {@link EventExecutor} to use for the {@link TrafficCounter}.\n      * @param writeLimit\n      *            0 or a limit in bytes/s\n      * @param readLimit\n@@ -131,7 +131,7 @@ protected int userDefinedWritabilityIndex() {\n      * @param maxTime\n      *            The maximum delay to wait in case of traffic excess.\n      */\n-    public GlobalTrafficShapingHandler(ScheduledExecutorService executor, long writeLimit, long readLimit,\n+    public GlobalTrafficShapingHandler(EventExecutor executor, long writeLimit, long readLimit,\n             long checkInterval, long maxTime) {\n         super(writeLimit, readLimit, checkInterval, maxTime);\n         createGlobalTrafficCounter(executor);\n@@ -142,7 +142,7 @@ public GlobalTrafficShapingHandler(ScheduledExecutorService executor, long write\n      * default max time as delay allowed value of 15000 ms.\n      *\n      * @param executor\n-     *          the {@link ScheduledExecutorService} to use for the {@link TrafficCounter}.\n+     *          the {@link EventExecutor} to use for the {@link TrafficCounter}.\n      * @param writeLimit\n      *          0 or a limit in bytes/s\n      * @param readLimit\n@@ -151,7 +151,7 @@ public GlobalTrafficShapingHandler(ScheduledExecutorService executor, long write\n      *          The delay between two computations of performances for\n      *            channels or 0 if no stats are to be computed.\n      */\n-    public GlobalTrafficShapingHandler(ScheduledExecutorService executor, long writeLimit,\n+    public GlobalTrafficShapingHandler(EventExecutor executor, long writeLimit,\n             long readLimit, long checkInterval) {\n         super(writeLimit, readLimit, checkInterval);\n         createGlobalTrafficCounter(executor);\n@@ -168,7 +168,7 @@ public GlobalTrafficShapingHandler(ScheduledExecutorService executor, long write\n      * @param readLimit\n      *          0 or a limit in bytes/s\n      */\n-    public GlobalTrafficShapingHandler(ScheduledExecutorService executor, long writeLimit,\n+    public GlobalTrafficShapingHandler(EventExecutor executor, long writeLimit,\n             long readLimit) {\n         super(writeLimit, readLimit);\n         createGlobalTrafficCounter(executor);\n@@ -184,7 +184,7 @@ public GlobalTrafficShapingHandler(ScheduledExecutorService executor, long write\n      *          The delay between two computations of performances for\n      *            channels or 0 if no stats are to be computed.\n      */\n-    public GlobalTrafficShapingHandler(ScheduledExecutorService executor, long checkInterval) {\n+    public GlobalTrafficShapingHandler(EventExecutor executor, long checkInterval) {\n         super(checkInterval);\n         createGlobalTrafficCounter(executor);\n     }\ndiff --git a/handler/src/main/java/io/netty/handler/traffic/TrafficCounter.java b/handler/src/main/java/io/netty/handler/traffic/TrafficCounter.java\nindex cc4fd0b3564..8c449ae25ff 100644\n--- a/handler/src/main/java/io/netty/handler/traffic/TrafficCounter.java\n+++ b/handler/src/main/java/io/netty/handler/traffic/TrafficCounter.java\n@@ -17,6 +17,8 @@\n \n import static io.netty.util.internal.ObjectUtil.checkNotNull;\n import static io.netty.util.internal.ObjectUtil.checkNotNullWithIAE;\n+\n+import io.netty.util.concurrent.EventExecutor;\n import io.netty.util.internal.logging.InternalLogger;\n import io.netty.util.internal.logging.InternalLoggerFactory;\n \n@@ -147,7 +149,7 @@ public static long milliSecondFromNano() {\n     /**\n      * Executor that will run the monitor\n      */\n-    final ScheduledExecutorService executor;\n+    final EventExecutor executor;\n     /**\n      * Monitor created once in start()\n      */\n@@ -251,7 +253,7 @@ synchronized void resetAccounting(long newLastTime) {\n      * @param checkInterval\n      *            the checkInterval in millisecond between two computations.\n      */\n-    public TrafficCounter(ScheduledExecutorService executor, String name, long checkInterval) {\n+    public TrafficCounter(EventExecutor executor, String name, long checkInterval) {\n \n         this.name = checkNotNull(name, \"name\");\n         trafficShapingHandler = null;\n@@ -275,7 +277,7 @@ public TrafficCounter(ScheduledExecutorService executor, String name, long check\n      *            the checkInterval in millisecond between two computations.\n      */\n     public TrafficCounter(\n-            AbstractTrafficShapingHandler trafficShapingHandler, ScheduledExecutorService executor,\n+            AbstractTrafficShapingHandler trafficShapingHandler, EventExecutor executor,\n             String name, long checkInterval) {\n         this.name = checkNotNull(name, \"name\");\n         this.trafficShapingHandler = checkNotNullWithIAE(trafficShapingHandler, \"trafficShapingHandler\");\ndiff --git a/microbench/src/main/java/io/netty/microbench/concurrent/BurstCostExecutorsBenchmark.java b/microbench/src/main/java/io/netty/microbench/concurrent/BurstCostExecutorsBenchmark.java\nindex e73d7cedd4e..34cddf71f9c 100644\n--- a/microbench/src/main/java/io/netty/microbench/concurrent/BurstCostExecutorsBenchmark.java\n+++ b/microbench/src/main/java/io/netty/microbench/concurrent/BurstCostExecutorsBenchmark.java\n@@ -34,10 +34,12 @@\n import java.util.Queue;\n import java.util.concurrent.Callable;\n import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Executor;\n import java.util.concurrent.ExecutorService;\n import java.util.concurrent.Executors;\n import java.util.concurrent.Future;\n import java.util.concurrent.RejectedExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.TimeoutException;\n import java.util.concurrent.atomic.AtomicBoolean;\n@@ -176,8 +178,8 @@ private enum ExecutorType {\n     @Param({ \"0\", \"10\" })\n     private int work;\n \n-    private ExecutorService executor;\n-    private ExecutorService executorToShutdown;\n+    private Executor executor;\n+    private AutoCloseable executorToShutdown;\n \n     @Setup\n     public void setup() {\n@@ -188,23 +190,27 @@ public void setup() {\n             //4 is to leave some room between the offers and 1024 is to leave some room\n             //between producer/consumer when work is > 0 and 1 producer.\n             //If work = 0 then the task queue is supposed to be near empty most of the time.\n-            executor = new SpinExecutorService(Math.min(1024, burstLength * 4));\n-            executorToShutdown = executor;\n+            io.netty.microbench.concurrent.BurstCostExecutorsBenchmark.SpinExecutorService spinExecutor\n+                    = new SpinExecutorService(Math.min(1024, burstLength * 4));\n+            executor = spinExecutor;\n+            executorToShutdown = spinExecutor;\n             break;\n         case defaultEventExecutor:\n-            executor = new DefaultEventExecutor();\n-            executorToShutdown = executor;\n+            io.netty.util.concurrent.EventExecutor eventExecutor = new DefaultEventExecutor();\n+            executor = eventExecutor;\n+            executorToShutdown = eventExecutor::shutdownGracefully;\n             break;\n         case juc:\n-            executor = Executors.newSingleThreadScheduledExecutor();\n-            executorToShutdown = executor;\n+            java.util.concurrent.ScheduledExecutorService scheduled = Executors.newSingleThreadScheduledExecutor();\n+            executor = scheduled;\n+            executorToShutdown = scheduled;\n             break;\n         }\n     }\n \n     @TearDown\n-    public void tearDown() {\n-        executorToShutdown.shutdown();\n+    public void tearDown() throws Exception {\n+        executorToShutdown.close();\n     }\n \n     @State(Scope.Thread)\n@@ -293,7 +299,7 @@ public int test3Producers(final PerThreadState state) {\n     }\n \n     private int executeBurst(final PerThreadState state) {\n-        final ExecutorService executor = this.executor;\n+        final Executor executor = this.executor;\n         final int burstLength = this.burstLength;\n         final Runnable completeTask = state.completeTask;\n         for (int i = 0; i < burstLength; i++) {\ndiff --git a/microbench/src/main/java/io/netty/microbench/util/AbstractMicrobenchmark.java b/microbench/src/main/java/io/netty/microbench/util/AbstractMicrobenchmark.java\nindex 20f7b18b148..2537757e96d 100644\n--- a/microbench/src/main/java/io/netty/microbench/util/AbstractMicrobenchmark.java\n+++ b/microbench/src/main/java/io/netty/microbench/util/AbstractMicrobenchmark.java\n@@ -20,6 +20,7 @@\n import io.netty.util.concurrent.EventExecutor;\n import io.netty.util.concurrent.FastThreadLocalThread;\n import io.netty.util.concurrent.Future;\n+import io.netty.util.concurrent.ScheduledFuture;\n import io.netty.util.internal.EmptyArrays;\n import io.netty.util.internal.PlatformDependent;\n import io.netty.util.internal.SystemPropertyUtil;\n@@ -30,6 +31,7 @@\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.List;\n+import java.util.concurrent.Callable;\n import java.util.concurrent.LinkedBlockingQueue;\n import java.util.concurrent.ThreadPoolExecutor;\n import java.util.concurrent.TimeUnit;\n@@ -53,10 +55,6 @@ public HarnessExecutor(int maxThreads, String prefix) {\n                     new LinkedBlockingQueue<Runnable>(),\n                     new DefaultThreadFactory(prefix));\n             EventExecutor eventExecutor = new AbstractEventExecutor() {\n-                @Override\n-                public void shutdown() {\n-                    throw new UnsupportedOperationException();\n-                }\n \n                 @Override\n                 public boolean inEventLoop(Thread thread) {\n@@ -97,6 +95,28 @@ public boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedE\n                 public void execute(Runnable command) {\n                     throw new UnsupportedOperationException();\n                 }\n+\n+                @Override\n+                public ScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit) {\n+                    throw new UnsupportedOperationException();\n+                }\n+\n+                @Override\n+                public <V> ScheduledFuture<V> schedule(Callable<V> callable, long delay, TimeUnit unit) {\n+                    throw new UnsupportedOperationException();\n+                }\n+\n+                @Override\n+                public ScheduledFuture<?> scheduleAtFixedRate(\n+                        Runnable command, long initialDelay, long period, TimeUnit unit) {\n+                    throw new UnsupportedOperationException();\n+                }\n+\n+                @Override\n+                public ScheduledFuture<?> scheduleWithFixedDelay(\n+                        Runnable command, long initialDelay, long delay, TimeUnit unit) {\n+                    throw new UnsupportedOperationException();\n+                }\n             };\n             setThreadFactory(ThreadExecutorMap.apply(getThreadFactory(), eventExecutor));\n \ndiff --git a/microbench/src/main/java/io/netty/microbench/util/AbstractSharedExecutorMicrobenchmark.java b/microbench/src/main/java/io/netty/microbench/util/AbstractSharedExecutorMicrobenchmark.java\nindex c90d88bfb29..f2b753d52da 100644\n--- a/microbench/src/main/java/io/netty/microbench/util/AbstractSharedExecutorMicrobenchmark.java\n+++ b/microbench/src/main/java/io/netty/microbench/util/AbstractSharedExecutorMicrobenchmark.java\n@@ -19,9 +19,11 @@\n import io.netty.util.concurrent.AbstractEventExecutor;\n import io.netty.util.concurrent.Future;\n import io.netty.util.concurrent.Promise;\n+import io.netty.util.concurrent.ScheduledFuture;\n import io.netty.util.internal.logging.InternalLogger;\n import io.netty.util.internal.logging.InternalLoggerFactory;\n \n+import java.util.concurrent.Callable;\n import java.util.concurrent.TimeUnit;\n \n import org.openjdk.jmh.annotations.Fork;\n@@ -99,13 +101,6 @@ public Future<?> terminationFuture() {\n             return executor.terminationFuture();\n         }\n \n-        @Override\n-        @Deprecated\n-        public void shutdown() {\n-            executor.shutdown();\n-        }\n-\n-        @Override\n         public boolean isShuttingDown() {\n             return executor.isShuttingDown();\n         }\n@@ -139,6 +134,27 @@ public void execute(Runnable command) {\n         public <V> Promise<V> newPromise() {\n             return executor.newPromise();\n         }\n+\n+        @Override\n+        public ScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit) {\n+            return executor.schedule(command, delay, unit);\n+        }\n+\n+        @Override\n+        public <V> ScheduledFuture<V> schedule(Callable<V> callable, long delay, TimeUnit unit) {\n+            return executor.schedule(callable, delay, unit);\n+        }\n+\n+        @Override\n+        public ScheduledFuture<?> scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit) {\n+            return executor.scheduleAtFixedRate(command, initialDelay, period, unit);\n+        }\n+\n+        @Override\n+        public ScheduledFuture<?> scheduleWithFixedDelay(\n+                Runnable command, long initialDelay, long delay, TimeUnit unit) {\n+            return executor.scheduleWithFixedDelay(command, initialDelay, delay, unit);\n+        }\n     }\n \n     @Override\ndiff --git a/transport/src/main/java/io/netty/channel/ManualIoEventLoop.java b/transport/src/main/java/io/netty/channel/ManualIoEventLoop.java\nindex 0c49547c1bd..5109673432e 100644\n--- a/transport/src/main/java/io/netty/channel/ManualIoEventLoop.java\n+++ b/transport/src/main/java/io/netty/channel/ManualIoEventLoop.java\n@@ -26,15 +26,10 @@\n import io.netty.util.internal.PlatformDependent;\n import io.netty.util.internal.ThreadExecutorMap;\n \n-import java.util.Collection;\n-import java.util.List;\n import java.util.Objects;\n import java.util.Queue;\n-import java.util.concurrent.Callable;\n-import java.util.concurrent.ExecutionException;\n import java.util.concurrent.RejectedExecutionException;\n import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.TimeoutException;\n import java.util.concurrent.atomic.AtomicInteger;\n import java.util.concurrent.atomic.AtomicReference;\n \n@@ -469,12 +464,6 @@ public final Future<?> shutdownGracefully(long quietPeriod, long timeout, TimeUn\n         return terminationFuture();\n     }\n \n-    @Override\n-    @Deprecated\n-    public final void shutdown() {\n-        shutdown0(-1, -1, ST_SHUTDOWN);\n-    }\n-\n     @Override\n     public final Future<?> terminationFuture() {\n         return terminationFuture;\n@@ -585,45 +574,6 @@ private boolean confirmShutdown() {\n         return true;\n     }\n \n-    @Override\n-    public final <T> T invokeAny(Collection<? extends Callable<T>> tasks)\n-            throws InterruptedException, ExecutionException {\n-        // We need to check if the method was called from within the EventLoop as this would cause a deadlock.\n-        throwIfInEventLoop(\"invokeAny\");\n-        return super.invokeAny(tasks);\n-    }\n-\n-    @Override\n-    public final <T> T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n-            throws InterruptedException, ExecutionException, TimeoutException {\n-        // We need to check if the method was called from within the EventLoop as this would cause a deadlock.\n-        throwIfInEventLoop(\"invokeAny\");\n-        return super.invokeAny(tasks, timeout, unit);\n-    }\n-\n-    @Override\n-    public final <T> List<java.util.concurrent.Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)\n-            throws InterruptedException {\n-        // We need to check if the method was called from within the EventLoop as this would cause a deadlock.\n-        throwIfInEventLoop(\"invokeAll\");\n-        return super.invokeAll(tasks);\n-    }\n-\n-    @Override\n-    public final <T> List<java.util.concurrent.Future<T>> invokeAll(\n-            Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit) throws InterruptedException {\n-        // We need to check if the method was called from within the EventLoop as this would cause a deadlock.\n-        throwIfInEventLoop(\"invokeAll\");\n-        return super.invokeAll(tasks, timeout, unit);\n-    }\n-\n-    private void throwIfInEventLoop(String method) {\n-        if (inEventLoop()) {\n-            throw new RejectedExecutionException(\n-                    \"Calling \" + method + \" from within the EventLoop is not allowed as it would deadlock\");\n-        }\n-    }\n-\n     private class BlockingIoHandlerContext implements IoHandlerContext {\n         // this is a positive amount of nanos or Long.MAX_VALUE for no limit\n         long maxBlockingNanos = Long.MAX_VALUE;\ndiff --git a/transport/src/main/java/io/netty/channel/embedded/EmbeddedEventLoop.java b/transport/src/main/java/io/netty/channel/embedded/EmbeddedEventLoop.java\nindex d3bc417fb96..c56120097ae 100644\n--- a/transport/src/main/java/io/netty/channel/embedded/EmbeddedEventLoop.java\n+++ b/transport/src/main/java/io/netty/channel/embedded/EmbeddedEventLoop.java\n@@ -110,12 +110,6 @@ public Future<?> terminationFuture() {\n         throw new UnsupportedOperationException();\n     }\n \n-    @Override\n-    @Deprecated\n-    public void shutdown() {\n-        throw new UnsupportedOperationException();\n-    }\n-\n     @Override\n     public boolean isShuttingDown() {\n         return false;\n",
  "test_patch" : "diff --git a/common/src/test/java/io/netty/util/concurrent/AbstractScheduledEventExecutorTest.java b/common/src/test/java/io/netty/util/concurrent/AbstractScheduledEventExecutorTest.java\nindex fbc708c55d6..926cca2c2d5 100644\n--- a/common/src/test/java/io/netty/util/concurrent/AbstractScheduledEventExecutorTest.java\n+++ b/common/src/test/java/io/netty/util/concurrent/AbstractScheduledEventExecutorTest.java\n@@ -135,11 +135,6 @@ public boolean inEventLoop(Thread thread) {\n             return true;\n         }\n \n-        @Override\n-        public void shutdown() {\n-            // NOOP\n-        }\n-\n         @Override\n         public Future<?> shutdownGracefully(long quietPeriod, long timeout, TimeUnit unit) {\n             throw new UnsupportedOperationException();\ndiff --git a/common/src/test/java/io/netty/util/concurrent/DefaultPromiseTest.java b/common/src/test/java/io/netty/util/concurrent/DefaultPromiseTest.java\nindex 187e7275102..87ac314c06b 100644\n--- a/common/src/test/java/io/netty/util/concurrent/DefaultPromiseTest.java\n+++ b/common/src/test/java/io/netty/util/concurrent/DefaultPromiseTest.java\n@@ -86,10 +86,6 @@ public Future<?> terminationFuture() {\n             return null;\n         }\n \n-        @Override\n-        public void shutdown() {\n-        }\n-\n         @Override\n         public boolean isShutdown() {\n             return false;\ndiff --git a/common/src/test/java/io/netty/util/concurrent/NonStickyEventExecutorGroupTest.java b/common/src/test/java/io/netty/util/concurrent/NonStickyEventExecutorGroupTest.java\nindex 7e3e4784920..aafb1f51db1 100644\n--- a/common/src/test/java/io/netty/util/concurrent/NonStickyEventExecutorGroupTest.java\n+++ b/common/src/test/java/io/netty/util/concurrent/NonStickyEventExecutorGroupTest.java\n@@ -27,6 +27,7 @@\n import java.util.Collections;\n import java.util.Iterator;\n import java.util.List;\n+import java.util.concurrent.Callable;\n import java.util.concurrent.CountDownLatch;\n import java.util.concurrent.RejectedExecutionException;\n import java.util.concurrent.TimeUnit;\n@@ -139,10 +140,6 @@ public void testInEventLoopAfterReschedulingFailure() throws Exception {\n         final AtomicInteger executeCount = new AtomicInteger();\n \n         final EventExecutorGroup wrapper = new AbstractEventExecutorGroup() {\n-            @Override\n-            public void shutdown() {\n-                shutdownGracefully();\n-            }\n \n             private final EventExecutor executor = new AbstractEventExecutor(this) {\n                 @Override\n@@ -150,11 +147,6 @@ public boolean inEventLoop(Thread thread) {\n                     return underlying.inEventLoop(thread);\n                 }\n \n-                @Override\n-                public void shutdown() {\n-                    shutdownGracefully();\n-                }\n-\n                 @Override\n                 public void execute(Runnable command) {\n                     // Reject the 2nd execute() call (the reschedule attempt)\n@@ -195,6 +187,28 @@ public boolean isTerminated() {\n                 public boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException {\n                     return underlying.awaitTermination(timeout, unit);\n                 }\n+\n+                @Override\n+                public ScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit) {\n+                    return underlying.schedule(command, delay, unit);\n+                }\n+\n+                @Override\n+                public <V> ScheduledFuture<V> schedule(Callable<V> callable, long delay, TimeUnit unit) {\n+                    return underlying.schedule(callable, delay, unit);\n+                }\n+\n+                @Override\n+                public ScheduledFuture<?> scheduleAtFixedRate(\n+                        Runnable command, long initialDelay, long period, TimeUnit unit) {\n+                    return underlying.scheduleAtFixedRate(command, initialDelay, period, unit);\n+                }\n+\n+                @Override\n+                public ScheduledFuture<?> scheduleWithFixedDelay(\n+                        Runnable command, long initialDelay, long delay, TimeUnit unit) {\n+                    return underlying.scheduleWithFixedDelay(command, initialDelay, delay, unit);\n+                }\n             };\n \n             @Override\ndiff --git a/common/src/test/java/io/netty/util/concurrent/SingleThreadEventExecutorTest.java b/common/src/test/java/io/netty/util/concurrent/SingleThreadEventExecutorTest.java\nindex a9889179fad..06b06731231 100644\n--- a/common/src/test/java/io/netty/util/concurrent/SingleThreadEventExecutorTest.java\n+++ b/common/src/test/java/io/netty/util/concurrent/SingleThreadEventExecutorTest.java\n@@ -20,9 +20,6 @@\n import org.junit.jupiter.api.Timeout;\n import org.junit.jupiter.api.function.Executable;\n \n-import java.util.Collections;\n-import java.util.Set;\n-import java.util.concurrent.Callable;\n import java.util.concurrent.CountDownLatch;\n import java.util.concurrent.Executor;\n import java.util.concurrent.ExecutorService;\n@@ -318,87 +315,6 @@ protected void run() {\n         executor.shutdownGracefully(0, 0, TimeUnit.MILLISECONDS).syncUninterruptibly();\n     }\n \n-    @Test\n-    @Timeout(value = 3000, unit = TimeUnit.MILLISECONDS)\n-    public void testInvokeAnyInEventLoop() {\n-        testInvokeInEventLoop(true, false);\n-    }\n-\n-    @Test\n-    @Timeout(value = 3000, unit = TimeUnit.MILLISECONDS)\n-    public void testInvokeAnyInEventLoopWithTimeout() {\n-        testInvokeInEventLoop(true, true);\n-    }\n-\n-    @Test\n-    @Timeout(value = 3000, unit = TimeUnit.MILLISECONDS)\n-    public void testInvokeAllInEventLoop() {\n-        testInvokeInEventLoop(false, false);\n-    }\n-\n-    @Test\n-    @Timeout(value = 3000, unit = TimeUnit.MILLISECONDS)\n-    public void testInvokeAllInEventLoopWithTimeout() {\n-        testInvokeInEventLoop(false, true);\n-    }\n-\n-    private static void testInvokeInEventLoop(final boolean any, final boolean timeout) {\n-        final SingleThreadEventExecutor executor = new SingleThreadEventExecutor(null,\n-                Executors.defaultThreadFactory(), true) {\n-            @Override\n-            protected void run() {\n-                while (!confirmShutdown()) {\n-                    Runnable task = takeTask();\n-                    if (task != null) {\n-                        task.run();\n-                    }\n-                }\n-            }\n-        };\n-        try {\n-            assertThrows(RejectedExecutionException.class, new Executable() {\n-                @Override\n-                public void execute() throws Throwable {\n-                    final Promise<Void> promise = executor.newPromise();\n-                    executor.execute(new Runnable() {\n-                        @Override\n-                        public void run() {\n-                            try {\n-                                Set<Callable<Boolean>> set = Collections.<Callable<Boolean>>singleton(\n-                                        new Callable<Boolean>() {\n-                                    @Override\n-                                    public Boolean call() throws Exception {\n-                                        promise.setFailure(new AssertionError(\"Should never execute the Callable\"));\n-                                        return Boolean.TRUE;\n-                                    }\n-                                });\n-                                if (any) {\n-                                    if (timeout) {\n-                                        executor.invokeAny(set, 10, TimeUnit.SECONDS);\n-                                    } else {\n-                                        executor.invokeAny(set);\n-                                    }\n-                                } else {\n-                                    if (timeout) {\n-                                        executor.invokeAll(set, 10, TimeUnit.SECONDS);\n-                                    } else {\n-                                        executor.invokeAll(set);\n-                                    }\n-                                }\n-                                promise.setFailure(new AssertionError(\"Should never reach here\"));\n-                            } catch (Throwable cause) {\n-                                promise.setFailure(cause);\n-                            }\n-                        }\n-                    });\n-                    promise.syncUninterruptibly();\n-                }\n-            });\n-        } finally {\n-            executor.shutdownGracefully(0, 0, TimeUnit.MILLISECONDS).syncUninterruptibly();\n-        }\n-    }\n-\n     static class LatchTask extends CountDownLatch implements Runnable {\n         LatchTask() {\n             super(1);\ndiff --git a/common/src/test/java/io/netty/util/internal/ThreadExecutorMapTest.java b/common/src/test/java/io/netty/util/internal/ThreadExecutorMapTest.java\nindex 789a259b869..bf6c2f6892f 100644\n--- a/common/src/test/java/io/netty/util/internal/ThreadExecutorMapTest.java\n+++ b/common/src/test/java/io/netty/util/internal/ThreadExecutorMapTest.java\n@@ -20,9 +20,11 @@\n import io.netty.util.concurrent.Future;\n import io.netty.util.concurrent.ImmediateEventExecutor;\n import io.netty.util.concurrent.ImmediateExecutor;\n+import io.netty.util.concurrent.ScheduledFuture;\n import org.jetbrains.annotations.NotNull;\n import org.junit.jupiter.api.Test;\n \n+import java.util.concurrent.Callable;\n import java.util.concurrent.Executor;\n import java.util.concurrent.Executors;\n import java.util.concurrent.ThreadFactory;\n@@ -32,10 +34,6 @@\n \n public class ThreadExecutorMapTest {\n     private static final EventExecutor EVENT_EXECUTOR = new AbstractEventExecutor() {\n-        @Override\n-        public void shutdown() {\n-            throw new UnsupportedOperationException();\n-        }\n \n         @Override\n         public boolean inEventLoop(Thread thread) {\n@@ -76,6 +74,27 @@ public boolean awaitTermination(long timeout, @NotNull TimeUnit unit) {\n         public void execute(@NotNull Runnable command) {\n             throw new UnsupportedOperationException();\n         }\n+\n+        @Override\n+        public ScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public <V> ScheduledFuture<V> schedule(Callable<V> callable, long delay, TimeUnit unit) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public ScheduledFuture<?> scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public ScheduledFuture<?> scheduleWithFixedDelay(\n+                Runnable command, long initialDelay, long delay, TimeUnit unit) {\n+            throw new UnsupportedOperationException();\n+        }\n     };\n \n     @Test\ndiff --git a/handler/src/test/java/io/netty/handler/traffic/FileRegionThrottleTest.java b/handler/src/test/java/io/netty/handler/traffic/FileRegionThrottleTest.java\nindex 6d17b3bd3b1..2301194cbd0 100644\n--- a/handler/src/test/java/io/netty/handler/traffic/FileRegionThrottleTest.java\n+++ b/handler/src/test/java/io/netty/handler/traffic/FileRegionThrottleTest.java\n@@ -88,7 +88,7 @@ public void tearDown() {\n     @Test\n     public void testGlobalWriteThrottle() throws Exception {\n         final CountDownLatch latch = new CountDownLatch(1);\n-        final GlobalTrafficShapingHandler gtsh = new GlobalTrafficShapingHandler(group, WRITE_LIMIT, 0);\n+        final GlobalTrafficShapingHandler gtsh = new GlobalTrafficShapingHandler(group.next(), WRITE_LIMIT, 0);\n         ServerBootstrap bs = new ServerBootstrap();\n         bs.group(group).channel(NioServerSocketChannel.class).childHandler(new ChannelInitializer<SocketChannel>() {\n             @Override\ndiff --git a/handler/src/test/java/io/netty/handler/traffic/TrafficShapingHandlerTest.java b/handler/src/test/java/io/netty/handler/traffic/TrafficShapingHandlerTest.java\nindex 75fea11149e..8f4cae61c04 100644\n--- a/handler/src/test/java/io/netty/handler/traffic/TrafficShapingHandlerTest.java\n+++ b/handler/src/test/java/io/netty/handler/traffic/TrafficShapingHandlerTest.java\n@@ -16,9 +16,6 @@\n \n package io.netty.handler.traffic;\n \n-import java.util.concurrent.Executors;\n-import java.util.concurrent.ScheduledExecutorService;\n-\n import io.netty.bootstrap.Bootstrap;\n import io.netty.bootstrap.ServerBootstrap;\n import io.netty.buffer.Unpooled;\n@@ -34,6 +31,8 @@\n import io.netty.channel.local.LocalServerChannel;\n import io.netty.util.Attribute;\n import io.netty.util.CharsetUtil;\n+import io.netty.util.concurrent.DefaultEventExecutorGroup;\n+import io.netty.util.concurrent.EventExecutorGroup;\n import org.junit.jupiter.api.AfterAll;\n import org.junit.jupiter.api.Disabled;\n import org.junit.jupiter.api.Test;\n@@ -45,27 +44,27 @@\n public class TrafficShapingHandlerTest {\n \n     private static final long READ_LIMIT_BYTES_PER_SECOND = 1;\n-    private static final ScheduledExecutorService SES = Executors.newSingleThreadScheduledExecutor();\n+    private static final EventExecutorGroup SES = new DefaultEventExecutorGroup(1);\n     private static final EventLoopGroup GROUP = new MultiThreadIoEventLoopGroup(1, LocalIoHandler.newFactory());\n \n     @AfterAll\n     public static void destroy() {\n         GROUP.shutdownGracefully();\n-        SES.shutdown();\n+        SES.shutdownGracefully();\n     }\n \n     @Test\n     public void testHandlerRemove() throws Exception {\n         testHandlerRemove0(new ChannelTrafficShapingHandler(0, READ_LIMIT_BYTES_PER_SECOND));\n         GlobalTrafficShapingHandler trafficHandler1 =\n-                new GlobalTrafficShapingHandler(SES, 0, READ_LIMIT_BYTES_PER_SECOND);\n+                new GlobalTrafficShapingHandler(SES.next(), 0, READ_LIMIT_BYTES_PER_SECOND);\n         try {\n             testHandlerRemove0(trafficHandler1);\n         } finally {\n             trafficHandler1.release();\n         }\n         GlobalChannelTrafficShapingHandler trafficHandler2 =\n-                new GlobalChannelTrafficShapingHandler(SES, 0,\n+                new GlobalChannelTrafficShapingHandler(SES.next(), 0,\n                         READ_LIMIT_BYTES_PER_SECOND, 0, READ_LIMIT_BYTES_PER_SECOND);\n         try {\n             testHandlerRemove0(trafficHandler2);\ndiff --git a/testsuite/src/main/java/io/netty/testsuite/transport/AbstractSingleThreadEventLoopTest.java b/testsuite/src/main/java/io/netty/testsuite/transport/AbstractSingleThreadEventLoopTest.java\nindex 7e9b25cc18f..5a591d0b5d5 100644\n--- a/testsuite/src/main/java/io/netty/testsuite/transport/AbstractSingleThreadEventLoopTest.java\n+++ b/testsuite/src/main/java/io/netty/testsuite/transport/AbstractSingleThreadEventLoopTest.java\n@@ -124,7 +124,7 @@ public Integer call() {\n     public void shutdownBeforeStart() throws Exception {\n         EventLoopGroup group = newEventLoopGroup();\n         assertFalse(group.awaitTermination(2, TimeUnit.MILLISECONDS));\n-        group.shutdown();\n+        group.shutdownGracefully(0, 0, TimeUnit.MILLISECONDS);\n         assertTrue(group.awaitTermination(200, TimeUnit.MILLISECONDS));\n     }\n \ndiff --git a/testsuite/src/main/java/io/netty/testsuite/transport/socket/TrafficShapingHandlerTest.java b/testsuite/src/main/java/io/netty/testsuite/transport/socket/TrafficShapingHandlerTest.java\nindex b76c0812c1b..72c3b496194 100644\n--- a/testsuite/src/main/java/io/netty/testsuite/transport/socket/TrafficShapingHandlerTest.java\n+++ b/testsuite/src/main/java/io/netty/testsuite/transport/socket/TrafficShapingHandlerTest.java\n@@ -348,13 +348,15 @@ private static void testTrafficShapping0(\n         final AbstractTrafficShapingHandler handler;\n         if (limitRead) {\n             if (globalLimit) {\n-                handler = new GlobalTrafficShapingHandler(groupForGlobal, 0, bandwidthFactor * messageSize, check);\n+                handler = new GlobalTrafficShapingHandler(\n+                        groupForGlobal.next(), 0, bandwidthFactor * messageSize, check);\n             } else {\n                 handler = new ChannelTrafficShapingHandler(0, bandwidthFactor * messageSize, check);\n             }\n         } else if (limitWrite) {\n             if (globalLimit) {\n-                handler = new GlobalTrafficShapingHandler(groupForGlobal, bandwidthFactor * messageSize, 0, check);\n+                handler = new GlobalTrafficShapingHandler(\n+                        groupForGlobal.next(), bandwidthFactor * messageSize, 0, check);\n             } else {\n                 handler = new ChannelTrafficShapingHandler(bandwidthFactor * messageSize, 0, check);\n             }\ndiff --git a/transport/src/test/java/io/netty/channel/DefaultChannelPipelineTest.java b/transport/src/test/java/io/netty/channel/DefaultChannelPipelineTest.java\nindex 4b133b123bc..a4063b18606 100644\n--- a/transport/src/test/java/io/netty/channel/DefaultChannelPipelineTest.java\n+++ b/transport/src/test/java/io/netty/channel/DefaultChannelPipelineTest.java\n@@ -38,6 +38,7 @@\n import io.netty.util.concurrent.FutureListener;\n import io.netty.util.concurrent.ImmediateEventExecutor;\n import io.netty.util.concurrent.Promise;\n+import io.netty.util.concurrent.ScheduledFuture;\n import org.junit.jupiter.api.AfterAll;\n import org.junit.jupiter.api.AfterEach;\n import org.junit.jupiter.api.BeforeAll;\n@@ -56,6 +57,7 @@\n import java.util.Queue;\n import java.util.concurrent.ArrayBlockingQueue;\n import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.Callable;\n import java.util.concurrent.CountDownLatch;\n import java.util.concurrent.ExecutorService;\n import java.util.concurrent.Executors;\n@@ -2124,16 +2126,6 @@ public Future<?> terminationFuture() {\n             throw new IllegalStateException();\n         }\n \n-        @Override\n-        public void shutdown() {\n-            wrapped.shutdown();\n-        }\n-\n-        @Override\n-        public List<Runnable> shutdownNow() {\n-            return wrapped.shutdownNow();\n-        }\n-\n         @Override\n         public boolean isShutdown() {\n             return wrapped.isShutdown();\n@@ -2163,5 +2155,26 @@ public boolean inEventLoop(Thread thread) {\n         public void execute(Runnable command) {\n             wrapped.execute(command);\n         }\n+\n+        @Override\n+        public ScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public <V> ScheduledFuture<V> schedule(Callable<V> callable, long delay, TimeUnit unit) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public ScheduledFuture<?> scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public ScheduledFuture<?> scheduleWithFixedDelay(\n+                Runnable command, long initialDelay, long delay, TimeUnit unit) {\n+            throw new UnsupportedOperationException();\n+        }\n     }\n }\ndiff --git a/transport/src/test/java/io/netty/channel/ManualIoEventLoopTest.java b/transport/src/test/java/io/netty/channel/ManualIoEventLoopTest.java\nindex c2fb47cfc40..c804ccac393 100644\n--- a/transport/src/test/java/io/netty/channel/ManualIoEventLoopTest.java\n+++ b/transport/src/test/java/io/netty/channel/ManualIoEventLoopTest.java\n@@ -19,23 +19,16 @@\n import io.netty.channel.nio.NioIoHandler;\n import io.netty.util.concurrent.EventExecutor;\n import io.netty.util.concurrent.MockTicker;\n-import io.netty.util.concurrent.Promise;\n import io.netty.util.concurrent.Ticker;\n import io.netty.util.internal.ThreadExecutorMap;\n import org.junit.jupiter.api.Test;\n-import org.junit.jupiter.api.Timeout;\n-import org.junit.jupiter.api.function.Executable;\n import org.junit.jupiter.params.ParameterizedTest;\n import org.junit.jupiter.params.provider.EnumSource;\n \n-import java.util.Collections;\n-import java.util.Set;\n import java.util.concurrent.BlockingQueue;\n-import java.util.concurrent.Callable;\n import java.util.concurrent.CompletableFuture;\n import java.util.concurrent.ExecutionException;\n import java.util.concurrent.LinkedBlockingQueue;\n-import java.util.concurrent.RejectedExecutionException;\n import java.util.concurrent.Semaphore;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicBoolean;\n@@ -60,7 +53,7 @@ public void testRunNow() throws Exception {\n \n         assertEquals(1, eventLoop.runNow());\n         assertTrue(runnable.isDone());\n-        eventLoop.shutdown();\n+        eventLoop.shutdownGracefully(0, 0, TimeUnit.MILLISECONDS);\n         while (!eventLoop.isTerminated()) {\n             eventLoop.runNow();\n         }\n@@ -91,7 +84,7 @@ public void testRun() throws Exception {\n         assertThat(waitTime).isGreaterThan(System.nanoTime() - current);\n \n         assertTrue(runnable.isDone());\n-        eventLoop.shutdown();\n+        eventLoop.shutdownGracefully(0, 0, TimeUnit.MILLISECONDS);\n \n         while (!eventLoop.isTerminated()) {\n             eventLoop.runNow();\n@@ -105,7 +98,7 @@ public void testShutdownOutSideOfOwningThread() throws Exception {\n         Thread ownerThread = new Thread();\n         ManualIoEventLoop eventLoop = new ManualIoEventLoop(ownerThread, executor ->\n                 new TestIoHandler(semaphore));\n-        eventLoop.shutdown();\n+        eventLoop.shutdownGracefully(0, 0, TimeUnit.MILLISECONDS);\n         assertTrue(eventLoop.isShuttingDown());\n         // we expect wakeup to be called!\n         assertEquals(1, semaphore.availablePermits());\n@@ -132,7 +125,7 @@ public void testThreadEventExecutorMap() throws Exception {\n         eventLoop.execute(() -> queue.offer(ThreadExecutorMap.currentExecutor()));\n         assertEquals(1, eventLoop.runNow());\n         assertSame(eventLoop, queue.take());\n-        eventLoop.shutdown();\n+        eventLoop.shutdownGracefully(0, 0, TimeUnit.MILLISECONDS);\n \n         while (!eventLoop.isTerminated()) {\n             eventLoop.runNow();\n@@ -140,86 +133,6 @@ public void testThreadEventExecutorMap() throws Exception {\n         eventLoop.terminationFuture().sync();\n     }\n \n-    @Test\n-    @Timeout(value = 3000, unit = TimeUnit.MILLISECONDS)\n-    public void testInvokeAnyInEventLoop() {\n-        testInvokeInEventLoop(true, false);\n-    }\n-\n-    @Test\n-    @Timeout(value = 3000, unit = TimeUnit.MILLISECONDS)\n-    public void testInvokeAnyInEventLoopWithTimeout() {\n-        testInvokeInEventLoop(true, true);\n-    }\n-\n-    @Test\n-    @Timeout(value = 3000, unit = TimeUnit.MILLISECONDS)\n-    public void testInvokeAllInEventLoop() {\n-        testInvokeInEventLoop(false, false);\n-    }\n-\n-    @Test\n-    @Timeout(value = 3000, unit = TimeUnit.MILLISECONDS)\n-    public void testInvokeAllInEventLoopWithTimeout() {\n-        testInvokeInEventLoop(false, true);\n-    }\n-\n-    private static void testInvokeInEventLoop(final boolean any, final boolean timeout) {\n-        Semaphore semaphore = new Semaphore(0);\n-        ManualIoEventLoop eventLoop = new ManualIoEventLoop(Thread.currentThread(), executor ->\n-                new TestIoHandler(semaphore));\n-        try {\n-            assertThrows(RejectedExecutionException.class, new Executable() {\n-                @Override\n-                public void execute() throws Throwable {\n-                    final Promise<Void> promise = eventLoop.newPromise();\n-                    eventLoop.execute(new Runnable() {\n-                        @Override\n-                        public void run() {\n-                            try {\n-                                Set<Callable<Boolean>> set = Collections.<Callable<Boolean>>singleton(\n-                                        new Callable<Boolean>() {\n-                                            @Override\n-                                            public Boolean call() {\n-                                                promise.setFailure(\n-                                                        new AssertionError(\"Should never execute the Callable\"));\n-                                                return Boolean.TRUE;\n-                                            }\n-                                        });\n-                                if (any) {\n-                                    if (timeout) {\n-                                        eventLoop.invokeAny(set, 10, TimeUnit.SECONDS);\n-                                    } else {\n-                                        eventLoop.invokeAny(set);\n-                                    }\n-                                } else {\n-                                    if (timeout) {\n-                                        eventLoop.invokeAll(set, 10, TimeUnit.SECONDS);\n-                                    } else {\n-                                        eventLoop.invokeAll(set);\n-                                    }\n-                                }\n-                                promise.setFailure(new AssertionError(\"Should never reach here\"));\n-                            } catch (Throwable cause) {\n-                                promise.setFailure(cause);\n-                            }\n-                        }\n-                    });\n-                    while (!promise.isDone()) {\n-                        eventLoop.runNow();\n-                    }\n-                    promise.syncUninterruptibly();\n-                }\n-            });\n-        } finally {\n-            eventLoop.shutdownGracefully(0, 0, TimeUnit.MILLISECONDS);\n-            while (!eventLoop.isTerminated()) {\n-                eventLoop.runNow();\n-            }\n-            assertTrue(eventLoop.terminationFuture().isSuccess());\n-        }\n-    }\n-\n     @Test\n     public void testDelayOwningThread() throws ExecutionException, InterruptedException {\n         Semaphore semaphore = new Semaphore(0);\ndiff --git a/transport/src/test/java/io/netty/channel/SingleThreadEventLoopTest.java b/transport/src/test/java/io/netty/channel/SingleThreadEventLoopTest.java\nindex 84e81a39671..175960575eb 100644\n--- a/transport/src/test/java/io/netty/channel/SingleThreadEventLoopTest.java\n+++ b/transport/src/test/java/io/netty/channel/SingleThreadEventLoopTest.java\n@@ -109,7 +109,7 @@ public void stopEventLoop() {\n     @Test\n     @SuppressWarnings(\"deprecation\")\n     public void shutdownBeforeStart() throws Exception {\n-        loopA.shutdown();\n+        loopA.shutdownGracefully(0, 0, TimeUnit.MILLISECONDS).sync();\n         assertRejection(loopA);\n     }\n \n@@ -128,7 +128,7 @@ public void run() {\n         latch.await();\n \n         // Request the event loop thread to stop.\n-        loopA.shutdown();\n+        loopA.shutdownGracefully(0, 0, TimeUnit.MILLISECONDS).sync();\n         assertRejection(loopA);\n \n         assertTrue(loopA.isShutdown());\n@@ -359,7 +359,7 @@ public void run() {\n         assertEquals(1, ranTasks.get());\n \n         // Shut down the event loop to test if the other tasks are run before termination.\n-        loopA.shutdown();\n+        loopA.shutdownGracefully(0, 0, TimeUnit.MILLISECONDS);\n \n         // Let the other tasks run.\n         latch.countDown();\n@@ -378,7 +378,7 @@ public void run() {\n     @Timeout(value = 10000, unit = TimeUnit.MILLISECONDS)\n     @SuppressWarnings(\"deprecation\")\n     public void testRegistrationAfterShutdown() throws Exception {\n-        loopA.shutdown();\n+        loopA.shutdownGracefully(0, 0, TimeUnit.MILLISECONDS);\n \n         // Disable logging temporarily.\n         Logger root = (Logger) LoggerFactory.getLogger(org.slf4j.Logger.ROOT_LOGGER_NAME);\n@@ -408,7 +408,7 @@ public void testRegistrationAfterShutdown() throws Exception {\n     @Timeout(value = 10000, unit = TimeUnit.MILLISECONDS)\n     @SuppressWarnings(\"deprecation\")\n     public void testRegistrationAfterShutdown2() throws Exception {\n-        loopA.shutdown();\n+        loopA.shutdownGracefully(0, 0, TimeUnit.MILLISECONDS);\n         final CountDownLatch latch = new CountDownLatch(1);\n         Channel ch = new LocalChannel(loopA);\n         Promise<Void> promise = ch.newPromise();\ndiff --git a/transport/src/test/java/io/netty/channel/nio/NioEventLoopTest.java b/transport/src/test/java/io/netty/channel/nio/NioEventLoopTest.java\nindex 0074643aed7..98ce7f1d727 100644\n--- a/transport/src/test/java/io/netty/channel/nio/NioEventLoopTest.java\n+++ b/transport/src/test/java/io/netty/channel/nio/NioEventLoopTest.java\n@@ -172,7 +172,7 @@ public void run() {\n                 }\n             });\n             t.start();\n-            group.shutdownNow();\n+            group.shutdownGracefully(0, 0, TimeUnit.MILLISECONDS);\n             t.join();\n             group.terminationFuture().syncUninterruptibly();\n             assertInstanceOf(RejectedExecutionException.class, error.get());\n",
  "problem_statement" : "EventLoopGroup should not extend ScheduledExecutorService\n\nMotivation:\n\nOur EventLoopGroup should better not extend ScheduledExecutorService to not limit our selves\n\nModifications:\n\n- EventLoopGroup does not extend ScheduledExecutorServie anymore\n- Fix up tests\n\nResult:\n\nHierarchy cleanup\n",
  "hints_text" : null,
  "created_at" : "Tue Jan 20 12:21:57 CET 2026",
  "version" : null,
  "FAIL_TO_PASS" : [ "NonStickyEventExecutorGroupTest", "SingleThreadEventExecutorTest", "AbstractSingleThreadEventLoopTest", "ManualIoEventLoopTest", "DefaultPromiseTest", "SingleThreadEventLoopTest", "AbstractScheduledEventExecutorTest", "ThreadExecutorMapTest", "TrafficShapingHandlerTest", "DefaultChannelPipelineTest", "NioEventLoopTest", "FileRegionThrottleTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -pl common -Dtest=NonStickyEventExecutorGroupTest,SingleThreadEventExecutorTest,AbstractSingleThreadEventLoopTest,ManualIoEventLoopTest,DefaultPromiseTest,SingleThreadEventLoopTest,AbstractScheduledEventExecutorTest,ThreadExecutorMapTest,TrafficShapingHandlerTest,DefaultChannelPipelineTest,NioEventLoopTest,FileRegionThrottleTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 16157,
  "metadata" : null
}, {
  "instance_id" : "netty-netty-PR-16155",
  "repo" : "netty/netty",
  "base_commit" : "6008169575ddc86ad2be37a6a8da3c9e54b19ce5",
  "patch" : "diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionHandler.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionHandler.java\nindex 96dc4e5abb1..b9609a39894 100644\n--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionHandler.java\n+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionHandler.java\n@@ -248,6 +248,10 @@ public void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) thro\n                     byteDecoder.decode(ctx, in, out);\n                 }\n             } catch (Throwable e) {\n+                if (byteDecoder != null) {\n+                    // Skip all bytes before we report the exception as\n+                    in.skipBytes(in.readableBytes());\n+                }\n                 onError(ctx, false, e);\n             }\n         }\n@@ -346,12 +350,17 @@ private boolean verifyFirstFrameIsSettings(ByteBuf in) throws Http2Exception {\n             }\n \n             short frameType = in.getUnsignedByte(in.readerIndex() + 3);\n-            short flags = in.getUnsignedByte(in.readerIndex() + 4);\n-            if (frameType != SETTINGS || (flags & Http2Flags.ACK) != 0) {\n+            if (frameType != SETTINGS) {\n                 throw connectionError(PROTOCOL_ERROR, \"First received frame was not SETTINGS. \" +\n                                                       \"Hex dump for first 5 bytes: %s\",\n                                       hexDump(in, in.readerIndex(), 5));\n             }\n+            short flags = in.getUnsignedByte(in.readerIndex() + 4);\n+            if ((flags & Http2Flags.ACK) != 0) {\n+                throw connectionError(PROTOCOL_ERROR, \"First received frame was SETTINGS frame but had ACK flag set. \" +\n+                        \"Hex dump for first 5 bytes: %s\",\n+                        hexDump(in, in.readerIndex(), 5));\n+            }\n             return true;\n         }\n \n",
  "test_patch" : "diff --git a/codec-http2/src/test/java/io/netty/handler/codec/http2/Http2ConnectionHandlerTest.java b/codec-http2/src/test/java/io/netty/handler/codec/http2/Http2ConnectionHandlerTest.java\nindex 4d752362764..9c480c1d37e 100644\n--- a/codec-http2/src/test/java/io/netty/handler/codec/http2/Http2ConnectionHandlerTest.java\n+++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/Http2ConnectionHandlerTest.java\n@@ -46,10 +46,13 @@\n import java.util.concurrent.atomic.AtomicBoolean;\n \n import static io.netty.buffer.Unpooled.copiedBuffer;\n+import static io.netty.handler.codec.http2.Http2CodecUtil.FRAME_HEADER_LENGTH;\n import static io.netty.handler.codec.http2.Http2CodecUtil.connectionPrefaceBuf;\n+import static io.netty.handler.codec.http2.Http2CodecUtil.writeFrameHeaderInternal;\n import static io.netty.handler.codec.http2.Http2Error.CANCEL;\n import static io.netty.handler.codec.http2.Http2Error.PROTOCOL_ERROR;\n import static io.netty.handler.codec.http2.Http2Error.STREAM_CLOSED;\n+import static io.netty.handler.codec.http2.Http2FrameTypes.SETTINGS;\n import static io.netty.handler.codec.http2.Http2Stream.State.CLOSED;\n import static io.netty.handler.codec.http2.Http2Stream.State.IDLE;\n import static io.netty.util.CharsetUtil.US_ASCII;\n@@ -298,6 +301,20 @@ public void serverReceivingInvalidClientPrefaceStringShouldHandleException() thr\n         assertEquals(0, captor.getValue().refCnt());\n     }\n \n+    @Test\n+    public void serverReceivingInvalidClientSettingsAfterPrefaceShouldHandleException() throws Exception {\n+        ByteBuf buf = ctx.alloc().buffer(FRAME_HEADER_LENGTH);\n+        writeFrameHeaderInternal(buf, 0, SETTINGS, new Http2Flags().ack(true), 0);\n+\n+        when(connection.isServer()).thenReturn(true);\n+        handler = newHandler();\n+        handler.channelRead(ctx, Unpooled.wrappedBuffer(connectionPrefaceBuf(), buf));\n+        ArgumentCaptor<ByteBuf> captor = ArgumentCaptor.forClass(ByteBuf.class);\n+        verify(frameWriter).writeGoAway(eq(ctx), eq(Integer.MAX_VALUE), eq(PROTOCOL_ERROR.code()),\n+                captor.capture(), any(Promise.class));\n+        assertEquals(0, captor.getValue().refCnt());\n+    }\n+\n     @Test\n     public void serverReceivingHttp1ClientPrefaceStringShouldIncludePreface() throws Exception {\n         when(connection.isServer()).thenReturn(true);\n",
  "problem_statement" : "Improve exception message when first HTTP2SettingsFrame has the ack f (#16153)\n\nlag set\n\nMotivation:\n\nThe first HTTP2SettingsFrame must not have the ACK flag set. We already\ndid correctly enforce this but the exception that we used was\nmissleading\n\nModifications:\n\n- Clarify exception\n- Add unit test\n\nResult:\n\nRelated to https://github.com/netty/netty/issues/16142",
  "hints_text" : null,
  "created_at" : "Tue Jan 20 09:55:27 CET 2026",
  "version" : null,
  "FAIL_TO_PASS" : [ "Http2ConnectionHandlerTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -pl codec-http2 -Dtest=Http2ConnectionHandlerTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 16155,
  "metadata" : null
}, {
  "instance_id" : "netty-netty-PR-16154",
  "repo" : "netty/netty",
  "base_commit" : "496f55cdf6edfd621320a2d803a53298ac2df9dd",
  "patch" : "diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionHandler.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionHandler.java\nindex 61e9cd1213b..7636e925f15 100644\n--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionHandler.java\n+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionHandler.java\n@@ -248,6 +248,10 @@ public void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) thro\n                     byteDecoder.decode(ctx, in, out);\n                 }\n             } catch (Throwable e) {\n+                if (byteDecoder != null) {\n+                    // Skip all bytes before we report the exception as\n+                    in.skipBytes(in.readableBytes());\n+                }\n                 onError(ctx, false, e);\n             }\n         }\n@@ -346,12 +350,17 @@ private boolean verifyFirstFrameIsSettings(ByteBuf in) throws Http2Exception {\n             }\n \n             short frameType = in.getUnsignedByte(in.readerIndex() + 3);\n-            short flags = in.getUnsignedByte(in.readerIndex() + 4);\n-            if (frameType != SETTINGS || (flags & Http2Flags.ACK) != 0) {\n+            if (frameType != SETTINGS) {\n                 throw connectionError(PROTOCOL_ERROR, \"First received frame was not SETTINGS. \" +\n                                                       \"Hex dump for first 5 bytes: %s\",\n                                       hexDump(in, in.readerIndex(), 5));\n             }\n+            short flags = in.getUnsignedByte(in.readerIndex() + 4);\n+            if ((flags & Http2Flags.ACK) != 0) {\n+                throw connectionError(PROTOCOL_ERROR, \"First received frame was SETTINGS frame but had ACK flag set. \" +\n+                        \"Hex dump for first 5 bytes: %s\",\n+                        hexDump(in, in.readerIndex(), 5));\n+            }\n             return true;\n         }\n \n",
  "test_patch" : "diff --git a/codec-http2/src/test/java/io/netty/handler/codec/http2/Http2ConnectionHandlerTest.java b/codec-http2/src/test/java/io/netty/handler/codec/http2/Http2ConnectionHandlerTest.java\nindex 4c48e2780dc..de3d3e12f93 100644\n--- a/codec-http2/src/test/java/io/netty/handler/codec/http2/Http2ConnectionHandlerTest.java\n+++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/Http2ConnectionHandlerTest.java\n@@ -53,10 +53,13 @@\n import java.util.concurrent.atomic.AtomicBoolean;\n \n import static io.netty.buffer.Unpooled.copiedBuffer;\n+import static io.netty.handler.codec.http2.Http2CodecUtil.FRAME_HEADER_LENGTH;\n import static io.netty.handler.codec.http2.Http2CodecUtil.connectionPrefaceBuf;\n+import static io.netty.handler.codec.http2.Http2CodecUtil.writeFrameHeaderInternal;\n import static io.netty.handler.codec.http2.Http2Error.CANCEL;\n import static io.netty.handler.codec.http2.Http2Error.PROTOCOL_ERROR;\n import static io.netty.handler.codec.http2.Http2Error.STREAM_CLOSED;\n+import static io.netty.handler.codec.http2.Http2FrameTypes.SETTINGS;\n import static io.netty.handler.codec.http2.Http2Stream.State.CLOSED;\n import static io.netty.handler.codec.http2.Http2Stream.State.IDLE;\n import static io.netty.handler.codec.http2.Http2TestUtil.newVoidPromise;\n@@ -329,6 +332,20 @@ public void serverReceivingInvalidClientPrefaceStringShouldHandleException() thr\n         assertEquals(0, captor.getValue().refCnt());\n     }\n \n+    @Test\n+    public void serverReceivingInvalidClientSettingsAfterPrefaceShouldHandleException() throws Exception {\n+        ByteBuf buf = ctx.alloc().buffer(FRAME_HEADER_LENGTH);\n+        writeFrameHeaderInternal(buf, 0, SETTINGS, new Http2Flags().ack(true), 0);\n+\n+        when(connection.isServer()).thenReturn(true);\n+        handler = newHandler();\n+        handler.channelRead(ctx, Unpooled.wrappedBuffer(connectionPrefaceBuf(), buf));\n+        ArgumentCaptor<ByteBuf> captor = ArgumentCaptor.forClass(ByteBuf.class);\n+        verify(frameWriter).writeGoAway(eq(ctx), eq(Integer.MAX_VALUE), eq(PROTOCOL_ERROR.code()),\n+                captor.capture(), eq(promise));\n+        assertEquals(0, captor.getValue().refCnt());\n+    }\n+\n     @Test\n     public void serverReceivingHttp1ClientPrefaceStringShouldIncludePreface() throws Exception {\n         when(connection.isServer()).thenReturn(true);\n",
  "problem_statement" : "Improve exception message when first HTTP2SettingsFrame has the ack f (#16153)\n\nlag set\n\nMotivation:\n\nThe first HTTP2SettingsFrame must not have the ACK flag set. We already\ndid correctly enforce this but the exception that we used was\nmissleading\n\nModifications:\n\n- Clarify exception\n- Add unit test\n\nResult:\n\nRelated to https://github.com/netty/netty/issues/16142",
  "hints_text" : null,
  "created_at" : "Tue Jan 20 09:50:22 CET 2026",
  "version" : null,
  "FAIL_TO_PASS" : [ "Http2ConnectionHandlerTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -pl codec-http2 -Dtest=Http2ConnectionHandlerTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 16154,
  "metadata" : null
}, {
  "instance_id" : "netty-netty-PR-16153",
  "repo" : "netty/netty",
  "base_commit" : "ba8fbaa38eb613e0161eb288fad5f92abc58db47",
  "patch" : "diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionHandler.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionHandler.java\nindex 0517a9bc836..8c1cba2fbba 100644\n--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionHandler.java\n+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2ConnectionHandler.java\n@@ -248,6 +248,10 @@ public void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) thro\n                     byteDecoder.decode(ctx, in, out);\n                 }\n             } catch (Throwable e) {\n+                if (byteDecoder != null) {\n+                    // Skip all bytes before we report the exception as\n+                    in.skipBytes(in.readableBytes());\n+                }\n                 onError(ctx, false, e);\n             }\n         }\n@@ -346,12 +350,17 @@ private boolean verifyFirstFrameIsSettings(ByteBuf in) throws Http2Exception {\n             }\n \n             short frameType = in.getUnsignedByte(in.readerIndex() + 3);\n-            short flags = in.getUnsignedByte(in.readerIndex() + 4);\n-            if (frameType != SETTINGS || (flags & Http2Flags.ACK) != 0) {\n+            if (frameType != SETTINGS) {\n                 throw connectionError(PROTOCOL_ERROR, \"First received frame was not SETTINGS. \" +\n                                                       \"Hex dump for first 5 bytes: %s\",\n                                       hexDump(in, in.readerIndex(), 5));\n             }\n+            short flags = in.getUnsignedByte(in.readerIndex() + 4);\n+            if ((flags & Http2Flags.ACK) != 0) {\n+                throw connectionError(PROTOCOL_ERROR, \"First received frame was SETTINGS frame but had ACK flag set. \" +\n+                        \"Hex dump for first 5 bytes: %s\",\n+                        hexDump(in, in.readerIndex(), 5));\n+            }\n             return true;\n         }\n \n",
  "test_patch" : "diff --git a/codec-http2/src/test/java/io/netty/handler/codec/http2/Http2ConnectionHandlerTest.java b/codec-http2/src/test/java/io/netty/handler/codec/http2/Http2ConnectionHandlerTest.java\nindex f9eaeadc029..ee3b8b209d4 100644\n--- a/codec-http2/src/test/java/io/netty/handler/codec/http2/Http2ConnectionHandlerTest.java\n+++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/Http2ConnectionHandlerTest.java\n@@ -53,10 +53,13 @@\n import java.util.concurrent.atomic.AtomicBoolean;\n \n import static io.netty.buffer.Unpooled.copiedBuffer;\n+import static io.netty.handler.codec.http2.Http2CodecUtil.FRAME_HEADER_LENGTH;\n import static io.netty.handler.codec.http2.Http2CodecUtil.connectionPrefaceBuf;\n+import static io.netty.handler.codec.http2.Http2CodecUtil.writeFrameHeaderInternal;\n import static io.netty.handler.codec.http2.Http2Error.CANCEL;\n import static io.netty.handler.codec.http2.Http2Error.PROTOCOL_ERROR;\n import static io.netty.handler.codec.http2.Http2Error.STREAM_CLOSED;\n+import static io.netty.handler.codec.http2.Http2FrameTypes.SETTINGS;\n import static io.netty.handler.codec.http2.Http2Stream.State.CLOSED;\n import static io.netty.handler.codec.http2.Http2Stream.State.IDLE;\n import static io.netty.handler.codec.http2.Http2TestUtil.newVoidPromise;\n@@ -329,6 +332,20 @@ public void serverReceivingInvalidClientPrefaceStringShouldHandleException() thr\n         assertEquals(0, captor.getValue().refCnt());\n     }\n \n+    @Test\n+    public void serverReceivingInvalidClientSettingsAfterPrefaceShouldHandleException() throws Exception {\n+        ByteBuf buf = ctx.alloc().buffer(FRAME_HEADER_LENGTH);\n+        writeFrameHeaderInternal(buf, 0, SETTINGS, new Http2Flags().ack(true), 0);\n+\n+        when(connection.isServer()).thenReturn(true);\n+        handler = newHandler();\n+        handler.channelRead(ctx, Unpooled.wrappedBuffer(connectionPrefaceBuf(), buf));\n+        ArgumentCaptor<ByteBuf> captor = ArgumentCaptor.forClass(ByteBuf.class);\n+        verify(frameWriter).writeGoAway(eq(ctx), eq(Integer.MAX_VALUE), eq(PROTOCOL_ERROR.code()),\n+                captor.capture(), eq(promise));\n+        assertEquals(0, captor.getValue().refCnt());\n+    }\n+\n     @Test\n     public void serverReceivingHttp1ClientPrefaceStringShouldIncludePreface() throws Exception {\n         when(connection.isServer()).thenReturn(true);\n",
  "problem_statement" : "Improve exception message when first HTTP2SettingsFrame has the ack f\n\nlag set\r\n\r\nMotivation:\r\n\r\nThe first HTTP2SettingsFrame must not have the ACK flag set. We already did correctly enforce this but the exception that we used was missleading\r\n\r\nModifications:\r\n\r\n- Clarify exception\r\n- Add unit test\r\n\r\nResult:\r\n\r\nRelated to https://github.com/netty/netty/issues/16142",
  "hints_text" : null,
  "created_at" : "Mon Jan 19 12:37:01 CET 2026",
  "version" : null,
  "FAIL_TO_PASS" : [ "Http2ConnectionHandlerTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -pl codec-http2 -Dtest=Http2ConnectionHandlerTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 16153,
  "metadata" : null
}, {
  "instance_id" : "netty-netty-PR-16152",
  "repo" : "netty/netty",
  "base_commit" : "16ba19e615820c50866528f06410951e16dc5061",
  "patch" : "diff --git a/transport/src/main/java/io/netty/channel/AbstractChannelHandlerContext.java b/transport/src/main/java/io/netty/channel/AbstractChannelHandlerContext.java\nindex 4e75759e73e..778a2cfec5d 100644\n--- a/transport/src/main/java/io/netty/channel/AbstractChannelHandlerContext.java\n+++ b/transport/src/main/java/io/netty/channel/AbstractChannelHandlerContext.java\n@@ -23,7 +23,9 @@\n import io.netty.util.concurrent.DefaultPromise;\n import io.netty.util.concurrent.EventExecutor;\n import io.netty.util.concurrent.Future;\n+import io.netty.util.concurrent.FutureListener;\n import io.netty.util.concurrent.Promise;\n+import io.netty.util.concurrent.PromiseNotifier;\n import io.netty.util.internal.ObjectPool.Handle;\n import io.netty.util.internal.ObjectUtil;\n import io.netty.util.internal.PromiseNotificationUtil;\n@@ -366,8 +368,27 @@ public void fireChannelShutdown(ChannelShutdownType type) {\n         }\n     }\n \n+    /**\n+     * Check if the given {@link Promise} is using the same {@link EventExecutor} as this\n+     * {@link ChannelHandlerContext} and if not return a new {@link Promise} that runs on the same\n+     * {@link EventExecutor} as this {@link ChannelHandlerContext}. The result of the new {@link Promise} is\n+     * cascaded to the old {@link Promise}.\n+     *\n+     * This is done to ensure that {@link FutureListener}s that are added to the {@link Promise} by an\n+     * {@link ChannelOutboundHandler} are executed in the same thread as the handler itself. By doing so we can\n+     * ensure that there are not issues even if fields etc that are stored in the handler are modified by the listener.\n+     */\n+    private Promise<Void> ensurePromiseUseCorrectExecutor(Promise<Void> promise) {\n+        if (!promise.executor().inEventLoop()) {\n+            Promise<Void> newPromise = newPromise();\n+            PromiseNotifier.cascade(newPromise, promise);\n+            return newPromise;\n+        }\n+        return promise;\n+    }\n+\n     @Override\n-    public void register(final Promise<Void> promise) {\n+    public void register(Promise<Void> promise) {\n         if (isNotValidPromise(promise)) {\n             // cancelled\n             return;\n@@ -377,6 +398,7 @@ public void register(final Promise<Void> promise) {\n         EventExecutor executor = next.executor();\n         if (executor.inEventLoop()) {\n             if (next.invokeHandler()) {\n+                promise = ensurePromiseUseCorrectExecutor(promise);\n                 try {\n                     next.saveCurrentPendingBytesIfNeeded();\n                     ((ChannelOutboundHandler) next.handler()).register(next, promise);\n@@ -389,12 +411,13 @@ public void register(final Promise<Void> promise) {\n                 next.register(promise);\n             }\n         } else {\n-            safeExecute(executor, () -> register(promise), promise, null, false);\n+            final Promise<Void> p = promise;\n+            safeExecute(executor, () -> register(p), p, null, false);\n         }\n     }\n \n     @Override\n-    public void bind(final SocketAddress localAddress, final Promise<Void> promise) {\n+    public void bind(final SocketAddress localAddress, Promise<Void> promise) {\n         ObjectUtil.checkNotNull(localAddress, \"localAddress\");\n         if (isNotValidPromise(promise)) {\n             // cancelled\n@@ -405,6 +428,7 @@ public void bind(final SocketAddress localAddress, final Promise<Void> promise)\n         EventExecutor executor = next.executor();\n         if (executor.inEventLoop()) {\n             if (next.invokeHandler()) {\n+                promise = ensurePromiseUseCorrectExecutor(promise);\n                 try {\n                     next.saveCurrentPendingBytesIfNeeded();\n                     ((ChannelOutboundHandler) next.handler()).bind(next, localAddress, promise);\n@@ -417,7 +441,8 @@ public void bind(final SocketAddress localAddress, final Promise<Void> promise)\n                 next.bind(localAddress, promise);\n             }\n         } else {\n-            safeExecute(executor, () -> bind(localAddress, promise), promise, null, false);\n+            final Promise<Void> p = promise;\n+            safeExecute(executor, () -> bind(localAddress, p), p, null, false);\n         }\n     }\n \n@@ -428,7 +453,7 @@ public void connect(SocketAddress remoteAddress, Promise<Void> promise) {\n \n     @Override\n     public void connect(\n-            final SocketAddress remoteAddress, final SocketAddress localAddress, final Promise<Void> promise) {\n+            final SocketAddress remoteAddress, final SocketAddress localAddress, Promise<Void> promise) {\n         ObjectUtil.checkNotNull(remoteAddress, \"remoteAddress\");\n \n         if (isNotValidPromise(promise)) {\n@@ -440,6 +465,7 @@ public void connect(\n         EventExecutor executor = next.executor();\n         if (executor.inEventLoop()) {\n             if (next.invokeHandler()) {\n+                promise = ensurePromiseUseCorrectExecutor(promise);\n                 try {\n                     next.saveCurrentPendingBytesIfNeeded();\n                     ((ChannelOutboundHandler) next.handler()).connect(next, remoteAddress, localAddress, promise);\n@@ -452,12 +478,13 @@ public void connect(\n                 next.connect(remoteAddress, localAddress, promise);\n             }\n         } else {\n-            safeExecute(executor, () -> connect(remoteAddress, localAddress, promise), promise, null, false);\n+            final Promise<Void> p = promise;\n+            safeExecute(executor, () -> connect(remoteAddress, localAddress, p), p, null, false);\n         }\n     }\n \n     @Override\n-    public void disconnect(final Promise<Void> promise) {\n+    public void disconnect(Promise<Void> promise) {\n         if (!pipeline.hasDisconnect) {\n             // Translate disconnect to close if the channel has no notion of disconnect-reconnect.\n             // So far, UDP/IP is the only transport that has such behavior.\n@@ -473,6 +500,7 @@ public void disconnect(final Promise<Void> promise) {\n         EventExecutor executor = next.executor();\n         if (executor.inEventLoop()) {\n             if (next.invokeHandler()) {\n+                promise = ensurePromiseUseCorrectExecutor(promise);\n                 try {\n                     next.saveCurrentPendingBytesIfNeeded();\n                     ((ChannelOutboundHandler) next.handler()).disconnect(next, promise);\n@@ -485,12 +513,13 @@ public void disconnect(final Promise<Void> promise) {\n                 next.disconnect(promise);\n             }\n         } else {\n-            safeExecute(executor, () -> disconnect(promise), promise, null, false);\n+            final Promise<Void> p = promise;\n+            safeExecute(executor, () -> disconnect(p), p, null, false);\n         }\n     }\n \n     @Override\n-    public void close(final Promise<Void> promise) {\n+    public void close(Promise<Void> promise) {\n         if (isNotValidPromise(promise)) {\n             // cancelled\n             return;\n@@ -500,6 +529,7 @@ public void close(final Promise<Void> promise) {\n         EventExecutor executor = next.executor();\n         if (executor.inEventLoop()) {\n             if (next.invokeHandler()) {\n+                promise = ensurePromiseUseCorrectExecutor(promise);\n                 try {\n                     next.saveCurrentPendingBytesIfNeeded();\n                     ((ChannelOutboundHandler) next.handler()).close(next, promise);\n@@ -512,12 +542,13 @@ public void close(final Promise<Void> promise) {\n                 next.close(promise);\n             }\n         } else {\n-            safeExecute(executor, () -> close(promise), promise, null, false);\n+            final Promise<Void> p = promise;\n+            safeExecute(executor, () -> close(p), p, null, false);\n         }\n     }\n \n     @Override\n-    public void deregister(final Promise<Void> promise) {\n+    public void deregister(Promise<Void> promise) {\n         if (isNotValidPromise(promise)) {\n             // cancelled\n             return;\n@@ -527,6 +558,7 @@ public void deregister(final Promise<Void> promise) {\n         EventExecutor executor = next.executor();\n         if (executor.inEventLoop()) {\n             if (next.invokeHandler()) {\n+                promise = ensurePromiseUseCorrectExecutor(promise);\n                 try {\n                     next.saveCurrentPendingBytesIfNeeded();\n                     ((ChannelOutboundHandler) next.handler()).deregister(next, promise);\n@@ -539,7 +571,8 @@ public void deregister(final Promise<Void> promise) {\n                 next.deregister(promise);\n             }\n         } else {\n-            safeExecute(executor, () -> deregister(promise), promise, null, false);\n+            final Promise<Void> p = promise;\n+            safeExecute(executor, () -> deregister(p), p, null, false);\n         }\n     }\n \n@@ -556,6 +589,7 @@ public void shutdown(ChannelShutdownType type, Promise<Void> promise) {\n         EventExecutor executor = next.executor();\n         if (executor.inEventLoop()) {\n             if (next.invokeHandler()) {\n+                promise = ensurePromiseUseCorrectExecutor(promise);\n                 try {\n                     next.saveCurrentPendingBytesIfNeeded();\n                     ((ChannelOutboundHandler) next.handler()).shutdown(next, type, promise);\n@@ -568,7 +602,8 @@ public void shutdown(ChannelShutdownType type, Promise<Void> promise) {\n                 next.shutdown(type, promise);\n             }\n         } else {\n-            safeExecute(executor, () -> shutdown(type, promise), promise, null, false);\n+            final Promise<Void> p = promise;\n+            safeExecute(executor, () -> shutdown(type, p), p, null, false);\n         }\n     }\n \n@@ -640,6 +675,7 @@ void write(Object msg, boolean flush, Promise<Void> promise) {\n             EventExecutor executor = next.executor();\n             if (executor.inEventLoop()) {\n                 if (next.invokeHandler()) {\n+                    promise = ensurePromiseUseCorrectExecutor(promise);\n                     try {\n                         next.saveCurrentPendingBytesIfNeeded();\n                         ((ChannelOutboundHandler) next.handler()).write(next, msg, promise);\n",
  "test_patch" : "diff --git a/transport/src/test/java/io/netty/channel/DefaultChannelPipelineTest.java b/transport/src/test/java/io/netty/channel/DefaultChannelPipelineTest.java\nindex cd930b5c1dc..4b133b123bc 100644\n--- a/transport/src/test/java/io/netty/channel/DefaultChannelPipelineTest.java\n+++ b/transport/src/test/java/io/netty/channel/DefaultChannelPipelineTest.java\n@@ -18,8 +18,6 @@\n \n import io.netty.bootstrap.Bootstrap;\n import io.netty.bootstrap.ServerBootstrap;\n-import io.netty.buffer.ByteBuf;\n-import io.netty.buffer.Unpooled;\n import io.netty.channel.ChannelHandlerMask.Skip;\n import io.netty.channel.embedded.EmbeddedChannel;\n import io.netty.channel.local.LocalAddress;\n@@ -32,9 +30,12 @@\n import io.netty.util.ReferenceCountUtil;\n import io.netty.util.ReferenceCounted;\n import io.netty.util.concurrent.AbstractEventExecutor;\n+import io.netty.util.concurrent.DefaultEventExecutor;\n+import io.netty.util.concurrent.DefaultPromise;\n import io.netty.util.concurrent.EventExecutor;\n import io.netty.util.concurrent.EventExecutorGroup;\n import io.netty.util.concurrent.Future;\n+import io.netty.util.concurrent.FutureListener;\n import io.netty.util.concurrent.ImmediateEventExecutor;\n import io.netty.util.concurrent.Promise;\n import org.junit.jupiter.api.AfterAll;\n@@ -53,6 +54,7 @@\n import java.util.List;\n import java.util.NoSuchElementException;\n import java.util.Queue;\n+import java.util.concurrent.ArrayBlockingQueue;\n import java.util.concurrent.BlockingQueue;\n import java.util.concurrent.CountDownLatch;\n import java.util.concurrent.ExecutorService;\n@@ -901,6 +903,124 @@ public void run() {\n         }).sync();\n     }\n \n+    @Test\n+    public void testPromiseCorrectExecutor() throws Exception {\n+        final ChannelPipeline pipeline = new LocalChannel(group.next()).pipeline();\n+        final BlockingQueue<Boolean> queue = new ArrayBlockingQueue<Boolean>(6);\n+        EventExecutor executor = new DefaultEventExecutor();\n+        try {\n+            pipeline.addLast(new ChannelOutboundHandler() {\n+                @Override\n+                public void bind(ChannelHandlerContext ctx, SocketAddress localAddress, Promise<Void> promise) {\n+                    promise.setSuccess(null);\n+                }\n+\n+                @Override\n+                public void connect(ChannelHandlerContext ctx, SocketAddress remoteAddress,\n+                                    SocketAddress localAddress, Promise<Void> promise) {\n+                    promise.setSuccess(null);\n+                }\n+\n+                @Override\n+                public void disconnect(ChannelHandlerContext ctx, Promise<Void> promise) {\n+                    promise.setSuccess(null);\n+                }\n+\n+                @Override\n+                public void close(ChannelHandlerContext ctx, Promise<Void> promise) {\n+                    promise.setSuccess(null);\n+                }\n+\n+                @Override\n+                public void deregister(ChannelHandlerContext ctx, Promise<Void> promise) {\n+                    promise.setSuccess(null);\n+                }\n+\n+                @Override\n+                public void write(ChannelHandlerContext ctx, Object msg, Promise<Void> promise) {\n+                    promise.setSuccess(null);\n+                }\n+            }, new ChannelOutboundHandler() {\n+\n+                FutureListener<Void> listener;\n+\n+                @Override\n+                public void handlerAdded(ChannelHandlerContext ctx) {\n+                    listener = f -> {\n+                        queue.add(ctx.executor().inEventLoop());\n+                    };\n+                }\n+\n+                @Override\n+                public void bind(ChannelHandlerContext ctx, SocketAddress localAddress, Promise<Void> promise) {\n+                    ctx.bind(localAddress, promise.addListener(listener));\n+                }\n+\n+                @Override\n+                public void connect(ChannelHandlerContext ctx, SocketAddress remoteAddress,\n+                                    SocketAddress localAddress, Promise<Void> promise) {\n+                    ctx.connect(remoteAddress, localAddress, promise.addListener(listener));\n+                }\n+\n+                @Override\n+                public void disconnect(ChannelHandlerContext ctx, Promise<Void> promise) {\n+                    ctx.disconnect(promise.addListener(listener));\n+                }\n+\n+                @Override\n+                public void close(ChannelHandlerContext ctx, Promise<Void> promise) {\n+                    ctx.close(promise.addListener(listener));\n+                }\n+\n+                @Override\n+                public void deregister(ChannelHandlerContext ctx, Promise<Void> promise) {\n+                    ctx.deregister(promise.addListener(listener));\n+                }\n+\n+                @Override\n+                public void write(ChannelHandlerContext ctx, Object msg, Promise<Void> promise) {\n+                    ctx.write(msg, promise.addListener(listener));\n+                }\n+            });\n+            pipeline.channel().register();\n+\n+            Promise<Void> promise = new DefaultPromise<>(executor);\n+            pipeline.bind(new SocketAddress() { }, promise);\n+            promise.sync();\n+\n+            promise = new DefaultPromise<>(executor);\n+            pipeline.connect(new SocketAddress() { }, promise);\n+            promise.sync();\n+\n+            promise = new DefaultPromise<>(executor);\n+            pipeline.disconnect(promise);\n+            promise.sync();\n+\n+            promise = new DefaultPromise<>(executor);\n+            pipeline.close(promise);\n+            promise.sync();\n+\n+            promise = new DefaultPromise<>(executor);\n+            pipeline.deregister(promise);\n+            promise.sync();\n+\n+            promise = new DefaultPromise<>(executor);\n+            pipeline.write(\"\", promise);\n+            promise.sync();\n+        } finally {\n+            // Remove the handlers before closing so we don't intercept it.\n+            while (pipeline.lastContext() != null) {\n+                pipeline.removeLast();\n+            }\n+            pipeline.close();\n+            executor.shutdownGracefully();\n+        }\n+\n+        for (int i = 0; i < 6; i++) {\n+            assertTrue(queue.take());\n+        }\n+    }\n+\n     @Test\n     public void testUnexpectedVoidChannelPromiseCloseFuture() throws Exception {\n         final ChannelPipeline pipeline = new LocalChannel(group.next()).pipeline();\n",
  "problem_statement" : "Ensure ChannelPromise that are used by ChannelOutboundHandler will al (#16052)\n\nways complete in the assumed thread.\n\nMotivation:\n\nAt the moment we often make the assumption that the\nChannelFutureListener attached by an ChannelOutboundHandler will execute\nin the same thread as the ChannelOutboundHandler by itself. This is not\nreally safe to assume as the user can pass in a ChannelPromise that is\ntight to another EventExecutor or the previous ChannelOutboundHandler\nmight use a different EventExecutor as the current one and might have\ncreated the ChannelPromise.\n\nModifications:\n\n- If the ChannelPromise is not using the \"correct\" EventExecutor just\ncreate a new one, cascade its result to the original ChannelPromise and\npass the new ChannelPromise to the ChannelOutboundHandler. This ensures\nwe execute stuff in the assumed thread.\n- Add unit test\n\nResult:\n\nMore safe behaviour when executing ChannelOutboundHandler\n",
  "hints_text" : null,
  "created_at" : "Sun Jan 18 10:16:18 CET 2026",
  "version" : null,
  "FAIL_TO_PASS" : [ "DefaultChannelPipelineTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -pl transport -Dtest=DefaultChannelPipelineTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 16152,
  "metadata" : null
}, {
  "instance_id" : "netty-netty-PR-16151",
  "repo" : "netty/netty",
  "base_commit" : "33ac30b2c32dc228d8d3fe6a121f760eff12aa39",
  "patch" : "diff --git a/transport-classes-epoll/src/main/java/io/netty/channel/epoll/EpollDatagramChannel.java b/transport-classes-epoll/src/main/java/io/netty/channel/epoll/EpollDatagramChannel.java\nindex d77d2704d8c..1ef46b73ab8 100644\n--- a/transport-classes-epoll/src/main/java/io/netty/channel/epoll/EpollDatagramChannel.java\n+++ b/transport-classes-epoll/src/main/java/io/netty/channel/epoll/EpollDatagramChannel.java\n@@ -412,7 +412,14 @@ private boolean doWriteMessage(Object msg) throws Exception {\n             return true;\n         }\n \n-        return doWriteOrSendBytes(data, remoteAddress, false) > 0;\n+        try {\n+            return doWriteOrSendBytes(data, remoteAddress, false) > 0;\n+        } catch (NativeIoException e) {\n+            if (remoteAddress == null) {\n+                throw translateForConnected(e);\n+            }\n+            throw e;\n+        }\n     }\n \n     private static void checkUnresolved(SocketAddress address) {\ndiff --git a/transport-classes-io_uring/src/main/java/io/netty/channel/uring/IoUringDatagramChannel.java b/transport-classes-io_uring/src/main/java/io/netty/channel/uring/IoUringDatagramChannel.java\nindex 2609294d331..0e780fe08ce 100644\n--- a/transport-classes-io_uring/src/main/java/io/netty/channel/uring/IoUringDatagramChannel.java\n+++ b/transport-classes-io_uring/src/main/java/io/netty/channel/uring/IoUringDatagramChannel.java\n@@ -498,7 +498,9 @@ private boolean removeFromOutboundBuffer(ChannelOutboundBuffer outboundBuffer, i\n         try {\n             return ioResult(errormsg, res) != 0;\n         } catch (Throwable cause) {\n-            return outboundBuffer.remove(cause);\n+            Throwable e = (connected && cause instanceof NativeIoException) ?\n+                    translateForConnected((NativeIoException) cause) : cause;\n+            return outboundBuffer.remove(e);\n         }\n     }\n \ndiff --git a/transport-classes-kqueue/src/main/java/io/netty/channel/kqueue/KQueueDatagramChannel.java b/transport-classes-kqueue/src/main/java/io/netty/channel/kqueue/KQueueDatagramChannel.java\nindex 7b928a5f4a9..0e9f34a8119 100644\n--- a/transport-classes-kqueue/src/main/java/io/netty/channel/kqueue/KQueueDatagramChannel.java\n+++ b/transport-classes-kqueue/src/main/java/io/netty/channel/kqueue/KQueueDatagramChannel.java\n@@ -296,7 +296,11 @@ private boolean doWriteMessage(Object msg) throws Exception {\n         if (data.hasMemoryAddress()) {\n             long memoryAddress = data.memoryAddress();\n             if (remoteAddress == null) {\n-                writtenBytes = socket.writeAddress(memoryAddress, data.readerIndex(), data.writerIndex());\n+                try {\n+                    writtenBytes = socket.writeAddress(memoryAddress, data.readerIndex(), data.writerIndex());\n+                } catch (Errors.NativeIoException e) {\n+                    throw translateForConnected(e);\n+                }\n             } else {\n                 if (socket.protocolFamily() == SocketProtocolFamily.UNIX) {\n                     DomainSocketAddress address = (DomainSocketAddress) remoteAddress;\n@@ -347,6 +351,16 @@ private boolean doWriteMessage(Object msg) throws Exception {\n         return writtenBytes > 0;\n     }\n \n+    private static IOException translateForConnected(Errors.NativeIoException e) {\n+        // We need to correctly translate connect errors to match NIO behaviour.\n+        if (e.expectedErr() == Errors.ERROR_ECONNREFUSED_NEGATIVE) {\n+            PortUnreachableException error = new PortUnreachableException(e.getMessage());\n+            error.initCause(e);\n+            return error;\n+        }\n+        return e;\n+    }\n+\n     private static void checkUnresolved(SocketAddress address) {\n         if (address instanceof InetSocketAddress\n                 && (((InetSocketAddress) address).isUnresolved())) {\n",
  "test_patch" : "diff --git a/testsuite/src/main/java/io/netty/testsuite/transport/socket/DatagramConnectedWriteExceptionTest.java b/testsuite/src/main/java/io/netty/testsuite/transport/socket/DatagramConnectedWriteExceptionTest.java\nnew file mode 100644\nindex 00000000000..69891bac2ed\n--- /dev/null\n+++ b/testsuite/src/main/java/io/netty/testsuite/transport/socket/DatagramConnectedWriteExceptionTest.java\n@@ -0,0 +1,128 @@\n+/*\n+ * Copyright 2026 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.testsuite.transport.socket;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelOption;\n+import io.netty.channel.SimpleChannelInboundHandler;\n+import io.netty.channel.socket.DatagramPacket;\n+import io.netty.testsuite.transport.TestsuitePermutation;\n+import io.netty.util.CharsetUtil;\n+import io.netty.util.NetUtil;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestInfo;\n+import org.junit.jupiter.api.Timeout;\n+import org.junit.jupiter.api.condition.DisabledOnOs;\n+import org.junit.jupiter.api.condition.OS;\n+\n+import java.net.InetSocketAddress;\n+import java.net.PortUnreachableException;\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import static org.junit.jupiter.api.Assertions.assertInstanceOf;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+public class DatagramConnectedWriteExceptionTest extends AbstractClientSocketTest {\n+\n+    @Override\n+    protected List<TestsuitePermutation.BootstrapFactory<Bootstrap>> newFactories() {\n+        return SocketTestPermutation.INSTANCE.datagramSocket();\n+    }\n+\n+    @Test\n+    @Timeout(value = 10000, unit = TimeUnit.MILLISECONDS)\n+    @DisabledOnOs(OS.WINDOWS)\n+    public void testWriteThrowsPortUnreachableException(TestInfo testInfo) throws Throwable {\n+        run(testInfo, (Runner<Bootstrap>) this::testWriteExceptionAfterServerStop);\n+    }\n+\n+    protected void testWriteExceptionAfterServerStop(Bootstrap clientBootstrap) throws Throwable {\n+        CountDownLatch serverReceivedLatch = new CountDownLatch(1);\n+        Bootstrap serverBootstrap = clientBootstrap.clone()\n+                .option(ChannelOption.SO_BROADCAST, false)\n+                .handler(new SimpleChannelInboundHandler<DatagramPacket>() {\n+\n+                    @Override\n+                    protected void channelRead0(ChannelHandlerContext ctx, DatagramPacket msg) {\n+                        serverReceivedLatch.countDown();\n+                    }\n+                });\n+\n+        Channel serverChannel = serverBootstrap.bind(new InetSocketAddress(NetUtil.LOCALHOST, 0)).get();\n+        InetSocketAddress serverAddress = (InetSocketAddress) serverChannel.localAddress();\n+\n+        clientBootstrap.option(ChannelOption.AUTO_READ, false)\n+                .handler(new SimpleChannelInboundHandler<DatagramPacket>() {\n+\n+                    @Override\n+                    protected void channelRead0(ChannelHandlerContext ctx, DatagramPacket msg) {\n+                        // no-op\n+                    }\n+                });\n+\n+        Channel clientChannel = clientBootstrap.connect(serverAddress).get();\n+\n+        CountDownLatch clientFirstSendLatch = new CountDownLatch(1);\n+        try {\n+            ByteBuf firstMessage = Unpooled.wrappedBuffer(\"First message\".getBytes(CharsetUtil.UTF_8));\n+            clientChannel.writeAndFlush(firstMessage)\n+                    .addListener(future -> {\n+                        if (future.isSuccess()) {\n+                            clientFirstSendLatch.countDown();\n+                        }\n+                    });\n+\n+            assertTrue(serverReceivedLatch.await(5, TimeUnit.SECONDS), \"Server should receive first message\");\n+            assertTrue(clientFirstSendLatch.await(5, TimeUnit.SECONDS), \"Client should send first message\");\n+\n+            serverChannel.close().sync();\n+\n+            AtomicReference<Throwable> writeException = new AtomicReference<>();\n+            CountDownLatch writesCompleteLatch = new CountDownLatch(10);\n+\n+            for (int i = 0; i < 10; i++) {\n+                ByteBuf message = Unpooled.wrappedBuffer((\"Message \" + i).getBytes(CharsetUtil.UTF_8));\n+                clientChannel.writeAndFlush(message)\n+                        .addListener(future -> {\n+                            if (!future.isSuccess()) {\n+                                writeException.compareAndSet(null, future.cause());\n+                            }\n+                            writesCompleteLatch.countDown();\n+                        });\n+                Thread.sleep(50);\n+            }\n+\n+            assertTrue(writesCompleteLatch.await(5, TimeUnit.SECONDS), \"All writes should complete\");\n+\n+            assertNotNull(writeException.get(), \"Should have captured a write exception\");\n+\n+            assertInstanceOf(PortUnreachableException.class, writeException.get(), \"Expected \" +\n+                    \"PortUnreachableException but got: \" + writeException.get().getClass().getName());\n+        } finally {\n+            if (clientChannel != null) {\n+                clientChannel.close().sync();\n+            }\n+        }\n+    }\n+}\ndiff --git a/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringDatagramConnectedWriteExceptionTest.java b/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringDatagramConnectedWriteExceptionTest.java\nnew file mode 100644\nindex 00000000000..fe660e5bbcf\n--- /dev/null\n+++ b/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringDatagramConnectedWriteExceptionTest.java\n@@ -0,0 +1,30 @@\n+/*\n+ * Copyright 2026 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.channel.uring;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.testsuite.transport.TestsuitePermutation;\n+import io.netty.testsuite.transport.socket.DatagramConnectedWriteExceptionTest;\n+\n+import java.util.List;\n+\n+public class IoUringDatagramConnectedWriteExceptionTest extends DatagramConnectedWriteExceptionTest {\n+\n+    @Override\n+    protected List<TestsuitePermutation.BootstrapFactory<Bootstrap>> newFactories() {\n+        return IoUringSocketTestPermutation.INSTANCE.datagramSocket();\n+    }\n+}\ndiff --git a/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringSocketTestPermutation.java b/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringSocketTestPermutation.java\nindex cdf134be383..db48b53db1d 100644\n--- a/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringSocketTestPermutation.java\n+++ b/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringSocketTestPermutation.java\n@@ -275,6 +275,18 @@ public Bootstrap newInstance() {\n         );\n     }\n \n+    @Override\n+    public List<BootstrapFactory<Bootstrap>> datagramSocket() {\n+        return Collections.<BootstrapFactory<Bootstrap>>singletonList(\n+                new BootstrapFactory<Bootstrap>() {\n+                    @Override\n+                    public Bootstrap newInstance() {\n+                        return new Bootstrap().group(IO_URING_GROUP).channel(IoUringDatagramChannel.class);\n+                    }\n+                }\n+        );\n+    }\n+\n     public static DomainSocketAddress newDomainSocketAddress() {\n         return UnixTestUtils.newDomainSocketAddress();\n     }\ndiff --git a/transport-native-kqueue/src/test/java/io/netty/channel/kqueue/KQueueDatagramConnectedWriteExceptionTest.java b/transport-native-kqueue/src/test/java/io/netty/channel/kqueue/KQueueDatagramConnectedWriteExceptionTest.java\nnew file mode 100644\nindex 00000000000..c964ca8acb3\n--- /dev/null\n+++ b/transport-native-kqueue/src/test/java/io/netty/channel/kqueue/KQueueDatagramConnectedWriteExceptionTest.java\n@@ -0,0 +1,30 @@\n+/*\n+ * Copyright 2026 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.channel.kqueue;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.testsuite.transport.TestsuitePermutation;\n+import io.netty.testsuite.transport.socket.DatagramConnectedWriteExceptionTest;\n+\n+import java.util.List;\n+\n+public class KQueueDatagramConnectedWriteExceptionTest extends DatagramConnectedWriteExceptionTest {\n+\n+    @Override\n+    protected List<TestsuitePermutation.BootstrapFactory<Bootstrap>> newFactories() {\n+        return KQueueSocketTestPermutation.INSTANCE.datagramSocket();\n+    }\n+}\n",
  "problem_statement" : "Wrap ECONNREFUSED in PortUnreachableException for UDP (#16131)\n\nMotivation:\n\nCurrently, `KQueueDatagramChannel` handles `ECONNREFUSED` inconsistently\ndepending on how data is sent:\n- `sendToAddress()` (Unconnected): Correctly wraps errors in\n`PortUnreachableException`.\n- `writeAddress()` (Connected): Returns raw `ECONNREFUSED`, causing an\ninconsistency with `NIO` behaviour.\n\nIn `NIO`, the exception is thrown from the write path:\n\n```\n java.net.PortUnreachableException\n    at java.base/sun.nio.ch.DatagramDispatcher.write0(Native Method)\n    at java.base/sun.nio.ch.DatagramDispatcher.write(DatagramDispatcher.java:51)\n    at java.base/sun.nio.ch.IOUtil.writeFromNativeBuffer(IOUtil.java:137)\n    at java.base/sun.nio.ch.IOUtil.write(IOUtil.java:81)\n    at java.base/sun.nio.ch.IOUtil.write(IOUtil.java:58)\n    at java.base/sun.nio.ch.DatagramChannelImpl.write(DatagramChannelImpl.java:1160)\n    at io.netty.channel.socket.nio.NioDatagramChannel.doWriteMessage(NioDatagramChannel.java:309)\n```\n\nModifications:\n\n- Introduced `translateForConnected()` to handle error mapping\nspecifically for the connected state.\n- Updated `doWriteMessage()` to apply this translation when the channel\nis connected (`remoteAddress == null`) and `writeAddress()` fails with\n`ECONNREFUSED`.\n\nResult:\n\nImproved behavioural parity between `KQueue` and `NIO` transports. Users\nwill now receive a consistent `PortUnreachableException` regardless of\nthe send path used.\n\n---------\n\nCo-authored-by: Norman Maurer <norman_maurer@apple.com>\n",
  "hints_text" : null,
  "created_at" : "Sat Jan 17 14:12:44 CET 2026",
  "version" : null,
  "FAIL_TO_PASS" : [ "DatagramConnectedWriteExceptionTest", "IoUringSocketTestPermutation", "IoUringDatagramConnectedWriteExceptionTest", "KQueueDatagramConnectedWriteExceptionTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -pl transport-classes-epoll -Dtest=DatagramConnectedWriteExceptionTest,IoUringSocketTestPermutation,IoUringDatagramConnectedWriteExceptionTest,KQueueDatagramConnectedWriteExceptionTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 16151,
  "metadata" : null
}, {
  "instance_id" : "netty-netty-PR-16150",
  "repo" : "netty/netty",
  "base_commit" : "f80b70c75ed7dff27d7e74d2c18ca8a0724a1cc7",
  "patch" : "diff --git a/transport-classes-epoll/src/main/java/io/netty/channel/epoll/EpollDatagramChannel.java b/transport-classes-epoll/src/main/java/io/netty/channel/epoll/EpollDatagramChannel.java\nindex c42ac048467..613e2c2f274 100644\n--- a/transport-classes-epoll/src/main/java/io/netty/channel/epoll/EpollDatagramChannel.java\n+++ b/transport-classes-epoll/src/main/java/io/netty/channel/epoll/EpollDatagramChannel.java\n@@ -415,7 +415,14 @@ private boolean doWriteMessage(Object msg) throws Exception {\n             return true;\n         }\n \n-        return doWriteOrSendBytes(data, remoteAddress, false) > 0;\n+        try {\n+            return doWriteOrSendBytes(data, remoteAddress, false) > 0;\n+        } catch (NativeIoException e) {\n+            if (remoteAddress == null) {\n+                throw translateForConnected(e);\n+            }\n+            throw e;\n+        }\n     }\n \n     private static void checkUnresolved(AddressedEnvelope<?, ?> envelope) {\ndiff --git a/transport-classes-kqueue/src/main/java/io/netty/channel/kqueue/KQueueDatagramChannel.java b/transport-classes-kqueue/src/main/java/io/netty/channel/kqueue/KQueueDatagramChannel.java\nindex 70f848a3e90..52aa4d4fb27 100644\n--- a/transport-classes-kqueue/src/main/java/io/netty/channel/kqueue/KQueueDatagramChannel.java\n+++ b/transport-classes-kqueue/src/main/java/io/netty/channel/kqueue/KQueueDatagramChannel.java\n@@ -34,6 +34,7 @@\n import io.netty.util.internal.ObjectUtil;\n import io.netty.util.internal.StringUtil;\n \n+import java.io.IOException;\n import java.net.InetAddress;\n import java.net.InetSocketAddress;\n import java.net.NetworkInterface;\n@@ -265,7 +266,11 @@ protected boolean doWriteMessage(Object msg) throws Exception {\n         if (data.hasMemoryAddress()) {\n             long memoryAddress = data.memoryAddress();\n             if (remoteAddress == null) {\n-                writtenBytes = socket.writeAddress(memoryAddress, data.readerIndex(), data.writerIndex());\n+                try {\n+                    writtenBytes = socket.writeAddress(memoryAddress, data.readerIndex(), data.writerIndex());\n+                } catch (Errors.NativeIoException e) {\n+                    throw translateForConnected(e);\n+                }\n             } else {\n                 writtenBytes = socket.sendToAddress(memoryAddress, data.readerIndex(), data.writerIndex(),\n                         remoteAddress.getAddress(), remoteAddress.getPort());\n@@ -295,6 +300,16 @@ protected boolean doWriteMessage(Object msg) throws Exception {\n         return writtenBytes > 0;\n     }\n \n+    private static IOException translateForConnected(Errors.NativeIoException e) {\n+        // We need to correctly translate connect errors to match NIO behaviour.\n+        if (e.expectedErr() == Errors.ERROR_ECONNREFUSED_NEGATIVE) {\n+            PortUnreachableException error = new PortUnreachableException(e.getMessage());\n+            error.initCause(e);\n+            return error;\n+        }\n+        return e;\n+    }\n+\n     private static void checkUnresolved(AddressedEnvelope<?, ?> envelope) {\n         if (envelope.recipient() instanceof InetSocketAddress\n                 && (((InetSocketAddress) envelope.recipient()).isUnresolved())) {\n",
  "test_patch" : "diff --git a/testsuite/src/main/java/io/netty/testsuite/transport/socket/DatagramConnectedWriteExceptionTest.java b/testsuite/src/main/java/io/netty/testsuite/transport/socket/DatagramConnectedWriteExceptionTest.java\nnew file mode 100644\nindex 00000000000..c26e3a0fb7c\n--- /dev/null\n+++ b/testsuite/src/main/java/io/netty/testsuite/transport/socket/DatagramConnectedWriteExceptionTest.java\n@@ -0,0 +1,141 @@\n+/*\n+ * Copyright 2026 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.testsuite.transport.socket;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelOption;\n+import io.netty.channel.SimpleChannelInboundHandler;\n+import io.netty.channel.socket.DatagramPacket;\n+import io.netty.testsuite.transport.TestsuitePermutation;\n+import io.netty.util.CharsetUtil;\n+import io.netty.util.NetUtil;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestInfo;\n+import org.junit.jupiter.api.Timeout;\n+import org.junit.jupiter.api.condition.DisabledOnOs;\n+import org.junit.jupiter.api.condition.OS;\n+\n+import java.net.InetSocketAddress;\n+import java.net.PortUnreachableException;\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import static org.junit.jupiter.api.Assertions.assertInstanceOf;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+public class DatagramConnectedWriteExceptionTest extends AbstractClientSocketTest {\n+\n+    @Override\n+    protected List<TestsuitePermutation.BootstrapFactory<Bootstrap>> newFactories() {\n+        return SocketTestPermutation.INSTANCE.datagramSocket();\n+    }\n+\n+    @Test\n+    @Timeout(value = 10000, unit = TimeUnit.MILLISECONDS)\n+    @DisabledOnOs(OS.WINDOWS)\n+    public void testWriteThrowsPortUnreachableException(TestInfo testInfo) throws Throwable {\n+        run(testInfo, new Runner<Bootstrap>() {\n+            @Override\n+            public void run(Bootstrap bootstrap) throws Throwable {\n+                testWriteExceptionAfterServerStop(bootstrap);\n+            }\n+        });\n+    }\n+\n+    protected void testWriteExceptionAfterServerStop(Bootstrap clientBootstrap) throws Throwable {\n+        final CountDownLatch serverReceivedLatch = new CountDownLatch(1);\n+        Bootstrap serverBootstrap = clientBootstrap.clone()\n+                .option(ChannelOption.SO_BROADCAST, false)\n+                .handler(new SimpleChannelInboundHandler<DatagramPacket>() {\n+\n+                    @Override\n+                    protected void channelRead0(ChannelHandlerContext ctx, DatagramPacket msg) {\n+                        serverReceivedLatch.countDown();\n+                    }\n+                });\n+\n+        Channel serverChannel = serverBootstrap.bind(new InetSocketAddress(NetUtil.LOCALHOST, 0)).sync().channel();\n+        InetSocketAddress serverAddress = (InetSocketAddress) serverChannel.localAddress();\n+\n+        clientBootstrap.option(ChannelOption.AUTO_READ, false)\n+                .handler(new SimpleChannelInboundHandler<DatagramPacket>() {\n+\n+                    @Override\n+                    protected void channelRead0(ChannelHandlerContext ctx, DatagramPacket msg) {\n+                        // no-op\n+                    }\n+                });\n+\n+        Channel clientChannel = clientBootstrap.connect(serverAddress).sync().channel();\n+\n+        final CountDownLatch clientFirstSendLatch = new CountDownLatch(1);\n+        try {\n+            ByteBuf firstMessage = Unpooled.wrappedBuffer(\"First message\".getBytes(CharsetUtil.UTF_8));\n+            clientChannel.writeAndFlush(firstMessage)\n+                    .addListener(new ChannelFutureListener() {\n+                        @Override\n+                        public void operationComplete(ChannelFuture future) {\n+                            if (future.isSuccess()) {\n+                                clientFirstSendLatch.countDown();\n+                            }\n+                        }\n+                    });\n+\n+            assertTrue(serverReceivedLatch.await(5, TimeUnit.SECONDS), \"Server should receive first message\");\n+            assertTrue(clientFirstSendLatch.await(5, TimeUnit.SECONDS), \"Client should send first message\");\n+\n+            serverChannel.close().sync();\n+\n+            final AtomicReference<Throwable> writeException = new AtomicReference<Throwable>();\n+            final CountDownLatch writesCompleteLatch = new CountDownLatch(10);\n+\n+            for (int i = 0; i < 10; i++) {\n+                ByteBuf message = Unpooled.wrappedBuffer((\"Message \" + i).getBytes(CharsetUtil.UTF_8));\n+                clientChannel.writeAndFlush(message)\n+                        .addListener(new ChannelFutureListener() {\n+                            @Override\n+                            public void operationComplete(ChannelFuture future) {\n+                                if (!future.isSuccess()) {\n+                                    writeException.compareAndSet(null, future.cause());\n+                                }\n+                                writesCompleteLatch.countDown();\n+                            }\n+                        });\n+                Thread.sleep(50);\n+            }\n+\n+            assertTrue(writesCompleteLatch.await(5, TimeUnit.SECONDS), \"All writes should complete\");\n+\n+            assertNotNull(writeException.get(), \"Should have captured a write exception\");\n+\n+            assertInstanceOf(PortUnreachableException.class, writeException.get(), \"Expected \" +\n+                    \"PortUnreachableException but got: \" + writeException.get().getClass().getName());\n+        } finally {\n+            if (clientChannel != null) {\n+                clientChannel.close().sync();\n+            }\n+        }\n+    }\n+}\ndiff --git a/transport-native-kqueue/src/test/java/io/netty/channel/kqueue/KQueueDatagramConnectedWriteExceptionTest.java b/transport-native-kqueue/src/test/java/io/netty/channel/kqueue/KQueueDatagramConnectedWriteExceptionTest.java\nnew file mode 100644\nindex 00000000000..c964ca8acb3\n--- /dev/null\n+++ b/transport-native-kqueue/src/test/java/io/netty/channel/kqueue/KQueueDatagramConnectedWriteExceptionTest.java\n@@ -0,0 +1,30 @@\n+/*\n+ * Copyright 2026 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.channel.kqueue;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.testsuite.transport.TestsuitePermutation;\n+import io.netty.testsuite.transport.socket.DatagramConnectedWriteExceptionTest;\n+\n+import java.util.List;\n+\n+public class KQueueDatagramConnectedWriteExceptionTest extends DatagramConnectedWriteExceptionTest {\n+\n+    @Override\n+    protected List<TestsuitePermutation.BootstrapFactory<Bootstrap>> newFactories() {\n+        return KQueueSocketTestPermutation.INSTANCE.datagramSocket();\n+    }\n+}\n",
  "problem_statement" : "Wrap ECONNREFUSED in PortUnreachableException for UDP (#16131)\n\nMotivation:\n\nCurrently, `KQueueDatagramChannel` handles `ECONNREFUSED` inconsistently\ndepending on how data is sent:\n- `sendToAddress()` (Unconnected): Correctly wraps errors in\n`PortUnreachableException`.\n- `writeAddress()` (Connected): Returns raw `ECONNREFUSED`, causing an\ninconsistency with `NIO` behaviour.\n\nIn `NIO`, the exception is thrown from the write path:\n\n```\n java.net.PortUnreachableException\n    at java.base/sun.nio.ch.DatagramDispatcher.write0(Native Method)\n    at java.base/sun.nio.ch.DatagramDispatcher.write(DatagramDispatcher.java:51)\n    at java.base/sun.nio.ch.IOUtil.writeFromNativeBuffer(IOUtil.java:137)\n    at java.base/sun.nio.ch.IOUtil.write(IOUtil.java:81)\n    at java.base/sun.nio.ch.IOUtil.write(IOUtil.java:58)\n    at java.base/sun.nio.ch.DatagramChannelImpl.write(DatagramChannelImpl.java:1160)\n    at io.netty.channel.socket.nio.NioDatagramChannel.doWriteMessage(NioDatagramChannel.java:309)\n```\n\nModifications:\n\n- Introduced `translateForConnected()` to handle error mapping\nspecifically for the connected state.\n- Updated `doWriteMessage()` to apply this translation when the channel\nis connected (`remoteAddress == null`) and `writeAddress()` fails with\n`ECONNREFUSED`.\n\nResult:\n\nImproved behavioural parity between `KQueue` and `NIO` transports. Users\nwill now receive a consistent `PortUnreachableException` regardless of\nthe send path used.\n\n---------\n\nCo-authored-by: Norman Maurer <norman_maurer@apple.com>\n",
  "hints_text" : null,
  "created_at" : "Sat Jan 17 14:10:14 CET 2026",
  "version" : null,
  "FAIL_TO_PASS" : [ "DatagramConnectedWriteExceptionTest", "KQueueDatagramConnectedWriteExceptionTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -pl transport-classes-epoll -Dtest=DatagramConnectedWriteExceptionTest,KQueueDatagramConnectedWriteExceptionTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 16150,
  "metadata" : null
}, {
  "instance_id" : "netty-netty-PR-16143",
  "repo" : "netty/netty",
  "base_commit" : "1155c463771f3788d951b377c5f0f478f517f96f",
  "patch" : "diff --git a/codec-classes-quic/src/main/java/io/netty/handler/codec/quic/QuicheQuicChannel.java b/codec-classes-quic/src/main/java/io/netty/handler/codec/quic/QuicheQuicChannel.java\nindex 32c308d987b..50f001dac8e 100644\n--- a/codec-classes-quic/src/main/java/io/netty/handler/codec/quic/QuicheQuicChannel.java\n+++ b/codec-classes-quic/src/main/java/io/netty/handler/codec/quic/QuicheQuicChannel.java\n@@ -1507,9 +1507,6 @@ protected void doConnect(SocketAddress remote, SocketAddress local, Promise<Void\n \n     void connectStream(QuicStreamType type, @Nullable ChannelHandler handler,\n                        Promise<QuicStreamChannel> promise) {\n-        if (!promise.setUncancellable()) {\n-            return;\n-        }\n         long streamId = idGenerator.nextStreamId(type == QuicStreamType.BIDIRECTIONAL);\n \n         try {\ndiff --git a/codec-classes-quic/src/main/java/io/netty/handler/codec/quic/QuicheQuicStreamChannel.java b/codec-classes-quic/src/main/java/io/netty/handler/codec/quic/QuicheQuicStreamChannel.java\nindex 3bf7d1ae162..08e416a6034 100644\n--- a/codec-classes-quic/src/main/java/io/netty/handler/codec/quic/QuicheQuicStreamChannel.java\n+++ b/codec-classes-quic/src/main/java/io/netty/handler/codec/quic/QuicheQuicStreamChannel.java\n@@ -140,9 +140,6 @@ public void updatePriority(QuicStreamPriority priority, Promise<Void> promise) {\n \n     private void updatePriority0(QuicStreamPriority priority, Promise<Void> promise) {\n         assert executor().inEventLoop();\n-        if (!promise.setUncancellable()) {\n-            return;\n-        }\n         try {\n             parent().streamPriority(streamId(), (byte) priority.urgency(), priority.isIncremental());\n         } catch (Throwable cause) {\n@@ -438,9 +435,6 @@ private void shutdown0(boolean read, boolean write, int error, Promise<Void> pro\n \n         @Override\n         public void register(Promise<Void> promise) {\n-            if (!promise.setUncancellable()) {\n-                return;\n-            }\n             if (registered) {\n                 promise.setFailure(new IllegalStateException());\n                 return;\n@@ -454,9 +448,6 @@ public void register(Promise<Void> promise) {\n         @Override\n         public void bind(SocketAddress localAddress, Promise<Void> promise) {\n             assert executor().inEventLoop();\n-            if (!promise.setUncancellable()) {\n-                return;\n-            }\n             promise.setFailure(new UnsupportedOperationException());\n         }\n \n@@ -473,9 +464,6 @@ public void close(Promise<Void> promise) {\n \n         void close(@Nullable ClosedChannelException writeFailCause, Promise<Void> promise) {\n             assert executor().inEventLoop();\n-            if (!promise.setUncancellable()) {\n-                return;\n-            }\n             if (!active || closePromise.isDone()) {\n                 closePromise.addListener(new PromiseNotifier<>(promise));\n                 return;\n@@ -516,10 +504,6 @@ void close(@Nullable ClosedChannelException writeFailCause, Promise<Void> promis\n \n         private void deregister(final Promise<Void> promise, final boolean fireChannelInactive) {\n             assert executor().inEventLoop();\n-            if (!promise.setUncancellable()) {\n-                return;\n-            }\n-\n             if (!registered) {\n                 promise.trySuccess(null);\n                 return;\n@@ -652,10 +636,6 @@ boolean writeQueued() {\n         @Override\n         public void write(Object msg, Promise<Void> promise) {\n             assert executor().inEventLoop();\n-            if (!promise.setUncancellable()) {\n-                ReferenceCountUtil.release(msg);\n-                return;\n-            }\n             // Check first if the Channel is in a state in which it will accept writes, if not fail everything\n             // with the right exception\n             if (!isOpen()) {\ndiff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/AbstractHttp2StreamChannel.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/AbstractHttp2StreamChannel.java\nindex 6dabc9a2845..ad1a94507d6 100644\n--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/AbstractHttp2StreamChannel.java\n+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/AbstractHttp2StreamChannel.java\n@@ -635,9 +635,6 @@ public void shutdown(ChannelShutdownType type, Promise<Void> promise) {\n         @Override\n         public void connect(final SocketAddress remoteAddress,\n                             SocketAddress localAddress, final Promise<Void> promise) {\n-            if (!promise.setUncancellable()) {\n-                return;\n-            }\n             promise.setFailure(new UnsupportedOperationException());\n         }\n \n@@ -651,9 +648,6 @@ public RecvByteBufAllocator.Handle recvBufAllocHandle() {\n \n         @Override\n         public void register(Promise<Void> promise) {\n-            if (!promise.setUncancellable()) {\n-                return;\n-            }\n             if (registered) {\n                 promise.setFailure(new UnsupportedOperationException(\"Re-register is not supported\"));\n                 return;\n@@ -671,9 +665,6 @@ public void register(Promise<Void> promise) {\n \n         @Override\n         public void bind(SocketAddress localAddress, Promise<Void> promise) {\n-            if (!promise.setUncancellable()) {\n-                return;\n-            }\n             promise.setFailure(new UnsupportedOperationException());\n         }\n \n@@ -688,9 +679,6 @@ public void close(final Promise<Void> promise) {\n         }\n \n         private void close(final Promise<Void> promise, Http2Error error) {\n-            if (!promise.setUncancellable()) {\n-                return;\n-            }\n             if (closeInitiated) {\n                 if (closePromise.isDone()) {\n                     // Closed already.\n@@ -755,10 +743,6 @@ public void deregister(Promise<Void> promise) {\n \n         private void fireChannelInactiveAndDeregister(final Promise<Void> promise,\n                                                       final boolean fireChannelInactive) {\n-            if (!promise.setUncancellable()) {\n-                return;\n-            }\n-\n             if (!registered) {\n                 promise.setSuccess(null);\n                 return;\n@@ -978,12 +962,6 @@ private Future<Void> writeWindowUpdateFrame(Http2WindowUpdateFrame windowUpdateF\n \n         @Override\n         public void write(Object msg, final Promise<Void> promise) {\n-            // After this point its not possible to cancel a write anymore.\n-            if (!promise.setUncancellable()) {\n-                ReferenceCountUtil.release(msg);\n-                return;\n-            }\n-\n             if (!isActive() ||\n                     // Once the outbound side was closed we should not allow header / data frames\n                     outboundClosed && (msg instanceof Http2HeadersFrame || msg instanceof Http2DataFrame)) {\ndiff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2StreamChannelBootstrap.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2StreamChannelBootstrap.java\nindex 9aac2647bfc..28bf793b3cc 100644\n--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2StreamChannelBootstrap.java\n+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/Http2StreamChannelBootstrap.java\n@@ -162,9 +162,6 @@ private ChannelHandlerContext findCtx() throws ClosedChannelException {\n     @Deprecated\n     public void open0(ChannelHandlerContext ctx, final Promise<Http2StreamChannel> promise) {\n         assert ctx.executor().inEventLoop();\n-        if (!promise.setUncancellable()) {\n-            return;\n-        }\n         final Http2StreamChannel streamChannel;\n         try {\n             if (ctx.handler() instanceof Http2MultiplexCodec) {\n@@ -188,12 +185,15 @@ public void open0(ChannelHandlerContext ctx, final Promise<Http2StreamChannel> p\n         future.addListener(f -> {\n             if (f.isSuccess()) {\n                 promise.setSuccess(streamChannel);\n-            } else if (f.isCancelled()) {\n-                promise.cancel(false);\n-            } else {\n-                streamChannel.close();\n-                promise.setFailure(f.cause());\n+                return;\n+            }\n+            if (f.isCancelled()) {\n+                if (promise.cancel(false)) {\n+                    return;\n+                }\n             }\n+            streamChannel.close();\n+            promise.setFailure(f.cause());\n         });\n     }\n \ndiff --git a/common/src/main/java/io/netty/util/concurrent/DefaultPromise.java b/common/src/main/java/io/netty/util/concurrent/DefaultPromise.java\nindex c77fad08a11..c94588d7b4e 100644\n--- a/common/src/main/java/io/netty/util/concurrent/DefaultPromise.java\n+++ b/common/src/main/java/io/netty/util/concurrent/DefaultPromise.java\n@@ -131,8 +131,11 @@ public boolean tryFailure(Throwable cause) {\n         return setFailure0(cause);\n     }\n \n-    @Override\n-    public boolean setUncancellable() {\n+    boolean isCancellationSupported() {\n+        return false;\n+    }\n+\n+    final boolean setUncancellable() {\n         if (RESULT_UPDATER.compareAndSet(this, null, UNCANCELLABLE)) {\n             return true;\n         }\n@@ -148,7 +151,7 @@ public boolean isSuccess() {\n \n     @Override\n     public boolean isCancellable() {\n-        return result == null;\n+        return isCancellationSupported() && result == null;\n     }\n \n     private static final class LeanCancellationException extends CancellationException {\n@@ -358,7 +361,8 @@ public V get(long timeout, TimeUnit unit) throws InterruptedException, Execution\n      */\n     @Override\n     public boolean cancel(boolean mayInterruptIfRunning) {\n-        if (RESULT_UPDATER.compareAndSet(this, null, CANCELLATION_CAUSE_HOLDER)) {\n+        if (isCancellationSupported() &&\n+                RESULT_UPDATER.compareAndSet(this, null, CANCELLATION_CAUSE_HOLDER)) {\n             if (checkNotifyWaiters()) {\n                 notifyListeners();\n             }\ndiff --git a/common/src/main/java/io/netty/util/concurrent/Promise.java b/common/src/main/java/io/netty/util/concurrent/Promise.java\nindex 563a3982da8..fa8ffde997b 100644\n--- a/common/src/main/java/io/netty/util/concurrent/Promise.java\n+++ b/common/src/main/java/io/netty/util/concurrent/Promise.java\n@@ -56,14 +56,6 @@ public interface Promise<V> extends Future<V> {\n      */\n     boolean tryFailure(Throwable cause);\n \n-    /**\n-     * Make this future impossible to cancel.\n-     *\n-     * @return {@code true} if and only if successfully marked this future as uncancellable or it is already done\n-     *         without being cancelled.  {@code false} if this future has been cancelled already.\n-     */\n-    boolean setUncancellable();\n-\n     @Override\n     Promise<V> addListener(FutureListener<? super V> listener);\n \ndiff --git a/common/src/main/java/io/netty/util/concurrent/PromiseTask.java b/common/src/main/java/io/netty/util/concurrent/PromiseTask.java\nindex 1a14219b8cd..a8356a9b39b 100644\n--- a/common/src/main/java/io/netty/util/concurrent/PromiseTask.java\n+++ b/common/src/main/java/io/netty/util/concurrent/PromiseTask.java\n@@ -102,7 +102,7 @@ V runTask() throws Throwable {\n     @Override\n     public void run() {\n         try {\n-            if (setUncancellableInternal()) {\n+            if (setUncancellable()) {\n                 V result = runTask();\n                 setSuccessInternal(result);\n             }\n@@ -162,15 +162,6 @@ protected final boolean trySuccessInternal(V result) {\n         return clearTaskAfterCompletion(super.trySuccess(result), COMPLETED);\n     }\n \n-    @Override\n-    public final boolean setUncancellable() {\n-        throw new IllegalStateException();\n-    }\n-\n-    protected final boolean setUncancellableInternal() {\n-        return super.setUncancellable();\n-    }\n-\n     @Override\n     public boolean cancel(boolean mayInterruptIfRunning) {\n         return clearTaskAfterCompletion(super.cancel(mayInterruptIfRunning), CANCELLED);\ndiff --git a/common/src/main/java/io/netty/util/concurrent/ScheduledFutureTask.java b/common/src/main/java/io/netty/util/concurrent/ScheduledFutureTask.java\nindex 4c5960d6741..5500ec63e19 100644\n--- a/common/src/main/java/io/netty/util/concurrent/ScheduledFutureTask.java\n+++ b/common/src/main/java/io/netty/util/concurrent/ScheduledFutureTask.java\n@@ -151,7 +151,7 @@ public void run() {\n                 return;\n             }\n             if (periodNanos == 0) {\n-                if (setUncancellableInternal()) {\n+                if (setUncancellable()) {\n                     V result = runTask();\n                     setSuccessInternal(result);\n                 }\n@@ -219,4 +219,9 @@ public int priorityQueueIndex(DefaultPriorityQueue<?> queue) {\n     public void priorityQueueIndex(DefaultPriorityQueue<?> queue, int i) {\n         queueIndex = i;\n     }\n+\n+    @Override\n+    boolean isCancellationSupported() {\n+        return true;\n+    }\n }\ndiff --git a/common/src/main/java/io/netty/util/concurrent/UnorderedThreadPoolEventExecutor.java b/common/src/main/java/io/netty/util/concurrent/UnorderedThreadPoolEventExecutor.java\nindex cda34e84146..c869da0886b 100644\n--- a/common/src/main/java/io/netty/util/concurrent/UnorderedThreadPoolEventExecutor.java\n+++ b/common/src/main/java/io/netty/util/concurrent/UnorderedThreadPoolEventExecutor.java\n@@ -227,6 +227,11 @@ private static final class RunnableScheduledFutureTask<V> extends PromiseTask<V>\n             this.wasCallable = wasCallable;\n         }\n \n+        @Override\n+        boolean isCancellationSupported() {\n+            return true;\n+        }\n+\n         @Override\n         V runTask() throws Throwable {\n             V result =  super.runTask();\ndiff --git a/transport/src/main/java/io/netty/channel/AbstractChannel.java b/transport/src/main/java/io/netty/channel/AbstractChannel.java\nindex a3c9aca5963..af1530aef2a 100644\n--- a/transport/src/main/java/io/netty/channel/AbstractChannel.java\n+++ b/transport/src/main/java/io/netty/channel/AbstractChannel.java\n@@ -449,9 +449,6 @@ private final class IoTransportImpl implements IoTransport {\n         @Override\n         public void shutdown(ChannelShutdownType type, Promise<Void> promise) {\n             assertEventLoop();\n-            if (!promise.setUncancellable()) {\n-                return;\n-            }\n             if (!isActive()) {\n                 if (isOpen()) {\n                     promise.setFailure(new NotYetConnectedException());\n@@ -492,7 +489,7 @@ public void register(final Promise<Void> promise) {\n \n             // check if the channel is still open as it could be closed in the mean time when the register\n             // call was outside of the eventLoop\n-            if (!promise.setUncancellable() || !ensureOpen(promise)) {\n+            if (!ensureOpen(promise)) {\n                 return;\n             }\n             if (isRegistered()) {\n@@ -536,7 +533,7 @@ public void register(final Promise<Void> promise) {\n         public void bind(final SocketAddress localAddress, final Promise<Void> promise) {\n             assertEventLoop();\n \n-            if (!promise.setUncancellable() || !ensureOpen(promise)) {\n+            if (!ensureOpen(promise)) {\n                 return;\n             }\n \n@@ -667,10 +664,6 @@ private void fulfillConnectPromise(Promise<Void> promise, Throwable cause, Socke\n         public void disconnect(final Promise<Void> promise) {\n             assertEventLoop();\n \n-            if (!promise.setUncancellable()) {\n-                return;\n-            }\n-\n             boolean wasActive = isActive();\n             Promise<Void> disconnectPromise = newPromise();\n             disconnectPromise.addListener((FutureListener<Void>) f -> {\n@@ -703,10 +696,6 @@ public void close(final Promise<Void> promise) {\n \n         private void close(final Promise<Void> promise, final Throwable cause,\n                            final ClosedChannelException closeCause) {\n-            if (!promise.setUncancellable()) {\n-                return;\n-            }\n-\n             if (closeInitiated) {\n                 if (closeFuture.isDone()) {\n                     // Closed already.\n@@ -784,10 +773,6 @@ public void deregister(final Promise<Void> promise) {\n         }\n \n         private void deregister(final Promise<Void> promise, final boolean fireChannelInactive) {\n-            if (!promise.setUncancellable()) {\n-                return;\n-            }\n-\n             if (!registered) {\n                 safeSetSuccess(promise);\n                 return;\ndiff --git a/transport/src/main/java/io/netty/channel/ChannelOutboundBuffer.java b/transport/src/main/java/io/netty/channel/ChannelOutboundBuffer.java\nindex 360d8d3ad11..e03aab55b7f 100644\n--- a/transport/src/main/java/io/netty/channel/ChannelOutboundBuffer.java\n+++ b/transport/src/main/java/io/netty/channel/ChannelOutboundBuffer.java\n@@ -18,7 +18,6 @@\n import io.netty.buffer.AbstractReferenceCountedByteBuf;\n import io.netty.buffer.ByteBuf;\n import io.netty.buffer.ByteBufHolder;\n-import io.netty.buffer.Unpooled;\n import io.netty.util.Recycler;\n import io.netty.util.Recycler.EnhancedHandle;\n import io.netty.util.ReferenceCountUtil;\n@@ -167,11 +166,6 @@ public void addFlush() {\n             }\n             do {\n                 flushed ++;\n-                if (!entry.promise.setUncancellable()) {\n-                    // Was cancelled so make sure we free up memory and notify about the freed bytes\n-                    int pending = entry.cancel();\n-                    decrementPendingOutboundBytes(pending);\n-                }\n                 entry = entry.next;\n             } while (entry != null);\n \n@@ -226,23 +220,20 @@ public boolean remove() {\n \n         removeEntry(e);\n \n-        // only release message, notify and decrement if it was not canceled before.\n-        if (!e.cancelled) {\n-            // this save both checking against the ReferenceCounted interface\n-            // and makes better use of virtual calls vs interface ones\n-            if (msg instanceof AbstractReferenceCountedByteBuf) {\n-                try {\n-                    // release now as it is flushed.\n-                    ((AbstractReferenceCountedByteBuf) msg).release();\n-                } catch (Throwable t) {\n-                    logger.warn(\"Failed to release a ByteBuf: {}\", msg, t);\n-                }\n-            } else {\n-                ReferenceCountUtil.safeRelease(msg);\n+        // this save both checking against the ReferenceCounted interface\n+        // and makes better use of virtual calls vs interface ones\n+        if (msg instanceof AbstractReferenceCountedByteBuf) {\n+            try {\n+                // release now as it is flushed.\n+                ((AbstractReferenceCountedByteBuf) msg).release();\n+            } catch (Throwable t) {\n+                logger.warn(\"Failed to release a ByteBuf: {}\", msg, t);\n             }\n-            safeSuccess(promise);\n-            decrementPendingOutboundBytes(size);\n+        } else {\n+            ReferenceCountUtil.safeRelease(msg);\n         }\n+        safeSuccess(promise);\n+        decrementPendingOutboundBytes(size);\n \n         // recycle the entry\n         e.unguardedRecycle();\n@@ -269,13 +260,10 @@ public boolean remove(Throwable cause) {\n \n         removeEntry(e);\n \n-        if (!e.cancelled) {\n-            // only release message, fail and decrement if it was not canceled before.\n-            ReferenceCountUtil.safeRelease(msg);\n+        ReferenceCountUtil.safeRelease(msg);\n \n-            safeFail(promise, cause);\n-            decrementPendingOutboundBytes(size);\n-        }\n+        safeFail(promise, cause);\n+        decrementPendingOutboundBytes(size);\n \n         // recycle the entry\n         e.unguardedRecycle();\n@@ -374,53 +362,51 @@ public ByteBuffer[] nioBuffers(int maxCount, long maxBytes) {\n         ByteBuffer[] nioBuffers = NIO_BUFFERS.get(threadLocalMap);\n         Entry entry = flushedEntry;\n         while (isFlushedEntry(entry) && entry.msg instanceof ByteBuf) {\n-            if (!entry.cancelled) {\n-                ByteBuf buf = (ByteBuf) entry.msg;\n-                final int readerIndex = buf.readerIndex();\n-                final int readableBytes = buf.writerIndex() - readerIndex;\n-\n-                if (readableBytes > 0) {\n-                    if (maxBytes - readableBytes < nioBufferSize && nioBufferCount != 0) {\n-                        // If the nioBufferSize + readableBytes will overflow maxBytes, and there is at least one entry\n-                        // we stop populate the ByteBuffer array. This is done for 2 reasons:\n-                        // 1. bsd/osx don't allow to write more bytes then Integer.MAX_VALUE with one writev(...) call\n-                        // and so will return 'EINVAL', which will raise an IOException. On Linux it may work depending\n-                        // on the architecture and kernel but to be safe we also enforce the limit here.\n-                        // 2. There is no sense in putting more data in the array than is likely to be accepted by the\n-                        // OS.\n-                        //\n-                        // See also:\n-                        // - https://www.freebsd.org/cgi/man.cgi?query=write&sektion=2\n-                        // - https://linux.die.net//man/2/writev\n-                        break;\n-                    }\n-                    nioBufferSize += readableBytes;\n-                    int count = entry.count;\n-                    if (count == -1) {\n-                        //noinspection ConstantValueVariableUse\n-                        entry.count = count = buf.nioBufferCount();\n-                    }\n-                    int neededSpace = min(maxCount, nioBufferCount + count);\n-                    if (neededSpace > nioBuffers.length) {\n-                        nioBuffers = expandNioBufferArray(nioBuffers, neededSpace, nioBufferCount);\n-                        NIO_BUFFERS.set(threadLocalMap, nioBuffers);\n-                    }\n-                    if (count == 1) {\n-                        ByteBuffer nioBuf = entry.buf;\n-                        if (nioBuf == null) {\n-                            // cache ByteBuffer as it may need to create a new ByteBuffer instance if its a\n-                            // derived buffer\n-                            entry.buf = nioBuf = buf.internalNioBuffer(readerIndex, readableBytes);\n-                        }\n-                        nioBuffers[nioBufferCount++] = nioBuf;\n-                    } else {\n-                        // The code exists in an extra method to ensure the method is not too big to inline as this\n-                        // branch is not very likely to get hit very frequently.\n-                        nioBufferCount = nioBuffers(entry, buf, nioBuffers, nioBufferCount, maxCount);\n-                    }\n-                    if (nioBufferCount >= maxCount) {\n-                        break;\n+            ByteBuf buf = (ByteBuf) entry.msg;\n+            final int readerIndex = buf.readerIndex();\n+            final int readableBytes = buf.writerIndex() - readerIndex;\n+\n+            if (readableBytes > 0) {\n+                if (maxBytes - readableBytes < nioBufferSize && nioBufferCount != 0) {\n+                    // If the nioBufferSize + readableBytes will overflow maxBytes, and there is at least one entry\n+                    // we stop populate the ByteBuffer array. This is done for 2 reasons:\n+                    // 1. bsd/osx don't allow to write more bytes then Integer.MAX_VALUE with one writev(...) call\n+                    // and so will return 'EINVAL', which will raise an IOException. On Linux it may work depending\n+                    // on the architecture and kernel but to be safe we also enforce the limit here.\n+                    // 2. There is no sense in putting more data in the array than is likely to be accepted by the\n+                    // OS.\n+                    //\n+                    // See also:\n+                    // - https://www.freebsd.org/cgi/man.cgi?query=write&sektion=2\n+                    // - https://linux.die.net//man/2/writev\n+                    break;\n+                }\n+                nioBufferSize += readableBytes;\n+                int count = entry.count;\n+                if (count == -1) {\n+                    //noinspection ConstantValueVariableUse\n+                    entry.count = count = buf.nioBufferCount();\n+                }\n+                int neededSpace = min(maxCount, nioBufferCount + count);\n+                if (neededSpace > nioBuffers.length) {\n+                    nioBuffers = expandNioBufferArray(nioBuffers, neededSpace, nioBufferCount);\n+                    NIO_BUFFERS.set(threadLocalMap, nioBuffers);\n+                }\n+                if (count == 1) {\n+                    ByteBuffer nioBuf = entry.buf;\n+                    if (nioBuf == null) {\n+                        // cache ByteBuffer as it may need to create a new ByteBuffer instance if its a\n+                        // derived buffer\n+                        entry.buf = nioBuf = buf.internalNioBuffer(readerIndex, readableBytes);\n                     }\n+                    nioBuffers[nioBufferCount++] = nioBuf;\n+                } else {\n+                    // The code exists in an extra method to ensure the method is not too big to inline as this\n+                    // branch is not very likely to get hit very frequently.\n+                    nioBufferCount = nioBuffers(entry, buf, nioBuffers, nioBufferCount, maxCount);\n+                }\n+                if (nioBufferCount >= maxCount) {\n+                    break;\n                 }\n             }\n             entry = entry.next;\n@@ -560,10 +546,8 @@ public void run() {\n                 int size = e.pendingSize;\n                 decrementPendingOutboundBytes(size);\n \n-                if (!e.cancelled) {\n-                    ReferenceCountUtil.safeRelease(e.msg);\n-                    safeFail(e.promise, cause);\n-                }\n+                ReferenceCountUtil.safeRelease(e.msg);\n+                safeFail(e.promise, cause);\n                 e = e.unguardedRecycleAndGetNext();\n             }\n         } finally {\n@@ -603,10 +587,8 @@ public void forEachFlushedMessage(MessageProcessor processor) throws Exception {\n         }\n \n         do {\n-            if (!entry.cancelled) {\n-                if (!processor.processMessage(entry.msg)) {\n-                    return;\n-                }\n+            if (!processor.processMessage(entry.msg)) {\n+                return;\n             }\n             entry = entry.next;\n         } while (isFlushedEntry(entry));\n@@ -642,7 +624,6 @@ protected Entry newObject(Handle<Entry> handle) {\n         long total;\n         int pendingSize;\n         int count = -1;\n-        boolean cancelled;\n \n         private Entry(Handle<Entry> handle) {\n             this.handle = (EnhancedHandle<Entry>) handle;\n@@ -657,25 +638,6 @@ static Entry newInstance(Object msg, int size, long total, Promise<Void> promise\n             return entry;\n         }\n \n-        int cancel() {\n-            if (!cancelled) {\n-                cancelled = true;\n-                int pSize = pendingSize;\n-\n-                // release message and replace with an empty buffer\n-                ReferenceCountUtil.safeRelease(msg);\n-                msg = Unpooled.EMPTY_BUFFER;\n-\n-                pendingSize = 0;\n-                total = 0;\n-                progress = 0;\n-                bufs = null;\n-                buf = null;\n-                return pSize;\n-            }\n-            return 0;\n-        }\n-\n         void unguardedRecycle() {\n             next = null;\n             bufs = null;\n@@ -686,7 +648,6 @@ void unguardedRecycle() {\n             total = 0;\n             pendingSize = 0;\n             count = -1;\n-            cancelled = false;\n             handle.unguardedRecycle(this);\n         }\n \ndiff --git a/transport/src/main/java/io/netty/channel/DelegatingChannelPromiseNotifier.java b/transport/src/main/java/io/netty/channel/DelegatingChannelPromiseNotifier.java\nindex 7d17d528e84..866b21fee64 100644\n--- a/transport/src/main/java/io/netty/channel/DelegatingChannelPromiseNotifier.java\n+++ b/transport/src/main/java/io/netty/channel/DelegatingChannelPromiseNotifier.java\n@@ -94,11 +94,6 @@ public boolean tryFailure(Throwable cause) {\n         return delegate.tryFailure(cause);\n     }\n \n-    @Override\n-    public boolean setUncancellable() {\n-        return delegate.setUncancellable();\n-    }\n-\n     @Override\n     public Promise<Void> await() throws InterruptedException {\n         delegate.await();\n",
  "test_patch" : "diff --git a/common/src/test/java/io/netty/util/concurrent/DefaultPromiseTest.java b/common/src/test/java/io/netty/util/concurrent/DefaultPromiseTest.java\nindex 8e8f0a360a3..187e7275102 100644\n--- a/common/src/test/java/io/netty/util/concurrent/DefaultPromiseTest.java\n+++ b/common/src/test/java/io/netty/util/concurrent/DefaultPromiseTest.java\n@@ -141,7 +141,12 @@ public void execute(Runnable command) {\n     public void testCancelDoesNotScheduleWhenNoListeners() {\n         EventExecutor executor = new RejectingEventExecutor();\n \n-        Promise<Void> promise = new DefaultPromise<Void>(executor);\n+        Promise<Void> promise = new DefaultPromise<Void>(executor) {\n+            @Override\n+            boolean isCancellationSupported() {\n+                return true;\n+            }\n+        };\n         assertTrue(promise.cancel(false));\n         assertTrue(promise.isCancelled());\n     }\n@@ -168,7 +173,12 @@ public void testFailureDoesNotScheduleWhenNoListeners() {\n \n     @Test\n     public void testCancellationExceptionIsThrownWhenBlockingGet() {\n-        final Promise<Void> promise = new DefaultPromise<Void>(ImmediateEventExecutor.INSTANCE);\n+        final Promise<Void> promise = new DefaultPromise<Void>(ImmediateEventExecutor.INSTANCE) {\n+            @Override\n+            boolean isCancellationSupported() {\n+                return true;\n+            }\n+        };\n         assertTrue(promise.cancel(false));\n         assertThrows(CancellationException.class, new Executable() {\n             @Override\n@@ -180,7 +190,12 @@ public void execute() throws Throwable {\n \n     @Test\n     public void testCancellationExceptionIsThrownWhenBlockingGetWithTimeout() {\n-        final Promise<Void> promise = new DefaultPromise<Void>(ImmediateEventExecutor.INSTANCE);\n+        final Promise<Void> promise = new DefaultPromise<Void>(ImmediateEventExecutor.INSTANCE) {\n+            @Override\n+            boolean isCancellationSupported() {\n+                return true;\n+            }\n+        };\n         assertTrue(promise.cancel(false));\n         assertThrows(CancellationException.class, new Executable() {\n             @Override\n@@ -191,10 +206,10 @@ public void execute() throws Throwable {\n     }\n \n     @Test\n-    public void testCancellationExceptionIsReturnedAsCause() {\n+    public void testCancellation() {\n         final Promise<Void> promise = new DefaultPromise<Void>(ImmediateEventExecutor.INSTANCE);\n-        assertTrue(promise.cancel(false));\n-        assertThat(promise.cause()).isInstanceOf(CancellationException.class);\n+        assertFalse(promise.cancel(false));\n+        assertNull(promise.cause());\n     }\n \n     @Test\n@@ -378,22 +393,6 @@ public void signalSuccessCompletionValue() {\n         assertTrue(promise.isSuccess());\n     }\n \n-    @Test\n-    public void setUncancellableGetNow() {\n-        final Promise<String> promise = new DefaultPromise<String>(ImmediateEventExecutor.INSTANCE);\n-        assertNull(promise.getNow());\n-        assertTrue(promise.setUncancellable());\n-        assertNull(promise.getNow());\n-        assertFalse(promise.isDone());\n-        assertFalse(promise.isSuccess());\n-\n-        promise.setSuccess(\"success\");\n-\n-        assertTrue(promise.isDone());\n-        assertTrue(promise.isSuccess());\n-        assertEquals(\"success\", promise.getNow());\n-    }\n-\n     private static void testStackOverFlowChainedFuturesA(int promiseChainLength, final EventExecutor executor,\n                                                          boolean runTestInExecutorThread)\n             throws InterruptedException {\ndiff --git a/common/src/test/java/io/netty/util/concurrent/PromiseNotifierTest.java b/common/src/test/java/io/netty/util/concurrent/PromiseNotifierTest.java\nindex b3baf39003d..554c557444e 100644\n--- a/common/src/test/java/io/netty/util/concurrent/PromiseNotifierTest.java\n+++ b/common/src/test/java/io/netty/util/concurrent/PromiseNotifierTest.java\n@@ -97,8 +97,18 @@ public void testListenerFailure() throws Exception {\n \n     @Test\n     public void testCancelPropagationWhenFusedFromFuture() {\n-        Promise<Void> p1 = ImmediateEventExecutor.INSTANCE.newPromise();\n-        Promise<Void> p2 = ImmediateEventExecutor.INSTANCE.newPromise();\n+        Promise<Void> p1 = new DefaultPromise<>(ImmediateEventExecutor.INSTANCE) {\n+            @Override\n+            boolean isCancellationSupported() {\n+                return true;\n+            }\n+        };\n+        Promise<Void> p2 = new DefaultPromise<>(ImmediateEventExecutor.INSTANCE) {\n+            @Override\n+            boolean isCancellationSupported() {\n+                return true;\n+            }\n+        };\n \n         Future<Void> returned = PromiseNotifier.cascade(p1, p2);\n         assertSame(p1, returned);\ndiff --git a/handler/src/test/java/io/netty/handler/ssl/CipherSuiteCanaryTest.java b/handler/src/test/java/io/netty/handler/ssl/CipherSuiteCanaryTest.java\nindex 5447724a9dd..29ddf070820 100644\n--- a/handler/src/test/java/io/netty/handler/ssl/CipherSuiteCanaryTest.java\n+++ b/handler/src/test/java/io/netty/handler/ssl/CipherSuiteCanaryTest.java\n@@ -160,7 +160,7 @@ protected void initChannel(Channel ch) throws Exception {\n                         pipeline.addLast(new SimpleChannelInboundHandler<Object>() {\n                             @Override\n                             public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n-                                serverPromise.cancel(true);\n+                                serverPromise.tryFailure(new IllegalStateException());\n                                 ctx.fireChannelInactive();\n                             }\n \n@@ -196,7 +196,7 @@ protected void initChannel(Channel ch) throws Exception {\n                             pipeline.addLast(new SimpleChannelInboundHandler<Object>() {\n                                 @Override\n                                 public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n-                                    clientPromise.cancel(true);\n+                                    clientPromise.tryFailure(new IllegalStateException());\n                                     ctx.fireChannelInactive();\n                                 }\n \ndiff --git a/handler/src/test/java/io/netty/handler/ssl/OpenSslPrivateKeyMethodTest.java b/handler/src/test/java/io/netty/handler/ssl/OpenSslPrivateKeyMethodTest.java\nindex c7b29ad799a..06984a3b505 100644\n--- a/handler/src/test/java/io/netty/handler/ssl/OpenSslPrivateKeyMethodTest.java\n+++ b/handler/src/test/java/io/netty/handler/ssl/OpenSslPrivateKeyMethodTest.java\n@@ -246,7 +246,7 @@ protected void initChannel(Channel ch) {\n                         pipeline.addLast(new SimpleChannelInboundHandler<Object>() {\n                             @Override\n                             public void channelInactive(ChannelHandlerContext ctx) {\n-                                serverPromise.cancel(true);\n+                                serverPromise.tryFailure(new IllegalStateException());\n                                 ctx.fireChannelInactive();\n                             }\n \n@@ -282,7 +282,7 @@ protected void initChannel(Channel ch) {\n                             pipeline.addLast(new SimpleChannelInboundHandler<Object>() {\n                                 @Override\n                                 public void channelInactive(ChannelHandlerContext ctx) {\n-                                    clientPromise.cancel(true);\n+                                    clientPromise.tryFailure(new IllegalStateException());\n                                     ctx.fireChannelInactive();\n                                 }\n \ndiff --git a/handler/src/test/java/io/netty/handler/ssl/SniHandlerTest.java b/handler/src/test/java/io/netty/handler/ssl/SniHandlerTest.java\nindex 58a844c271f..a893a468704 100644\n--- a/handler/src/test/java/io/netty/handler/ssl/SniHandlerTest.java\n+++ b/handler/src/test/java/io/netty/handler/ssl/SniHandlerTest.java\n@@ -549,7 +549,7 @@ public void handlerRemoved0(ChannelHandlerContext ctx) throws Exception {\n                             } finally {\n                                 if (!success) {\n                                     ReferenceCountUtil.safeRelease(sslContext);\n-                                    releasePromise.cancel(true);\n+                                    releasePromise.tryFailure(new IllegalStateException());\n                                 }\n                             }\n                         }\ndiff --git a/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java b/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java\nindex fd16adab48a..56e91009748 100644\n--- a/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java\n+++ b/resolver-dns/src/test/java/io/netty/resolver/dns/DnsNameResolverTest.java\n@@ -3595,48 +3595,6 @@ public DatagramChannel newChannel(EventLoop eventLoop) {\n         }\n     }\n \n-    @ParameterizedTest\n-    @EnumSource(DnsNameResolverChannelStrategy.class)\n-    public void testCancelPromise(DnsNameResolverChannelStrategy strategy) throws Exception {\n-        final EventLoop eventLoop = group.next();\n-        final Promise<InetAddress> promise = eventLoop.newPromise();\n-        final TestDnsServer dnsServer1 = new TestDnsServer(Collections.<String>emptySet()) {\n-            @Override\n-            protected DnsMessage filterMessage(DnsMessage message) {\n-                promise.cancel(true);\n-                return message;\n-            }\n-        };\n-        dnsServer1.start();\n-        final AtomicBoolean isQuerySentToSecondServer = new AtomicBoolean();\n-        final TestDnsServer dnsServer2 = new TestDnsServer(Collections.<String>emptySet()) {\n-            @Override\n-            protected DnsMessage filterMessage(DnsMessage message) {\n-                isQuerySentToSecondServer.set(true);\n-                return message;\n-            }\n-        };\n-        dnsServer2.start();\n-        DnsServerAddressStreamProvider nameServerProvider =\n-                new SequentialDnsServerAddressStreamProvider(dnsServer1.localAddress(),\n-                                                             dnsServer2.localAddress());\n-        final DnsNameResolver resolver = new DnsNameResolverBuilder(group.next())\n-                .dnsQueryLifecycleObserverFactory(new TestRecursiveCacheDnsQueryLifecycleObserverFactory())\n-                .datagramChannelType(NioDatagramChannel.class)\n-                .optResourceEnabled(false)\n-                .nameServerProvider(nameServerProvider)\n-                .datagramChannelStrategy(strategy)\n-                .build();\n-\n-        try {\n-            resolver.resolve(\"non-existent.netty.io\", promise).sync();\n-            fail();\n-        } catch (Exception e) {\n-            assertInstanceOf(CancellationException.class, e);\n-        }\n-        assertFalse(isQuerySentToSecondServer.get());\n-    }\n-\n     @ParameterizedTest\n     @EnumSource(DnsNameResolverChannelStrategy.class)\n     public void testCNAMERecursiveResolveDifferentNameServersForDomains(DnsNameResolverChannelStrategy strategy)\ndiff --git a/testsuite/src/main/java/io/netty/testsuite/transport/socket/SocketCancelWriteTest.java b/testsuite/src/main/java/io/netty/testsuite/transport/socket/SocketCancelWriteTest.java\ndeleted file mode 100644\nindex d9c32563c86..00000000000\n--- a/testsuite/src/main/java/io/netty/testsuite/transport/socket/SocketCancelWriteTest.java\n+++ /dev/null\n@@ -1,128 +0,0 @@\n-/*\n- * Copyright 2014 The Netty Project\n- *\n- * The Netty Project licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-package io.netty.testsuite.transport.socket;\n-\n-import io.netty.bootstrap.Bootstrap;\n-import io.netty.bootstrap.ServerBootstrap;\n-import io.netty.buffer.ByteBuf;\n-import io.netty.buffer.Unpooled;\n-import io.netty.channel.Channel;\n-import io.netty.channel.ChannelHandlerContext;\n-import io.netty.channel.SimpleChannelInboundHandler;\n-\n-import java.util.concurrent.Future;\n-import java.util.concurrent.TimeUnit;\n-import org.junit.jupiter.api.Test;\n-import org.junit.jupiter.api.TestInfo;\n-import org.junit.jupiter.api.Timeout;\n-\n-import java.io.IOException;\n-import java.util.concurrent.atomic.AtomicReference;\n-\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n-import static org.junit.jupiter.api.Assertions.assertTrue;\n-\n-public class SocketCancelWriteTest extends AbstractSocketTest {\n-\n-    @Test\n-    @Timeout(value = 30000, unit = TimeUnit.MILLISECONDS)\n-    public void testCancelWrite(TestInfo testInfo) throws Throwable {\n-        run(testInfo, new Runner<ServerBootstrap, Bootstrap>() {\n-            @Override\n-            public void run(ServerBootstrap serverBootstrap, Bootstrap bootstrap) throws Throwable {\n-                testCancelWrite(serverBootstrap, bootstrap);\n-            }\n-        });\n-    }\n-\n-    public void testCancelWrite(ServerBootstrap sb, Bootstrap cb) throws Throwable {\n-        final TestHandler sh = new TestHandler();\n-        final TestHandler ch = new TestHandler();\n-        final ByteBuf a = Unpooled.buffer().writeByte('a');\n-        final ByteBuf b = Unpooled.buffer().writeByte('b');\n-        final ByteBuf c = Unpooled.buffer().writeByte('c');\n-        final ByteBuf d = Unpooled.buffer().writeByte('d');\n-        final ByteBuf e = Unpooled.buffer().writeByte('e');\n-\n-        cb.handler(ch);\n-        sb.childHandler(sh);\n-\n-        Channel sc = sb.bind().get();\n-        Channel cc = cb.connect(sc.localAddress()).get();\n-\n-        Future<Void> f = cc.write(a);\n-        assertTrue(f.cancel(false));\n-        cc.writeAndFlush(b);\n-        cc.write(c);\n-        Future<Void> f2 = cc.write(d);\n-        assertTrue(f2.cancel(false));\n-        cc.writeAndFlush(e);\n-\n-        while (sh.counter < 3) {\n-            if (sh.exception.get() != null) {\n-                break;\n-            }\n-            if (ch.exception.get() != null) {\n-                break;\n-            }\n-            Thread.sleep(50);\n-        }\n-        sh.channel.close().sync();\n-        ch.channel.close().sync();\n-        sc.close().sync();\n-\n-        if (sh.exception.get() != null && !(sh.exception.get() instanceof IOException)) {\n-            throw sh.exception.get();\n-        }\n-        if (sh.exception.get() != null) {\n-            throw sh.exception.get();\n-        }\n-        if (ch.exception.get() != null && !(ch.exception.get() instanceof IOException)) {\n-            throw ch.exception.get();\n-        }\n-        if (ch.exception.get() != null) {\n-            throw ch.exception.get();\n-        }\n-        assertEquals(0, ch.counter);\n-        assertEquals(Unpooled.wrappedBuffer(new byte[]{'b', 'c', 'e'}), sh.received);\n-    }\n-\n-    private static class TestHandler extends SimpleChannelInboundHandler<ByteBuf> {\n-        volatile Channel channel;\n-        final AtomicReference<Throwable> exception = new AtomicReference<Throwable>();\n-        volatile int counter;\n-        final ByteBuf received = Unpooled.buffer();\n-        @Override\n-        public void channelActive(ChannelHandlerContext ctx)\n-                throws Exception {\n-            channel = ctx.channel();\n-        }\n-\n-        @Override\n-        public void channelRead0(ChannelHandlerContext ctx, ByteBuf in) throws Exception {\n-            counter += in.readableBytes();\n-            received.writeBytes(in);\n-        }\n-\n-        @Override\n-        public void exceptionCaught(ChannelHandlerContext ctx,\n-                Throwable cause) throws Exception {\n-            if (exception.compareAndSet(null, cause)) {\n-                ctx.close();\n-            }\n-        }\n-    }\n-}\ndiff --git a/testsuite/src/main/java/io/netty/testsuite/transport/socket/SocketConnectionAttemptTest.java b/testsuite/src/main/java/io/netty/testsuite/transport/socket/SocketConnectionAttemptTest.java\nindex a0a574ceacc..a8588e67e93 100644\n--- a/testsuite/src/main/java/io/netty/testsuite/transport/socket/SocketConnectionAttemptTest.java\n+++ b/testsuite/src/main/java/io/netty/testsuite/transport/socket/SocketConnectionAttemptTest.java\n@@ -22,7 +22,6 @@\n import io.netty.channel.ChannelInboundHandler;\n import io.netty.channel.ChannelOption;\n import io.netty.util.concurrent.Future;\n-import io.netty.util.internal.SocketUtils;\n import io.netty.util.NetUtil;\n import io.netty.util.concurrent.GlobalEventExecutor;\n import io.netty.util.concurrent.Promise;\n@@ -31,9 +30,7 @@\n import org.junit.jupiter.api.TestInfo;\n import org.junit.jupiter.api.Timeout;\n \n-import java.io.IOException;\n import java.net.ConnectException;\n-import java.net.Socket;\n import java.util.concurrent.TimeUnit;\n \n import static io.netty.testsuite.transport.socket.SocketTestPermutation.BAD_HOST;\n@@ -42,8 +39,6 @@\n import static org.junit.jupiter.api.Assertions.assertInstanceOf;\n import static org.junit.jupiter.api.Assertions.assertNull;\n import static org.junit.jupiter.api.Assertions.assertTrue;\n-import static org.junit.jupiter.api.Assertions.fail;\n-import static org.junit.jupiter.api.Assumptions.assumeTrue;\n \n public class SocketConnectionAttemptTest extends AbstractClientSocketTest {\n \n@@ -116,61 +111,6 @@ public void channelActive(ChannelHandlerContext ctx) throws Exception {\n         assertNull(errorPromise.cause());\n     }\n \n-    @Test\n-    public void testConnectCancellation(TestInfo testInfo) throws Throwable {\n-        // Check if the test can be executed or should be skipped because of no network/internet connection\n-        // See https://github.com/netty/netty/issues/1474\n-        boolean badHostTimedOut = true;\n-        Socket socket = new Socket();\n-        try {\n-            SocketUtils.connect(socket, SocketUtils.socketAddress(BAD_HOST, BAD_PORT), 10);\n-        } catch (ConnectException e) {\n-            badHostTimedOut = false;\n-            // is thrown for no route to host when using Socket connect\n-        } catch (Exception e) {\n-            // ignore\n-        } finally {\n-            try {\n-                socket.close();\n-            } catch (IOException e) {\n-                // ignore\n-            }\n-        }\n-\n-        assumeTrue(badHostTimedOut, \"The connection attempt to \" + BAD_HOST + \" does not time out.\");\n-\n-        run(testInfo, new Runner<Bootstrap>() {\n-            @Override\n-            public void run(Bootstrap bootstrap) throws Throwable {\n-                testConnectCancellation(bootstrap);\n-            }\n-        });\n-    }\n-\n-    public void testConnectCancellation(Bootstrap cb) throws Throwable {\n-        cb.handler(new TestHandler()).option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 4000);\n-        Future<Channel> future = cb.connect(BAD_HOST, BAD_PORT);\n-        try {\n-            if (future.await(1000)) {\n-                if (future.isSuccess()) {\n-                    fail(\"A connection attempt to \" + BAD_HOST + \" must not succeed.\");\n-                } else {\n-                    throw future.cause();\n-                }\n-            }\n-\n-            if (future.cancel(true)) {\n-                assertTrue(future.isCancelled());\n-            } else {\n-                fail();\n-            }\n-        } finally {\n-            if (future.isSuccess()) {\n-                future.getNow().close();\n-            }\n-        }\n-    }\n-\n     private static class TestHandler implements ChannelInboundHandler {\n         @Override\n         public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\ndiff --git a/transport/src/test/java/io/netty/channel/ChannelOutboundBufferTest.java b/transport/src/test/java/io/netty/channel/ChannelOutboundBufferTest.java\nindex 3692f777627..c0baa798617 100644\n--- a/transport/src/test/java/io/netty/channel/ChannelOutboundBufferTest.java\n+++ b/transport/src/test/java/io/netty/channel/ChannelOutboundBufferTest.java\n@@ -50,42 +50,6 @@ public void testEmptyNioBuffers() {\n         release(buffer);\n     }\n \n-    @Test\n-    public void testNioBuffersCancelledRemoveBytes() {\n-        TestChannel channel = new TestChannel();\n-        ChannelOutboundBuffer buffer = new ChannelOutboundBuffer(channel.executor());\n-        ByteBuf b1 = wrappedBuffer(new byte[] { 0 });\n-        int r1 = b1.readableBytes();\n-        Promise<Void> p1 = channel.newPromise();\n-        buffer.addMessage(b1, r1, p1);\n-\n-        ByteBuf b2 = wrappedBuffer(new byte[] { 0, 1 });\n-        int r2 = b2.readableBytes();\n-        Promise<Void> p2 = channel.newPromise();\n-        buffer.addMessage(b2, r2, p2);\n-        p2.cancel(false);\n-\n-        ByteBuf b3 = wrappedBuffer(new byte[] { 0 });\n-        int r3 = b3.readableBytes();\n-        Promise<Void> p3 = channel.newPromise();\n-        buffer.addMessage(b3, r3, p3);\n-        buffer.addFlush();\n-\n-        ByteBuffer[] buffers = buffer.nioBuffers();\n-        assertEquals(2, buffer.nioBufferCount());\n-        assertNotNull(buffers);\n-        assertEquals(r1, buffers[0].remaining());\n-        assertEquals(r3, buffers[1].remaining());\n-\n-        buffer.removeBytes(r1 + r3);\n-        assertEquals(0, b1.refCnt());\n-        assertEquals(0, b2.refCnt());\n-        assertEquals(0, b3.refCnt());\n-\n-        assertTrue(buffer.isEmpty());\n-        release(buffer);\n-    }\n-\n     @Test\n     public void testNioBuffersSingleBacked() {\n         TestChannel channel = new TestChannel();\ndiff --git a/transport/src/test/java/io/netty/channel/DefaultChannelPipelineTest.java b/transport/src/test/java/io/netty/channel/DefaultChannelPipelineTest.java\nindex 291c612cb19..cd930b5c1dc 100644\n--- a/transport/src/test/java/io/netty/channel/DefaultChannelPipelineTest.java\n+++ b/transport/src/test/java/io/netty/channel/DefaultChannelPipelineTest.java\n@@ -901,51 +901,6 @@ public void run() {\n         }).sync();\n     }\n \n-    // Tests for https://github.com/netty/netty/issues/2349\n-    @Test\n-    public void testCancelBind() {\n-        ChannelPipeline pipeline = new LocalChannel(group.next()).pipeline();\n-        pipeline.channel().register();\n-\n-        Promise<Void> promise = pipeline.channel().newPromise();\n-        assertTrue(promise.cancel(false));\n-        pipeline.bind(new LocalAddress(\"test\"), promise);\n-        assertTrue(promise.isCancelled());\n-    }\n-\n-    @Test\n-    public void testCancelConnect() {\n-        ChannelPipeline pipeline = new LocalChannel(group.next()).pipeline();\n-        pipeline.channel().register();\n-\n-        Promise<Void> promise = pipeline.channel().newPromise();\n-        assertTrue(promise.cancel(false));\n-        pipeline.connect(new LocalAddress(\"test\"), promise);\n-        assertTrue(promise.isCancelled());\n-    }\n-\n-    @Test\n-    public void testCancelDisconnect() {\n-        ChannelPipeline pipeline = new LocalChannel(group.next()).pipeline();\n-        pipeline.channel().register();\n-\n-        Promise<Void> promise = pipeline.channel().newPromise();\n-        assertTrue(promise.cancel(false));\n-        pipeline.disconnect(promise);\n-        assertTrue(promise.isCancelled());\n-    }\n-\n-    @Test\n-    public void testCancelClose() {\n-        ChannelPipeline pipeline = new LocalChannel(group.next()).pipeline();\n-        pipeline.channel().register();\n-\n-        Promise<Void> promise = pipeline.channel().newPromise();\n-        assertTrue(promise.cancel(false));\n-        pipeline.close(promise);\n-        assertTrue(promise.isCancelled());\n-    }\n-\n     @Test\n     public void testUnexpectedVoidChannelPromiseCloseFuture() throws Exception {\n         final ChannelPipeline pipeline = new LocalChannel(group.next()).pipeline();\n@@ -964,45 +919,6 @@ public void execute() {\n         }\n     }\n \n-    @Test\n-    public void testCancelDeregister() {\n-        ChannelPipeline pipeline = new LocalChannel(group.next()).pipeline();\n-        pipeline.channel().register();\n-\n-        Promise<Void> promise = pipeline.channel().newPromise();\n-        assertTrue(promise.cancel(false));\n-        pipeline.deregister(promise);\n-        assertTrue(promise.isCancelled());\n-    }\n-\n-    @Test\n-    public void testCancelWrite() {\n-        ChannelPipeline pipeline = new LocalChannel(group.next()).pipeline();\n-        pipeline.channel().register();\n-\n-        Promise<Void> promise = pipeline.channel().newPromise();\n-        assertTrue(promise.cancel(false));\n-        ByteBuf buffer = Unpooled.buffer();\n-        assertEquals(1, buffer.refCnt());\n-        pipeline.write(buffer, promise);\n-        assertTrue(promise.isCancelled());\n-        assertEquals(0, buffer.refCnt());\n-    }\n-\n-    @Test\n-    public void testCancelWriteAndFlush() {\n-        ChannelPipeline pipeline = new LocalChannel(group.next()).pipeline();\n-        pipeline.channel().register();\n-\n-        Promise<Void> promise = pipeline.channel().newPromise();\n-        assertTrue(promise.cancel(false));\n-        ByteBuf buffer = Unpooled.buffer();\n-        assertEquals(1, buffer.refCnt());\n-        pipeline.writeAndFlush(buffer, promise);\n-        assertTrue(promise.isCancelled());\n-        assertEquals(0, buffer.refCnt());\n-    }\n-\n     @Test\n     public void testFirstContextEmptyPipeline() {\n         ChannelPipeline pipeline = new LocalChannel(group.next()).pipeline();\n",
  "problem_statement" : "Only support cancellation for scheduled tasks\n\nMotivation:\r\n\r\nCancellation is really racy when done for io operations that also flow through the ChannelPipeline as usually handlers don't expect that someone will fail the promise from the outside (which is what happens with cancel) while they still use it. Let's only support cancellation for scheduled operations to make things easier to reason about and also less racy.\r\n\r\nModifications:\r\n\r\nDon't support cancellation for io operations\r\n\r\nResult:\r\n\r\nCleanup and less racy behaviour",
  "hints_text" : null,
  "created_at" : "Fri Jan 16 11:11:23 CET 2026",
  "version" : null,
  "FAIL_TO_PASS" : [ "SniHandlerTest", "CipherSuiteCanaryTest", "OpenSslPrivateKeyMethodTest", "ChannelOutboundBufferTest", "DefaultPromiseTest", "PromiseNotifierTest", "DnsNameResolverTest", "DefaultChannelPipelineTest", "SocketCancelWriteTest", "SocketConnectionAttemptTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -pl codec-classes-quic -Dtest=SniHandlerTest,CipherSuiteCanaryTest,OpenSslPrivateKeyMethodTest,ChannelOutboundBufferTest,DefaultPromiseTest,PromiseNotifierTest,DnsNameResolverTest,DefaultChannelPipelineTest,SocketCancelWriteTest,SocketConnectionAttemptTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 16143,
  "metadata" : null
}, {
  "instance_id" : "netty-netty-PR-16118",
  "repo" : "netty/netty",
  "base_commit" : "f84f78b0a6b5c61abb81068b142b009357e33c7a",
  "patch" : "diff --git a/handler-ssl-ocsp/src/main/java/io/netty/handler/ssl/ocsp/OcspClient.java b/handler-ssl-ocsp/src/main/java/io/netty/handler/ssl/ocsp/OcspClient.java\nindex e08ab32efb0..bf22bad57c5 100644\n--- a/handler-ssl-ocsp/src/main/java/io/netty/handler/ssl/ocsp/OcspClient.java\n+++ b/handler-ssl-ocsp/src/main/java/io/netty/handler/ssl/ocsp/OcspClient.java\n@@ -42,6 +42,7 @@\n import org.bouncycastle.asn1.x509.Extension;\n import org.bouncycastle.asn1.x509.Extensions;\n import org.bouncycastle.cert.X509CertificateHolder;\n+import org.bouncycastle.cert.jcajce.JcaX509CertificateConverter;\n import org.bouncycastle.cert.jcajce.JcaX509CertificateHolder;\n import org.bouncycastle.cert.ocsp.BasicOCSPResp;\n import org.bouncycastle.cert.ocsp.CertificateID;\n@@ -55,9 +56,22 @@\n \n import java.net.InetAddress;\n import java.net.URL;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.NoSuchAlgorithmException;\n import java.security.SecureRandom;\n+import java.security.cert.CertPathBuilder;\n+import java.security.cert.CertPathBuilderException;\n+import java.security.cert.CertStore;\n import java.security.cert.CertificateEncodingException;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CollectionCertStoreParameters;\n+import java.security.cert.PKIXBuilderParameters;\n+import java.security.cert.TrustAnchor;\n+import java.security.cert.X509CertSelector;\n import java.security.cert.X509Certificate;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n \n import static io.netty.handler.codec.http.HttpMethod.POST;\n import static io.netty.handler.codec.http.HttpVersion.HTTP_1_1;\n@@ -264,14 +278,83 @@ private static void validateNonce(BasicOCSPResp basicResponse, DEROctetString en\n     /**\n      * Validate OCSP response signature\n      */\n-    private static void validateSignature(BasicOCSPResp resp, X509Certificate certificate) throws OCSPException {\n+    static void validateSignature(BasicOCSPResp resp, X509Certificate issuerCertificate) throws OCSPException {\n         try {\n-            ContentVerifierProvider verifier = new JcaContentVerifierProviderBuilder().build(certificate);\n-            if (!resp.isSignatureValid(verifier)) {\n-                throw new OCSPException(\"OCSP signature is not valid\");\n+            X509CertificateHolder[] certs = resp.getCerts();\n+            JcaContentVerifierProviderBuilder providerBuilder = new JcaContentVerifierProviderBuilder();\n+\n+            // If responder certificate is included, validate the chain\n+            if (certs != null && certs.length > 0) {\n+\n+                // Use the first included certificate to verify the OCSP response signature.\n+                X509CertificateHolder responderCert = certs[0];\n+\n+                // Verify OCSP response signature using responder cert\n+                ContentVerifierProvider responderVerifier = providerBuilder.build(responderCert);\n+\n+                if (!resp.isSignatureValid(responderVerifier)) {\n+                    throw new OCSPException(\"OCSP response signature is not valid\");\n+                }\n+\n+                // Build chain from responder certificate to issuer using CertPathBuilder\n+                validateCertificateChain(responderCert, certs, issuerCertificate);\n+            } else {\n+                // Validate signature using issuer certificate\n+                ContentVerifierProvider issuerVerifier = providerBuilder.build(issuerCertificate);\n+\n+                if (!resp.isSignatureValid(issuerVerifier)) {\n+                    throw new OCSPException(\"OCSP response signature is not valid\");\n+                }\n             }\n         } catch (OperatorCreationException e) {\n             throw new OCSPException(\"Error validating OCSP-Signature\", e);\n+        } catch (CertificateException e) {\n+            throw new OCSPException(\"Error while processing certificates for OCSP signature validation\", e);\n+        }\n+    }\n+\n+    /**\n+     * Validates that a certificate chain can be built from the responder certificate to the issuer.\n+     * Uses Java's CertPathBuilder to construct and validate the chain.\n+     */\n+    private static void validateCertificateChain(X509CertificateHolder responderCert,\n+                                                   X509CertificateHolder[] allCerts,\n+                                                   X509Certificate issuerCertificate) throws OCSPException {\n+        try {\n+            // Convert BouncyCastle certificate holders to Java X509Certificates\n+            List<X509Certificate> certList = new ArrayList<>(allCerts.length);\n+            for (X509CertificateHolder certHolder : allCerts) {\n+                certList.add(new JcaX509CertificateConverter().getCertificate(certHolder));\n+            }\n+\n+            // Create a CertStore with all the certificates from the OCSP response\n+            CertStore certStore = CertStore.getInstance(\"Collection\",\n+                    new CollectionCertStoreParameters(certList));\n+\n+            // Set up the target certificate selector for the responder certificate\n+            X509CertSelector targetConstraints = new X509CertSelector();\n+            targetConstraints.setCertificate(new JcaX509CertificateConverter().getCertificate(responderCert));\n+\n+            // Set up trust anchor with the issuer certificate\n+            TrustAnchor trustAnchor = new TrustAnchor(issuerCertificate, null);\n+\n+            // Build PKIX parameters\n+            PKIXBuilderParameters pkixParams = new PKIXBuilderParameters(\n+                    Collections.singleton(trustAnchor), targetConstraints);\n+            pkixParams.addCertStore(certStore);\n+            pkixParams.setRevocationEnabled(false); // Don't check revocation when validating OCSP response\n+\n+            // Build and validate the certificate path\n+            CertPathBuilder builder = CertPathBuilder.getInstance(\"PKIX\");\n+            builder.build(pkixParams);\n+\n+            // If we reach here, the chain is valid\n+        } catch (CertPathBuilderException e) {\n+            throw new OCSPException(\"OCSP responder certificate is not trusted by issuer: \" + e.getMessage(), e);\n+        } catch (InvalidAlgorithmParameterException | NoSuchAlgorithmException e) {\n+            throw new OCSPException(\"Error setting up certificate path validation\", e);\n+        } catch (CertificateException e) {\n+            throw new OCSPException(\"Error converting certificates for path validation\", e);\n         }\n     }\n \n",
  "test_patch" : "diff --git a/handler-ssl-ocsp/src/test/java/io/netty/handler/ssl/ocsp/OcspClientTest.java b/handler-ssl-ocsp/src/test/java/io/netty/handler/ssl/ocsp/OcspClientTest.java\nindex 08ed2bba9af..fba2257e864 100644\n--- a/handler-ssl-ocsp/src/test/java/io/netty/handler/ssl/ocsp/OcspClientTest.java\n+++ b/handler-ssl-ocsp/src/test/java/io/netty/handler/ssl/ocsp/OcspClientTest.java\n@@ -15,26 +15,44 @@\n  */\n package io.netty.handler.ssl.ocsp;\n \n+import io.netty.pkitesting.CertificateBuilder;\n+import io.netty.pkitesting.X509Bundle;\n import io.netty.util.concurrent.Promise;\n+import org.bouncycastle.cert.X509CertificateHolder;\n+import org.bouncycastle.cert.jcajce.JcaX509CertificateHolder;\n import org.bouncycastle.cert.ocsp.BasicOCSPResp;\n+import org.bouncycastle.cert.ocsp.BasicOCSPRespBuilder;\n+import org.bouncycastle.cert.ocsp.CertificateID;\n+import org.bouncycastle.cert.ocsp.CertificateStatus;\n+import org.bouncycastle.cert.ocsp.OCSPException;\n+import org.bouncycastle.cert.ocsp.RespID;\n+import org.bouncycastle.operator.ContentSigner;\n+import org.bouncycastle.operator.jcajce.JcaContentSignerBuilder;\n+import org.bouncycastle.operator.jcajce.JcaDigestCalculatorProviderBuilder;\n import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n \n import javax.net.ssl.HttpsURLConnection;\n import java.io.IOException;\n import java.net.URL;\n import java.security.cert.X509Certificate;\n+import java.util.Date;\n import java.util.concurrent.ExecutionException;\n \n import static io.netty.handler.ssl.ocsp.OcspServerCertificateValidator.createDefaultResolver;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n \n class OcspClientTest extends AbstractOcspTest {\n \n-    @Test\n-    void simpleOcspQueryTest() throws IOException, ExecutionException, InterruptedException {\n+    @ParameterizedTest\n+    @ValueSource(strings = {\"https://netty.io\", \"https://apple.com\"})\n+    void simpleOcspQueryTest(String urlString) throws IOException, ExecutionException, InterruptedException {\n         HttpsURLConnection httpsConnection = null;\n         try {\n-            URL url = new URL(\"https://netty.io\");\n+            URL url = new URL(urlString);\n             httpsConnection = (HttpsURLConnection) url.openConnection();\n             httpsConnection.connect();\n \n@@ -55,4 +73,108 @@ void simpleOcspQueryTest() throws IOException, ExecutionException, InterruptedEx\n             }\n         }\n     }\n+\n+    @Test\n+    void validateSignatureWithIncludedChainSucceeds() throws Exception {\n+        X509Bundle rootIssuer = new CertificateBuilder()\n+                .algorithm(CertificateBuilder.Algorithm.rsa2048)\n+                .subject(\"CN=SomeRootCA\")\n+                .setIsCertificateAuthority(true)\n+                .buildSelfSigned();\n+\n+        X509Bundle intermediateIssuer = new CertificateBuilder()\n+                .algorithm(CertificateBuilder.Algorithm.rsa2048)\n+                .subject(\"CN=SomeIntermediateCA\")\n+                .setIsCertificateAuthority(true)\n+                .buildIssuedBy(rootIssuer);\n+\n+        X509Bundle ocspResponder = new CertificateBuilder()\n+                .algorithm(CertificateBuilder.Algorithm.rsa2048)\n+                .subject(\"CN=SomeOCSPResponder\")\n+                .buildIssuedBy(intermediateIssuer);\n+\n+        // Create actual OCSP response with the responder's certificate\n+        X509CertificateHolder responderHolder = new JcaX509CertificateHolder(ocspResponder.getCertificate());\n+        X509CertificateHolder intermediateHolder = new JcaX509CertificateHolder(intermediateIssuer.getCertificate());\n+\n+        // Create a minimal BasicOCSPResp that contains the certificate chain\n+        BasicOCSPResp resp = createBasicOcspResponse(\n+                ocspResponder,\n+                new X509CertificateHolder[]{responderHolder, intermediateHolder}\n+        );\n+\n+        assertDoesNotThrow(() -> OcspClient.validateSignature(resp, rootIssuer.getCertificate()));\n+    }\n+\n+    @Test\n+    void validateSignatureWithInvalidChainThrows() throws Exception {\n+        // Build an unrelated responder chain so nothing is signed by the provided issuer (using RSA)\n+        X509Bundle issuerBundle = new CertificateBuilder()\n+                .algorithm(CertificateBuilder.Algorithm.rsa2048)\n+                .subject(\"CN=Issuer\")\n+                .setIsCertificateAuthority(true)\n+                .buildSelfSigned();\n+\n+        // Different CA\n+        X509Bundle otherRoot = new CertificateBuilder()\n+                .algorithm(CertificateBuilder.Algorithm.rsa2048)\n+                .subject(\"CN=SomeRootCA\")\n+                .setIsCertificateAuthority(true)\n+                .buildSelfSigned();\n+\n+        X509Bundle otherIntermediate = new CertificateBuilder()\n+                .algorithm(CertificateBuilder.Algorithm.rsa2048)\n+                .subject(\"CN=SomeIntermediateCA\")\n+                .setIsCertificateAuthority(true)\n+                .buildIssuedBy(otherRoot);\n+\n+        X509Bundle otherResponder = new CertificateBuilder()\n+                .algorithm(CertificateBuilder.Algorithm.rsa2048)\n+                .subject(\"CN=SomeResponder\")\n+                .buildIssuedBy(otherIntermediate);\n+\n+        X509CertificateHolder responderHolder = new JcaX509CertificateHolder(otherResponder.getCertificate());\n+        X509CertificateHolder intermediateHolder = new JcaX509CertificateHolder(otherIntermediate.getCertificate());\n+\n+        // Create actual OCSP response with untrusted chain\n+        BasicOCSPResp resp = createBasicOcspResponse(\n+                otherResponder,\n+                new X509CertificateHolder[]{responderHolder, intermediateHolder}\n+        );\n+\n+        assertThrows(OCSPException.class, () ->\n+                OcspClient.validateSignature(resp, issuerBundle.getCertificate())\n+        );\n+    }\n+\n+    private static BasicOCSPResp createBasicOcspResponse(X509Bundle responderBundle,\n+                                                         X509CertificateHolder[] certChain) throws Exception {\n+        X509Bundle dummyCert = new CertificateBuilder()\n+                .algorithm(CertificateBuilder.Algorithm.rsa2048)\n+                .subject(\"CN=DummyCert\")\n+                .setIsCertificateAuthority(true)\n+                .buildSelfSigned();\n+\n+        // Create certificate ID for OCSP response\n+        CertificateID certId = new CertificateID(\n+                new JcaDigestCalculatorProviderBuilder().build().get(CertificateID.HASH_SHA1),\n+                new JcaX509CertificateHolder(dummyCert.getCertificate()),\n+                dummyCert.getCertificate().getSerialNumber()\n+        );\n+\n+        // Create response builder with responder ID based on certificate\n+        X509CertificateHolder responderHolder = new JcaX509CertificateHolder(responderBundle.getCertificate());\n+        RespID respID = new RespID(responderHolder.getSubject());\n+\n+        BasicOCSPRespBuilder respBuilder = new BasicOCSPRespBuilder(respID);\n+\n+        // Add response for the certificate (status: good)\n+        respBuilder.addResponse(certId, CertificateStatus.GOOD);\n+\n+        // Build and sign the response with the responder's private key\n+        ContentSigner signer = new JcaContentSignerBuilder(\"SHA256withRSA\")\n+                .build(responderBundle.getKeyPair().getPrivate());\n+\n+        return respBuilder.build(signer, certChain, new Date());\n+    }\n }\n",
  "problem_statement" : "[The issuer of the server certificate](https://github.com/netty/netty/blob/4.2/handler-ssl-ocsp/src/main/java/io/netty/handler/ssl/ocsp/OcspServerCertificateValidator.java#L148) from the presumably successful TLS handshake is used to verify the [signature](https://github.com/netty/netty/blob/4.2/handler-ssl-ocsp/src/main/java/io/netty/handler/ssl/ocsp/OcspClient.java#L277) in the `BasicOCSPResponse`\n\n```\nBasicOCSPResponse       ::= SEQUENCE {\n   tbsResponseData      ResponseData,\n   signatureAlgorithm   AlgorithmIdentifier{SIGNATURE-ALGORITHM,\n                            {sa-dsaWithSHA1 | sa-rsaWithSHA1 |\n                                 sa-rsaWithMD5 | sa-rsaWithMD2, ...}},\n   signature            BIT STRING,\n   certs            [0] EXPLICIT SEQUENCE OF Certificate OPTIONAL }\n```\n\nThis is fine if there are no certificates in the `BasicOCSPResponse` but not if there is a specific private key for producing the signature above.\n\nChange `netty.io` to `apple.com` and then this [simpleOcspQueryTest](https://github.com/netty/netty/blob/4.2/handler-ssl-ocsp/src/test/java/io/netty/handler/ssl/ocsp/OcspClientTest.java#L37) fails.\n\nIf there are certificates in the response, one must determine whether one trusts the leaf of that chain because that is what produced the signature referenced in the data structure above.\n\nI believe I have correctly understood what is going on here but apologies if not.\n\nThis was a fun issue to investigate and I appreciate that you all have produced such high quality software. If I have correctly identified an issue, then I would be happy to give back to the netty developers.",
  "hints_text" : null,
  "created_at" : "Fri Jan 09 06:26:35 CET 2026",
  "version" : null,
  "FAIL_TO_PASS" : [ "OcspClientTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -pl handler-ssl-ocsp -Dtest=OcspClientTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : 15829,
  "pull_number" : 16118,
  "metadata" : null
}, {
  "instance_id" : "netty-netty-PR-16117",
  "repo" : "netty/netty",
  "base_commit" : "627c3b73926775df35aa288fdf9587f42f5fca4e",
  "patch" : "diff --git a/codec-http3/src/main/java/io/netty/handler/codec/http3/Http3ConnectionHandler.java b/codec-http3/src/main/java/io/netty/handler/codec/http3/Http3ConnectionHandler.java\nindex ff34fa29248..36aa5bdf76a 100644\n--- a/codec-http3/src/main/java/io/netty/handler/codec/http3/Http3ConnectionHandler.java\n+++ b/codec-http3/src/main/java/io/netty/handler/codec/http3/Http3ConnectionHandler.java\n@@ -71,8 +71,9 @@ public abstract class Http3ConnectionHandler extends ChannelInboundHandlerAdapte\n         }\n         Long maxFieldSectionSize = localSettings.get(Http3SettingsFrame.HTTP3_SETTINGS_MAX_FIELD_SECTION_SIZE);\n         if (maxFieldSectionSize == null) {\n-            // Just use the maximum value we can represent via a Long.\n-            maxFieldSectionSize = Long.MAX_VALUE;\n+             // Default value in rfc is unlimited\n+             // but Quic can have max 2^62-1 max value as TWO bits reserved for Variable-Length Integer Encoding\n+            maxFieldSectionSize = (1L << 62) - 1;\n         }\n         this.maxTableCapacity = localSettings.getOrDefault(HTTP3_SETTINGS_QPACK_MAX_TABLE_CAPACITY, 0);\n         int maxBlockedStreams = toIntExact(localSettings.getOrDefault(HTTP3_SETTINGS_QPACK_BLOCKED_STREAMS, 0));\n",
  "test_patch" : "diff --git a/codec-http3/src/test/java/io/netty/handler/codec/http3/EmbeddedQuicChannel.java b/codec-http3/src/test/java/io/netty/handler/codec/http3/EmbeddedQuicChannel.java\nindex dbc696219c7..3a43fd11577 100644\n--- a/codec-http3/src/test/java/io/netty/handler/codec/http3/EmbeddedQuicChannel.java\n+++ b/codec-http3/src/test/java/io/netty/handler/codec/http3/EmbeddedQuicChannel.java\n@@ -64,6 +64,16 @@ final class EmbeddedQuicChannel extends EmbeddedChannel implements QuicChannel {\n     private final ConcurrentLinkedQueue<Integer> closeErrorCodes = new ConcurrentLinkedQueue<>();\n     private QuicChannelConfig config;\n \n+    /**\n+     * TWO bits reserved for Variable-Length Integer Encoding\n+     * <a href=\"https://datatracker.ietf.org/doc/html/rfc9000?#name-variable-length-integer-enc\">rfc9000</a>\n+     * TWO LSB used for distinguish Client/Server initiated stream & Bi/unidirection\n+     * these are not reserved but part of it\n+     * <a href=\"https://datatracker.ietf.org/doc/html/rfc9000?#name-stream-types-and-identifier\">rfc9000</a>\n+     * so we can max stream per stream type (bi/uni) = (2^62-1)/2\n+     */\n+    private static final long MAX_PEER_STREAMS_PER_STREAM_TYPE = ((1L << 62) - 1) / 2;\n+\n     EmbeddedQuicChannel(boolean server) {\n         this(server, new ChannelHandler[0]);\n     }\n@@ -140,10 +150,13 @@ public QuicChannel read() {\n \n     @Override\n     public long peerAllowedStreams(QuicStreamType type) {\n-        return peerAllowedStreams.getOrDefault(type, Long.MAX_VALUE);\n+        return peerAllowedStreams.getOrDefault(type, MAX_PEER_STREAMS_PER_STREAM_TYPE);\n     }\n \n     public void peerAllowedStreams(QuicStreamType type, long peerAllowedStreams) {\n+        if (peerAllowedStreams > MAX_PEER_STREAMS_PER_STREAM_TYPE) {\n+            peerAllowedStreams = MAX_PEER_STREAMS_PER_STREAM_TYPE;\n+        }\n         this.peerAllowedStreams.put(type, peerAllowedStreams);\n     }\n \n",
  "problem_statement" : "Limit QUIC stream and field section sizes to protocol max\n\nUpdated the default maxFieldSectionSize in Http3ConnectionHandler to (2^62) - 1, aligning with QUIC variable-length integer limits defined in RFC 9000. Introduced MAX_PEER_STREAMS_PER_STREAM_TYPE in EmbeddedQuicChannel and enforced this maximum for peer allowed streams, ensuring compliance with QUIC stream identifier constraints.\r\n\r\n**Motivation**\r\nQUIC uses 62-bit variable-length integers, allowing values up to (2^62) - 1. The previous default did not fully reflect this limit.\r\nAdditionally, peer stream limits are applied per stream direction and initiator, but the current stream type model arbitrarily uses or allows Long.MAX_VALUE. This required enforcing a corrected maximum per stream type.\r\n\r\n**Modification**\r\nSet maxFieldSectionSize default to (2^62) - 1.\r\nIntroduced MAX_PEER_STREAMS_PER_STREAM_TYPE to ((1L << 62) - 1) / 2\r\nEnforced the maximum when storing peer allowed stream counts.\r\n\r\n**Result**\r\nAligns HTTP/3 settings and peer stream limits with RFC 9000 and prevents invalid stream allocations.",
  "hints_text" : null,
  "created_at" : "Thu Jan 08 19:43:31 CET 2026",
  "version" : null,
  "FAIL_TO_PASS" : [ "EmbeddedQuicChannel" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -pl codec-http3 -Dtest=EmbeddedQuicChannel",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 16117,
  "metadata" : null
} ]