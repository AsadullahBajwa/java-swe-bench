diff --git a/src/main/java/org/apache/commons/lang3/math/NumberUtils.java b/src/main/java/org/apache/commons/lang3/math/NumberUtils.java
index 2ef56f4d952..6abd66502a5 100644
--- a/src/main/java/org/apache/commons/lang3/math/NumberUtils.java
+++ b/src/main/java/org/apache/commons/lang3/math/NumberUtils.java
@@ -21,6 +21,7 @@
 import java.math.BigInteger;
 import java.math.RoundingMode;
 import java.util.Objects;
+import java.util.function.Consumer;
 
 import org.apache.commons.lang3.CharUtils;
 import org.apache.commons.lang3.StringUtils;
@@ -104,6 +105,15 @@ public class NumberUtils {
      */
     public static final Long LONG_INT_MIN_VALUE = Long.valueOf(Integer.MIN_VALUE);
 
+    private static <T> boolean accept(final Consumer<T> consumer, final T obj) {
+        try {
+            consumer.accept(obj);
+            return true;
+        } catch (Exception e) {
+            return false;
+        }
+    }
+
     /**
      * Compares two {@code byte} values numerically. This is the same functionality as provided in Java 7.
      *
@@ -167,7 +177,7 @@ public static int compare(final short x, final short y) {
      * Returns {@code null} if the string is {@code null}.
      * </p>
      *
-     * @param str a {@link String} to convert, may be null.
+     * @param str a {@link String} to convert, may be null.Return
      * @return converted {@link BigDecimal} (or null if the input is null).
      * @throws NumberFormatException if the value cannot be converted.
      */
@@ -730,7 +740,8 @@ public static boolean isNumber(final String str) {
      * </p>
      *
      * <p>
-     * Hexadecimal and scientific notations are <strong>not</strong> considered parsable. See {@link #isCreatable(String)} on those cases.
+     * Scientific notation (for example, {@code "1.2e-5"}) and type suffixes (e.g., {@code "2.0f"}, {@code "2.0d"}) are supported
+     * as they are valid for {@link Float#parseFloat(String)} and {@link Double#parseDouble(String)}.
      * </p>
      *
      * <p>
@@ -739,55 +750,14 @@ public static boolean isNumber(final String str) {
      *
      * @param str the String to check.
      * @return {@code true} if the string is a parsable number.
+     * @see Integer#parseInt(String)
+     * @see Long#parseLong(String)
+     * @see Double#parseDouble(String)
+     * @see Float#parseFloat(String)
      * @since 3.4
      */
     public static boolean isParsable(final String str) {
-        if (StringUtils.isEmpty(str)) {
-            return false;
-        }
-        if (str.charAt(0) == '-') {
-            if (str.length() == 1) {
-                return false;
-            }
-            return isParsableDecimal(str, 1);
-        }
-        return isParsableDecimal(str, 0);
-    }
-
-    /**
-     * Tests whether a number string is parsable as a decimal number or integer.
-     *
-     * <ul>
-     * <li>At most one decimal point is allowed.</li>
-     * <li>No signs, exponents or type qualifiers are allowed.</li>
-     * <li>Only ASCII digits are allowed if a decimal point is present.</li>
-     * </ul>
-     *
-     * @param str      the String to test.
-     * @param beginIdx the index to start checking from.
-     * @return {@code true} if the string is a parsable number.
-     */
-    private static boolean isParsableDecimal(final String str, final int beginIdx) {
-        // See https://docs.oracle.com/javase/specs/jls/se8/html/jls-3.html#jls-NonZeroDigit
-        int decimalPoints = 0;
-        boolean asciiNumeric = true;
-        for (int i = beginIdx; i < str.length(); i++) {
-            final char ch = str.charAt(i);
-            final boolean isDecimalPoint = ch == '.';
-            if (isDecimalPoint) {
-                decimalPoints++;
-            }
-            if (decimalPoints > 1 || !isDecimalPoint && !Character.isDigit(ch)) {
-                return false;
-            }
-            if (!isDecimalPoint) {
-                asciiNumeric &= CharUtils.isAsciiNumeric(ch);
-            }
-            if (decimalPoints > 0 && !asciiNumeric) {
-                return false;
-            }
-        }
-        return true;
+        return accept(Double::parseDouble, str) || accept(Long::parseLong, str) || accept(Float::parseFloat, str) || accept(Long::parseLong, str);
     }
 
     private static boolean isSign(final char ch) {
