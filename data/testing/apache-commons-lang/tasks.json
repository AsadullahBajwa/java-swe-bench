[ {
  "instance_id" : "apache-commons-lang-PR-1591",
  "repo" : "apache/commons-lang",
  "base_commit" : "7bcb03a49923bc12f7e3f2c04912d0925f178978",
  "patch" : "diff --git a/src/main/java/org/apache/commons/lang3/ClassUtils.java b/src/main/java/org/apache/commons/lang3/ClassUtils.java\nindex 5c2cf099d19..3032caee6d0 100644\n--- a/src/main/java/org/apache/commons/lang3/ClassUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/ClassUtils.java\n@@ -18,9 +18,11 @@\n \n import java.lang.reflect.Method;\n import java.lang.reflect.Modifier;\n+import java.util.ArrayDeque;\n import java.util.ArrayList;\n import java.util.Collections;\n import java.util.Comparator;\n+import java.util.Deque;\n import java.util.HashMap;\n import java.util.HashSet;\n import java.util.Iterator;\n@@ -1011,11 +1013,6 @@ public static String getShortCanonicalName(final String canonicalName) {\n     /**\n      * Gets the class name minus the package name from a {@link Class}.\n      *\n-     * <p>\n-     * This method simply gets the name using {@code Class.getName()} and then calls {@link #getShortClassName(String)}. See\n-     * relevant notes there.\n-     * </p>\n-     *\n      * @param cls the class to get the short name for.\n      * @return the class name without the package name or an empty string. If the class is an inner class then the returned\n      *         value will contain the outer class or classes separated with {@code .} (dot) character.\n@@ -1024,17 +1021,31 @@ public static String getShortClassName(final Class<?> cls) {\n         if (cls == null) {\n             return StringUtils.EMPTY;\n         }\n-        return getShortClassName(cls.getName());\n+        int dim = 0;\n+        Class<?> c = cls;\n+        while (c.isArray()) {\n+            dim++;\n+            c = c.getComponentType();\n+        }\n+        final String base;\n+        // Preserve legacy behavior for anonymous/local classes (keeps compiler ordinals: $13, $10Named, etc.)\n+        if (c.isAnonymousClass() || c.isLocalClass()) {\n+            base = getShortClassName(c.getName());\n+        } else {\n+            final Deque<String> parts = new ArrayDeque<>();\n+            Class<?> x = c;\n+            while (x != null) {\n+                parts.push(x.getSimpleName());\n+                x = x.getDeclaringClass();\n+            }\n+            base = String.join(\".\", parts);\n+        }\n+        return base + StringUtils.repeat(\"[]\", dim);\n     }\n \n     /**\n      * Gets the class name of the {@code object} without the package name or names.\n      *\n-     * <p>\n-     * The method looks up the class of the object and then converts the name of the class invoking\n-     * {@link #getShortClassName(Class)} (see relevant notes there).\n-     * </p>\n-     *\n      * @param object the class to get the short name for, may be {@code null}.\n      * @param valueIfNull the value to return if the object is {@code null}.\n      * @return the class name of the object without the package name, or {@code valueIfNull} if the argument {@code object}\n",
  "test_patch" : "diff --git a/src/test/java/org/apache/commons/lang3/ClassUtilsShortClassNameTest.java b/src/test/java/org/apache/commons/lang3/ClassUtilsShortClassNameTest.java\nnew file mode 100644\nindex 00000000000..d19bc039306\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/lang3/ClassUtilsShortClassNameTest.java\n@@ -0,0 +1,74 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.lang3;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+import org.junit.jupiter.api.Test;\n+\n+class $trange {\n+\n+}\n+\n+class Pa$$word {\n+\n+}\n+\n+/**\n+ * Tests for <a href=\"https://issues.apache.org/jira/browse/LANG-1818\">LANG-1818</a>\n+ */\n+public class ClassUtilsShortClassNameTest {\n+\n+    class $Inner {\n+\n+    }\n+\n+    class Inner {\n+        class Ne$ted {\n+\n+        }\n+    }\n+\n+    @Test\n+    void testDollarSignImmediatelyAfterPackage() {\n+        assertEquals(\"$trange\", ClassUtils.getShortClassName($trange.class));\n+    }\n+\n+    @Test\n+    void testDollarSignWithinName() {\n+        assertEquals(\"Pa$$word\", ClassUtils.getShortClassName(Pa$$word.class));\n+    }\n+\n+    @Test\n+    void testMultipleDollarSigns() {\n+        assertEquals(getClass().getSimpleName() + \".$Inner\",\n+                ClassUtils.getShortClassName($Inner.class));\n+    }\n+\n+    @Test\n+    void testInnerClassName() {\n+        assertEquals(getClass().getSimpleName() + \".Inner\",\n+                ClassUtils.getShortClassName(Inner.class));\n+    }\n+\n+    @Test\n+    void testNe$tedClassName() {\n+        assertEquals(getClass().getSimpleName() + \".Inner.Ne$ted\",\n+                ClassUtils.getShortClassName(Inner.Ne$ted.class));\n+    }\n+}\n",
  "problem_statement" : "LANG-1818: Fix ClassUtils.getShortClassName(Class) to correctly handle $ in valid class names\n\nThis issue is tracked in https://issues.apache.org/jira/browse/LANG-1818\r\n\r\n## Problem\r\n\r\n`ClassUtils.getShortClassName(Class)` currently delegates to the string-based `getShortClassName(String)` using `cls.getName()`.\r\n\r\nThe string-based method is inherently heuristic and, as documented, cannot reliably distinguish package names, outer classes, and inner classes when given only a JVM binary name. As a result, any `$` character is treated as an inner-class separator, even when `$` is part of a legitimate Java identifier.\r\n\r\nWhile this limitation is unavoidable for `getShortClassName(String)`, it should not apply to `getShortClassName(Class)`, where full reflective metadata is available.\r\n\r\n## Changes\r\n\r\n* Reimplemented `getShortClassName(Class)` (and by extension `getShortClassName(Object))` to use `Class` metadata instead of parsing `Class.getName()`.\r\n* Correctly preserves `$` characters that are part of actual class identifiers (top-level classes, member classes, and nested member classes).\r\n* Maintains existing behavior for local and anonymous classes by falling back to the string-based logic, preserving compiler-generated ordinal naming expected by existing tests.\r\n* Leaves getShortClassName(String) and getShortCanonicalName(String) unchanged, along with their documented limitations.\r\n\r\n## Examples (fixed behaviour)\r\n\r\n```java\r\nclass $trange {}\r\nclass Pa$$word {}\r\n\r\nclass Outer {\r\n    class $Inner {}\r\n    class Inner {\r\n        class Ne$ted {}\r\n    }\r\n}\r\n\r\nClassUtils.getShortClassName($trange.class)        // \"$trange\"\r\nClassUtils.getShortClassName(Pa$$word.class)       // \"Pa$$word\"\r\nClassUtils.getShortClassName(Outer.$Inner.class)   // \"Outer.$Inner\"\r\nClassUtils.getShortClassName(Outer.Inner.Ne$ted.class) // \"Outer.Inner.Ne$ted\"\r\n\r\n```\r\n\r\n## Rationale\r\n\r\nThe ambiguity of $ in JVM binary names is explicitly documented for the string-based APIs. However, when a Class<?> instance is available, that ambiguity disappears. This change improves correctness for the Class-based overloads without altering or reinterpreting the behavior of the string-based methods.",
  "hints_text" : null,
  "created_at" : "Tue Jan 27 19:23:21 CET 2026",
  "version" : null,
  "FAIL_TO_PASS" : [ "ClassUtilsShortClassNameTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=ClassUtilsShortClassNameTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 1591,
  "metadata" : null
}, {
  "instance_id" : "apache-commons-lang-PR-1589",
  "repo" : "apache/commons-lang",
  "base_commit" : "cebde0312d37eb5b9f8efb1974ef322bdb25142c",
  "patch" : "diff --git a/src/main/java/org/apache/commons/lang3/ArrayUtils.java b/src/main/java/org/apache/commons/lang3/ArrayUtils.java\nindex 6cd708582f0..57f9da441b3 100644\n--- a/src/main/java/org/apache/commons/lang3/ArrayUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/ArrayUtils.java\n@@ -2830,13 +2830,14 @@ public static int indexOf(final double[] array, final double valueToFind, final\n      * @return the index of the value within the array, {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input.\n      */\n     public static int indexOf(final double[] array, final double valueToFind, final int startIndex) {\n+        if (Double.isNaN(valueToFind)) {\n+            return indexOfNaN(array, startIndex);\n+        }\n         if (isEmpty(array)) {\n             return INDEX_NOT_FOUND;\n         }\n-        final boolean searchNaN = Double.isNaN(valueToFind);\n         for (int i = max0(startIndex); i < array.length; i++) {\n-            final double element = array[i];\n-            if (valueToFind == element || searchNaN && Double.isNaN(element)) {\n+            if (valueToFind == array[i]) {\n                 return i;\n             }\n         }\n@@ -2860,6 +2861,9 @@ public static int indexOf(final double[] array, final double valueToFind, final\n      * @return the index of the value within the array, {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input.\n      */\n     public static int indexOf(final double[] array, final double valueToFind, final int startIndex, final double tolerance) {\n+        if (Double.isNaN(valueToFind)) {\n+            return indexOfNaN(array, startIndex);\n+        }\n         if (isEmpty(array)) {\n             return INDEX_NOT_FOUND;\n         }\n@@ -2873,6 +2877,24 @@ public static int indexOf(final double[] array, final double valueToFind, final\n         return INDEX_NOT_FOUND;\n     }\n \n+    /**\n+     * Finds the index of the NaN value in a double array.\n+     * @param array the array to search for NaN, may be {@code null}.\n+     * @param startIndex the index to start searching.\n+     * @return the index of the NaN value within the array, {@link #INDEX_NOT_FOUND} ({@code -1}) if not found or {@code null} array input.\n+     */\n+    private static int indexOfNaN(final double[] array, final int startIndex) {\n+        if (isEmpty(array)) {\n+            return INDEX_NOT_FOUND;\n+        }\n+        for (int i = max0(startIndex); i < array.length; i++) {\n+            if (Double.isNaN(array[i])) {\n+                return i;\n+            }\n+        }\n+        return INDEX_NOT_FOUND;\n+    }\n+\n     /**\n      * Finds the index of the given value in the array.\n      * <p>\n",
  "test_patch" : "diff --git a/src/test/java/org/apache/commons/lang3/ArrayUtilsTest.java b/src/test/java/org/apache/commons/lang3/ArrayUtilsTest.java\nindex bf3d3d398f8..a096e949fff 100644\n--- a/src/test/java/org/apache/commons/lang3/ArrayUtilsTest.java\n+++ b/src/test/java/org/apache/commons/lang3/ArrayUtilsTest.java\n@@ -362,6 +362,10 @@ void testContainsDoubleNaN() {\n         assertTrue(ArrayUtils.contains(a, Double.POSITIVE_INFINITY));\n         assertTrue(ArrayUtils.contains(a, Double.NEGATIVE_INFINITY));\n         assertTrue(ArrayUtils.contains(a, Double.NaN));\n+\n+        assertTrue(ArrayUtils.contains(a, Double.POSITIVE_INFINITY, 0.1));\n+        assertTrue(ArrayUtils.contains(a, Double.NEGATIVE_INFINITY, 0.1));\n+        assertTrue(ArrayUtils.contains(a, Double.NaN, 0.1));\n     }\n \n     @Test\n@@ -1135,17 +1139,21 @@ void testIndexOfDouble() {\n     void testIndexOfDoubleNaN() {\n         final double[] array = { Double.NEGATIVE_INFINITY, Double.NaN, Double.POSITIVE_INFINITY, Double.NaN };\n         assertEquals(0, ArrayUtils.indexOf(array, Double.NEGATIVE_INFINITY));\n+        assertEquals(0, ArrayUtils.indexOf(array, Double.NEGATIVE_INFINITY, (double) 0));\n         assertEquals(1, ArrayUtils.indexOf(array, Double.NaN));\n+        assertEquals(1, ArrayUtils.indexOf(array, Double.NaN, (double) 0));\n         assertEquals(2, ArrayUtils.indexOf(array, Double.POSITIVE_INFINITY));\n-\n+        assertEquals(2, ArrayUtils.indexOf(array, Double.POSITIVE_INFINITY, (double) 0));\n     }\n \n     @Test\n     void testIndexOfDoubleTolerance() {\n         double[] array = null;\n         assertEquals(-1, ArrayUtils.indexOf(array, (double) 0, (double) 0));\n+        assertEquals(-1, ArrayUtils.indexOf(array, Double.NaN, (double) 0));\n         array = new double[0];\n         assertEquals(-1, ArrayUtils.indexOf(array, (double) 0, (double) 0));\n+        assertEquals(-1, ArrayUtils.indexOf(array, Double.NaN, (double) 0));\n         array = new double[]{0, 1, 2, 3, 0};\n         assertEquals(0, ArrayUtils.indexOf(array, 0, 0.3));\n         assertEquals(2, ArrayUtils.indexOf(array, 2.2, 0.35));\n",
  "problem_statement" : "LANG-1816: ArrayUtils contains/indexOf/indexesOf with tolerance fail to match NaN values\n\nThis PR fixes https://issues.apache.org/jira/browse/LANG-1816\r\n\r\n## Changes\r\n\r\nThis PR makes `NaN` handling explicit and consistent across overloads:\r\n\r\n* Introduced a private helper method `indexOfNaN(double[], int)` that searches for the first `NaN` value.\r\n* Updated both `indexOf` overloads (with and without tolerance) to delegate to `indexOfNaN` when `valueToFind` is `NaN`.\r\n\r\nAs a by-product, simplified the linear search in `indexOf` without tolerance by removing the mixed NaN / equality logic.\r\n\r\nThe search now treats `NaN` as a special case in both with/withouth tolerance scenarios rather than attempting meaningless comparisons.\r\n\r\nAdded test cases to cover tolerance search of `NaN` in empty and non-empty arrays.\r\n\r\n- [X] Read the [contribution guidelines](CONTRIBUTING.md) for this project.\r\n- [X] Read the [ASF Generative Tooling Guidance](https://www.apache.org/legal/generative-tooling.html) if you use Artificial Intelligence (AI).\r\n- [ ] I used AI to create any part of, or all of, this pull request. Which AI tool was used to create this pull request, and to what extent did it contribute?\r\n- [X] Run a successful build using the default [Maven](https://maven.apache.org/) goal with `mvn`; that's `mvn` on the command line by itself.\r\n- [ ] Write unit tests that match behavioral changes, where the tests fail if the changes to the runtime are not applied. This may not always be possible, but it is a best practice.\r\n- [X] Write a pull request description that is detailed enough to understand what the pull request does, how, and why.\r\n- [ ] Each commit in the pull request should have a meaningful subject line and body. Note that a maintainer may squash commits during the merge process.\r\n",
  "hints_text" : null,
  "created_at" : "Tue Jan 27 12:55:06 CET 2026",
  "version" : null,
  "FAIL_TO_PASS" : [ "ArrayUtilsTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=ArrayUtilsTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 1589,
  "metadata" : null
}, {
  "instance_id" : "apache-commons-lang-PR-1585",
  "repo" : "apache/commons-lang",
  "base_commit" : "87538ebd4de1d3f81aa8cec8af0ace1da1b23f60",
  "patch" : "diff --git a/src/main/java/org/apache/commons/lang3/ArrayUtils.java b/src/main/java/org/apache/commons/lang3/ArrayUtils.java\nindex b6039adcfd2..7a7c34d3d62 100644\n--- a/src/main/java/org/apache/commons/lang3/ArrayUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/ArrayUtils.java\n@@ -8088,7 +8088,7 @@ public static boolean[] subarray(final boolean[] array, int startIndexInclusive,\n             return null;\n         }\n         startIndexInclusive = max0(startIndexInclusive);\n-        endIndexExclusive = Math.min(endIndexExclusive, array.length);\n+        endIndexExclusive = max0(Math.min(endIndexExclusive, array.length));\n         final int newSize = endIndexExclusive - startIndexInclusive;\n         if (newSize <= 0) {\n             return EMPTY_BOOLEAN_ARRAY;\n@@ -8115,7 +8115,7 @@ public static byte[] subarray(final byte[] array, int startIndexInclusive, int e\n             return null;\n         }\n         startIndexInclusive = max0(startIndexInclusive);\n-        endIndexExclusive = Math.min(endIndexExclusive, array.length);\n+        endIndexExclusive = max0(Math.min(endIndexExclusive, array.length));\n         final int newSize = endIndexExclusive - startIndexInclusive;\n         if (newSize <= 0) {\n             return EMPTY_BYTE_ARRAY;\n@@ -8142,7 +8142,7 @@ public static char[] subarray(final char[] array, int startIndexInclusive, int e\n             return null;\n         }\n         startIndexInclusive = max0(startIndexInclusive);\n-        endIndexExclusive = Math.min(endIndexExclusive, array.length);\n+        endIndexExclusive = max0(Math.min(endIndexExclusive, array.length));\n         final int newSize = endIndexExclusive - startIndexInclusive;\n         if (newSize <= 0) {\n             return EMPTY_CHAR_ARRAY;\n@@ -8169,7 +8169,7 @@ public static double[] subarray(final double[] array, int startIndexInclusive, i\n             return null;\n         }\n         startIndexInclusive = max0(startIndexInclusive);\n-        endIndexExclusive = Math.min(endIndexExclusive, array.length);\n+        endIndexExclusive = max0(Math.min(endIndexExclusive, array.length));\n         final int newSize = endIndexExclusive - startIndexInclusive;\n         if (newSize <= 0) {\n             return EMPTY_DOUBLE_ARRAY;\n@@ -8196,7 +8196,7 @@ public static float[] subarray(final float[] array, int startIndexInclusive, int\n             return null;\n         }\n         startIndexInclusive = max0(startIndexInclusive);\n-        endIndexExclusive = Math.min(endIndexExclusive, array.length);\n+        endIndexExclusive = max0(Math.min(endIndexExclusive, array.length));\n         final int newSize = endIndexExclusive - startIndexInclusive;\n         if (newSize <= 0) {\n             return EMPTY_FLOAT_ARRAY;\n@@ -8223,7 +8223,7 @@ public static int[] subarray(final int[] array, int startIndexInclusive, int end\n             return null;\n         }\n         startIndexInclusive = max0(startIndexInclusive);\n-        endIndexExclusive = Math.min(endIndexExclusive, array.length);\n+        endIndexExclusive = max0(Math.min(endIndexExclusive, array.length));\n         final int newSize = endIndexExclusive - startIndexInclusive;\n         if (newSize <= 0) {\n             return EMPTY_INT_ARRAY;\n@@ -8250,7 +8250,7 @@ public static long[] subarray(final long[] array, int startIndexInclusive, int e\n             return null;\n         }\n         startIndexInclusive = max0(startIndexInclusive);\n-        endIndexExclusive = Math.min(endIndexExclusive, array.length);\n+        endIndexExclusive = max0(Math.min(endIndexExclusive, array.length));\n         final int newSize = endIndexExclusive - startIndexInclusive;\n         if (newSize <= 0) {\n             return EMPTY_LONG_ARRAY;\n@@ -8277,7 +8277,7 @@ public static short[] subarray(final short[] array, int startIndexInclusive, int\n             return null;\n         }\n         startIndexInclusive = max0(startIndexInclusive);\n-        endIndexExclusive = Math.min(endIndexExclusive, array.length);\n+        endIndexExclusive = max0(Math.min(endIndexExclusive, array.length));\n         final int newSize = endIndexExclusive - startIndexInclusive;\n         if (newSize <= 0) {\n             return EMPTY_SHORT_ARRAY;\n@@ -8314,7 +8314,7 @@ public static <T> T[] subarray(final T[] array, int startIndexInclusive, int end\n             return null;\n         }\n         startIndexInclusive = max0(startIndexInclusive);\n-        endIndexExclusive = Math.min(endIndexExclusive, array.length);\n+        endIndexExclusive = max0(Math.min(endIndexExclusive, array.length));\n         final int newSize = endIndexExclusive - startIndexInclusive;\n         final Class<T> type = getComponentType(array);\n         if (newSize <= 0) {\n",
  "test_patch" : "diff --git a/src/test/java/org/apache/commons/lang3/ArrayUtilsTest.java b/src/test/java/org/apache/commons/lang3/ArrayUtilsTest.java\nindex 1bf5f517d10..bf3d3d398f8 100644\n--- a/src/test/java/org/apache/commons/lang3/ArrayUtilsTest.java\n+++ b/src/test/java/org/apache/commons/lang3/ArrayUtilsTest.java\n@@ -5618,6 +5618,7 @@ void testSubarrayBoolean() {\n         assertSame(ArrayUtils.EMPTY_BOOLEAN_ARRAY, ArrayUtils.subarray(ArrayUtils.EMPTY_BOOLEAN_ARRAY, 1, 2),\n                 \"empty array, object test\");\n         assertSame(ArrayUtils.EMPTY_BOOLEAN_ARRAY, ArrayUtils.subarray(array, 4, 1), \"start > end, object test\");\n+        assertSame(ArrayUtils.EMPTY_BOOLEAN_ARRAY, ArrayUtils.subarray(array, 2147483647, -2147483648), \"start > end, object test\");\n         assertSame(ArrayUtils.EMPTY_BOOLEAN_ARRAY, ArrayUtils.subarray(array, 3, 3), \"start == end, object test\");\n         assertSame(ArrayUtils.EMPTY_BOOLEAN_ARRAY, ArrayUtils.subarray(array, 8733, 4),\n                 \"start overshoot, any end, object test\");\n@@ -5649,6 +5650,7 @@ void testSubarrayByte() {\n         // empty-return tests\n         assertSame(ArrayUtils.EMPTY_BYTE_ARRAY, ArrayUtils.subarray(ArrayUtils.EMPTY_BYTE_ARRAY, 1, 2), \"empty array, object test\");\n         assertSame(ArrayUtils.EMPTY_BYTE_ARRAY, ArrayUtils.subarray(array, 4, 1), \"start > end, object test\");\n+        assertSame(ArrayUtils.EMPTY_BYTE_ARRAY, ArrayUtils.subarray(array, 2147483647, -2147483648), \"start > end, possible overflow\");\n         assertSame(ArrayUtils.EMPTY_BYTE_ARRAY, ArrayUtils.subarray(array, 3, 3), \"start == end, object test\");\n         assertSame(ArrayUtils.EMPTY_BYTE_ARRAY, ArrayUtils.subarray(array, 8733, 4), \"start overshoot, any end, object test\");\n         // array type tests\n@@ -5677,6 +5679,7 @@ void testSubarrayDouble() {\n         // empty-return tests\n         assertSame(ArrayUtils.EMPTY_DOUBLE_ARRAY, ArrayUtils.subarray(ArrayUtils.EMPTY_DOUBLE_ARRAY, 1, 2), \"empty array, object test\");\n         assertSame(ArrayUtils.EMPTY_DOUBLE_ARRAY, ArrayUtils.subarray(array, 4, 1), \"start > end, object test\");\n+        assertSame(ArrayUtils.EMPTY_DOUBLE_ARRAY, ArrayUtils.subarray(array, 2147483647, -2147483648), \"start > end, possible overflow\");\n         assertSame(ArrayUtils.EMPTY_DOUBLE_ARRAY, ArrayUtils.subarray(array, 3, 3), \"start == end, object test\");\n         assertSame(ArrayUtils.EMPTY_DOUBLE_ARRAY, ArrayUtils.subarray(array, 8733, 4), \"start overshoot, any end, object test\");\n         // array type tests\n@@ -5705,6 +5708,7 @@ void testSubarrayFloat() {\n         // empty-return tests\n         assertSame(ArrayUtils.EMPTY_FLOAT_ARRAY, ArrayUtils.subarray(ArrayUtils.EMPTY_FLOAT_ARRAY, 1, 2), \"empty array, object test\");\n         assertSame(ArrayUtils.EMPTY_FLOAT_ARRAY, ArrayUtils.subarray(array, 4, 1), \"start > end, object test\");\n+        assertSame(ArrayUtils.EMPTY_FLOAT_ARRAY, ArrayUtils.subarray(array, 2147483647, -2147483648), \"start > end, possible overflow\");\n         assertSame(ArrayUtils.EMPTY_FLOAT_ARRAY, ArrayUtils.subarray(array, 3, 3), \"start == end, object test\");\n         assertSame(ArrayUtils.EMPTY_FLOAT_ARRAY, ArrayUtils.subarray(array, 8733, 4), \"start overshoot, any end, object test\");\n         // array type tests\n@@ -5733,6 +5737,7 @@ void testSubarrayInt() {\n         // empty-return tests\n         assertSame(ArrayUtils.EMPTY_INT_ARRAY, ArrayUtils.subarray(ArrayUtils.EMPTY_INT_ARRAY, 1, 2), \"empty array, object test\");\n         assertSame(ArrayUtils.EMPTY_INT_ARRAY, ArrayUtils.subarray(array, 4, 1), \"start > end, object test\");\n+        assertSame(ArrayUtils.EMPTY_INT_ARRAY, ArrayUtils.subarray(array, 2147483647, -2147483648), \"start > end, possible overflow\");\n         assertSame(ArrayUtils.EMPTY_INT_ARRAY, ArrayUtils.subarray(array, 3, 3), \"start == end, object test\");\n         assertSame(ArrayUtils.EMPTY_INT_ARRAY, ArrayUtils.subarray(array, 8733, 4), \"start overshoot, any end, object test\");\n         // array type tests\n@@ -5781,6 +5786,7 @@ void testSubarrayLong() {\n                 \"empty array, object test\");\n \n         assertSame(ArrayUtils.EMPTY_LONG_ARRAY, ArrayUtils.subarray(array, 4, 1), \"start > end, object test\");\n+        assertSame(ArrayUtils.EMPTY_LONG_ARRAY, ArrayUtils.subarray(array, 2147483647, -2147483648), \"start > end, possible overflow\");\n \n         assertSame(ArrayUtils.EMPTY_LONG_ARRAY, ArrayUtils.subarray(array, 3, 3), \"start == end, object test\");\n \n@@ -5808,6 +5814,7 @@ void testSubarrayObject() {\n         assertNull(ArrayUtils.subarray(nullArray, 0, 3), \"null input\");\n         assertEquals(\"\", StringUtils.join(ArrayUtils.subarray(ArrayUtils.EMPTY_OBJECT_ARRAY, 1, 2)), \"empty array\");\n         assertEquals(\"\", StringUtils.join(ArrayUtils.subarray(objectArray, 4, 2)), \"start > end\");\n+        assertEquals(\"\", StringUtils.join(ArrayUtils.subarray(objectArray, 2147483647, -2147483648)), \"start > end\");\n         assertEquals(\"\", StringUtils.join(ArrayUtils.subarray(objectArray, 3, 3)), \"start == end\");\n         assertEquals(\"abcd\", StringUtils.join(ArrayUtils.subarray(objectArray, -2, 4)), \"start undershoot, normal end\");\n         assertEquals(\"\", StringUtils.join(ArrayUtils.subarray(objectArray, 33, 4)), \"start overshoot, any end\");\n@@ -5860,6 +5867,7 @@ void testSubarrayShort() {\n         assertSame(ArrayUtils.EMPTY_SHORT_ARRAY, ArrayUtils.subarray(ArrayUtils.EMPTY_SHORT_ARRAY, 1, 2),\n                 \"empty array, object test\");\n         assertSame(ArrayUtils.EMPTY_SHORT_ARRAY, ArrayUtils.subarray(array, 4, 1), \"start > end, object test\");\n+        assertSame(ArrayUtils.EMPTY_SHORT_ARRAY, ArrayUtils.subarray(array, 2147483647, -2147483648), \"start > end, possible overflow\");\n         assertSame(ArrayUtils.EMPTY_SHORT_ARRAY, ArrayUtils.subarray(array, 3, 3), \"start == end, object test\");\n         assertSame(ArrayUtils.EMPTY_SHORT_ARRAY, ArrayUtils.subarray(array, 8733, 4),\n                 \"start overshoot, any end, object test\");\n@@ -5895,6 +5903,7 @@ void testSubarrChar() {\n \n         assertSame(ArrayUtils.EMPTY_CHAR_ARRAY, ArrayUtils.subarray(ArrayUtils.EMPTY_CHAR_ARRAY, 1, 2), \"empty array, object test\");\n         assertSame(ArrayUtils.EMPTY_CHAR_ARRAY, ArrayUtils.subarray(array, 4, 1), \"start > end, object test\");\n+        assertSame(ArrayUtils.EMPTY_CHAR_ARRAY, ArrayUtils.subarray(array, 2147483647, -2147483648), \"start > end, possible overflow\");\n         assertSame(ArrayUtils.EMPTY_CHAR_ARRAY, ArrayUtils.subarray(array, 3, 3), \"start == end, object test\");\n         assertSame(ArrayUtils.EMPTY_CHAR_ARRAY, ArrayUtils.subarray(array, 8733, 4), \"start overshoot, any end, object test\");\n \n",
  "problem_statement" : "LANG-1814: ArrayUtils.subarray(..) may overflow index arithmetic\n\n## Problem\r\n\r\n`ArrayUtils.subarray(..)` is documented to return an empty array when `endIndexExclusive < startIndexInclusive.`\r\n\r\nFor extreme combinations of indices, the current implementation may violate this contract due to subtraction overflow in the computation of:\r\n\r\n```java\r\nfinal int newSize = endIndexExclusive - startIndexInclusive;\r\n```\r\n\r\nAlthough `startIndexInclusive` is clamped to `>= 0`, `endIndexExclusive` was previously only clamped to `<= array.length` and could remain negative. The subtraction could therefore overflow to a positive value, causing the method to attempt allocation and/or copying instead of returning an empty array.\r\n\r\nDepending on the overflowed value and heap size, this resulted in:\r\n\r\n* `ArrayIndexOutOfBoundsException` (small positive overflow), or\r\n* `OutOfMemoryError` (large positive overflow)\r\n\r\nBoth outcomes contradict the documented behavior.\r\n\r\n## Changes\r\n\r\nFor all ArrayUtils.subarray(..) overloads, endIndexExclusive is now clamped symmetrically to the valid range before computing the size:\r\n\r\n```java\r\nendIndexExclusive = max0(Math.min(endIndexExclusive, array.length));\r\n```\r\n\r\nThis guarantees:\r\n\r\n* `endIndexExclusive` is always in `[0 .. array.length]`\r\n* `endIndexExclusive - startIndexInclusive` cannot overflow\r\n\r\nCases where `endIndexExclusive < startIndexInclusive` consistently return an empty array\r\n\r\n## Tests\r\n\r\nAdded regression tests for all subarray overloads covering extreme index combinations that previously triggered integer overflow and resulted in `ArrayIndexOutOfBoundsException`.\r\n\r\n- [x] Read the [contribution guidelines](CONTRIBUTING.md) for this project.\r\n- [x] Read the [ASF Generative Tooling Guidance](https://www.apache.org/legal/generative-tooling.html) if you use Artificial Intelligence (AI).\r\n- [ ] I used AI to create any part of, or all of, this pull request. Which AI tool was used to create this pull request, and to what extent did it contribute?\r\n- [ ] Run a successful build using the default [Maven](https://maven.apache.org/) goal with `mvn`; that's `mvn` on the command line by itself.\r\n- [x] Write unit tests that match behavioral changes, where the tests fail if the changes to the runtime are not applied. This may not always be possible, but it is a best practice.\r\n- [x] Write a pull request description that is detailed enough to understand what the pull request does, how, and why.\r\n- [ ] Each commit in the pull request should have a meaningful subject line and body. Note that a maintainer may squash commits during the merge process.\r\n",
  "hints_text" : null,
  "created_at" : "Mon Jan 26 16:46:56 CET 2026",
  "version" : null,
  "FAIL_TO_PASS" : [ "ArrayUtilsTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=ArrayUtilsTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 1585,
  "metadata" : null
}, {
  "instance_id" : "apache-commons-lang-PR-1584",
  "repo" : "apache/commons-lang",
  "base_commit" : "3f803b8bf78602c9464b2d01023634e32df1c388",
  "patch" : "diff --git a/src/main/java/org/apache/commons/lang3/builder/RecursiveToStringStyle.java b/src/main/java/org/apache/commons/lang3/builder/RecursiveToStringStyle.java\nindex 15968eb124b..95695079a82 100644\n--- a/src/main/java/org/apache/commons/lang3/builder/RecursiveToStringStyle.java\n+++ b/src/main/java/org/apache/commons/lang3/builder/RecursiveToStringStyle.java\n@@ -17,8 +17,10 @@\n package org.apache.commons.lang3.builder;\n \n import java.util.Collection;\n+import java.util.concurrent.atomic.AtomicBoolean;\n \n import org.apache.commons.lang3.ClassUtils;\n+import org.apache.commons.lang3.mutable.MutableBoolean;\n \n /**\n  * Works with {@link ToStringBuilder} to create a \"deep\" {@code toString}.\n@@ -66,16 +68,29 @@ public RecursiveToStringStyle() {\n     }\n \n     /**\n-     * Returns whether or not to recursively format the given {@link Class}.\n-     * By default, this method always returns {@code true}, but may be overwritten by\n-     * subclasses to filter specific classes.\n+     * Tests whether or not to recursively format the given {@link Class}.\n+     * <p>\n+     * By default, this method always filters out the following:\n+     * </p>\n+     * <ul>\n+     * <li><a href=\"https://docs.oracle.com/javase/specs/jls/se25/html/jls-5.html#jls-5.1.7\">Boxed primitives</a>, see {@link ClassUtils#isPrimitiveWrapper(Class)}\n+     * <li>{@link String}</li>\n+     * <li>{@link Number} subclasses</li>\n+     * <li>{@link AtomicBoolean}</li>\n+     * <li>{@link MutableBoolean}</li>\n+     * </ul>\n      *\n-     * @param clazz\n-     *            The class to test.\n-     * @return Whether or not to recursively format the given {@link Class}.\n+     * @param clazz The class to test.\n+     * @return Whether or not to recursively format instances of the given {@link Class}.\n      */\n     protected boolean accept(final Class<?> clazz) {\n-        return true;\n+        // @formatter:off\n+        return !ClassUtils.isPrimitiveWrapper(clazz) &&\n+               !String.class.equals(clazz) &&\n+               !Number.class.isAssignableFrom(clazz) &&\n+               !AtomicBoolean.class.equals(clazz) &&\n+               !MutableBoolean.class.equals(clazz);\n+        // @formatter:on\n     }\n \n     @Override\n@@ -87,10 +102,7 @@ protected void appendDetail(final StringBuffer buffer, final String fieldName, f\n \n     @Override\n     public void appendDetail(final StringBuffer buffer, final String fieldName, final Object value) {\n-        final Class<? extends Object> clazz = value.getClass();\n-        if (!ClassUtils.isPrimitiveWrapper(clazz) &&\n-            !String.class.equals(clazz) &&\n-            accept(clazz)) {\n+        if (value != null && accept(value.getClass())) {\n             buffer.append(ReflectionToStringBuilder.toString(value, this));\n         } else {\n             super.appendDetail(buffer, fieldName, value);\n",
  "test_patch" : "diff --git a/src/test/java/org/apache/commons/lang3/builder/RecursiveToStringStyleTest.java b/src/test/java/org/apache/commons/lang3/builder/RecursiveToStringStyleTest.java\nindex 2f73484fabe..e8618e84d53 100644\n--- a/src/test/java/org/apache/commons/lang3/builder/RecursiveToStringStyleTest.java\n+++ b/src/test/java/org/apache/commons/lang3/builder/RecursiveToStringStyleTest.java\n@@ -18,10 +18,22 @@\n \n import static org.junit.jupiter.api.Assertions.assertEquals;\n \n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n import java.util.ArrayList;\n import java.util.HashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n \n import org.apache.commons.lang3.AbstractLangTest;\n+import org.apache.commons.lang3.mutable.MutableBoolean;\n+import org.apache.commons.lang3.mutable.MutableByte;\n+import org.apache.commons.lang3.mutable.MutableDouble;\n+import org.apache.commons.lang3.mutable.MutableFloat;\n+import org.apache.commons.lang3.mutable.MutableInt;\n+import org.apache.commons.lang3.mutable.MutableLong;\n+import org.apache.commons.lang3.mutable.MutableShort;\n import org.junit.jupiter.api.AfterEach;\n import org.junit.jupiter.api.BeforeEach;\n import org.junit.jupiter.api.Test;\n@@ -85,6 +97,30 @@ void testAppendSuper() {\n         assertEquals(baseStr + \"[a=hello]\", new ToStringBuilder(base).appendSuper(null).append(\"a\", \"hello\").toString());\n     }\n \n+    @Test\n+    void testAtomicsArray() {\n+        assertEquals(baseStr + \"[{<null>,5,{3,6}}]\",\n+                new ToStringBuilder(base).append(new Object[] { null, base, new AtomicLong[] { new AtomicLong(3), new AtomicLong(6) } }).toString());\n+        assertEquals(baseStr + \"[{<null>,5,{3,6}}]\",\n+                new ToStringBuilder(base).append(new Object[] { null, base, new AtomicInteger[] { new AtomicInteger(3), new AtomicInteger(6) } }).toString());\n+        assertEquals(baseStr + \"[{<null>,5,{true,false}}]\",\n+                new ToStringBuilder(base).append(new Object[] { null, base, new AtomicBoolean[] { new AtomicBoolean(true), new AtomicBoolean(false) } }).toString());\n+    }\n+\n+    @Test\n+    void testBigDecimal() {\n+        assertEquals(baseStr + \"[{<null>,5,{3,6}}]\",\n+                new ToStringBuilder(base).append(new Object[] { null, base, new BigDecimal[] { BigDecimal.valueOf(3), BigDecimal.valueOf(6) } }).toString());\n+        assertEquals(baseStr + \"[{<null>,5,{3.0,6.0}}]\",\n+                new ToStringBuilder(base).append(new Object[] { null, base, new BigDecimal[] { BigDecimal.valueOf(3.0), BigDecimal.valueOf(6.0) } }).toString());\n+    }\n+\n+    @Test\n+    void testBigInteger() {\n+        assertEquals(baseStr + \"[{<null>,5,{3,6}}]\",\n+                new ToStringBuilder(base).append(new Object[] { null, base, new BigInteger[] { BigInteger.valueOf(3), BigInteger.valueOf(6) } }).toString());\n+    }\n+\n     @Test\n     void testBlank() {\n         assertEquals(baseStr + \"[]\", new ToStringBuilder(base).toString());\n@@ -117,6 +153,24 @@ void testLongArrayArray() {\n         assertEquals(baseStr + \"[<null>]\", new ToStringBuilder(base).append((Object) array).toString());\n     }\n \n+    @Test\n+    void testMutableWrapperArray() {\n+        assertEquals(baseStr + \"[{<null>,5,{3,6}}]\",\n+                new ToStringBuilder(base).append(new Object[] { null, base, new MutableLong[] { new MutableLong(3), new MutableLong(6) } }).toString());\n+        assertEquals(baseStr + \"[{<null>,5,{3,6}}]\",\n+                new ToStringBuilder(base).append(new Object[] { null, base, new MutableInt[] { new MutableInt(3), new MutableInt(6) } }).toString());\n+        assertEquals(baseStr + \"[{<null>,5,{3,6}}]\",\n+                new ToStringBuilder(base).append(new Object[] { null, base, new MutableShort[] { new MutableShort(3), new MutableShort(6) } }).toString());\n+        assertEquals(baseStr + \"[{<null>,5,{3,6}}]\",\n+                new ToStringBuilder(base).append(new Object[] { null, base, new MutableByte[] { new MutableByte((byte) 3), new MutableByte((byte) 6) } }).toString());\n+        assertEquals(baseStr + \"[{<null>,5,{3.0,6.0}}]\",\n+                new ToStringBuilder(base).append(new Object[] { null, base, new MutableFloat[] { new MutableFloat(3f), new MutableFloat(6f) } }).toString());\n+        assertEquals(baseStr + \"[{<null>,5,{3.0,6.0}}]\",\n+                new ToStringBuilder(base).append(new Object[] { null, base, new MutableDouble[] { new MutableDouble(3d), new MutableDouble(6d) } }).toString());\n+        assertEquals(baseStr + \"[{<null>,5,{true,false}}]\",\n+                new ToStringBuilder(base).append(new Object[] { null, base, new MutableBoolean[] { new MutableBoolean(true), new MutableBoolean(false) } }).toString());\n+    }\n+\n     @Test\n     void testObject() {\n         final Integer i3 = Integer.valueOf(3);\n@@ -174,5 +228,4 @@ void testPrimitiveWrapperArray() {\n         assertEquals(baseStr + \"[{<null>,5,{true,false}}]\",\n                 new ToStringBuilder(base).append(new Object[] { null, base, new Boolean[] { true, false } }).toString());\n     }\n-\n }\n",
  "problem_statement" : "[LANG-1452] RecursiveToStringStyle and MultilineRecursiveToStringStyle shouldn't recurse into a java.math.BigDecimal\n\nBefore you push a pull request, review this list:\r\n\r\n- [x] Read the [contribution guidelines](CONTRIBUTING.md) for this project.\r\n- [x] Read the [ASF Generative Tooling Guidance](https://www.apache.org/legal/generative-tooling.html) if you use Artificial Intelligence (AI).\r\n- [x] I didn't use AI to create any part of, or all of, this pull request.\r\n- [x] Run a successful build using the default [Maven](https://maven.apache.org/) goal with `mvn`; that's `mvn` on the command line by itself.\r\n- [x] Write unit tests that match behavioral changes, where the tests fail if the changes to the runtime are not applied. This may not always be possible, but it is a best practice.\r\n- [x] Write a pull request description that is detailed enough to understand what the pull request does, how, and why.\r\n- [x] Each commit in the pull request should have a meaningful subject line and body. Note that a maintainer may squash commits during the merge process.\r\n",
  "hints_text" : null,
  "created_at" : "Sun Jan 25 14:39:19 CET 2026",
  "version" : null,
  "FAIL_TO_PASS" : [ "RecursiveToStringStyleTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=RecursiveToStringStyleTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 1584,
  "metadata" : null
}, {
  "instance_id" : "apache-commons-lang-PR-1577",
  "repo" : "apache/commons-lang",
  "base_commit" : "ac91ddd6ad1c09e0fadf0c6422bf04ba4aed37a9",
  "patch" : "diff --git a/src/main/java/org/apache/commons/lang3/ClassUtils.java b/src/main/java/org/apache/commons/lang3/ClassUtils.java\nindex b4bfd4d22b0..5c2cf099d19 100644\n--- a/src/main/java/org/apache/commons/lang3/ClassUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/ClassUtils.java\n@@ -601,7 +601,7 @@ public static Class<?> getClass(final ClassLoader classLoader, final String clas\n                 }\n             }\n         } while (lastDotIndex != -1);\n-        throw new ClassNotFoundException(next);\n+        throw new ClassNotFoundException(className);\n     }\n \n     /**\n",
  "test_patch" : "diff --git a/src/test/java/org/apache/commons/lang3/ClassUtilsTest.java b/src/test/java/org/apache/commons/lang3/ClassUtilsTest.java\nindex 9029bb1e363..abe8004e425 100644\n--- a/src/test/java/org/apache/commons/lang3/ClassUtilsTest.java\n+++ b/src/test/java/org/apache/commons/lang3/ClassUtilsTest.java\n@@ -110,8 +110,11 @@ private void assertGetClassThrowsClassNotFound(final String className) {\n     }\n \n     private void assertGetClassThrowsException(final String className, final Class<? extends Exception> exceptionType) {\n-        assertThrows(exceptionType, () -> ClassUtils.getClass(className),\n+        final Exception exception = assertThrows(exceptionType, () -> ClassUtils.getClass(className),\n             \"ClassUtils.getClass() should fail with an exception of type \" + exceptionType.getName() + \" when given class name \\\"\" + className + \"\\\".\");\n+        if (className != null) {\n+            assertEquals(className, exception.getMessage());\n+        }\n     }\n \n     private void assertGetClassThrowsNullPointerException(final String className) {\n@@ -1251,6 +1254,7 @@ void testGetClassClassNotFound() throws Exception {\n         assertGetClassThrowsClassNotFound(\"bool\");\n         assertGetClassThrowsClassNotFound(\"bool[]\");\n         assertGetClassThrowsClassNotFound(\"integer[]\");\n+        assertGetClassThrowsClassNotFound(\"org.apache.commons.lang3.ClassUtilsTest.AClassThatCannotBeFound\");\n     }\n \n     @Test\n",
  "problem_statement" : "Fix ClassNotFoundException message in ClassUtils.getClass(String)\n\n<!--\r\n  Licensed to the Apache Software Foundation (ASF) under one\r\n  or more contributor license agreements.  See the NOTICE file\r\n  distributed with this work for additional information\r\n  regarding copyright ownership.  The ASF licenses this file\r\n  to you under the Apache License, Version 2.0 (the\r\n  \"License\"); you may not use this file except in compliance\r\n  with the License.  You may obtain a copy of the License at\r\n\r\n    https://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing,\r\n  software distributed under the License is distributed on an\r\n  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n  KIND, either express or implied.  See the License for the\r\n  specific language governing permissions and limitations\r\n  under the License.\r\n-->\r\n\r\nThanks for your contribution to [Apache Commons](https://commons.apache.org/)! Your help is appreciated!\r\n\r\nBefore you push a pull request, review this list:\r\n\r\n- [ ] Read the [contribution guidelines](CONTRIBUTING.md) for this project.\r\n- [ ] Read the [ASF Generative Tooling Guidance](https://www.apache.org/legal/generative-tooling.html) if you use Artificial Intelligence (AI).\r\n- [ ] I used AI to create any part of, or all of, this pull request. Which AI tool was used to create this pull request, and to what extent did it contribute?\r\n- [ ] Run a successful build using the default [Maven](https://maven.apache.org/) goal with `mvn`; that's `mvn` on the command line by itself.\r\n- [ ] Write unit tests that match behavioral changes, where the tests fail if the changes to the runtime are not applied. This may not always be possible, but it is a best practice.\r\n- [ ] Write a pull request description that is detailed enough to understand what the pull request does, how, and why.\r\n- [ ] Each commit in the pull request should have a meaningful subject line and body. Note that a maintainer may squash commits during the merge process.\r\n",
  "hints_text" : null,
  "created_at" : "Wed Jan 21 15:04:56 CET 2026",
  "version" : null,
  "FAIL_TO_PASS" : [ "ClassUtilsTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=ClassUtilsTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 1577,
  "metadata" : null
}, {
  "instance_id" : "apache-commons-lang-PR-1571",
  "repo" : "apache/commons-lang",
  "base_commit" : "67f50236bf337e20c6daa987d4d42c4fedb482ce",
  "patch" : "diff --git a/src/main/java/org/apache/commons/lang3/StringUtils.java b/src/main/java/org/apache/commons/lang3/StringUtils.java\nindex 1ae37530616..4616abfc024 100644\n--- a/src/main/java/org/apache/commons/lang3/StringUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/StringUtils.java\n@@ -350,13 +350,13 @@ public static String abbreviate(final String str, final String abbrevMarker, fin\n      * @throws IllegalArgumentException if the width is too small.\n      * @since 3.6\n      */\n-    public static String abbreviate(final String str, final String abbrevMarker, int offset, final int maxWidth) {\n-        if (isNotEmpty(str) && EMPTY.equals(abbrevMarker) && maxWidth > 0) {\n-            return substring(str, 0, maxWidth);\n-        }\n-        if (isAnyEmpty(str, abbrevMarker)) {\n+    public static String abbreviate(final String str, String abbrevMarker, int offset, final int maxWidth) {\n+        if (isEmpty(str)) {\n             return str;\n         }\n+        if (abbrevMarker == null) {\n+            abbrevMarker = EMPTY;\n+        }\n         final int abbrevMarkerLength = abbrevMarker.length();\n         final int minAbbrevWidth = abbrevMarkerLength + 1;\n         final int minAbbrevWidthOffset = abbrevMarkerLength + abbrevMarkerLength + 1;\n",
  "test_patch" : "diff --git a/src/test/java/org/apache/commons/lang3/StringUtilsAbbreviateTest.java b/src/test/java/org/apache/commons/lang3/StringUtilsAbbreviateTest.java\nindex 49a188d06de..8ef0cfc855c 100644\n--- a/src/test/java/org/apache/commons/lang3/StringUtilsAbbreviateTest.java\n+++ b/src/test/java/org/apache/commons/lang3/StringUtilsAbbreviateTest.java\n@@ -107,7 +107,7 @@ void testAbbreviate_StringIntInt() {\n     void testAbbreviate_StringStringInt() {\n         assertNull(StringUtils.abbreviate(null, null, 10));\n         assertNull(StringUtils.abbreviate(null, \"...\", 10));\n-        assertEquals(\"paranaguacu\", StringUtils.abbreviate(\"paranaguacu\", null, 10));\n+        assertEquals(\"paranaguac\", StringUtils.abbreviate(\"paranaguacu\", null, 10));\n         assertEquals(\"\", StringUtils.abbreviate(\"\", \"...\", 2));\n         assertEquals(\"wai**\", StringUtils.abbreviate(\"waiheke\", \"**\", 5));\n         assertEquals(\"And af,,,,\", StringUtils.abbreviate(\"And after a long time, he finally met his son.\", \",,,,\", 10));\n@@ -130,6 +130,12 @@ void testAbbreviate_StringStringIntInt() {\n         assertNull(StringUtils.abbreviate(null, \"...\", 10, 12));\n         assertEquals(\"\", StringUtils.abbreviate(\"\", null, 0, 10));\n         assertEquals(\"\", StringUtils.abbreviate(\"\", \"...\", 2, 10));\n+        assertEquals(\"abcdefg\", StringUtils.abbreviate(\"abcdefg\", null, 2, 10));\n+        assertEquals(\"abcdefg\", StringUtils.abbreviate(\"abcdefg\", \"\", 2, 10));\n+        assertEquals(\"abc\", StringUtils.abbreviate(\"abcdefg\", null, 0, 3));\n+        assertEquals(\"cde\", StringUtils.abbreviate(\"abcdefg\", null, 2, 3));\n+        assertEquals(\"abc\", StringUtils.abbreviate(\"abcdefg\", \"\", 0, 3));\n+        assertEquals(\"cde\", StringUtils.abbreviate(\"abcdefg\", \"\", 2, 3));\n         assertIllegalArgumentException(() -> StringUtils.abbreviate(\"abcdefghij\", \"::\", 0, 2),\n                 \"StringUtils.abbreviate expecting IllegalArgumentException\");\n         assertIllegalArgumentException(() -> StringUtils.abbreviate(\"abcdefghij\", \"!!!\", 5, 6),\n",
  "problem_statement" : "Fix handling of null marker in StringUtils.abbreviate(String, String, int, int) \n\nMake `abbreviate` apply the offset and maxWidth properties correctly when the abbrevMarker is `null` or empty string.\r\n\r\nPartial replacement of #1490 \r\n\r\n<!--\r\n  Licensed to the Apache Software Foundation (ASF) under one\r\n  or more contributor license agreements.  See the NOTICE file\r\n  distributed with this work for additional information\r\n  regarding copyright ownership.  The ASF licenses this file\r\n  to you under the Apache License, Version 2.0 (the\r\n  \"License\"); you may not use this file except in compliance\r\n  with the License.  You may obtain a copy of the License at\r\n\r\n    https://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing,\r\n  software distributed under the License is distributed on an\r\n  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n  KIND, either express or implied.  See the License for the\r\n  specific language governing permissions and limitations\r\n  under the License.\r\n-->\r\n\r\nThanks for your contribution to [Apache Commons](https://commons.apache.org/)! Your help is appreciated!\r\n\r\nBefore you push a pull request, review this list:\r\n\r\n- [X] Read the [contribution guidelines](CONTRIBUTING.md) for this project.\r\n- [X] Run a successful build using the default [Maven](https://maven.apache.org/) goal with `mvn`; that's `mvn` on the command line by itself.\r\n- [X] Write unit tests that match behavioral changes, where the tests fail if the changes to the runtime are not applied. This may not always be possible, but it is a best practice.\r\n- [X] Write a pull request description that is detailed enough to understand what the pull request does, how, and why.\r\n- [X] Each commit in the pull request should have a meaningful subject line and body. Note that a maintainer may squash commits during the merge process.\r\n",
  "hints_text" : null,
  "created_at" : "Sat Jan 17 04:27:32 CET 2026",
  "version" : null,
  "FAIL_TO_PASS" : [ "StringUtilsAbbreviateTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=StringUtilsAbbreviateTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 1571,
  "metadata" : null
}, {
  "instance_id" : "apache-commons-lang-PR-1561",
  "repo" : "apache/commons-lang",
  "base_commit" : "037880852770c3124f8d61c2dbf2b31f34a75508",
  "patch" : "diff --git a/src/main/java/org/apache/commons/lang3/BitField.java b/src/main/java/org/apache/commons/lang3/BitField.java\nindex edf4fdb4ee8..d8412021884 100644\n--- a/src/main/java/org/apache/commons/lang3/BitField.java\n+++ b/src/main/java/org/apache/commons/lang3/BitField.java\n@@ -72,7 +72,7 @@\n  */\n public class BitField {\n \n-    private final int mask;\n+    private final long mask;\n \n     private final int shiftCount;\n \n@@ -86,6 +86,17 @@ public BitField(final int mask) {\n         this.shiftCount = mask == 0 ? 0 : Integer.numberOfTrailingZeros(mask);\n     }\n \n+    /**\n+     * Creates a BitField instance.\n+     *\n+     * @param mask the mask specifying which bits apply to this BitField. Bits that are set in this mask are the bits that this BitField operates on.\n+     * @since 3.21.0\n+     */\n+    public BitField(final long mask) {\n+        this.mask = mask;\n+        this.shiftCount = mask == 0 ? 0 : Long.numberOfTrailingZeros(mask);\n+    }\n+\n     /**\n      * Clears the bits.\n      *\n@@ -93,6 +104,17 @@ public BitField(final int mask) {\n      * @return the value of holder with the specified bits cleared (set to {@code 0}).\n      */\n     public int clear(final int holder) {\n+        return (int) (holder & ~mask);\n+    }\n+\n+    /**\n+     * Clears the bits.\n+     *\n+     * @param holder the long data containing the bits we're interested in.\n+     * @return the value of holder with the specified bits cleared (set to {@code 0}).\n+     * @since 3.21.0\n+     */\n+    public long clear(final long holder) {\n         return holder & ~mask;\n     }\n \n@@ -123,6 +145,17 @@ public short clearShort(final short holder) {\n      * @return the selected bits.\n      */\n     public int getRawValue(final int holder) {\n+        return (int) (holder & mask);\n+    }\n+\n+    /**\n+     * Gets the value for the specified BitField, unshifted.\n+     *\n+     * @param holder the long data containing the bits we're interested in.\n+     * @return the selected bits.\n+     * @since 3.21.0\n+     */\n+    public long getRawValue(final long holder) {\n         return holder & mask;\n     }\n \n@@ -166,6 +199,22 @@ public int getValue(final int holder) {\n         return getRawValue(holder) >> shiftCount;\n     }\n \n+    /**\n+     * Gets the value for the specified BitField, appropriately shifted right.\n+     * <p>\n+     * Many users of a BitField will want to treat the specified bits as an long value, and will not want to be aware that the value is stored as a BitField (and\n+     * so shifted left so many bits).\n+     * </p>\n+     *\n+     * @param holder the long data containing the bits we're interested in.\n+     * @return the selected bits, shifted right appropriately.\n+     * @see #setValue(long,long)\n+     * @since 3.21.0\n+     */\n+    public long getValue(final long holder) {\n+        return getRawValue(holder) >> shiftCount;\n+    }\n+\n     /**\n      * Tests whether all of the bits are set or not.\n      * <p>\n@@ -179,11 +228,25 @@ public boolean isAllSet(final int holder) {\n         return (holder & mask) == mask;\n     }\n \n+    /**\n+     * Tests whether all of the bits are set or not.\n+     * <p>\n+     * This is a stricter test than {@link #isSet(long)}, in that all of the bits in a multi-bit set must be set for this method to return {@code true}.\n+     * </p>\n+     *\n+     * @param holder the long data containing the bits we're interested in.\n+     * @return {@code true} if all of the bits are set, else {@code false}.\n+     * @since 3.21.0\n+     */\n+    public boolean isAllSet(final long holder) {\n+        return (holder & mask) == mask;\n+    }\n+\n     /**\n      * Tests whether the field is set or not.\n      * <p>\n      * This is most commonly used for a single-bit field, which is often used to represent a boolean value; the results of using it for a multi-bit field is to\n-     * determine whether *any* of its bits are set.\n+     * determine whether <em>any</em> of its bits are set.\n      * </p>\n      *\n      * @param holder the int data containing the bits we're interested in\n@@ -193,6 +256,21 @@ public boolean isSet(final int holder) {\n         return (holder & mask) != 0;\n     }\n \n+    /**\n+     * Tests whether the field is set or not.\n+     * <p>\n+     * This is most commonly used for a single-bit field, which is often used to represent a boolean value; the results of using it for a multi-bit field is to\n+     * determine whether <em>any</em> of its bits are set.\n+     * </p>\n+     *\n+     * @param holder the long data containing the bits we're interested in\n+     * @return {@code true} if any of the bits are set, else {@code false}\n+     * @since 3.21.0\n+     */\n+    public boolean isSet(final long holder) {\n+        return (holder & mask) != 0;\n+    }\n+\n     /**\n      * Sets the bits.\n      *\n@@ -200,6 +278,17 @@ public boolean isSet(final int holder) {\n      * @return the value of holder with the specified bits set to {@code 1}.\n      */\n     public int set(final int holder) {\n+        return (int) (holder | mask);\n+    }\n+\n+    /**\n+     * Sets the bits.\n+     *\n+     * @param holder the long data containing the bits we're interested in.\n+     * @return the value of holder with the specified bits set to {@code 1}.\n+     * @since 3.21.0\n+     */\n+    public long set(final long holder) {\n         return holder | mask;\n     }\n \n@@ -214,6 +303,18 @@ public int setBoolean(final int holder, final boolean flag) {\n         return flag ? set(holder) : clear(holder);\n     }\n \n+    /**\n+     * Sets a boolean BitField.\n+     *\n+     * @param holder the long data containing the bits we're interested in.\n+     * @param flag   indicating whether to set or clear the bits.\n+     * @return the value of holder with the specified bits set or cleared.\n+     * @since 3.21.0\n+     */\n+    public long setBoolean(final long holder, final boolean flag) {\n+        return flag ? set(holder) : clear(holder);\n+    }\n+\n     /**\n      * Sets the bits.\n      *\n@@ -277,6 +378,19 @@ public short setShortValue(final short holder, final short value) {\n      * @see #getValue(int)\n      */\n     public int setValue(final int holder, final int value) {\n+        return (int) (holder & ~mask | value << shiftCount & mask);\n+    }\n+\n+    /**\n+     * Sets the bits with new values.\n+     *\n+     * @param holder the long data containing the bits we're interested in.\n+     * @param value  the new value for the specified bits.\n+     * @return the value of holder with the bits from the value parameter replacing the old bits.\n+     * @see #getValue(long)\n+     * @since 3.21.0\n+     */\n+    public long setValue(final long holder, final long value) {\n         return holder & ~mask | value << shiftCount & mask;\n     }\n }\n",
  "test_patch" : "diff --git a/src/test/java/org/apache/commons/lang3/BitFieldLongTest.java b/src/test/java/org/apache/commons/lang3/BitFieldLongTest.java\nnew file mode 100644\nindex 00000000000..d43d3f31a6b\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/lang3/BitFieldLongTest.java\n@@ -0,0 +1,231 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.lang3;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import org.junit.jupiter.api.Test;\n+\n+/**\n+ * Tests {@link BitField} constructed with long masks.\n+ */\n+class BitFieldLongTest {\n+\n+    private static final BitField BF_MULTI  = new BitField(0x3F80L);\n+    private static final BitField BF_MULTI_L  = new BitField(0x3F80_0000_0000_0000L);\n+    private static final BitField BF_SINGLE = new BitField(0x4000L);\n+    private static final BitField BF_SINGLE_L = new BitField(0x4000_0000_0000_0000L);\n+    private static final BitField BF_ZERO = new BitField(0L);\n+    private static final BitField BF_ZERO_L = new BitField(0L);\n+\n+    @Test\n+    void testByteBoolean() {\n+        assertEquals(0, new BitField(0L).setByteBoolean((byte) 0, true));\n+        assertEquals(1, new BitField(1L).setByteBoolean((byte) 0, true));\n+        assertEquals(2, new BitField(2L).setByteBoolean((byte) 0, true));\n+        assertEquals(4, new BitField(4L).setByteBoolean((byte) 0, true));\n+        assertEquals(8, new BitField(8L).setByteBoolean((byte) 0, true));\n+        assertEquals(16, new BitField(16L).setByteBoolean((byte) 0, true));\n+        assertEquals(32, new BitField(32L).setByteBoolean((byte) 0, true));\n+        assertEquals(64, new BitField(64L).setByteBoolean((byte) 0, true));\n+        assertEquals(-128, new BitField(128L).setByteBoolean((byte) 0, true));\n+        assertEquals(1, new BitField(0L).setByteBoolean((byte) 1, false));\n+        assertEquals(0, new BitField(1L).setByteBoolean((byte) 1, false));\n+        assertEquals(0, new BitField(2L).setByteBoolean((byte) 2, false));\n+        assertEquals(0, new BitField(4L).setByteBoolean((byte) 4, false));\n+        assertEquals(0, new BitField(8L).setByteBoolean((byte) 8, false));\n+        assertEquals(0, new BitField(16L).setByteBoolean((byte) 16, false));\n+        assertEquals(0, new BitField(32L).setByteBoolean((byte) 32, false));\n+        assertEquals(0, new BitField(64L).setByteBoolean((byte) 64, false));\n+        assertEquals(0, new BitField(128L).setByteBoolean((byte) 128, false));\n+        assertEquals(-2, new BitField(1L).setByteBoolean((byte) 255, false));\n+        final byte clearedBit = new BitField(0x40L).setByteBoolean((byte) - 63, false);\n+        assertFalse(new BitField(0x40).isSet(clearedBit));\n+    }\n+\n+    /**\n+     * Tests the {@link BitField#clear()} method.\n+     */\n+    @Test\n+    void testClearInt() {\n+        assertEquals(BF_MULTI.clear(-1), 0xFFFF_C07F);\n+        assertEquals(BF_SINGLE.clear(-1), 0xFFFF_BFFF);\n+        assertEquals(BF_ZERO.clear(-1), 0xFFFF_FFFF);\n+        assertEquals(BF_MULTI_L.clear(-1), 0xFFFF_FFFF);\n+        assertEquals(BF_SINGLE_L.clear(-1), 0xFFFF_FFFF);\n+        assertEquals(BF_ZERO_L.clear(-1), 0xFFFF_FFFF);\n+    }\n+\n+    /**\n+     * Tests the {@link BitField#clear()} method.\n+     */\n+    @Test\n+    void testClearLong() {\n+        assertEquals(BF_MULTI.clear(-1L), 0xFFFF_FFFF_FFFF_C07FL);\n+        assertEquals(BF_SINGLE.clear(-1L), 0xFFFF_FFFF_FFFF_BFFFL);\n+        assertEquals(BF_ZERO.clear(-1L), 0xFFFF_FFFF);\n+        assertEquals(BF_MULTI_L.clear(-1L), 0xC07F_FFFF_FFFF_FFFFL);\n+        assertEquals(BF_SINGLE_L.clear(-1L), 0xBFFF_FFFF_FFFF_FFFFL);\n+        assertEquals(BF_ZERO_L.clear(-1L), 0xFFFF_FFFF_FFFF_FFFFL);\n+    }\n+\n+    /**\n+     * Tests the {@link BitField#clearShort()} method.\n+     */\n+    @Test\n+    void testClearShort() {\n+        assertEquals(BF_MULTI.clearShort((short) - 1), (short) 0xC07F);\n+        assertEquals(BF_SINGLE.clearShort((short) - 1), (short) 0xBFFF);\n+        assertEquals(BF_ZERO.clearShort((short) -1), (short) 0xFFFF);\n+        assertEquals(BF_MULTI_L.clearShort((short) - 1), (short) 0xFFFF);\n+        assertEquals(BF_SINGLE_L.clearShort((short) - 1), (short) 0xFFFF);\n+        assertEquals(BF_ZERO_L.clearShort((short) -1), (short) 0xFFFF);\n+    }\n+\n+    @Test\n+    void testEdgeCases() {\n+        final BitField field = new BitField(0x1L); // bit 0\n+        assertEquals(1L, field.set(0L));\n+        assertEquals(0L, field.clear(1L));\n+        final BitField highField = new BitField(0x8000_0000_0000_0000L); // highest bit\n+        assertEquals(0x8000_0000_0000_0000L, highField.set(0L));\n+        assertEquals(0L, highField.clear(0x8000_0000_0000_0000L));\n+    }\n+\n+    /**\n+     * Tests the {@link BitField#getRawValue()} method.\n+     */\n+    @Test\n+    void testGetRawValue() {\n+        // mask < max int and int input\n+        assertEquals(BF_MULTI.getRawValue(-1), 0x3F80);\n+        assertEquals(BF_MULTI.getRawValue(0), 0);\n+        assertEquals(BF_SINGLE.getRawValue(-1), 0x4000);\n+        assertEquals(BF_SINGLE.getRawValue(0), 0);\n+        assertEquals(BF_ZERO.getRawValue(-1), 0);\n+        assertEquals(BF_ZERO.getRawValue(0), 0);\n+        // mask > max int and int input\n+        assertEquals(BF_MULTI_L.getRawValue(-1), 0);\n+        assertEquals(BF_MULTI_L.getRawValue(0), 0);\n+        assertEquals(BF_SINGLE_L.getRawValue(-1), 0);\n+        assertEquals(BF_SINGLE_L.getRawValue(0), 0);\n+        assertEquals(BF_ZERO_L.getRawValue(-1), 0);\n+        assertEquals(BF_ZERO_L.getRawValue(0), 0);\n+        // mask > max int and long input\n+        assertEquals(BF_MULTI_L.getRawValue(-1L), 0x3F80_0000_0000_0000L);\n+        assertEquals(BF_MULTI_L.getRawValue(0L), 0);\n+        assertEquals(BF_SINGLE_L.getRawValue(-1L), 0x4000_0000_0000_0000L);\n+        assertEquals(BF_SINGLE_L.getRawValue(0L), 0);\n+        assertEquals(BF_ZERO_L.getRawValue(-1L), 0);\n+        assertEquals(BF_ZERO_L.getRawValue(0L), 0);\n+    }\n+\n+    /**\n+     * Tests the {@link BitField#getShortRawValue()} method.\n+     */\n+    @Test\n+    void testGetShortRawValue() {\n+        // mask < max int and short input\n+        assertEquals(BF_MULTI.getShortRawValue((short) - 1), (short) 0x3F80);\n+        assertEquals(BF_MULTI.getShortRawValue((short) 0), (short) 0);\n+        assertEquals(BF_SINGLE.getShortRawValue((short) - 1), (short) 0x4000);\n+        assertEquals(BF_SINGLE.getShortRawValue((short) 0), (short) 0);\n+        assertEquals(BF_ZERO.getShortRawValue((short) -1), (short) 0);\n+        assertEquals(BF_ZERO.getShortRawValue((short) 0), (short) 0);\n+        // mask > max int and short input\n+        assertEquals(BF_MULTI_L.getShortRawValue((short) - 1), (short) 0);\n+        assertEquals(BF_MULTI_L.getShortRawValue((short) 0), (short) 0);\n+        assertEquals(BF_SINGLE_L.getShortRawValue((short) - 1), (short) 0);\n+        assertEquals(BF_SINGLE_L.getShortRawValue((short) 0), (short) 0);\n+        assertEquals(BF_ZERO_L.getShortRawValue((short) -1), (short) 0);\n+        assertEquals(BF_ZERO_L.getShortRawValue((short) 0), (short) 0);\n+    }\n+\n+    /**\n+     * Tests the getRawValue() and getValue() methods\n+     */\n+    @Test\n+    void testGetValueAndRawValueIntRange() {\n+        final BitField field = new BitField(0xFF00L); // bits 8-15\n+        final long holder = 0x1234L;\n+        // raw value: bits & mask\n+        assertEquals(0x1200L, field.getRawValue(holder));\n+        // shifted value: shifted right to LSB\n+        assertEquals(0x12L, field.getValue(holder));\n+    }\n+\n+    /**\n+     * Tests the isSet() and isAllSet() methods\n+     */\n+    @Test\n+    void testIsSetAndIsAllSet() {\n+        final BitField field1 = new BitField(0x3000L); // bits 12-13\n+        final long holder = 0x3000L;\n+        assertTrue(field1.isSet(holder));\n+        assertTrue(field1.isAllSet(holder));\n+        final long holderPartial = 0x1000L;\n+        assertTrue(field1.isSet(holderPartial));\n+        assertFalse(field1.isAllSet(holderPartial));\n+    }\n+\n+    @Test\n+    void testMultipleBits() {\n+        final BitField field = new BitField(0xF0F0L); // multiple bits\n+        final long holder = 0xAAAA;\n+        final long newValue = 0x55;\n+        final long result = field.setValue(holder, newValue);\n+        assertEquals(holder & ~0xF0F0L | newValue << 4 & 0xF0F0L, result);\n+    }\n+\n+    /**\n+     * Tests the set() method\n+     */\n+    @Test\n+    void testSet() {\n+        final BitField field = new BitField(0x1000L); // bit 12\n+        final long holder = 0x0000L;\n+        final long result = field.set(holder);\n+        assertEquals(0x1000L, result);\n+    }\n+\n+    /**\n+     * Tests the setBoolean() method\n+     */\n+    @Test\n+    void testSetBoolean() {\n+        final BitField field = new BitField(0x1000L); // bit 12\n+        final long holder = 0x0000L;\n+        final long setTrue = field.setBoolean(holder, true);\n+        assertEquals(0x1000L, setTrue);\n+        final long setFalse = field.setBoolean(setTrue, false);\n+        assertEquals(0x0000L, setFalse);\n+    }\n+\n+    /**\n+     * Tests the setValue() method\n+     */\n+    @Test\n+    void testSetValue() {\n+        final BitField field = new BitField(0xFF00L); // bits 8-15\n+        final long holder = 0x1200L;\n+        final long result = field.setValue(holder, 0x34L); // replace bits 8-15 with 0x34\n+        assertEquals(0x3400L, result);\n+    }\n+}\ndiff --git a/src/test/java/org/apache/commons/lang3/BitFieldTest.java b/src/test/java/org/apache/commons/lang3/BitFieldTest.java\nindex 27025cccb28..785cb2ac0b1 100644\n--- a/src/test/java/org/apache/commons/lang3/BitFieldTest.java\n+++ b/src/test/java/org/apache/commons/lang3/BitFieldTest.java\n@@ -23,16 +23,16 @@\n import org.junit.jupiter.api.Test;\n \n /**\n- * Class to test BitField functionality\n+ * Tests {@link BitField} constructed with int masks.\n  */\n class BitFieldTest extends AbstractLangTest {\n \n-    private static final BitField bf_multi  = new BitField(0x3F80);\n-    private static final BitField bf_single = new BitField(0x4000);\n-    private static final BitField bf_zero = new BitField(0);\n+    private static final BitField BF_MULTI  = new BitField(0x3F80);\n+    private static final BitField BF_SINGLE = new BitField(0x4000);\n+    private static final BitField BF_ZERO = new BitField(0);\n \n     @Test\n-    void testByte() {\n+    void testByteBoolean() {\n         assertEquals(0, new BitField(0).setByteBoolean((byte) 0, true));\n         assertEquals(1, new BitField(1).setByteBoolean((byte) 0, true));\n         assertEquals(2, new BitField(2).setByteBoolean((byte) 0, true));\n@@ -53,144 +53,153 @@ void testByte() {\n         assertEquals(0, new BitField(128).setByteBoolean((byte) 128, false));\n         assertEquals(-2, new BitField(1).setByteBoolean((byte) 255, false));\n         final byte clearedBit = new BitField(0x40).setByteBoolean((byte) - 63, false);\n-\n         assertFalse(new BitField(0x40).isSet(clearedBit));\n     }\n \n     /**\n-     * test the clear() method\n+     * Tests the {@link BitField#clear()} method.\n+     */\n+    @Test\n+    void testClearInt() {\n+        assertEquals(BF_MULTI.clear(-1), 0xFFFFC07F);\n+        assertEquals(BF_SINGLE.clear(-1), 0xFFFFBFFF);\n+        assertEquals(BF_ZERO.clear(-1), 0xFFFFFFFF);\n+    }\n+\n+    /**\n+     * Tests the {@link BitField#clear()} method.\n      */\n     @Test\n-    void testClear() {\n-        assertEquals(bf_multi.clear(-1), 0xFFFFC07F);\n-        assertEquals(bf_single.clear(-1), 0xFFFFBFFF);\n-        assertEquals(bf_zero.clear(-1), 0xFFFFFFFF);\n+    void testClearLong() {\n+        assertEquals(BF_MULTI.clear(-1L), 0xFFFFC07F);\n+        assertEquals(BF_SINGLE.clear(-1L), 0xFFFFBFFF);\n+        assertEquals(BF_ZERO.clear(-1L), 0xFFFFFFFF);\n     }\n \n     /**\n-     * test the clearShort() method\n+     * Tests the {@link BitField#clearShort()} method.\n      */\n     @Test\n     void testClearShort() {\n-        assertEquals(bf_multi.clearShort((short) - 1), (short) 0xC07F);\n-        assertEquals(bf_single.clearShort((short) - 1), (short) 0xBFFF);\n-        assertEquals(bf_zero.clearShort((short) -1), (short) 0xFFFF);\n+        assertEquals(BF_MULTI.clearShort((short) - 1), (short) 0xC07F);\n+        assertEquals(BF_SINGLE.clearShort((short) - 1), (short) 0xBFFF);\n+        assertEquals(BF_ZERO.clearShort((short) -1), (short) 0xFFFF);\n     }\n \n     /**\n-     * test the getRawValue() method\n+     * Tests the {@link BitField#getRawValue()} method.\n      */\n     @Test\n     void testGetRawValue() {\n-        assertEquals(bf_multi.getRawValue(-1), 0x3F80);\n-        assertEquals(bf_multi.getRawValue(0), 0);\n-        assertEquals(bf_single.getRawValue(-1), 0x4000);\n-        assertEquals(bf_single.getRawValue(0), 0);\n-        assertEquals(bf_zero.getRawValue(-1), 0);\n-        assertEquals(bf_zero.getRawValue(0), 0);\n+        assertEquals(BF_MULTI.getRawValue(-1), 0x3F80);\n+        assertEquals(BF_MULTI.getRawValue(0), 0);\n+        assertEquals(BF_SINGLE.getRawValue(-1), 0x4000);\n+        assertEquals(BF_SINGLE.getRawValue(0), 0);\n+        assertEquals(BF_ZERO.getRawValue(-1), 0);\n+        assertEquals(BF_ZERO.getRawValue(0), 0);\n     }\n \n     /**\n-     * test the getShortRawValue() method\n+     * Tests the {@link BitField#getShortRawValue()} method.\n      */\n     @Test\n     void testGetShortRawValue() {\n-        assertEquals(bf_multi.getShortRawValue((short) - 1), (short) 0x3F80);\n-        assertEquals(bf_multi.getShortRawValue((short) 0), (short) 0);\n-        assertEquals(bf_single.getShortRawValue((short) - 1), (short) 0x4000);\n-        assertEquals(bf_single.getShortRawValue((short) 0), (short) 0);\n-        assertEquals(bf_zero.getShortRawValue((short) -1), (short) 0);\n-        assertEquals(bf_zero.getShortRawValue((short) 0), (short) 0);\n+        assertEquals(BF_MULTI.getShortRawValue((short) - 1), (short) 0x3F80);\n+        assertEquals(BF_MULTI.getShortRawValue((short) 0), (short) 0);\n+        assertEquals(BF_SINGLE.getShortRawValue((short) - 1), (short) 0x4000);\n+        assertEquals(BF_SINGLE.getShortRawValue((short) 0), (short) 0);\n+        assertEquals(BF_ZERO.getShortRawValue((short) -1), (short) 0);\n+        assertEquals(BF_ZERO.getShortRawValue((short) 0), (short) 0);\n     }\n \n     /**\n-     * test the getShortValue() method\n+     * Tests the {@link BitField#getShortValue()} method.\n      */\n     @Test\n     void testGetShortValue() {\n-        assertEquals(bf_multi.getShortValue((short) - 1), (short) 127);\n-        assertEquals(bf_multi.getShortValue((short) 0), (short) 0);\n-        assertEquals(bf_single.getShortValue((short) - 1), (short) 1);\n-        assertEquals(bf_single.getShortValue((short) 0), (short) 0);\n-        assertEquals(bf_zero.getShortValue((short) -1), (short) 0);\n-        assertEquals(bf_zero.getShortValue((short) 0), (short) 0);\n+        assertEquals(BF_MULTI.getShortValue((short) - 1), (short) 127);\n+        assertEquals(BF_MULTI.getShortValue((short) 0), (short) 0);\n+        assertEquals(BF_SINGLE.getShortValue((short) - 1), (short) 1);\n+        assertEquals(BF_SINGLE.getShortValue((short) 0), (short) 0);\n+        assertEquals(BF_ZERO.getShortValue((short) -1), (short) 0);\n+        assertEquals(BF_ZERO.getShortValue((short) 0), (short) 0);\n     }\n \n     /**\n-     * test the getValue() method\n+     * Tests the {@link BitField#getValue()} method.\n      */\n     @Test\n     void testGetValue() {\n-        assertEquals(bf_multi.getValue(-1), 127);\n-        assertEquals(bf_multi.getValue(0), 0);\n-        assertEquals(bf_single.getValue(-1), 1);\n-        assertEquals(bf_single.getValue(0), 0);\n-        assertEquals(bf_zero.getValue(-1), 0);\n-        assertEquals(bf_zero.getValue(0), 0);\n+        assertEquals(BF_MULTI.getValue(-1), 127);\n+        assertEquals(BF_MULTI.getValue(0), 0);\n+        assertEquals(BF_SINGLE.getValue(-1), 1);\n+        assertEquals(BF_SINGLE.getValue(0), 0);\n+        assertEquals(BF_ZERO.getValue(-1), 0);\n+        assertEquals(BF_ZERO.getValue(0), 0);\n     }\n \n     /**\n-     * test the isAllSet() method\n+     * Tests the {@link BitField#isAllSet()} method.\n      */\n     @Test\n     void testIsAllSet() {\n         for (int j = 0; j < 0x3F80; j += 0x80) {\n-            assertFalse(bf_multi.isAllSet(j));\n-            assertTrue(bf_zero.isAllSet(j));\n+            assertFalse(BF_MULTI.isAllSet(j));\n+            assertTrue(BF_ZERO.isAllSet(j));\n         }\n-        assertTrue(bf_multi.isAllSet(0x3F80));\n-        assertFalse(bf_single.isAllSet(0));\n-        assertTrue(bf_single.isAllSet(0x4000));\n+        assertTrue(BF_MULTI.isAllSet(0x3F80));\n+        assertFalse(BF_SINGLE.isAllSet(0));\n+        assertTrue(BF_SINGLE.isAllSet(0x4000));\n     }\n \n     /**\n-     * test the isSet() method\n+     * test the isSet() method.\n      */\n     @Test\n     void testIsSet() {\n-        assertFalse(bf_multi.isSet(0));\n-        assertFalse(bf_zero.isSet(0));\n+        assertFalse(BF_MULTI.isSet(0));\n+        assertFalse(BF_ZERO.isSet(0));\n         for (int j = 0x80; j <= 0x3F80; j += 0x80) {\n-            assertTrue(bf_multi.isSet(j));\n+            assertTrue(BF_MULTI.isSet(j));\n         }\n         for (int j = 0x80; j <= 0x3F80; j += 0x80) {\n-            assertFalse(bf_zero.isSet(j));\n+            assertFalse(BF_ZERO.isSet(j));\n         }\n-        assertFalse(bf_single.isSet(0));\n-        assertTrue(bf_single.isSet(0x4000));\n+        assertFalse(BF_SINGLE.isSet(0));\n+        assertTrue(BF_SINGLE.isSet(0x4000));\n     }\n \n     /**\n-     * test the set() method\n+     * Tests the {@link BitField#set()} method.\n      */\n     @Test\n     void testSet() {\n-        assertEquals(bf_multi.set(0), 0x3F80);\n-        assertEquals(bf_single.set(0), 0x4000);\n-        assertEquals(bf_zero.set(0), 0);\n+        assertEquals(BF_MULTI.set(0), 0x3F80);\n+        assertEquals(BF_SINGLE.set(0), 0x4000);\n+        assertEquals(BF_ZERO.set(0), 0);\n     }\n \n     /**\n-     * test the setBoolean() method\n+     * Tests the {@link BitField#setBoolean()} method.\n      */\n     @Test\n     void testSetBoolean() {\n-        assertEquals(bf_multi.set(0), bf_multi.setBoolean(0, true));\n-        assertEquals(bf_single.set(0), bf_single.setBoolean(0, true));\n-        assertEquals(bf_zero.set(0), bf_zero.setBoolean(0, true));\n-        assertEquals(bf_multi.clear(-1), bf_multi.setBoolean(-1, false));\n-        assertEquals(bf_single.clear(-1), bf_single.setBoolean(-1, false));\n-        assertEquals(bf_zero.clear(-1), bf_zero.setBoolean(-1, false));\n+        assertEquals(BF_MULTI.set(0), BF_MULTI.setBoolean(0, true));\n+        assertEquals(BF_SINGLE.set(0), BF_SINGLE.setBoolean(0, true));\n+        assertEquals(BF_ZERO.set(0), BF_ZERO.setBoolean(0, true));\n+        assertEquals(BF_MULTI.clear(-1), BF_MULTI.setBoolean(-1, false));\n+        assertEquals(BF_SINGLE.clear(-1), BF_SINGLE.setBoolean(-1, false));\n+        assertEquals(BF_ZERO.clear(-1), BF_ZERO.setBoolean(-1, false));\n     }\n \n     /**\n-     * test the setShort() method\n+     * Tests the {@link BitField#setShort()} method.\n      */\n     @Test\n     void testSetShort() {\n-        assertEquals(bf_multi.setShort((short) 0), (short) 0x3F80);\n-        assertEquals(bf_single.setShort((short) 0), (short) 0x4000);\n-        assertEquals(bf_zero.setShort((short) 0), (short) 0);\n+        assertEquals(BF_MULTI.setShort((short) 0), (short) 0x3F80);\n+        assertEquals(BF_SINGLE.setShort((short) 0), (short) 0x4000);\n+        assertEquals(BF_ZERO.setShort((short) 0), (short) 0);\n     }\n \n     /**\n@@ -198,12 +207,12 @@ void testSetShort() {\n      */\n     @Test\n     void testSetShortBoolean() {\n-        assertEquals(bf_multi.setShort((short) 0), bf_multi.setShortBoolean((short) 0, true));\n-        assertEquals(bf_single.setShort((short) 0), bf_single.setShortBoolean((short) 0, true));\n-        assertEquals(bf_zero.setShort((short) 0), bf_zero.setShortBoolean((short) 0, true));\n-        assertEquals(bf_multi.clearShort((short) - 1), bf_multi.setShortBoolean((short) - 1, false));\n-        assertEquals(bf_single.clearShort((short) - 1), bf_single.setShortBoolean((short) - 1, false));\n-        assertEquals(bf_zero.clearShort((short) -1), bf_zero.setShortBoolean((short) -1, false));\n+        assertEquals(BF_MULTI.setShort((short) 0), BF_MULTI.setShortBoolean((short) 0, true));\n+        assertEquals(BF_SINGLE.setShort((short) 0), BF_SINGLE.setShortBoolean((short) 0, true));\n+        assertEquals(BF_ZERO.setShort((short) 0), BF_ZERO.setShortBoolean((short) 0, true));\n+        assertEquals(BF_MULTI.clearShort((short) - 1), BF_MULTI.setShortBoolean((short) - 1, false));\n+        assertEquals(BF_SINGLE.clearShort((short) - 1), BF_SINGLE.setShortBoolean((short) - 1, false));\n+        assertEquals(BF_ZERO.clearShort((short) -1), BF_ZERO.setShortBoolean((short) -1, false));\n     }\n \n     /**\n@@ -212,23 +221,23 @@ void testSetShortBoolean() {\n     @Test\n     void testSetShortValue() {\n         for (int j = 0; j < 128; j++) {\n-            assertEquals(bf_multi.getShortValue(bf_multi.setShortValue((short) 0, (short) j)), (short) j);\n-            assertEquals(bf_multi.setShortValue((short) 0, (short) j), (short) (j << 7));\n+            assertEquals(BF_MULTI.getShortValue(BF_MULTI.setShortValue((short) 0, (short) j)), (short) j);\n+            assertEquals(BF_MULTI.setShortValue((short) 0, (short) j), (short) (j << 7));\n         }\n         for (int j = 0; j < 128; j++) {\n-            assertEquals(bf_zero.getShortValue(bf_zero.setShortValue((short) 0, (short) j)), (short) 0);\n-            assertEquals(bf_zero.setShortValue((short) 0, (short) j), (short) 0);\n+            assertEquals(BF_ZERO.getShortValue(BF_ZERO.setShortValue((short) 0, (short) j)), (short) 0);\n+            assertEquals(BF_ZERO.setShortValue((short) 0, (short) j), (short) 0);\n         }\n \n         // verify that excess bits are stripped off\n-        assertEquals(bf_multi.setShortValue((short) 0x3f80, (short) 128), (short) 0);\n+        assertEquals(BF_MULTI.setShortValue((short) 0x3f80, (short) 128), (short) 0);\n         for (int j = 0; j < 2; j++) {\n-            assertEquals(bf_single.getShortValue(bf_single.setShortValue((short) 0, (short) j)), (short) j);\n-            assertEquals(bf_single.setShortValue((short) 0, (short) j), (short) (j << 14));\n+            assertEquals(BF_SINGLE.getShortValue(BF_SINGLE.setShortValue((short) 0, (short) j)), (short) j);\n+            assertEquals(BF_SINGLE.setShortValue((short) 0, (short) j), (short) (j << 14));\n         }\n \n         // verify that excess bits are stripped off\n-        assertEquals(bf_single.setShortValue((short) 0x4000, (short) 2), (short) 0);\n+        assertEquals(BF_SINGLE.setShortValue((short) 0x4000, (short) 2), (short) 0);\n     }\n \n     /**\n@@ -237,23 +246,23 @@ void testSetShortValue() {\n     @Test\n     void testSetValue() {\n         for (int j = 0; j < 128; j++) {\n-            assertEquals(bf_multi.getValue(bf_multi.setValue(0, j)), j);\n-            assertEquals(bf_multi.setValue(0, j), j << 7);\n+            assertEquals(BF_MULTI.getValue(BF_MULTI.setValue(0, j)), j);\n+            assertEquals(BF_MULTI.setValue(0, j), j << 7);\n         }\n         for (int j = 0; j < 128; j++) {\n-          assertEquals(bf_zero.getValue(bf_zero.setValue(0, j)), 0);\n-          assertEquals(bf_zero.setValue(0, j), 0);\n+          assertEquals(BF_ZERO.getValue(BF_ZERO.setValue(0, j)), 0);\n+          assertEquals(BF_ZERO.setValue(0, j), 0);\n       }\n \n         // verify that excess bits are stripped off\n-        assertEquals(bf_multi.setValue(0x3f80, 128), 0);\n+        assertEquals(BF_MULTI.setValue(0x3f80, 128), 0);\n         for (int j = 0; j < 2; j++) {\n-            assertEquals(bf_single.getValue(bf_single.setValue(0, j)), j);\n-            assertEquals(bf_single.setValue(0, j), j << 14);\n+            assertEquals(BF_SINGLE.getValue(BF_SINGLE.setValue(0, j)), j);\n+            assertEquals(BF_SINGLE.setValue(0, j), j << 14);\n         }\n \n         // verify that excess bits are stripped off\n-        assertEquals(bf_single.setValue(0x4000, 2), 0);\n+        assertEquals(BF_SINGLE.setValue(0x4000, 2), 0);\n     }\n \n }\n",
  "problem_statement" : "Add long support to `BitField`\n\nAdd long support to `BitField`.\r\n\r\nBefore you push a pull request, review this list:\r\n\r\n- [x] Read the [contribution guidelines](CONTRIBUTING.md) for this project.\r\n- [x] Read the [ASF Generative Tooling Guidance](https://www.apache.org/legal/generative-tooling.html) if you use Artificial Intelligence (AI).\r\n- [No] I used AI to create any part of, or all of, this pull request. Which AI tool was used to create this pull request, and to what extent did it contribute?\r\n- [x] Run a successful build using the default [Maven](https://maven.apache.org/) goal with `mvn`; that's `mvn` on the command line by itself.\r\n- [x] Write unit tests that match behavioral changes, where the tests fail if the changes to the runtime are not applied. This may not always be possible, but it is a best practice.\r\n- [x] Write a pull request description that is detailed enough to understand what the pull request does, how, and why.\r\n- [x] Each commit in the pull request should have a meaningful subject line and body. Note that a maintainer may squash commits during the merge process.\r\n",
  "hints_text" : null,
  "created_at" : "Sat Jan 10 18:29:47 CET 2026",
  "version" : null,
  "FAIL_TO_PASS" : [ "BitFieldTest", "BitFieldLongTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=BitFieldTest,BitFieldLongTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 1561,
  "metadata" : null
}, {
  "instance_id" : "apache-commons-lang-PR-1560",
  "repo" : "apache/commons-lang",
  "base_commit" : "ba6cf8e2390f18db484da766db19285255ac3e82",
  "patch" : "diff --git a/src/main/java/org/apache/commons/lang3/math/NumberUtils.java b/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\nindex 2ef56f4d952..6abd66502a5 100644\n--- a/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\n@@ -21,6 +21,7 @@\n import java.math.BigInteger;\n import java.math.RoundingMode;\n import java.util.Objects;\n+import java.util.function.Consumer;\n \n import org.apache.commons.lang3.CharUtils;\n import org.apache.commons.lang3.StringUtils;\n@@ -104,6 +105,15 @@ public class NumberUtils {\n      */\n     public static final Long LONG_INT_MIN_VALUE = Long.valueOf(Integer.MIN_VALUE);\n \n+    private static <T> boolean accept(final Consumer<T> consumer, final T obj) {\n+        try {\n+            consumer.accept(obj);\n+            return true;\n+        } catch (Exception e) {\n+            return false;\n+        }\n+    }\n+\n     /**\n      * Compares two {@code byte} values numerically. This is the same functionality as provided in Java 7.\n      *\n@@ -167,7 +177,7 @@ public static int compare(final short x, final short y) {\n      * Returns {@code null} if the string is {@code null}.\n      * </p>\n      *\n-     * @param str a {@link String} to convert, may be null.\n+     * @param str a {@link String} to convert, may be null.Return\n      * @return converted {@link BigDecimal} (or null if the input is null).\n      * @throws NumberFormatException if the value cannot be converted.\n      */\n@@ -730,7 +740,8 @@ public static boolean isNumber(final String str) {\n      * </p>\n      *\n      * <p>\n-     * Hexadecimal and scientific notations are <strong>not</strong> considered parsable. See {@link #isCreatable(String)} on those cases.\n+     * Scientific notation (for example, {@code \"1.2e-5\"}) and type suffixes (e.g., {@code \"2.0f\"}, {@code \"2.0d\"}) are supported\n+     * as they are valid for {@link Float#parseFloat(String)} and {@link Double#parseDouble(String)}.\n      * </p>\n      *\n      * <p>\n@@ -739,55 +750,14 @@ public static boolean isNumber(final String str) {\n      *\n      * @param str the String to check.\n      * @return {@code true} if the string is a parsable number.\n+     * @see Integer#parseInt(String)\n+     * @see Long#parseLong(String)\n+     * @see Double#parseDouble(String)\n+     * @see Float#parseFloat(String)\n      * @since 3.4\n      */\n     public static boolean isParsable(final String str) {\n-        if (StringUtils.isEmpty(str)) {\n-            return false;\n-        }\n-        if (str.charAt(0) == '-') {\n-            if (str.length() == 1) {\n-                return false;\n-            }\n-            return isParsableDecimal(str, 1);\n-        }\n-        return isParsableDecimal(str, 0);\n-    }\n-\n-    /**\n-     * Tests whether a number string is parsable as a decimal number or integer.\n-     *\n-     * <ul>\n-     * <li>At most one decimal point is allowed.</li>\n-     * <li>No signs, exponents or type qualifiers are allowed.</li>\n-     * <li>Only ASCII digits are allowed if a decimal point is present.</li>\n-     * </ul>\n-     *\n-     * @param str      the String to test.\n-     * @param beginIdx the index to start checking from.\n-     * @return {@code true} if the string is a parsable number.\n-     */\n-    private static boolean isParsableDecimal(final String str, final int beginIdx) {\n-        // See https://docs.oracle.com/javase/specs/jls/se8/html/jls-3.html#jls-NonZeroDigit\n-        int decimalPoints = 0;\n-        boolean asciiNumeric = true;\n-        for (int i = beginIdx; i < str.length(); i++) {\n-            final char ch = str.charAt(i);\n-            final boolean isDecimalPoint = ch == '.';\n-            if (isDecimalPoint) {\n-                decimalPoints++;\n-            }\n-            if (decimalPoints > 1 || !isDecimalPoint && !Character.isDigit(ch)) {\n-                return false;\n-            }\n-            if (!isDecimalPoint) {\n-                asciiNumeric &= CharUtils.isAsciiNumeric(ch);\n-            }\n-            if (decimalPoints > 0 && !asciiNumeric) {\n-                return false;\n-            }\n-        }\n-        return true;\n+        return accept(Double::parseDouble, str) || accept(Long::parseLong, str) || accept(Float::parseFloat, str) || accept(Long::parseLong, str);\n     }\n \n     private static boolean isSign(final char ch) {\n",
  "test_patch" : "diff --git a/src/test/java/org/apache/commons/lang3/math/NumberUtilsTest.java b/src/test/java/org/apache/commons/lang3/math/NumberUtilsTest.java\nindex 528039c9cf6..105dda46204 100644\n--- a/src/test/java/org/apache/commons/lang3/math/NumberUtilsTest.java\n+++ b/src/test/java/org/apache/commons/lang3/math/NumberUtilsTest.java\n@@ -37,6 +37,8 @@\n \n import org.apache.commons.lang3.AbstractLangTest;\n import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n \n /**\n  * Tests {@link org.apache.commons.lang3.math.NumberUtils}.\n@@ -1004,36 +1006,83 @@ void testIsNumberLANG992() {\n         compareIsNumberWithCreateNumber(\"0.4790\", true);\n     }\n \n-    @Test\n-    void testIsParsable() {\n-        assertFalse(NumberUtils.isParsable(null));\n-        assertFalse(NumberUtils.isParsable(\"\"));\n-        assertFalse(NumberUtils.isParsable(\"0xC1AB\"));\n-        assertFalse(NumberUtils.isParsable(\"65CBA2\"));\n-        assertFalse(NumberUtils.isParsable(\"pendro\"));\n-        assertFalse(NumberUtils.isParsable(\"64, 2\"));\n-        assertFalse(NumberUtils.isParsable(\"64.2.2\"));\n-        assertFalse(NumberUtils.isParsable(\"64..\"));\n-        assertTrue(NumberUtils.isParsable(\"64.\"));\n-        assertTrue(NumberUtils.isParsable(\"-64.\"));\n-        assertFalse(NumberUtils.isParsable(\"64L\"));\n-        assertFalse(NumberUtils.isParsable(\"-\"));\n-        assertFalse(NumberUtils.isParsable(\"--2\"));\n-        assertTrue(NumberUtils.isParsable(\"64.2\"));\n-        assertTrue(NumberUtils.isParsable(\"64\"));\n-        assertTrue(NumberUtils.isParsable(\"018\"));\n-        assertTrue(NumberUtils.isParsable(\".18\"));\n-        assertTrue(NumberUtils.isParsable(\"-65\"));\n-        assertTrue(NumberUtils.isParsable(\"-018\"));\n-        assertTrue(NumberUtils.isParsable(\"-018.2\"));\n-        assertTrue(NumberUtils.isParsable(\"-.236\"));\n-        assertTrue(NumberUtils.isParsable(\"2.\"));\n-        // TODO assertTrue(NumberUtils.isParsable(\"2.f\"));\n-        // TODO assertTrue(NumberUtils.isParsable(\"2.d\"));\n-        // Float.parseFloat(\"1.2e-5f\")\n-        // TODO assertTrue(NumberUtils.isParsable(\"1.2e-5f\"));\n-        // Double.parseDouble(\"1.2e-5d\")\n-        // TODO assertTrue(NumberUtils.isParsable(\"1.2e-5d\"));\n+    @ParameterizedTest\n+    // @formatter:off\n+    @ValueSource(strings = {\n+            // Decimal floating-point literals (no suffix or 'd'/'D' suffix)\n+            \"3.14\",\n+            \"3.14d\",\n+            \"3.14D\",\n+            \".5\",\n+            \".5d\",\n+            \"5.\",\n+            \"5.d\",\n+            \"5d\",\n+            \"0.0\",\n+            \"0.0d\",\n+            // Exponential (scientific) notation\n+            \"1.23e10\",\n+            \"1.23e10d\",\n+            \"1.23E10\",\n+            \"1.23e-10\",\n+            \"1.23e-10d\",\n+            \"1e5\",\n+            \"1e5d\",\n+            \".5e3\",\n+            \".5e3d\",\n+            // Hexadecimal floating-point literals\n+            \"0x1.8p3\",\n+            \"0x1.8p3d\",\n+            \"0x.8p0\",\n+            \"0x1p-3\",\n+            \"0x1.fffffffffffffp1023\",\n+            \"0x1.fffffffffffffp1023d\",\n+            // With leading zeros\n+            \"01.5\",\n+            \"01.5d\" })\n+    // @formatter:on\n+    void testIsParsableDoubleTrue(final String input) {\n+        Double.parseDouble(input);\n+        assertTrue(NumberUtils.isParsable(input));\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(strings = { \"\", \"0xC1AB\", \"65CBA2\", \"pendro\", \"64, 2\", \"64.2.2\", \"64..\", \"64L\", \"-\", \"--2\",\n+            // Invalid scientific notation.\n+            \"e5\", \"1e\", \"1e+\", \"1e-\", \"1ee5\", \"1e5e5\",\n+            // Invalid type suffixes.\n+            \"f\", \"d\", \"-f\", \"-d\", })\n+    void testIsParsableFalse(final String input) {\n+        assertFalse(NumberUtils.isParsable(input));\n+    }\n+\n+    @ParameterizedTest\n+    // @formatter:off\n+    @ValueSource(strings = {\n+            // Decimal floating-point literals\n+            \"3.14f\",\n+            \"3.14F\",\n+            \".5f\",\n+            \"5.f\",\n+            \"5f\",\n+            \"0.0f\",\n+            // Exponential (scientific) notation\n+            \"1.23e10f\",\n+            \"1.23E10f\",\n+            \"1.23e-10f\",\n+            \"1e5f\",\n+            \".5e3f\",\n+            // Hexadecimal floating-point literals\n+            \"0x1.8p3f\",\n+            \"0x.8p0f\",\n+            \"0x1p-3f\",\n+            \"0x1.fffffep127f\",\n+            // With leading zeros\n+            \"01.5f\"})\n+    // @formatter:on\n+    void testIsParsableFloatTrue(final String input) {\n+        Float.parseFloat(input);\n+        assertTrue(NumberUtils.isParsable(input));\n     }\n \n     /**\n@@ -1056,6 +1105,39 @@ void testIsParsableFullWidthUnicodeJDK8326627() {\n         assertFalse(NumberUtils.isParsable(\"0.\" + fullWidth123));\n     }\n \n+    @Test\n+    void testIsParsableNull() {\n+        // Can't use null in @ValueSource(strings)\n+        assertFalse(NumberUtils.isParsable(null));\n+    }\n+\n+    @ParameterizedTest\n+    // @formatter:off\n+    @ValueSource(strings = {\n+            \"64.\",\n+            \"-64.\",\n+            \"64.2\",\n+            \"64\",\n+            \"018\",\n+            \".18\",\n+            \"-65\",\n+            \"-018\",\n+            \"-018.2\",\n+            \"-.236\",\n+            \"2.\",\n+            \"2.f\",\n+            \"2.d\",\n+            \"1.2e-5f\",\n+            \"1.2e-5d\",\n+            // Additional tests for scientific notation.\n+            \"1e5\", \"1E5\", \"1.2e5\", \"1.2E5\", \"1.2e+5\", \"1.2e-5\", \"-1.2e-5\", \"1e5f\", \"1e5F\", \"1e5d\", \"1e5D\",\n+            // Additional tests for type suffixes.\n+            \"2f\", \"2F\", \"2d\", \"2D\", \"2.0f\", \"2.0F\", \"2.0d\", \"2.0D\", \"-2.0f\", \"-2.0d\" })\n+    // @formatter:on\n+    void testIsParsableTrue(final String input) {\n+        assertTrue(NumberUtils.isParsable(input));\n+    }\n+\n     @Test\n     void testLang1087() {\n         // no sign cases\n@@ -1087,8 +1169,8 @@ void testLang1729IsParsableByte() {\n     void testLang1729IsParsableDouble() {\n         assertTrue(isParsableDouble(\"1\"));\n         assertTrue(isParsableDouble(\"1.\"));\n-        // TODO assertTrue(isParsableDouble(\"1.f\"));\n-        // TODO assertTrue(isParsableDouble(\"1.d\"));\n+        assertTrue(isParsableDouble(\"1.f\"));\n+        assertTrue(isParsableDouble(\"1.d\"));\n         assertTrue(isParsableDouble(\"1.0\"));\n         assertFalse(isParsableDouble(\"1.0.\"));\n         assertFalse(isParsableDouble(\"1 2 3\"));\n@@ -1099,8 +1181,8 @@ void testLang1729IsParsableDouble() {\n     void testLang1729IsParsableFloat() {\n         assertTrue(isParsableFloat(\"1\"));\n         assertTrue(isParsableFloat(\"1.\"));\n-        // TODO assertTrue(isParsableFloat(\"1.f\"));\n-        // TODO assertTrue(isParsableFloat(\"1.d\"));\n+        assertTrue(isParsableFloat(\"1.f\"));\n+        assertTrue(isParsableFloat(\"1.d\"));\n         assertTrue(isParsableFloat(\"1.0\"));\n         assertFalse(isParsableFloat(\"1.0.\"));\n         assertFalse(isParsableFloat(\"1 2 3\"));\n",
  "problem_statement" : "[LANG-1806] NumberUtils.isParsable(\"1.f\") should return true\n\n[[LANG-1806]](https://issues.apache.org/jira/browse/LANG-1806) NumberUtils.isParsable(\"1.f\") should return true\r\n\r\n- Return true for numbers like 1.2e-5d and 1.2e-5f\r\n- Use a regular expression\r\n\r\nBefore you push a pull request, review this list:\r\n\r\n- [x] Read the [contribution guidelines](CONTRIBUTING.md) for this project.\r\n- [x] Read the [ASF Generative Tooling Guidance](https://www.apache.org/legal/generative-tooling.html) if you use Artificial Intelligence (AI).\r\n- [x] I used AI to create any part of, or all of, this pull request: Claude Sonet 4.5\r\n- [x] Run a successful build using the default [Maven](https://maven.apache.org/) goal with `mvn`; that's `mvn` on the command line by itself.\r\n- [x] Write unit tests that match behavioral changes, where the tests fail if the changes to the runtime are not applied. This may not always be possible, but it is a best practice.\r\n- [x] Write a pull request description that is detailed enough to understand what the pull request does, how, and why.\r\n- [x] Each commit in the pull request should have a meaningful subject line and body. Note that a maintainer may squash commits during the merge process.\r\n",
  "hints_text" : null,
  "created_at" : "Sat Jan 10 14:17:24 CET 2026",
  "version" : null,
  "FAIL_TO_PASS" : [ "NumberUtilsTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=NumberUtilsTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 1560,
  "metadata" : null
}, {
  "instance_id" : "apache-commons-lang-PR-1559",
  "repo" : "apache/commons-lang",
  "base_commit" : "037880852770c3124f8d61c2dbf2b31f34a75508",
  "patch" : "diff --git a/src/main/java/org/apache/commons/lang3/ArrayUtils.java b/src/main/java/org/apache/commons/lang3/ArrayUtils.java\nindex 4369d4f7e03..c63bd365bf9 100644\n--- a/src/main/java/org/apache/commons/lang3/ArrayUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/ArrayUtils.java\n@@ -194,9 +194,18 @@ public class ArrayUtils {\n      * The {@code SOFT_MAX_ARRAY_LENGTH} constant from Java's internal ArraySupport class.\n      *\n      * @since 3.19.0\n+     * @deprecated This variable will be final in 4.0; to guarantee immutability now, use {@link #SAFE_MAX_ARRAY_LENGTH}.\n      */\n+    @Deprecated\n     public static int SOFT_MAX_ARRAY_LENGTH = Integer.MAX_VALUE - 8;\n \n+    /**\n+     * The {@code MAX_ARRAY_LENGTH} constant from Java's internal ArraySupport class.\n+     *\n+     * @since 3.21.0\n+     */\n+    public static final int SAFE_MAX_ARRAY_LENGTH = Integer.MAX_VALUE - 8;\n+\n     /**\n      * Copies the given array and adds the given element at the end of the new array.\n      * <p>\n",
  "test_patch" : "diff --git a/src/test/java/org/apache/commons/lang3/ArrayUtilsTest.java b/src/test/java/org/apache/commons/lang3/ArrayUtilsTest.java\nindex cb3a38eeaeb..a6ff321b9c5 100644\n--- a/src/test/java/org/apache/commons/lang3/ArrayUtilsTest.java\n+++ b/src/test/java/org/apache/commons/lang3/ArrayUtilsTest.java\n@@ -6958,4 +6958,9 @@ void testToStringDefault() {\n         assertEquals(\"{<null>}\", ArrayUtils.toString(new String[]{null}, \"<empty>\"));\n         assertEquals(\"{pink,blue}\", ArrayUtils.toString(new String[]{\"pink\", \"blue\"}, \"<empty>\"));\n     }\n+\n+    @Test\n+    void testMaxArrayLength() {\n+        assertEquals(Integer.MAX_VALUE - 8, ArrayUtils.SAFE_MAX_ARRAY_LENGTH);\n+    }\n }\n",
  "problem_statement" : "[LANG-1810] Deprecate SOFT_MAX_ARRAY_LENGTH in favor of MAX_ARRAY_LENGTH\n\n## Overview\r\nAddresses **LANG-1810** by transitioning the non-final field `SOFT_MAX_ARRAY_LENGTH` to a final constant.\r\n\r\n## Changes\r\n- **Deprecation**: Marked `SOFT_MAX_ARRAY_LENGTH` as `@Deprecated`.\r\n- **New Constant**: Added `public static final int SAFE_ARRAY_LENGTH` as a safe alternative.\r\n\r\n## Why\r\nTo resolve the \"non-final public field\" flaw while maintaining Binary Compatibility for the 3.x release line.",
  "hints_text" : null,
  "created_at" : "Sat Jan 10 04:32:22 CET 2026",
  "version" : null,
  "FAIL_TO_PASS" : [ "ArrayUtilsTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=ArrayUtilsTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 1559,
  "metadata" : null
}, {
  "instance_id" : "apache-commons-lang-PR-1549",
  "repo" : "apache/commons-lang",
  "base_commit" : "71d4f3d17f029c16e0783f39d1fbf1ad88bedacf",
  "patch" : "diff --git a/src/main/java/org/apache/commons/lang3/reflect/TypeUtils.java b/src/main/java/org/apache/commons/lang3/reflect/TypeUtils.java\nindex f1fc44ae3da..3633a26e430 100644\n--- a/src/main/java/org/apache/commons/lang3/reflect/TypeUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/reflect/TypeUtils.java\n@@ -841,7 +841,19 @@ private static Map<TypeVariable<?>, Type> getTypeArguments(final ParameterizedTy\n             return typeVarAssigns;\n         }\n         // walk the inheritance hierarchy until the target class is reached\n-        return getTypeArguments(getClosestParentType(cls, toClass), toClass, typeVarAssigns);\n+        final Type parentType = getClosestParentType(cls, toClass);\n+        if (parentType instanceof ParameterizedType) {\n+            final ParameterizedType parameterizedParentType = (ParameterizedType) parentType;\n+            final Type[] parentTypeArgs = parameterizedParentType.getActualTypeArguments().clone();\n+            for (int i = 0; i < parentTypeArgs.length; i++) {\n+                final Type unrolled = unrollVariables(typeVarAssigns, parentTypeArgs[i]);\n+                if (unrolled != null) {\n+                    parentTypeArgs[i] = unrolled;\n+                }\n+            }\n+            return getTypeArguments(parameterizeWithOwner(parameterizedParentType.getOwnerType(), (Class<?>) parameterizedParentType.getRawType(), parentTypeArgs), toClass, typeVarAssigns);\n+        }\n+        return getTypeArguments(parentType, toClass, typeVarAssigns);\n     }\n \n     /**\n@@ -1672,9 +1684,17 @@ public static Type unrollVariables(Map<TypeVariable<?>, Type> typeArguments, fin\n         if (typeArguments == null) {\n             typeArguments = Collections.emptyMap();\n         }\n+        return unrollVariables(typeArguments, type, new HashSet<>());\n+    }\n+\n+    private static Type unrollVariables(final Map<TypeVariable<?>, Type> typeArguments, final Type type, final Set<TypeVariable<?>> visited) {\n         if (containsTypeVariables(type)) {\n             if (type instanceof TypeVariable<?>) {\n-                return unrollVariables(typeArguments, typeArguments.get(type));\n+                final TypeVariable<?> var = (TypeVariable<?>) type;\n+                if (!visited.add(var)) {\n+                    return var;\n+                }\n+                return unrollVariables(typeArguments, typeArguments.get(type), visited);\n             }\n             if (type instanceof ParameterizedType) {\n                 final ParameterizedType p = (ParameterizedType) type;\n@@ -1685,9 +1705,9 @@ public static Type unrollVariables(Map<TypeVariable<?>, Type> typeArguments, fin\n                     parameterizedTypeArguments = new HashMap<>(typeArguments);\n                     parameterizedTypeArguments.putAll(getTypeArguments(p));\n                 }\n-                final Type[] args = p.getActualTypeArguments();\n+                final Type[] args = p.getActualTypeArguments().clone();\n                 for (int i = 0; i < args.length; i++) {\n-                    final Type unrolled = unrollVariables(parameterizedTypeArguments, args[i]);\n+                    final Type unrolled = unrollVariables(parameterizedTypeArguments, args[i], visited);\n                     if (unrolled != null) {\n                         args[i] = unrolled;\n                     }\n",
  "test_patch" : "diff --git a/src/test/java/org/apache/commons/lang3/reflect/TypeUtilsTest.java b/src/test/java/org/apache/commons/lang3/reflect/TypeUtilsTest.java\nindex fd3a6ec6565..f0355987432 100644\n--- a/src/test/java/org/apache/commons/lang3/reflect/TypeUtilsTest.java\n+++ b/src/test/java/org/apache/commons/lang3/reflect/TypeUtilsTest.java\n@@ -43,6 +43,7 @@\n import java.util.Collections;\n import java.util.Comparator;\n import java.util.HashMap;\n+import java.util.Iterator;\n import java.util.List;\n import java.util.Map;\n import java.util.Properties;\n@@ -368,6 +369,49 @@ void test_LANG_1702() throws NoSuchMethodException, SecurityException {\n         final Type unrolledType = TypeUtils.unrollVariables(typeArguments, type);\n     }\n \n+    static class MyException extends Exception implements Iterable<Throwable> {\n+\n+        private static final long serialVersionUID = 1L;\n+\n+        @Override\n+        public Iterator<Throwable> iterator() {\n+            return null;\n+        }\n+    }\n+\n+    static class MyNonTransientException extends MyException {\n+        private static final long serialVersionUID = 1L;\n+    }\n+\n+    interface MyComparator<T> {\n+    }\n+\n+    static class MyOrdering<T> implements MyComparator<T> {\n+    }\n+\n+    static class LexOrdering<T> extends MyOrdering<Iterable<T>> implements Serializable {\n+        private static final long serialVersionUID = 1L;\n+    }\n+\n+    /**\n+     * Tests that a parameterized type with a nested generic argument is correctly\n+     * evaluated for assignability to a wildcard lower-bounded type.\n+     *\n+     * @see <a href=\"https://issues.apache.org/jira/browse/LANG-1700\">LANG-1700</a>\n+     */\n+    @Test\n+    public void test_LANG_1700() {\n+        final ParameterizedType from = TypeUtils.parameterize(LexOrdering.class, MyNonTransientException.class);\n+        // MyComparator<? super MyNonTransientException>\n+        final ParameterizedType to = TypeUtils.parameterize(MyComparator.class,\n+                TypeUtils.wildcardType().withLowerBounds(MyNonTransientException.class).build());\n+        // This is MyComparator<Iterable<MyNonTransientException>>\n+        // It should NOT be assignable to MyComparator<? super MyNonTransientException>\n+        // because Iterable<MyNonTransientException> is NOT a supertype of MyNonTransientException\n+        assertFalse(TypeUtils.isAssignable(from, to),\n+                () -> String.format(\"Type %s should not be assignable to %s\", TypeUtils.toString(from), TypeUtils.toString(to)));\n+    }\n+\n     @Test\n     void testContainsTypeVariables() throws NoSuchMethodException {\n         assertFalse(TypeUtils.containsTypeVariables(Test1.class.getMethod(\"m0\").getGenericReturnType()));\n",
  "problem_statement" : "[LANG-1700] Improve handling of parameterized types and variable unrolling\n\n## Summary\r\nFixes incorrect assignability checks for parameterized types with nested generic arguments.\r\n\r\n## Problem\r\n`TypeUtils.isAssignable()` incorrectly returned `true` when checking if `MyComparator<Iterable<MyNonTransientException>>` is assignable to `MyComparator<? super MyNonTransientException>`. This happened because the type variable unrolling logic in `getTypeArguments()` didn't properly resolve nested generic arguments when traversing the inheritance hierarchy.\r\n\r\n## Changes\r\n- **Enhanced `getTypeArguments()`**: When walking up the inheritance hierarchy, now properly unrolls type variables in parameterized parent types before recursing, ensuring nested generic arguments are correctly resolved\r\n- **Fixed infinite recursion in `unrollVariables()`**: Added a `visited` set to track already-visited `TypeVariable` instances, preventing infinite loops when circular type variable references exist\r\n- **Fixed in-place mutation**: Now clones type argument arrays before modifying them to avoid unintended side effects\r\n- **Added test coverage**: New `test_LANG_1700()` validates the fix with a complex parameterized type hierarchy\r\n\r\n## Test Case\r\nThe test verifies that `LexOrdering<MyNonTransientException>` (which implements `MyComparator<Iterable<MyNonTransientException>>`) is correctly identified as **not** assignable to `MyComparator<? super MyNonTransientException>`, since `Iterable<MyNonTransientException>` is not a supertype of `MyNonTransientException`.\r\n",
  "hints_text" : null,
  "created_at" : "Tue Dec 30 20:44:15 CET 2025",
  "version" : null,
  "FAIL_TO_PASS" : [ "TypeUtilsTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=TypeUtilsTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 1549,
  "metadata" : null
}, {
  "instance_id" : "apache-commons-lang-PR-1548",
  "repo" : "apache/commons-lang",
  "base_commit" : "5e9736adf2b27f0a65cfa3fff9180cb34fac30c0",
  "patch" : "diff --git a/src/main/java/org/apache/commons/lang3/reflect/TypeUtils.java b/src/main/java/org/apache/commons/lang3/reflect/TypeUtils.java\nindex 3c721719ab9..f1fc44ae3da 100644\n--- a/src/main/java/org/apache/commons/lang3/reflect/TypeUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/reflect/TypeUtils.java\n@@ -1080,6 +1080,17 @@ private static boolean isAssignable(final Type type, final ParameterizedType toP\n         }\n         // get the target type's type arguments including owner type arguments\n         final Map<TypeVariable<?>, Type> toTypeVarAssigns = getTypeArguments(toParameterizedType, toClass, typeVarAssigns);\n+        // Class<T> is not assignable to Class<S> if T is not S (even if T extends S)\n+        if (toClass.equals(Class.class)) {\n+            final TypeVariable<?>[] typeParams = toClass.getTypeParameters();\n+            if (typeParams.length > 0) {\n+                final Type toTypeArg = unrollVariableAssignments(typeParams[0], toTypeVarAssigns);\n+                final Type fromTypeArg = unrollVariableAssignments(typeParams[0], fromTypeVarAssigns);\n+                if (toTypeArg != null && (fromTypeArg == null || !toTypeArg.equals(fromTypeArg))) {\n+                    return false;\n+                }\n+            }\n+        }\n         // now to check each type argument\n         for (final TypeVariable<?> var : toTypeVarAssigns.keySet()) {\n             final Type toTypeArg = unrollVariableAssignments(var, toTypeVarAssigns);\n",
  "test_patch" : "diff --git a/src/test/java/org/apache/commons/lang3/reflect/TypeUtilsTest.java b/src/test/java/org/apache/commons/lang3/reflect/TypeUtilsTest.java\nindex e9a6709d3e0..565a8d78a0b 100644\n--- a/src/test/java/org/apache/commons/lang3/reflect/TypeUtilsTest.java\n+++ b/src/test/java/org/apache/commons/lang3/reflect/TypeUtilsTest.java\n@@ -773,6 +773,33 @@ void testIsAssignableGenericArrayTypeToWildcardType() {\n                 () -> String.format(\"TypeUtils.isAssignable(%s, %s)\", testType, paramType));\n     }\n \n+    @Test\n+    void testIsAssignable_ClassWithParameterizedType() {\n+        final ParameterizedType topre1 = TypeUtils.parameterize(TestIF.class, TypeUtils.wildcardType().build());\n+        final Type to1 = TypeUtils.parameterize(Class.class, TypeUtils.wildcardType().withUpperBounds(topre1).build());\n+        final Type from1 = TypeUtils.parameterize(Class.class, TestIF.class);\n+        assertFalse(TypeUtils.isAssignable(from1, to1), \"Class<TestIF> should not be assignable to Class<? extends TestIF<?>>\");\n+\n+        final ParameterizedType topre2 = TypeUtils.parameterize(TestIF.class, TypeUtils.wildcardType().build());\n+        final Type to2 = TypeUtils.parameterize(Class.class, TypeUtils.wildcardType().withUpperBounds(topre2).build());\n+        final Type from2 = TypeUtils.parameterize(Class.class, TestImpl.class);\n+        assertFalse(TypeUtils.isAssignable(from2, to2), \"Class<TestImpl> should not be assignable to Class<? extends TestIF<?>>\");\n+\n+        final ParameterizedType topre3 = TypeUtils.parameterize(TestIF.class, Number.class);\n+        final Type to3 = TypeUtils.parameterize(Class.class, TypeUtils.wildcardType().withUpperBounds(topre3).build());\n+        final Type from3 = TypeUtils.parameterize(Class.class, TestImpl2.class);\n+        assertFalse(TypeUtils.isAssignable(from3, to3), \"Class<TestImpl2> should not be assignable to Class<? extends TestIF<Number>>\");\n+    }\n+\n+    private interface TestIF<T> {\n+    }\n+\n+    private static class TestImpl<T> implements TestIF<T> {\n+    }\n+\n+    private static class TestImpl2<R> implements TestIF<Number> {\n+    }\n+\n     @Test\n     void testIsAssignableGenericClassHierarchy() throws NoSuchFieldException {\n         /*\n",
  "problem_statement" : "[LANG-1749] Add stricter type checks for  parameterized types in  method\n\n### Fix `TypeUtils.isAssignable` for `Class` parameterized types\r\n\r\n#### Summary\r\nThis PR fixes a bug in `TypeUtils.isAssignable` where it incorrectly returned `true` for certain `ParameterizedType` assignments involving `java.lang.Class`. Specifically, it was allowing assignments like `Class<TestIF>` to `Class<? extends TestIF<?>>`, which are prohibited by the Java compiler due to the invariance of the `Class<T>` type.\r\n\r\n#### Problem\r\nIn Java, `Class<T>` is invariant. This means that even if `TestImpl` extends `TestIF`, `Class<TestImpl>` is NOT assignable to `Class<TestIF>`. Furthermore, `Class<TestIF>` is not assignable to `Class<? extends TestIF<?>>` because the type argument of the latter is a wildcard that requires a specific capturing behavior that a raw-ish or differently parameterized `Class` does not satisfy in the same way.\r\n\r\nThe previous implementation of `TypeUtils.isAssignable(Type, ParameterizedType, Map)` was too permissive when handling `Class.class` as the raw type, treating it like any other parameterized interface or class instead of enforcing the strict invariance required for `Class<T>`.\r\n\r\n#### Solution\r\nThe fix introduces a specialized check within `isAssignable(Type, ParameterizedType, Map)` when the target raw type is `java.lang.Class`. \r\n\r\n1.  It identifies if the target `ParameterizedType` represents a `Class<?>`.\r\n2.  It extracts the type argument from both the source and target.\r\n3.  It ensures that the source type argument matches the target type argument exactly, or correctly satisfies the target's wildcard bounds if applicable, adhering to the strict rules of the Java language for the `Class` class.\r\n\r\n#### Changes\r\n- **`org.apache.commons.lang3.reflect.TypeUtils`**: \r\n    - Added a logic block in `isAssignable(Type, ParameterizedType, Map)` specifically for `Class.class`.\r\n    - Implemented strict comparison for `Class` type arguments using `unrollVariableAssignments` to resolve any type variables in the current context.\r\n    - Ensures that even if the target is a wildcard (e.g., `Class<? extends Foo>`), the source must match the captured type exactly or satisfy the bound without violating invariance.\r\n- **`org.apache.commons.lang3.reflect.TypeUtilsTest`**: \r\n    - Added `testIsAssignable_ClassWithParameterizedType` which includes:\r\n        - `Class<TestIF>` to `Class<? extends TestIF<?>>` (Expected: `false`)\r\n        - `Class<TestImpl>` to `Class<? extends TestIF<?>>` (Expected: `false`)\r\n        - `Class<TestImpl2>` to `Class<? extends TestIF<Number>>` (Expected: `false`)\r\n    - Added helper internal interfaces and classes (`TestIF<T>`, `TestImpl<T>`, `TestImpl2<R>`) to support these test cases.\r\n\r\nNote: Used AI tools in the writing of this PR - JetBrains AI. There are no copyright issues with the submitted code.\r\n",
  "hints_text" : null,
  "created_at" : "Tue Dec 30 16:07:14 CET 2025",
  "version" : null,
  "FAIL_TO_PASS" : [ "TypeUtilsTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=TypeUtilsTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 1548,
  "metadata" : null
}, {
  "instance_id" : "apache-commons-lang-PR-1531",
  "repo" : "apache/commons-lang",
  "base_commit" : "ddf1ce9704cb94bd76fe9cb3dae280e2f2645dbc",
  "patch" : "diff --git a/src/main/java/org/apache/commons/lang3/math/NumberUtils.java b/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\nindex 3bfd0ece346..77682188bd2 100644\n--- a/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\n@@ -724,7 +724,7 @@ public static boolean isNumber(final String str) {\n      * @since 3.4\n      */\n     public static boolean isParsable(final String str) {\n-        if (StringUtils.isEmpty(str) || str.charAt(str.length() - 1) == '.') {\n+        if (StringUtils.isEmpty(str)) {\n             return false;\n         }\n         if (str.charAt(0) == '-') {\n",
  "test_patch" : "diff --git a/src/test/java/org/apache/commons/lang3/math/NumberUtilsTest.java b/src/test/java/org/apache/commons/lang3/math/NumberUtilsTest.java\nindex 3b8aae4e9af..e0ab4daa322 100644\n--- a/src/test/java/org/apache/commons/lang3/math/NumberUtilsTest.java\n+++ b/src/test/java/org/apache/commons/lang3/math/NumberUtilsTest.java\n@@ -1013,7 +1013,7 @@ void testIsParsable() {\n         assertFalse(NumberUtils.isParsable(\"pendro\"));\n         assertFalse(NumberUtils.isParsable(\"64, 2\"));\n         assertFalse(NumberUtils.isParsable(\"64.2.2\"));\n-        assertFalse(NumberUtils.isParsable(\"64.\"));\n+        assertTrue(NumberUtils.isParsable(\"64.\"));\n         assertFalse(NumberUtils.isParsable(\"64L\"));\n         assertFalse(NumberUtils.isParsable(\"-\"));\n         assertFalse(NumberUtils.isParsable(\"--2\"));\n@@ -1025,6 +1025,7 @@ void testIsParsable() {\n         assertTrue(NumberUtils.isParsable(\"-018\"));\n         assertTrue(NumberUtils.isParsable(\"-018.2\"));\n         assertTrue(NumberUtils.isParsable(\"-.236\"));\n+        assertTrue(NumberUtils.isParsable(\"2.\"));\n     }\n \n     /**\n",
  "problem_statement" : "LANG-1695: Allow trailing decimal point in NumberUtils.isParsable\n\nFixes LANG-1695.\r\n\r\nNumberUtils.isParsable rejected numeric strings ending with a decimal\r\npoint (e.g. \"2.\", \"64.\"), although such values are valid according to\r\nFloat.parseFloat and Double.parseDouble.\r\n\r\nThis change removes the premature trailing-dot rejection and updates\r\ntests to reflect the correct behavior.\r\n",
  "hints_text" : null,
  "created_at" : "Wed Dec 17 16:23:18 CET 2025",
  "version" : null,
  "FAIL_TO_PASS" : [ "NumberUtilsTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=NumberUtilsTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 1531,
  "metadata" : null
}, {
  "instance_id" : "apache-commons-lang-PR-1530",
  "repo" : "apache/commons-lang",
  "base_commit" : "2595926918d8783b1507fded8a65ee3439048839",
  "patch" : "diff --git a/src/main/java/org/apache/commons/lang3/CharSet.java b/src/main/java/org/apache/commons/lang3/CharSet.java\nindex 883cfa2860c..5853f84526d 100644\n--- a/src/main/java/org/apache/commons/lang3/CharSet.java\n+++ b/src/main/java/org/apache/commons/lang3/CharSet.java\n@@ -151,7 +151,7 @@ public class CharSet implements Serializable {\n      */\n     public static CharSet getInstance(final String... setStrs) {\n         if (setStrs == null) {\n-            return null;\n+            return EMPTY;\n         }\n         if (setStrs.length == 1) {\n             final CharSet common = COMMON.get(setStrs[0]);\n",
  "test_patch" : "diff --git a/src/test/java/org/apache/commons/lang3/CharSetTest.java b/src/test/java/org/apache/commons/lang3/CharSetTest.java\nindex 48e90c225d2..7fbed997a0a 100644\n--- a/src/test/java/org/apache/commons/lang3/CharSetTest.java\n+++ b/src/test/java/org/apache/commons/lang3/CharSetTest.java\n@@ -21,7 +21,6 @@\n import static org.junit.jupiter.api.Assertions.assertEquals;\n import static org.junit.jupiter.api.Assertions.assertFalse;\n import static org.junit.jupiter.api.Assertions.assertNotEquals;\n-import static org.junit.jupiter.api.Assertions.assertNull;\n import static org.junit.jupiter.api.Assertions.assertSame;\n import static org.junit.jupiter.api.Assertions.assertTrue;\n \n@@ -390,6 +389,8 @@ void testEquals_Object() {\n     @Test\n     void testGetInstance() {\n         assertSame(CharSet.EMPTY, CharSet.getInstance((String) null));\n+        assertSame(CharSet.EMPTY, CharSet.getInstance((String[]) null));\n+        assertSame(CharSet.EMPTY, CharSet.getInstance(null));\n         assertSame(CharSet.EMPTY, CharSet.getInstance(\"\"));\n         assertSame(CharSet.ASCII_ALPHA, CharSet.getInstance(\"a-zA-Z\"));\n         assertSame(CharSet.ASCII_ALPHA, CharSet.getInstance(\"A-Za-z\"));\n@@ -400,7 +401,7 @@ void testGetInstance() {\n \n     @Test\n     void testGetInstance_Stringarray() {\n-        assertNull(CharSet.getInstance((String[]) null));\n+        assertEquals(\"[]\", CharSet.getInstance((String[]) null).toString());\n         assertEquals(\"[]\", CharSet.getInstance().toString());\n         assertEquals(\"[]\", CharSet.getInstance(new String[] {null}).toString());\n         assertEquals(\"[a-e]\", CharSet.getInstance(\"a-e\").toString());\n",
  "problem_statement" : "[LANG-1804] Fix CharSet#getInstance returns null instead of EMPTY when input setStrs is null\n\n```\r\n// source code\r\npublic static CharSet getInstance(final String... setStrs) {\r\n    if (setStrs == null) {\r\n        return null; // error\r\n    }\r\n    if (setStrs.length == 1) {\r\n        final CharSet common = COMMON.get(setStrs[0]);\r\n        if (common != null) {\r\n            return common;\r\n        }\r\n    }\r\n    return new CharSet(setStrs);\r\n} \r\n```\r\nThegetInstancemethod ofCharSetcurrently returnsnullwhen the input parametersetStrsisnull. This behavior contradicts the documentation, which states that anullinput should return theEMPTYconstant (an empty character set). Returningnullcan lead toNullPointerExceptionin calling code that expects a validCharSetinstance even for empty inputs.\r\n\r\nThe Javadoc and source code are as follows\r\n<img width=\"896\" height=\"491\" alt=\"image\" src=\"https://github.com/user-attachments/assets/1ab28a8e-e76a-4f1f-ac50-15f005001ea5\" />\r\n\r\n```\r\n// Test NullPointerException\r\n  @Test\r\n  void testGetInstance_Null_Fixed_ReturnsEmpty_NoNPE() {\r\n    CharSet charSet = CharSet.getInstance(null);\r\n    assertThrows(NullPointerException.class,()->charSet.contains('['));\r\n  } \r\n```\r\n",
  "hints_text" : null,
  "created_at" : "Wed Dec 17 13:22:05 CET 2025",
  "version" : null,
  "FAIL_TO_PASS" : [ "CharSetTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=CharSetTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 1530,
  "metadata" : null
}, {
  "instance_id" : "apache-commons-lang-PR-1528",
  "repo" : "apache/commons-lang",
  "base_commit" : "3bd1625859000571b99b4193df1360ab18a33910",
  "patch" : "diff --git a/src/main/java/org/apache/commons/lang3/RandomStringUtils.java b/src/main/java/org/apache/commons/lang3/RandomStringUtils.java\nindex 558fc524242..b29231deeea 100644\n--- a/src/main/java/org/apache/commons/lang3/RandomStringUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/RandomStringUtils.java\n@@ -600,7 +600,7 @@ public static String randomNumeric(final int minLengthInclusive, final int maxLe\n      * @return the random string.\n      * @throws IllegalArgumentException if {@code count} &lt; 0.\n      * @since 3.5\n-     * @deprecated Use {@link #randomPrint(int)} from {@link #secure()}, {@link #secureStrong()}, or {@link #insecure()}.\n+     * @deprecated Use {@link #nextPrint(int)} from {@link #secure()}, {@link #secureStrong()}, or {@link #insecure()}.\n      */\n     @Deprecated\n     public static String randomPrint(final int count) {\n@@ -618,7 +618,7 @@ public static String randomPrint(final int count) {\n      * @param maxLengthExclusive the exclusive maximum length of the string to generate.\n      * @return the random string.\n      * @since 3.5\n-     * @deprecated Use {@link #randomPrint(int, int)} from {@link #secure()}, {@link #secureStrong()}, or {@link #insecure()}.\n+     * @deprecated Use {@link #nextPrint(int, int)} from {@link #secure()}, {@link #secureStrong()}, or {@link #insecure()}.\n      */\n     @Deprecated\n     public static String randomPrint(final int minLengthInclusive, final int maxLengthExclusive) {\n",
  "test_patch" : "diff --git a/src/test/java/org/apache/commons/lang3/ObjectUtilsTest.java b/src/test/java/org/apache/commons/lang3/ObjectUtilsTest.java\nindex 93db200457a..51a65021733 100644\n--- a/src/test/java/org/apache/commons/lang3/ObjectUtilsTest.java\n+++ b/src/test/java/org/apache/commons/lang3/ObjectUtilsTest.java\n@@ -397,7 +397,7 @@ void testConstMethods() {\n         assertIllegalArgumentException(() -> ObjectUtils.CONST_BYTE(128), \"CONST_BYTE(128): IllegalArgumentException should have been thrown.\");\n         assertIllegalArgumentException(() -> ObjectUtils.CONST_SHORT(-32769),\n                 \"CONST_SHORT(-32769): IllegalArgumentException should have been thrown.\");\n-        assertIllegalArgumentException(() -> ObjectUtils.CONST_BYTE(32768),\n+        assertIllegalArgumentException(() -> ObjectUtils.CONST_SHORT(32768),\n                 \"CONST_SHORT(32768): IllegalArgumentException should have been thrown.\");\n     }\n \n",
  "problem_statement" : "[LANG-1803] Fix incorrect method invocation in ObjectUtilsTest and Javadoc reference in RandomStringUtils\n\nTwo incorrect references need to be fixed in the codebase:\r\n**1. Wrong method call in ObjectUtilsTest#testConstMethods**\r\nIn the test method ObjectUtilsTest#testConstMethods, the assertion for validating IllegalArgumentException is incorrectly invoking ObjectUtils.CONST_BYTE(32768) instead of ObjectUtils.CONST_SHORT(32768).\r\n<img width=\"692\" height=\"105\" alt=\"image\" src=\"https://github.com/user-attachments/assets/7188248c-0de4-48fc-9196-7c16977a1f01\" />\r\n\r\n**2. Incorrect javadoc reference in RandomStringUtils#randomPrint**\r\nThe javadoc of the deprecated methods contain an incorrect link to {@link #randomPrint\r\n- RandomStringUtils#randomPrint(final int count)\r\n- RandomStringUtils#randomPrint(final int minLengthInclusive, final int maxLengthExclusive)\r\n<img width=\"692\" height=\"195\" alt=\"image\" src=\"https://github.com/user-attachments/assets/2ca68751-48f4-4cfb-9f6e-d024ca728dbd\" />\r\n<img width=\"692\" height=\"190\" alt=\"image\" src=\"https://github.com/user-attachments/assets/6ece818a-14c2-46d0-a562-2c51436729c5\" />\r\n",
  "hints_text" : null,
  "created_at" : "Tue Dec 16 16:36:20 CET 2025",
  "version" : null,
  "FAIL_TO_PASS" : [ "ObjectUtilsTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=ObjectUtilsTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 1528,
  "metadata" : null
}, {
  "instance_id" : "apache-commons-lang-PR-1519",
  "repo" : "apache/commons-lang",
  "base_commit" : "91b536e4f502f940c6c64399737a1f129c2e0374",
  "patch" : "diff --git a/pom.xml b/pom.xml\nindex 42ff459fa1c..4d77dc751dd 100644\n--- a/pom.xml\n+++ b/pom.xml\n@@ -77,6 +77,11 @@\n       <version>5.6.0</version>\n       <scope>test</scope>\n     </dependency>\n+    <dependency>\n+      <groupId>org.mockito</groupId>\n+      <artifactId>mockito-inline</artifactId>\n+      <version>${commons.mockito.version}</version>\n+    </dependency>\n     <!-- For Javadoc links -->\n     <dependency>\n       <groupId>org.apache.commons</groupId>\ndiff --git a/src/main/java/org/apache/commons/lang3/ArrayUtils.java b/src/main/java/org/apache/commons/lang3/ArrayUtils.java\nindex 1ce0247effd..4920f3c3aa8 100644\n--- a/src/main/java/org/apache/commons/lang3/ArrayUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/ArrayUtils.java\n@@ -9332,6 +9332,283 @@ public static String[] toStringArray(final Object[] array, final String valueFor\n         return map(array, String.class, e -> Objects.toString(e, valueForNullElements));\n     }\n \n+    /**\n+     * Concatenates multiple boolean arrays into a single array.\n+     * <p>\n+     * This method combines all input arrays in the order they are provided,\n+     * creating a new array that contains all elements from the input arrays.\n+     * The resulting array length is the sum of lengths of all non-null input arrays.\n+     * </p>\n+     *\n+     * @param arrays the arrays to concatenate. Can be empty, contain nulls,\n+     *               or be null itself (treated as empty varargs).\n+     * @return a new boolean array containing all elements from the input arrays\n+     *         in the order they appear, or an empty array if no elements are present.\n+     * @throws NullPointerException if the input array of arrays is null.\n+     * @throws IllegalArgumentException if total arrays length exceed {@link ArrayUtils#SAFE_MAX_ARRAY_LENGTH}.\n+     * @since 3.21.0\n+     */\n+    public static boolean[] concat(boolean[]... arrays) {\n+        int totalLength = 0;\n+        for (boolean[] array : arrays) {\n+            totalLength = addExact(totalLength, array);\n+        }\n+        final boolean[] result = new boolean[totalLength];\n+        int currentPos = 0;\n+        for (boolean[] array : arrays) {\n+            if (array != null && array.length > 0) {\n+                System.arraycopy(array, 0, result, currentPos, array.length);\n+                currentPos += array.length;\n+            }\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Concatenates multiple byte arrays into a single array.\n+     * <p>\n+     * This method combines all input arrays in the order they are provided,\n+     * creating a new array that contains all elements from the input arrays.\n+     * The resulting array length is the sum of lengths of all non-null input arrays.\n+     * </p>\n+     *\n+     * @param arrays the arrays to concatenate. Can be empty, contain nulls,\n+     *               or be null itself (treated as empty varargs).\n+     * @return a new byte array containing all elements from the input arrays\n+     *         in the order they appear, or an empty array if no elements are present.\n+     * @throws NullPointerException if the input array of arrays is null.\n+     * @throws IllegalArgumentException if total arrays length exceed {@link ArrayUtils#SAFE_MAX_ARRAY_LENGTH}.\n+     * @since 3.21.0\n+     */\n+    public static byte[] concat(byte[]... arrays) {\n+        int totalLength = 0;\n+        for (byte[] array : arrays) {\n+            totalLength = addExact(totalLength, array);\n+        }\n+        final byte[] result = new byte[totalLength];\n+        int currentPos = 0;\n+        for (byte[] array : arrays) {\n+            if (array != null && array.length > 0) {\n+                System.arraycopy(array, 0, result, currentPos, array.length);\n+                currentPos += array.length;\n+            }\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Concatenates multiple char arrays into a single array.\n+     * <p>\n+     * This method combines all input arrays in the order they are provided,\n+     * creating a new array that contains all elements from the input arrays.\n+     * The resulting array length is the sum of lengths of all non-null input arrays.\n+     * </p>\n+     *\n+     * @param arrays the arrays to concatenate. Can be empty, contain nulls,\n+     *               or be null itself (treated as empty varargs).\n+     * @return a new char array containing all elements from the input arrays\n+     *         in the order they appear, or an empty array if no elements are present.\n+     * @throws NullPointerException if the input array of arrays is null.\n+     * @throws IllegalArgumentException if total arrays length exceed {@link ArrayUtils#SAFE_MAX_ARRAY_LENGTH}.\n+     * @since 3.21.0\n+     */\n+    public static char[] concat(char[]... arrays) {\n+        int totalLength = 0;\n+        for (char[] array : arrays) {\n+            totalLength = addExact(totalLength, array);\n+        }\n+        final char[] result = new char[totalLength];\n+        int currentPos = 0;\n+        for (char[] array : arrays) {\n+            if (array != null && array.length > 0) {\n+                System.arraycopy(array, 0, result, currentPos, array.length);\n+                currentPos += array.length;\n+            }\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Concatenates multiple double arrays into a single array.\n+     * <p>\n+     * This method combines all input arrays in the order they are provided,\n+     * creating a new array that contains all elements from the input arrays.\n+     * The resulting array length is the sum of lengths of all non-null input arrays.\n+     * </p>\n+     *\n+     * @param arrays the arrays to concatenate. Can be empty, contain nulls,\n+     *               or be null itself (treated as empty varargs).\n+     * @return a new double array containing all elements from the input arrays\n+     *         in the order they appear, or an empty array if no elements are present.\n+     * @throws NullPointerException if the input array of arrays is null.\n+     * @throws IllegalArgumentException if total arrays length exceed {@link ArrayUtils#SAFE_MAX_ARRAY_LENGTH}.\n+     * @since 3.21.0\n+     */\n+    public static double[] concat(double[]... arrays) {\n+        int totalLength = 0;\n+        for (double[] array : arrays) {\n+            totalLength = addExact(totalLength, array);\n+        }\n+        final double[] result = new double[totalLength];\n+        int currentPos = 0;\n+        for (double[] array : arrays) {\n+            if (array != null && array.length > 0) {\n+                System.arraycopy(array, 0, result, currentPos, array.length);\n+                currentPos += array.length;\n+            }\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Concatenates multiple float arrays into a single array.\n+     * <p>\n+     * This method combines all input arrays in the order they are provided,\n+     * creating a new array that contains all elements from the input arrays.\n+     * The resulting array length is the sum of lengths of all non-null input arrays.\n+     * </p>\n+     *\n+     * @param arrays the arrays to concatenate. Can be empty, contain nulls,\n+     *               or be null itself (treated as empty varargs).\n+     * @return a new float array containing all elements from the input arrays\n+     *         in the order they appear, or an empty array if no elements are present.\n+     * @throws NullPointerException if the input array of arrays is null.\n+     * @throws IllegalArgumentException if total arrays length exceed {@link ArrayUtils#SAFE_MAX_ARRAY_LENGTH}.\n+     * @since 3.21.0\n+     */\n+    public static float[] concat(float[]... arrays) {\n+        int totalLength = 0;\n+        for (float[] array : arrays) {\n+            totalLength = addExact(totalLength, array);\n+        }\n+        final float[] result = new float[totalLength];\n+        int currentPos = 0;\n+        for (float[] array : arrays) {\n+            if (array != null && array.length > 0) {\n+                System.arraycopy(array, 0, result, currentPos, array.length);\n+                currentPos += array.length;\n+            }\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Concatenates multiple int arrays into a single array.\n+     * <p>\n+     * This method combines all input arrays in the order they are provided,\n+     * creating a new array that contains all elements from the input arrays.\n+     * The resulting array length is the sum of lengths of all non-null input arrays.\n+     * </p>\n+     *\n+     * @param arrays the arrays to concatenate. Can be empty, contain nulls,\n+     *               or be null itself (treated as empty varargs).\n+     * @return a new int array containing all elements from the input arrays\n+     *         in the order they appear, or an empty array if no elements are present.\n+     * @throws NullPointerException if the input array of arrays is null.\n+     * @throws IllegalArgumentException if total arrays length exceed {@link ArrayUtils#SAFE_MAX_ARRAY_LENGTH}.\n+     * @since 3.21.0\n+     */\n+    public static int[] concat(int[]... arrays) {\n+        int totalLength = 0;\n+        for (int[] array : arrays) {\n+            totalLength = addExact(totalLength, array);\n+        }\n+        final int[] result = new int[totalLength];\n+        int currentPos = 0;\n+        for (int[] array : arrays) {\n+            if (array != null && array.length > 0) {\n+                System.arraycopy(array, 0, result, currentPos, array.length);\n+                currentPos += array.length;\n+            }\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Concatenates multiple long arrays into a single array.\n+     * <p>\n+     * This method combines all input arrays in the order they are provided,\n+     * creating a new array that contains all elements from the input arrays.\n+     * The resulting array length is the sum of lengths of all non-null input arrays.\n+     * </p>\n+     *\n+     * @param arrays the arrays to concatenate. Can be empty, contain nulls,\n+     *               or be null itself (treated as empty varargs).\n+     * @return a new long array containing all elements from the input arrays\n+     *         in the order they appear, or an empty array if no elements are present.\n+     * @throws NullPointerException if the input array of arrays is null.\n+     * @throws IllegalArgumentException if total arrays length exceed {@link ArrayUtils#SAFE_MAX_ARRAY_LENGTH}.\n+     * @since 3.21.0\n+     */\n+    public static long[] concat(long[]... arrays) {\n+        int totalLength = 0;\n+        for (long[] array : arrays) {\n+            totalLength = addExact(totalLength, array);\n+        }\n+        final long[] result = new long[totalLength];\n+        int currentPos = 0;\n+        for (long[] array : arrays) {\n+            if (array != null && array.length > 0) {\n+                System.arraycopy(array, 0, result, currentPos, array.length);\n+                currentPos += array.length;\n+            }\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Concatenates multiple short arrays into a single array.\n+     * <p>\n+     * This method combines all input arrays in the order they are provided,\n+     * creating a new array that contains all elements from the input arrays.\n+     * The resulting array length is the sum of lengths of all non-null input arrays.\n+     * </p>\n+     *\n+     * @param arrays the arrays to concatenate. Can be empty, contain nulls,\n+     *               or be null itself (treated as empty varargs).\n+     * @return a new short array containing all elements from the input arrays\n+     *         in the order they appear, or an empty array if no elements are present.\n+     * @throws NullPointerException if the input array of arrays is null.\n+     * @throws IllegalArgumentException if total arrays length exceed {@link ArrayUtils#SAFE_MAX_ARRAY_LENGTH}.\n+     * @since 3.21.0\n+     */\n+    public static short[] concat(short[]... arrays) {\n+        int totalLength = 0;\n+        for (short[] array : arrays) {\n+            totalLength = addExact(totalLength, array);\n+        }\n+        final short[] result = new short[totalLength];\n+        int currentPos = 0;\n+        for (short[] array : arrays) {\n+            if (array != null && array.length > 0) {\n+                System.arraycopy(array, 0, result, currentPos, array.length);\n+                currentPos += array.length;\n+            }\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Safely adds the length of an array to a running total, checking for overflow.\n+     *\n+     * @param totalLength the current accumulated length\n+     * @param array the array whose length should be added (can be {@code null},\n+     *              in which case its length is considered 0)\n+     * @return the new total length after adding the array's length\n+     * @throws IllegalArgumentException if total arrays length exceed {@link ArrayUtils#SAFE_MAX_ARRAY_LENGTH}.\n+     */\n+    private static int addExact(final int totalLength, final Object array) {\n+        try {\n+            final int length = MathBridge.addExact(totalLength, getLength(array));\n+            if (length > SAFE_MAX_ARRAY_LENGTH) {\n+                throw new IllegalArgumentException(\"Total arrays length exceed \" + SAFE_MAX_ARRAY_LENGTH);\n+            }\n+            return length;\n+        } catch (final ArithmeticException exception) {\n+            throw new IllegalArgumentException(\"Total arrays length exceed \" + SAFE_MAX_ARRAY_LENGTH);\n+        }\n+    }\n+\n     /**\n      * ArrayUtils instances should NOT be constructed in standard programming. Instead, the class should be used as {@code ArrayUtils.clone(new int[] {2})}.\n      * <p>\n@@ -9344,4 +9621,13 @@ public static String[] toStringArray(final Object[] array, final String valueFor\n     public ArrayUtils() {\n         // empty\n     }\n+\n+    /**\n+     * Bridge class to {@link Math} methods for testing purposes.\n+     */\n+    static class MathBridge {\n+        static int addExact(final int a, final int b) {\n+            return Math.addExact(a, b);\n+        }\n+    }\n }\n",
  "test_patch" : "diff --git a/src/test/java/org/apache/commons/lang3/ArrayUtilsConcatTest.java b/src/test/java/org/apache/commons/lang3/ArrayUtilsConcatTest.java\nnew file mode 100644\nindex 00000000000..fdec27f0868\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/lang3/ArrayUtilsConcatTest.java\n@@ -0,0 +1,118 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.lang3;\n+\n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.mockito.ArgumentMatchers.anyInt;\n+import static org.mockito.Mockito.mockStatic;\n+\n+import org.junit.jupiter.api.Test;\n+import org.mockito.MockedStatic;\n+\n+/**\n+ * Tests {@link ArrayUtils} concat methods.\n+ */\n+class ArrayUtilsConcatTest extends AbstractLangTest {\n+\n+    @Test\n+    void testBooleanArraysConcat() {\n+        assertThrows(NullPointerException.class, () -> ArrayUtils.concat((boolean[][]) null));\n+        assertArrayEquals(new boolean[] {}, ArrayUtils.concat((boolean[]) null, null));\n+        assertArrayEquals(new boolean[] { true, false, true }, ArrayUtils.concat(new boolean[] { true, false, true }, null));\n+        assertArrayEquals(new boolean[] { false, true, false }, ArrayUtils.concat(null, new boolean[] { false, true, false }));\n+        assertArrayEquals(new boolean[] { false, true, false, false, true },\n+                ArrayUtils.concat(new boolean[] { false, true, false }, new boolean[] { false, true }));\n+    }\n+\n+    @Test\n+    void testByteArraysConcat() {\n+        assertThrows(NullPointerException.class, () -> ArrayUtils.concat((byte[][]) null));\n+        assertArrayEquals(new byte[] {}, ArrayUtils.concat((byte[]) null, null));\n+        assertArrayEquals(new byte[] { 1, 2, 3 }, ArrayUtils.concat(new byte[] { 1, 2, 3 }, null));\n+        assertArrayEquals(new byte[] { -3, 2, 1 }, ArrayUtils.concat(null, new byte[] { -3, 2, 1 }));\n+        assertArrayEquals(new byte[] { 1, 3, 2, 100, 7 }, ArrayUtils.concat(new byte[] { 1, 3, 2 }, new byte[] { 100, 7 }));\n+    }\n+\n+    @Test\n+    void testCharArraysConcat() {\n+        assertThrows(NullPointerException.class, () -> ArrayUtils.concat((char[][]) null));\n+        assertArrayEquals(new char[] {}, ArrayUtils.concat((char[]) null, null));\n+        assertArrayEquals(new char[] { 'a', 'b', 'c' }, ArrayUtils.concat(new char[] { 'a', 'b', 'c' }, null));\n+        assertArrayEquals(new char[] { 'b', 'a', 'c' }, ArrayUtils.concat(null, new char[] { 'b', 'a', 'c' }));\n+        assertArrayEquals(new char[] { 'a', 'b', 'c', 'q', 'w' }, ArrayUtils.concat(new char[] { 'a', 'b', 'c' }, new char[] { 'q', 'w' }));\n+    }\n+\n+    @Test\n+    void testDoubleArraysConcat() {\n+        assertThrows(NullPointerException.class, () -> ArrayUtils.concat((double[][]) null));\n+        assertArrayEquals(new double[] {}, ArrayUtils.concat((double[]) null, null));\n+        assertArrayEquals(new double[] { 1e-300, .2e-300, 3.0e-300 }, ArrayUtils.concat(new double[] { 1e-300, .2e-300, 3.0e-300 }, null));\n+        assertArrayEquals(new double[] { 3.0e-300, 1e-300, .2e-300 }, ArrayUtils.concat(null, new double[] { 3.0e-300, 1e-300, .2e-300 }));\n+        assertArrayEquals(new double[] { 1e-300, .2e-300, 3.0e-300, 10.01e-300, 0.001e-300 },\n+                ArrayUtils.concat(new double[] { 1e-300, .2e-300, 3.0e-300 }, new double[] { 10.01e-300, 0.001e-300 }));\n+    }\n+\n+    @Test\n+    void testExceedSafeMaxArraySize() {\n+        try (MockedStatic<ArrayUtils.MathBridge> mockedStatic = mockStatic(ArrayUtils.MathBridge.class)) {\n+            mockedStatic.when(() -> ArrayUtils.MathBridge.addExact(anyInt(), anyInt())).thenThrow(ArithmeticException.class);\n+            assertThrows(IllegalArgumentException.class, () -> ArrayUtils.concat(new int[] { 0 }, new int[] { 1 }));\n+        }\n+    }\n+\n+    @Test\n+    void testFloatArraysConcat() {\n+        assertThrows(NullPointerException.class, () -> ArrayUtils.concat((float[][]) null));\n+        assertArrayEquals(new float[] {}, ArrayUtils.concat((float[]) null, null));\n+        assertArrayEquals(new float[] { 1f, .2f, 3.0f }, ArrayUtils.concat(new float[] { 1f, .2f, 3.0f }, null));\n+        assertArrayEquals(new float[] { 3.0f, 1f, .2f }, ArrayUtils.concat(null, new float[] { 3.0f, 1f, .2f }));\n+        assertArrayEquals(new float[] { 1f, .2f, 3.0f, 10.01f, 0.001f }, ArrayUtils.concat(new float[] { 1f, .2f, 3.0f }, new float[] { 10.01f, 0.001f }));\n+    }\n+\n+    @Test\n+    void testIntArraysConcat() {\n+        assertThrows(NullPointerException.class, () -> ArrayUtils.concat((int[][]) null));\n+        assertArrayEquals(new int[] {}, ArrayUtils.concat((int[]) null, null));\n+        assertArrayEquals(new int[] { 10000000, 20000000, 30000000 }, ArrayUtils.concat(new int[] { 10000000, 20000000, 30000000 }, null));\n+        assertArrayEquals(new int[] { -30000000, 20000000, 10000000 }, ArrayUtils.concat(null, new int[] { -30000000, 20000000, 10000000 }));\n+        assertArrayEquals(new int[] { 10000000, 30000000, 20000000, 100000000, 70000000 },\n+                ArrayUtils.concat(new int[] { 10000000, 30000000, 20000000 }, new int[] { 100000000, 70000000 }));\n+    }\n+\n+    @Test\n+    void testLongArraysConcat() {\n+        assertThrows(NullPointerException.class, () -> ArrayUtils.concat((long[][]) null));\n+        assertArrayEquals(new long[] {}, ArrayUtils.concat((long[]) null, null));\n+        assertArrayEquals(new long[] { 10000000000L, 20000000000L, 30000000000L },\n+                ArrayUtils.concat(new long[] { 10000000000L, 20000000000L, 30000000000L }, null));\n+        assertArrayEquals(new long[] { -30000000000L, 20000000000L, 10000000000L },\n+                ArrayUtils.concat(null, new long[] { -30000000000L, 20000000000L, 10000000000L }));\n+        assertArrayEquals(new long[] { 10000000000L, 30000000000L, 20000000000L, 100000000000L, 70000000000L },\n+                ArrayUtils.concat(new long[] { 10000000000L, 30000000000L, 20000000000L }, new long[] { 100000000000L, 70000000000L }));\n+    }\n+\n+    @Test\n+    void testShortArraysConcat() {\n+        assertThrows(NullPointerException.class, () -> ArrayUtils.concat((short[][]) null));\n+        assertArrayEquals(new short[] {}, ArrayUtils.concat((short[]) null, null));\n+        assertArrayEquals(new short[] { 1000, 2000, 3000 }, ArrayUtils.concat(new short[] { 1000, 2000, 3000 }, null));\n+        assertArrayEquals(new short[] { -3000, 2000, 1000 }, ArrayUtils.concat(null, new short[] { -3000, 2000, 1000 }));\n+        assertArrayEquals(new short[] { 1000, 3000, 2000, 10000, 7000 }, ArrayUtils.concat(new short[] { 1000, 3000, 2000 }, new short[] { 10000, 7000 }));\n+    }\n+}\n",
  "problem_statement" : "[LANG-1707] Add ArrayUtils.concat methods for concatenating multiple arrays\n\nImplementation of the [LANG-1707](https://issues.apache.org/jira/browse/LANG-1707) suggestion: added the concat methods to ArrayUtils for convenient concatenation of multiple arrays in a single call.\r\n\r\n- [x] Read the [contribution guidelines](CONTRIBUTING.md) for this project.\r\n- [x] Read the [ASF Generative Tooling Guidance](https://www.apache.org/legal/generative-tooling.html) if you use Artificial Intelligence (AI).\r\n- [x] I used AI to create any part of, or all of, this pull request. Which AI tool was used to create this pull request, and to what extent did it contribute?\r\n- [x] Run a successful build using the default [Maven](https://maven.apache.org/) goal with `mvn`; that's `mvn` on the command line by itself.\r\n- [x] Write unit tests that match behavioral changes, where the tests fail if the changes to the runtime are not applied. This may not always be possible, but it is a best practice.\r\n- [x] Write a pull request description that is detailed enough to understand what the pull request does, how, and why.\r\n- [x] Each commit in the pull request should have a meaningful subject line and body. Note that a maintainer may squash commits during the merge process.\r\n\r\n",
  "hints_text" : null,
  "created_at" : "Mon Dec 08 16:55:35 CET 2025",
  "version" : null,
  "FAIL_TO_PASS" : [ "ArrayUtilsConcatTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=ArrayUtilsConcatTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 1519,
  "metadata" : null
}, {
  "instance_id" : "apache-commons-lang-PR-1495",
  "repo" : "apache/commons-lang",
  "base_commit" : "f8a6bf9500f655c0f772313e8d0098984420299b",
  "patch" : "diff --git a/src/main/java/org/apache/commons/lang3/ClassUtils.java b/src/main/java/org/apache/commons/lang3/ClassUtils.java\nindex 38962488f41..f6185e9d986 100644\n--- a/src/main/java/org/apache/commons/lang3/ClassUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/ClassUtils.java\n@@ -49,9 +49,22 @@\n public class ClassUtils {\n \n     /**\n-     * The JVM {@code CONSTANT_Class_info} structure defines an array type descriptor is valid only if it represents 255 or fewer dimensions.\n+     * The JLS-specified maximum class name length {@value}.\n      *\n+     * @see Class#forName(String, boolean, ClassLoader)\n      * @see <a href=\"https://docs.oracle.com/javase/specs/jvms/se25/html/jvms-4.html#jvms-4.4.1\">JVM: Array dimension limits in JVM Specification CONSTANT_Class_info</a>\n+     * @see <a href=\"https://docs.oracle.com/javase/specs/jls/se25/html/jls-6.html#jls-6.7\">JLS: Fully Qualified Names and Canonical Names</a>\n+     * @see <a href=\"https://docs.oracle.com/javase/specs/jls/se25/html/jls-13.html#jls-13.1\">JLS: The Form of a Binary</a>\n+     */\n+    private static final int MAX_CLASS_NAME_LENGTH = 65535;\n+\n+    /**\n+     * The JVM-specified {@code CONSTANT_Class_info} structure defines an array type descriptor is valid only if it represents {@value} or fewer dimensions.\n+     *\n+     * @see Class#forName(String, boolean, ClassLoader)\n+     * @see <a href=\"https://docs.oracle.com/javase/specs/jvms/se25/html/jvms-4.html#jvms-4.4.1\">JVM: Array dimension limits in JVM Specification CONSTANT_Class_info</a>\n+     * @see <a href=\"https://docs.oracle.com/javase/specs/jls/se25/html/jls-6.html#jls-6.7\">JLS: Fully Qualified Names and Canonical Names</a>\n+     * @see <a href=\"https://docs.oracle.com/javase/specs/jls/se25/html/jls-13.html#jls-13.1\">JLS: The Form of a Binary</a>\n      */\n     private static final int MAX_JVM_ARRAY_DIMENSION = 255;\n \n@@ -533,6 +546,7 @@ private static String getCanonicalName(final String name) {\n      * @throws NullPointerException if the className is null.\n      * @throws ClassNotFoundException if the class is not found.\n      * @throws IllegalArgumentException Thrown if the class name represents an array with more dimensions than the JVM supports, 255.\n+     * @throws IllegalArgumentException Thrown if the class name length is greater than 65,535.\n      * @see Class#forName(String, boolean, ClassLoader)\n      * @see <a href=\"https://docs.oracle.com/javase/specs/jvms/se25/html/jvms-4.html#jvms-4.4.1\">JVM: Array dimension limits in JVM Specification CONSTANT_Class_info</a>\n      * @see <a href=\"https://docs.oracle.com/javase/specs/jls/se25/html/jls-6.html#jls-6.7\">JLS: Fully Qualified Names and Canonical Names</a>\n@@ -554,6 +568,7 @@ public static Class<?> getClass(final ClassLoader classLoader, final String clas\n      * @throws NullPointerException if the className is null.\n      * @throws ClassNotFoundException if the class is not found.\n      * @throws IllegalArgumentException Thrown if the class name represents an array with more dimensions than the JVM supports, 255.\n+     * @throws IllegalArgumentException Thrown if the class name length is greater than 65,535.\n      * @see Class#forName(String, boolean, ClassLoader)\n      * @see <a href=\"https://docs.oracle.com/javase/specs/jvms/se25/html/jvms-4.html#jvms-4.4.1\">JVM: Array dimension limits in JVM Specification CONSTANT_Class_info</a>\n      * @see <a href=\"https://docs.oracle.com/javase/specs/jls/se25/html/jls-6.html#jls-6.7\">JLS: Fully Qualified Names and Canonical Names</a>\n@@ -566,7 +581,7 @@ public static Class<?> getClass(final ClassLoader classLoader, final String clas\n         do {\n             try {\n                 final Class<?> clazz = getPrimitiveClass(next);\n-                return clazz != null ? clazz : Class.forName(toCanonicalName(next), initialize, classLoader);\n+                return clazz != null ? clazz : Class.forName(toCleanName(next), initialize, classLoader);\n             } catch (final ClassNotFoundException ex) {\n                 lastDotIndex = next.lastIndexOf(PACKAGE_SEPARATOR_CHAR);\n                 if (lastDotIndex != -1) {\n@@ -587,6 +602,7 @@ public static Class<?> getClass(final ClassLoader classLoader, final String clas\n      * @throws NullPointerException if the className is null\n      * @throws ClassNotFoundException if the class is not found\n      * @throws IllegalArgumentException Thrown if the class name represents an array with more dimensions than the JVM supports, 255.\n+     * @throws IllegalArgumentException Thrown if the class name length is greater than 65,535.\n      * @see Class#forName(String, boolean, ClassLoader)\n      * @see <a href=\"https://docs.oracle.com/javase/specs/jvms/se25/html/jvms-4.html#jvms-4.4.1\">JVM: Array dimension limits in JVM Specification CONSTANT_Class_info</a>\n      * @see <a href=\"https://docs.oracle.com/javase/specs/jls/se25/html/jls-6.html#jls-6.7\">JLS: Fully Qualified Names and Canonical Names</a>\n@@ -607,6 +623,7 @@ public static Class<?> getClass(final String className) throws ClassNotFoundExce\n      * @throws NullPointerException if the className is null.\n      * @throws ClassNotFoundException if the class is not found.\n      * @throws IllegalArgumentException Thrown if the class name represents an array with more dimensions than the JVM supports, 255.\n+     * @throws IllegalArgumentException Thrown if the class name length is greater than 65,535.\n      * @see Class#forName(String, boolean, ClassLoader)\n      * @see <a href=\"https://docs.oracle.com/javase/specs/jvms/se25/html/jvms-4.html#jvms-4.4.1\">JVM: Array dimension limits in JVM Specification CONSTANT_Class_info</a>\n      * @see <a href=\"https://docs.oracle.com/javase/specs/jls/se25/html/jls-6.html#jls-6.7\">JLS: Fully Qualified Names and Canonical Names</a>\n@@ -1519,32 +1536,60 @@ public static Class<?> primitiveToWrapper(final Class<?> cls) {\n     }\n \n     /**\n-     * Converts a class name to a JLS style class name.\n+     * Converts and cleans up a class name to a JLS style class name.\n      *\n      * @param className the class name.\n      * @return the converted name.\n-     * @throws NullPointerException if the className is null.\n+     * @throws NullPointerException     if the className is null.\n      * @throws IllegalArgumentException Thrown if the class name represents an array with more dimensions than the JVM supports, 255.\n+     * @throws IllegalArgumentException Thrown if the class name length is greater than 65,535.\n+     * @see <a href=\"https://docs.oracle.com/javase/specs/jvms/se25/html/jvms-4.html#jvms-4.4.1\">JVM: Array dimension limits in JVM Specification\n+     *      CONSTANT_Class_info</a>\n+     * @see <a href=\"https://docs.oracle.com/javase/specs/jls/se25/html/jls-6.html#jls-6.7\">JLS: Fully Qualified Names and Canonical Names</a>\n+     * @see <a href=\"https://docs.oracle.com/javase/specs/jls/se25/html/jls-13.html#jls-13.1\">JLS: The Form of a Binary</a>\n      */\n-    private static String toCanonicalName(final String className) {\n+    private static String toCleanName(final String className) {\n         String canonicalName = StringUtils.deleteWhitespace(className);\n         Objects.requireNonNull(canonicalName, \"className\");\n+        if (canonicalName.isEmpty()) {\n+            throw new IllegalArgumentException(\"Class name is empty\");\n+        }\n+        final String encodedArrayOpen = \"[\";\n+        final String encodedClassNameStart = \"L\";\n+        final String encodedClassNameEnd = \";\";\n+        final boolean encodedName = canonicalName.startsWith(encodedArrayOpen) && canonicalName.endsWith(encodedClassNameEnd);\n+        if (encodedName) {\n+            final int arrIdx = canonicalName.indexOf(encodedClassNameStart);\n+            if (arrIdx > MAX_JVM_ARRAY_DIMENSION) {\n+                throw new IllegalArgumentException(\"Array dimension greater than JVM specification maximum of 255.\");\n+            }\n+            if (arrIdx < 0) {\n+                throw new IllegalArgumentException(\"Expected 'L' after '[' for an array style string.\");\n+            }\n+            final int cnLen = canonicalName.length() - (arrIdx + 2); // account for the ending ';'\n+            if (cnLen > MAX_CLASS_NAME_LENGTH) {\n+                throw new IllegalArgumentException(String.format(\"Class name greater than maxium length %,d\", MAX_CLASS_NAME_LENGTH));\n+            }\n+        }\n         final String arrayMarker = \"[]\";\n-        int arrayDim = 0;\n+        final int arrIdx = canonicalName.indexOf(arrayMarker);\n+        // The class name length without array markers.\n+        final int cnLen = arrIdx > 0 ? arrIdx : canonicalName.length();\n+        if (cnLen > MAX_CLASS_NAME_LENGTH && !encodedName) {\n+            throw new IllegalArgumentException(String.format(\"Class name greater than maxium length %,d\", MAX_CLASS_NAME_LENGTH));\n+        }\n         if (canonicalName.endsWith(arrayMarker)) {\n-            final StringBuilder classNameBuffer = new StringBuilder();\n-            while (canonicalName.endsWith(arrayMarker)) {\n-                if (++arrayDim > MAX_JVM_ARRAY_DIMENSION) {\n-                    throw new IllegalArgumentException(\"Array dimension greater than JVM specification maximum of 255.\");\n-                }\n-                canonicalName = canonicalName.substring(0, canonicalName.length() - 2);\n-                classNameBuffer.append(\"[\");\n+            final int dims =  (canonicalName.length() - arrIdx) / 2;\n+            if (dims > MAX_JVM_ARRAY_DIMENSION) {\n+                throw new IllegalArgumentException(\"Array dimension greater than JVM specification maximum of 255.\");\n             }\n+            final StringBuilder classNameBuffer = new StringBuilder(StringUtils.repeat(encodedArrayOpen, dims));\n+            canonicalName = canonicalName.substring(0, arrIdx);\n             final String abbreviation = ABBREVIATION_MAP.get(canonicalName);\n             if (abbreviation != null) {\n                 classNameBuffer.append(abbreviation);\n             } else {\n-                classNameBuffer.append(\"L\").append(canonicalName).append(\";\");\n+                classNameBuffer.append(encodedClassNameStart).append(canonicalName).append(encodedClassNameEnd);\n             }\n             canonicalName = classNameBuffer.toString();\n         }\n",
  "test_patch" : "diff --git a/src/test/java/org/apache/commons/lang3/ClassUtilsTest.java b/src/test/java/org/apache/commons/lang3/ClassUtilsTest.java\nindex 43957c97eb0..96ce5cdadf3 100644\n--- a/src/test/java/org/apache/commons/lang3/ClassUtilsTest.java\n+++ b/src/test/java/org/apache/commons/lang3/ClassUtilsTest.java\n@@ -59,6 +59,8 @@\n @SuppressWarnings(\"boxing\") // JUnit4 does not support primitive equality testing apart from long\n class ClassUtilsTest extends AbstractLangTest {\n \n+    private static final int MAX_ARRAY_DIMENSIONS = 255;\n+\n     private static class CX implements IB, IA, IE {\n         // empty\n     }\n@@ -1229,6 +1231,7 @@ void testGetClassByNormalNameArrays() throws ClassNotFoundException {\n         assertEquals(java.util.Map.Entry[].class, ClassUtils.getClass(\"java.util.Map$Entry[]\"));\n         assertEquals(java.util.Map.Entry[].class, ClassUtils.getClass(\"[Ljava.util.Map.Entry;\"));\n         assertEquals(java.util.Map.Entry[].class, ClassUtils.getClass(\"[Ljava.util.Map$Entry;\"));\n+        assertEquals(java.util.Map.Entry[][].class, ClassUtils.getClass(\"[[Ljava.util.Map$Entry;\"));\n     }\n \n     @Test\n@@ -1282,6 +1285,26 @@ void testGetClassInvalidArguments() throws Exception {\n         assertGetClassThrowsClassNotFound(\"hello..world\");\n     }\n \n+    @ParameterizedTest\n+    @IntRangeSource(from = 65536, to = 65555)\n+    void testGetClassLengthIllegal(final int classNameLength) throws ClassNotFoundException {\n+        assertThrows(IllegalArgumentException.class, () -> ClassUtils.getClass(StringUtils.repeat(\"a\", classNameLength)));\n+        assertThrows(IllegalArgumentException.class, () -> assertEquals(classNameLength, ClassUtils.getClass(StringUtils.repeat(\"a.\", classNameLength / 2))));\n+    }\n+\n+    @Test\n+    void testGetClassLongestCheck() throws ClassNotFoundException {\n+        final String maxClassName = StringUtils.repeat(\"a\", 65535);\n+        final String maxDimensions = StringUtils.repeat(\"[]\", MAX_ARRAY_DIMENSIONS);\n+        final String maxOpens = StringUtils.repeat(\"[\", MAX_ARRAY_DIMENSIONS);\n+        assertThrows(ClassNotFoundException.class, () -> ClassUtils.getClass(maxClassName));\n+        assertNotNull(ClassUtils.getClass(\"java.lang.String\" + maxDimensions));\n+        assertThrows(ClassNotFoundException.class, () -> ClassUtils.getClass(maxClassName + maxDimensions));\n+        assertThrows(ClassNotFoundException.class, () -> ClassUtils.getClass(maxOpens + \"L\" + maxClassName + \";\"));\n+        // maxOpens + 1\n+        assertThrows(IllegalArgumentException.class, () -> ClassUtils.getClass(maxOpens + \"[L\" + maxClassName + \";\"));\n+    }\n+\n     @Test\n     void testGetClassRawPrimitives() throws ClassNotFoundException {\n         assertEquals(int.class, ClassUtils.getClass(\"int\"));\n",
  "problem_statement" : "Bugfix/class utils to canonical name length check\n\nThe class `ClassUtils` now throws `IllegalArgumentException` if a class name is > 65535.\r\n\r\nThis affects:\r\n\r\n- `getClass(ClassLoader, String, boolean)`,\r\n- `ClassUtils.getClass(ClassLoader, String)`,\r\n- `ClassUtils.getClass(String, boolean)`,\r\n- `ClassUtils.getClass(String)`\r\n\r\n\r\nBefore you push a pull request, review this list:\r\n\r\n- [x] Read the [contribution guidelines](CONTRIBUTING.md) for this project.\r\n- [x] Read the [ASF Generative Tooling Guidance](https://www.apache.org/legal/generative-tooling.html) if you use Artificial Intelligence (AI).\r\n- [ ] I used AI to create any part of, or all of, this pull request.\r\n- [x] Run a successful build using the default [Maven](https://maven.apache.org/) goal with `mvn`; that's `mvn` on the command line by itself.\r\n- [x] Write unit tests that match behavioral changes, where the tests fail if the changes to the runtime are not applied. This may not always be possible, but it is a best practice.\r\n- [x] Write a pull request description that is detailed enough to understand what the pull request does, how, and why.\r\n- [x] Each commit in the pull request should have a meaningful subject line and body. Note that a maintainer may squash commits during the merge process.\r\n",
  "hints_text" : null,
  "created_at" : "Tue Nov 18 20:00:02 CET 2025",
  "version" : null,
  "FAIL_TO_PASS" : [ "ClassUtilsTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=ClassUtilsTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 1495,
  "metadata" : null
}, {
  "instance_id" : "apache-commons-lang-PR-1494",
  "repo" : "apache/commons-lang",
  "base_commit" : "162575cc6727316621b3761ade5e51fac0f497dd",
  "patch" : "diff --git a/src/main/java/org/apache/commons/lang3/ClassUtils.java b/src/main/java/org/apache/commons/lang3/ClassUtils.java\nindex 2e811b4f4d4..bc377bbec41 100644\n--- a/src/main/java/org/apache/commons/lang3/ClassUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/ClassUtils.java\n@@ -48,6 +48,13 @@\n  */\n public class ClassUtils {\n \n+    /**\n+     * The JVM {@code CONSTANT_Class_info} structure defines an array type descriptor is valid only if it represents 255 or fewer dimensions.\n+     *\n+     * @see <a href=\"https://docs.oracle.com/javase/specs/jvms/se25/html/jvms-4.html#jvms-4.4.1\">JVM: Array dimension limits in JVM Specification CONSTANT_Class_info</a>\n+     */\n+    private static final int MAX_JVM_ARRAY_DIMENSION = 255;\n+\n     /**\n      * Inclusivity literals for {@link #hierarchy(Class, Interfaces)}.\n      *\n@@ -520,11 +527,16 @@ private static String getCanonicalName(final String name) {\n      * supports the syntaxes \"{@code java.util.Map.Entry[]}\", \"{@code java.util.Map$Entry[]}\",\n      * \"{@code [Ljava.util.Map.Entry;}\", and \"{@code [Ljava.util.Map$Entry;}\".\n      *\n-     * @param classLoader the class loader to use to load the class\n-     * @param className the class name\n-     * @return the class represented by {@code className} using the {@code classLoader}\n-     * @throws NullPointerException if the className is null\n-     * @throws ClassNotFoundException if the class is not found\n+     * @param classLoader the class loader to use to load the class.\n+     * @param className the class name.\n+     * @return the class represented by {@code className} using the {@code classLoader}.\n+     * @throws NullPointerException if the className is null.\n+     * @throws ClassNotFoundException if the class is not found.\n+     * @throws IllegalArgumentException Thrown if the class name represents an array with more dimensions than the JVM supports, 255.\n+     * @see Class#forName(String, boolean, ClassLoader)\n+     * @see <a href=\"https://docs.oracle.com/javase/specs/jvms/se25/html/jvms-4.html#jvms-4.4.1\">JVM: Array dimension limits in JVM Specification CONSTANT_Class_info</a>\n+     * @see <a href=\"https://docs.oracle.com/javase/specs/jls/se25/html/jls-6.html#jls-6.7\">JLS: Fully Qualified Names and Canonical Names</a>\n+     * @see <a href=\"https://docs.oracle.com/javase/specs/jls/se25/html/jls-13.html#jls-13.1\">JLS: The Form of a Binary</a>\n      */\n     public static Class<?> getClass(final ClassLoader classLoader, final String className) throws ClassNotFoundException {\n         return getClass(classLoader, className, true);\n@@ -535,12 +547,17 @@ public static Class<?> getClass(final ClassLoader classLoader, final String clas\n      * syntaxes \"{@code java.util.Map.Entry[]}\", \"{@code java.util.Map$Entry[]}\", \"{@code [Ljava.util.Map.Entry;}\", and\n      * \"{@code [Ljava.util.Map$Entry;}\".\n      *\n-     * @param classLoader the class loader to use to load the class\n-     * @param className the class name\n-     * @param initialize whether the class must be initialized\n-     * @return the class represented by {@code className} using the {@code classLoader}\n-     * @throws NullPointerException if the className is null\n-     * @throws ClassNotFoundException if the class is not found\n+     * @param classLoader the class loader to use to load the class.\n+     * @param className the class name.\n+     * @param initialize whether the class must be initialized.\n+     * @return the class represented by {@code className} using the {@code classLoader}.\n+     * @throws NullPointerException if the className is null.\n+     * @throws ClassNotFoundException if the class is not found.\n+     * @throws IllegalArgumentException Thrown if the class name represents an array with more dimensions than the JVM supports, 255.\n+     * @see Class#forName(String, boolean, ClassLoader)\n+     * @see <a href=\"https://docs.oracle.com/javase/specs/jvms/se25/html/jvms-4.html#jvms-4.4.1\">JVM: Array dimension limits in JVM Specification CONSTANT_Class_info</a>\n+     * @see <a href=\"https://docs.oracle.com/javase/specs/jls/se25/html/jls-6.html#jls-6.7\">JLS: Fully Qualified Names and Canonical Names</a>\n+     * @see <a href=\"https://docs.oracle.com/javase/specs/jls/se25/html/jls-13.html#jls-13.1\">JLS: The Form of a Binary</a>\n      */\n     public static Class<?> getClass(final ClassLoader classLoader, final String className, final boolean initialize) throws ClassNotFoundException {\n         // This method was re-written to avoid recursion and stack overflows found by fuzz testing.\n@@ -569,6 +586,11 @@ public static Class<?> getClass(final ClassLoader classLoader, final String clas\n      * @return the class represented by {@code className} using the current thread's context class loader\n      * @throws NullPointerException if the className is null\n      * @throws ClassNotFoundException if the class is not found\n+     * @throws IllegalArgumentException Thrown if the class name represents an array with more dimensions than the JVM supports, 255.\n+     * @see Class#forName(String, boolean, ClassLoader)\n+     * @see <a href=\"https://docs.oracle.com/javase/specs/jvms/se25/html/jvms-4.html#jvms-4.4.1\">JVM: Array dimension limits in JVM Specification CONSTANT_Class_info</a>\n+     * @see <a href=\"https://docs.oracle.com/javase/specs/jls/se25/html/jls-6.html#jls-6.7\">JLS: Fully Qualified Names and Canonical Names</a>\n+     * @see <a href=\"https://docs.oracle.com/javase/specs/jls/se25/html/jls-13.html#jls-13.1\">JLS: The Form of a Binary</a>\n      */\n     public static Class<?> getClass(final String className) throws ClassNotFoundException {\n         return getClass(className, true);\n@@ -579,11 +601,16 @@ public static Class<?> getClass(final String className) throws ClassNotFoundExce\n      * implementation supports the syntaxes \"{@code java.util.Map.Entry[]}\", \"{@code java.util.Map$Entry[]}\",\n      * \"{@code [Ljava.util.Map.Entry;}\", and \"{@code [Ljava.util.Map$Entry;}\".\n      *\n-     * @param className the class name\n-     * @param initialize whether the class must be initialized\n-     * @return the class represented by {@code className} using the current thread's context class loader\n-     * @throws NullPointerException if the className is null\n-     * @throws ClassNotFoundException if the class is not found\n+     * @param className the class name.\n+     * @param initialize whether the class must be initialized.\n+     * @return the class represented by {@code className} using the current thread's context class loader.\n+     * @throws NullPointerException if the className is null.\n+     * @throws ClassNotFoundException if the class is not found.\n+     * @throws IllegalArgumentException Thrown if the class name represents an array with more dimensions than the JVM supports, 255.\n+     * @see Class#forName(String, boolean, ClassLoader)\n+     * @see <a href=\"https://docs.oracle.com/javase/specs/jvms/se25/html/jvms-4.html#jvms-4.4.1\">JVM: Array dimension limits in JVM Specification CONSTANT_Class_info</a>\n+     * @see <a href=\"https://docs.oracle.com/javase/specs/jls/se25/html/jls-6.html#jls-6.7\">JLS: Fully Qualified Names and Canonical Names</a>\n+     * @see <a href=\"https://docs.oracle.com/javase/specs/jls/se25/html/jls-13.html#jls-13.1\">JLS: The Form of a Binary</a>\n      */\n     public static Class<?> getClass(final String className, final boolean initialize) throws ClassNotFoundException {\n         final ClassLoader contextCL = Thread.currentThread().getContextClassLoader();\n@@ -1494,17 +1521,22 @@ public static Class<?> primitiveToWrapper(final Class<?> cls) {\n     /**\n      * Converts a class name to a JLS style class name.\n      *\n-     * @param className the class name\n-     * @return the converted name\n-     * @throws NullPointerException if the className is null\n+     * @param className the class name.\n+     * @return the converted name.\n+     * @throws NullPointerException if the className is null.\n+     * @throws IllegalArgumentException Thrown if the class name represents an array with more dimensions than the JVM supports, 255.\n      */\n     private static String toCanonicalName(final String className) {\n         String canonicalName = StringUtils.deleteWhitespace(className);\n         Objects.requireNonNull(canonicalName, \"className\");\n         final String arrayMarker = \"[]\";\n+        int arrayDim = 0;\n         if (canonicalName.endsWith(arrayMarker)) {\n             final StringBuilder classNameBuffer = new StringBuilder();\n             while (canonicalName.endsWith(arrayMarker)) {\n+                if (++arrayDim > MAX_JVM_ARRAY_DIMENSION) {\n+                    throw new IllegalArgumentException(\"Array dimension greater than JVM specification maximum of 255.\");\n+                }\n                 canonicalName = canonicalName.substring(0, canonicalName.length() - 2);\n                 classNameBuffer.append(\"[\");\n             }\n",
  "test_patch" : "diff --git a/src/test/java/org/apache/commons/lang3/ClassUtilsTest.java b/src/test/java/org/apache/commons/lang3/ClassUtilsTest.java\nindex 320391193aa..43957c97eb0 100644\n--- a/src/test/java/org/apache/commons/lang3/ClassUtilsTest.java\n+++ b/src/test/java/org/apache/commons/lang3/ClassUtilsTest.java\n@@ -26,6 +26,7 @@\n import static org.junit.jupiter.api.Assertions.assertSame;\n import static org.junit.jupiter.api.Assertions.assertThrows;\n import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n \n import java.io.Serializable;\n import java.lang.reflect.Constructor;\n@@ -37,6 +38,7 @@\n import java.util.Iterator;\n import java.util.List;\n import java.util.Map;\n+import java.util.Objects;\n import java.util.Set;\n import java.util.TreeMap;\n import java.util.function.Function;\n@@ -48,6 +50,8 @@\n import org.junit.jupiter.api.Assertions;\n import org.junit.jupiter.api.DisplayName;\n import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junitpioneer.jupiter.params.IntRangeSource;\n \n /**\n  * Tests {@link ClassUtils}.\n@@ -113,6 +117,22 @@ private void assertGetClassThrowsNullPointerException(final String className) {\n         assertGetClassThrowsException(className, NullPointerException.class);\n     }\n \n+    private int getDimension(final Class<?> clazz) {\n+        Objects.requireNonNull(clazz);\n+        if (!clazz.isArray()) {\n+            fail(\"Not an array: \" + clazz);\n+        }\n+        final String className = clazz.getName();\n+        int dimension = 0;\n+        for (final char c : className.toCharArray()) {\n+            if (c != '[') {\n+                break;\n+            }\n+            dimension++;\n+        }\n+        return dimension;\n+    }\n+\n     @Test\n     void test_convertClassesToClassNames_List() {\n         final List<Class<?>> list = new ArrayList<>();\n@@ -1177,6 +1197,23 @@ void testConstructor() {\n         assertFalse(Modifier.isFinal(ClassUtils.class.getModifiers()));\n     }\n \n+    @ParameterizedTest\n+    @IntRangeSource(from = 1, to = 255)\n+    void testGetClassArray(final int dimensions) throws ClassNotFoundException {\n+        assertEquals(dimensions,\n+                getDimension(ClassUtils.getClass(\"org.apache.commons.lang3.ClassUtilsTest$Inner.DeeplyNested\" + StringUtils.repeat(\"[]\", dimensions))));\n+        assertEquals(dimensions, getDimension(ClassUtils.getClass(\"java.lang.String\" + StringUtils.repeat(\"[]\", dimensions))));\n+    }\n+\n+    @ParameterizedTest\n+    @IntRangeSource(from = 256, to = 300)\n+    void testGetClassArrayIllegal(final int dimensions) throws ClassNotFoundException {\n+        assertThrows(IllegalArgumentException.class, () -> assertEquals(dimensions,\n+                getDimension(ClassUtils.getClass(\"org.apache.commons.lang3.ClassUtilsTest$Inner.DeeplyNested\" + StringUtils.repeat(\"[]\", dimensions)))));\n+        assertThrows(IllegalArgumentException.class,\n+                () -> assertEquals(dimensions, getDimension(ClassUtils.getClass(\"java.lang.String\" + StringUtils.repeat(\"[]\", dimensions)))));\n+    }\n+\n     @Test\n     void testGetClassByNormalNameArrays() throws ClassNotFoundException {\n         assertEquals(int[].class, ClassUtils.getClass(\"int[]\"));\n@@ -1214,6 +1251,26 @@ void testGetClassClassNotFound() throws Exception {\n         assertGetClassThrowsClassNotFound(\"integer[]\");\n     }\n \n+    @Test\n+    void testGetClassInner() throws ClassNotFoundException {\n+        assertEquals(Inner.DeeplyNested.class, ClassUtils.getClass(\"org.apache.commons.lang3.ClassUtilsTest.Inner.DeeplyNested\"));\n+        assertEquals(Inner.DeeplyNested.class, ClassUtils.getClass(\"org.apache.commons.lang3.ClassUtilsTest.Inner$DeeplyNested\"));\n+        assertEquals(Inner.DeeplyNested.class, ClassUtils.getClass(\"org.apache.commons.lang3.ClassUtilsTest$Inner$DeeplyNested\"));\n+        assertEquals(Inner.DeeplyNested.class, ClassUtils.getClass(\"org.apache.commons.lang3.ClassUtilsTest$Inner.DeeplyNested\"));\n+        assertEquals(Inner.DeeplyNested[].class, ClassUtils.getClass(\"org.apache.commons.lang3.ClassUtilsTest$Inner.DeeplyNested[]\"));\n+        //\n+        assertEquals(Inner.DeeplyNested.class, ClassUtils.getClass(\"org.apache.commons.lang3.ClassUtilsTest.Inner.DeeplyNested\", true));\n+        assertEquals(Inner.DeeplyNested.class, ClassUtils.getClass(\"org.apache.commons.lang3.ClassUtilsTest.Inner$DeeplyNested\", true));\n+        assertEquals(Inner.DeeplyNested.class, ClassUtils.getClass(\"org.apache.commons.lang3.ClassUtilsTest$Inner$DeeplyNested\", true));\n+        assertEquals(Inner.DeeplyNested.class, ClassUtils.getClass(\"org.apache.commons.lang3.ClassUtilsTest$Inner.DeeplyNested\", true));\n+        //\n+        final ClassLoader classLoader = Inner.DeeplyNested.class.getClassLoader();\n+        assertEquals(Inner.DeeplyNested.class, ClassUtils.getClass(classLoader, \"org.apache.commons.lang3.ClassUtilsTest.Inner.DeeplyNested\"));\n+        assertEquals(Inner.DeeplyNested.class, ClassUtils.getClass(classLoader, \"org.apache.commons.lang3.ClassUtilsTest.Inner$DeeplyNested\"));\n+        assertEquals(Inner.DeeplyNested.class, ClassUtils.getClass(classLoader, \"org.apache.commons.lang3.ClassUtilsTest$Inner$DeeplyNested\"));\n+        assertEquals(Inner.DeeplyNested.class, ClassUtils.getClass(classLoader, \"org.apache.commons.lang3.ClassUtilsTest$Inner.DeeplyNested\"));\n+    }\n+\n     @Test\n     void testGetClassInvalidArguments() throws Exception {\n         assertGetClassThrowsNullPointerException(null);\n@@ -1275,26 +1332,6 @@ void testGetComponentType() {\n         assertNull(ClassUtils.getComponentType(null));\n     }\n \n-    @Test\n-    void testGetInnerClass() throws ClassNotFoundException {\n-        assertEquals(Inner.DeeplyNested.class, ClassUtils.getClass(\"org.apache.commons.lang3.ClassUtilsTest.Inner.DeeplyNested\"));\n-        assertEquals(Inner.DeeplyNested.class, ClassUtils.getClass(\"org.apache.commons.lang3.ClassUtilsTest.Inner$DeeplyNested\"));\n-        assertEquals(Inner.DeeplyNested.class, ClassUtils.getClass(\"org.apache.commons.lang3.ClassUtilsTest$Inner$DeeplyNested\"));\n-        assertEquals(Inner.DeeplyNested.class, ClassUtils.getClass(\"org.apache.commons.lang3.ClassUtilsTest$Inner.DeeplyNested\"));\n-        //\n-        assertEquals(Inner.DeeplyNested.class, ClassUtils.getClass(\"org.apache.commons.lang3.ClassUtilsTest.Inner.DeeplyNested\", true));\n-        assertEquals(Inner.DeeplyNested.class, ClassUtils.getClass(\"org.apache.commons.lang3.ClassUtilsTest.Inner$DeeplyNested\", true));\n-        assertEquals(Inner.DeeplyNested.class, ClassUtils.getClass(\"org.apache.commons.lang3.ClassUtilsTest$Inner$DeeplyNested\", true));\n-        assertEquals(Inner.DeeplyNested.class, ClassUtils.getClass(\"org.apache.commons.lang3.ClassUtilsTest$Inner.DeeplyNested\", true));\n-        //\n-        final ClassLoader classLoader = Inner.DeeplyNested.class.getClassLoader();\n-        assertEquals(Inner.DeeplyNested.class, ClassUtils.getClass(classLoader, \"org.apache.commons.lang3.ClassUtilsTest.Inner.DeeplyNested\"));\n-        assertEquals(Inner.DeeplyNested.class, ClassUtils.getClass(classLoader, \"org.apache.commons.lang3.ClassUtilsTest.Inner$DeeplyNested\"));\n-        assertEquals(Inner.DeeplyNested.class, ClassUtils.getClass(classLoader, \"org.apache.commons.lang3.ClassUtilsTest$Inner$DeeplyNested\"));\n-        assertEquals(Inner.DeeplyNested.class, ClassUtils.getClass(classLoader, \"org.apache.commons.lang3.ClassUtilsTest$Inner.DeeplyNested\"));\n-        //\n-    }\n-\n     @Test\n     void testGetPublicMethod() throws Exception {\n         // Tests with Collections$UnmodifiableSet\n",
  "problem_statement" : "ClassUtils now throws `IllegalArgumentException` when array is greater than JVM spec limit (255)\n\nClassUtils now throws `IllegalArgumentException` if a class name represents an array with more dimensions than the JVM spec allow, `255`\r\n\r\nAffects `ClassUtils` methods:\r\n\r\n- `getClass(ClassLoader, String, boolean)`,\r\n- `getClass(ClassLoader, String)`,\r\n- `getClass(String, boolean)`,\r\n- `getClass(String)`\r\n\r\nSee also [JVM Specification section 4.3.2. Field Descriptors](https://docs.oracle.com/javase/specs/jvms/se16/html/jvms-4.html#:~:text=A%20field%20descriptor%20representing%20an%20array%20type%20is%20valid%20only%20if%20it%20represents%20a%20type%20with%20255%20or%20fewer%20dimensions).\r\n\r\n- [x] Read the [contribution guidelines](CONTRIBUTING.md) for this project.\r\n- [x] Read the [ASF Generative Tooling Guidance](https://www.apache.org/legal/generative-tooling.html) if you use Artificial Intelligence (AI).\r\n- [ ] I used AI to create any part of, or all of, this pull request.\r\n- [x] Run a successful build using the default [Maven](https://maven.apache.org/) goal with `mvn`; that's `mvn` on the command line by itself.\r\n- [x] Write unit tests that match behavioral changes, where the tests fail if the changes to the runtime are not applied. This may not always be possible, but it is a best practice.\r\n- [x] Write a pull request description that is detailed enough to understand what the pull request does, how, and why.\r\n- [x] Each commit in the pull request should have a meaningful subject line and body. Note that a maintainer may squash commits during the merge process.\r\n",
  "hints_text" : null,
  "created_at" : "Mon Nov 17 16:04:18 CET 2025",
  "version" : null,
  "FAIL_TO_PASS" : [ "ClassUtilsTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=ClassUtilsTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 1494,
  "metadata" : null
}, {
  "instance_id" : "apache-commons-lang-PR-1492",
  "repo" : "apache/commons-lang",
  "base_commit" : "a33e37af920fa084919134d20035bd807848dd3b",
  "patch" : "diff --git a/src/main/java/org/apache/commons/lang/ClassUtils.java b/src/main/java/org/apache/commons/lang/ClassUtils.java\nindex ebc38f0c936..c0f72fcd8c6 100644\n--- a/src/main/java/org/apache/commons/lang/ClassUtils.java\n+++ b/src/main/java/org/apache/commons/lang/ClassUtils.java\n@@ -748,30 +748,28 @@ public static boolean isInnerClass(Class cls) {\n      */\n     public static Class getClass(\n             ClassLoader classLoader, String className, boolean initialize) throws ClassNotFoundException {\n-        try {\n-            Class clazz;\n-            if (abbreviationMap.containsKey(className)) {\n-                String clsName = \"[\" + abbreviationMap.get(className);\n-                clazz = Class.forName(clsName, initialize, classLoader).getComponentType();\n-            } else {\n-                clazz = Class.forName(toCanonicalName(className), initialize, classLoader);\n-            }\n-            return clazz;\n-        } catch (ClassNotFoundException ex) {\n-            // allow path separators (.) as inner class name separators\n-            int lastDotIndex = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);\n-\n-            if (lastDotIndex != -1) {\n-                try {\n-                    return getClass(classLoader, className.substring(0, lastDotIndex) +\n-                            INNER_CLASS_SEPARATOR_CHAR + className.substring(lastDotIndex + 1),\n-                            initialize);\n-                } catch (ClassNotFoundException ex2) {\n+        // This method was re-written to avoid recursion and stack overflows found by fuzz testing.\n+        String next = className;\n+        int lastDotIndex = -1;\n+        do {\n+            try {\n+                Class clazz;\n+                if (abbreviationMap.containsKey(next)) {\n+                    String clsName = \"[\" + abbreviationMap.get(next);\n+                    clazz = Class.forName(clsName, initialize, classLoader).getComponentType();\n+                } else {\n+                    String canonicalName = toCanonicalName(next);\n+                    clazz = Class.forName(canonicalName, initialize, classLoader);\n+                }\n+                return clazz;\n+            } catch (final ClassNotFoundException ex) {\n+                lastDotIndex = next.lastIndexOf(PACKAGE_SEPARATOR_CHAR);\n+                if (lastDotIndex != -1) {\n+                    next = next.substring(0, lastDotIndex) + INNER_CLASS_SEPARATOR_CHAR + next.substring(lastDotIndex + 1);\n                 }\n             }\n-\n-            throw ex;\n-        }\n+        } while (lastDotIndex != -1);\n+        throw new ClassNotFoundException(next);\n     }\n \n     /**\n",
  "test_patch" : "diff --git a/src/test/java/org/apache/commons/lang/ClassUtilsTest.java b/src/test/java/org/apache/commons/lang/ClassUtilsTest.java\nindex b9353e629e7..98dd9c8d955 100644\n--- a/src/test/java/org/apache/commons/lang/ClassUtilsTest.java\n+++ b/src/test/java/org/apache/commons/lang/ClassUtilsTest.java\n@@ -500,6 +500,21 @@ public void testPrimitiveToWrapper() {\n             ClassUtils.primitiveToWrapper(null));\n     }\n \n+    public void testGetClassSOE() {\n+        int numLevels = 9000;\n+        StringBuffer sb = new StringBuffer(numLevels * 2 + 1);\n+        sb.append(\"a\");\n+        for (int i = 0; i < numLevels; i++) {\n+            sb.append(\".a\");\n+        }\n+        try {\n+            ClassUtils.getClass(sb.toString());\n+            fail(\"Expected ClassNotFoundException\");\n+        } catch (ClassNotFoundException ignore) {\n+            // ignore\n+        }\n+    }\n+\n     public void testPrimitivesToWrappers() {\n         // test null\n         assertNull(\"null -> null\",\n",
  "problem_statement" : "Rewrite ClassUtils.getClass() without recursion to avoid StackOverflowError on very long inputs\n\ncherry-pick from b424803abdb2bec818e4fbcb251ce031c22aca53\r\n\r\n- This was found fuzz testing Apache Commons Text which relies on ClassUtils.\r\n- OssFuzz Issue 42522972:\r\n\r\napache-commons-text:StringSubstitutorInterpolatorFuzzer: Security exception in org.apache.commons.lang3.ClassUtils.getClass\r\n\r\nBefore you push a pull request, review this list:\r\n\r\n- [x] Read the [contribution guidelines](CONTRIBUTING.md) for this project.\r\n- [x] Read the [ASF Generative Tooling Guidance](https://www.apache.org/legal/generative-tooling.html) if you use Artificial Intelligence (AI).\r\n- [ ] I used AI to create any part of, or all of, this pull request.\r\n- [ ] Run a successful build using the default [Maven](https://maven.apache.org/) goal with `mvn`; that's `mvn` on the command line by itself.\r\n- [x] Write unit tests that match behavioral changes, where the tests fail if the changes to the runtime are not applied. This may not always be possible, but it is a best practice.\r\n- [x] Write a pull request description that is detailed enough to understand what the pull request does, how, and why.\r\n- [x] Each commit in the pull request should have a meaningful subject line and body. Note that a maintainer may squash commits during the merge process.\r\n",
  "hints_text" : null,
  "created_at" : "Sun Nov 16 07:54:34 CET 2025",
  "version" : null,
  "FAIL_TO_PASS" : [ "ClassUtilsTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=ClassUtilsTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 1492,
  "metadata" : null
}, {
  "instance_id" : "apache-commons-lang-PR-1490",
  "repo" : "apache/commons-lang",
  "base_commit" : "09b30e3c293d28ac42f927bdf76996d9ea8b167f",
  "patch" : "diff --git a/src/main/java/org/apache/commons/lang3/StringUtils.java b/src/main/java/org/apache/commons/lang3/StringUtils.java\nindex 1ae37530616..4616abfc024 100644\n--- a/src/main/java/org/apache/commons/lang3/StringUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/StringUtils.java\n@@ -350,13 +350,13 @@ public static String abbreviate(final String str, final String abbrevMarker, fin\n      * @throws IllegalArgumentException if the width is too small.\n      * @since 3.6\n      */\n-    public static String abbreviate(final String str, final String abbrevMarker, int offset, final int maxWidth) {\n-        if (isNotEmpty(str) && EMPTY.equals(abbrevMarker) && maxWidth > 0) {\n-            return substring(str, 0, maxWidth);\n-        }\n-        if (isAnyEmpty(str, abbrevMarker)) {\n+    public static String abbreviate(final String str, String abbrevMarker, int offset, final int maxWidth) {\n+        if (isEmpty(str)) {\n             return str;\n         }\n+        if (abbrevMarker == null) {\n+            abbrevMarker = EMPTY;\n+        }\n         final int abbrevMarkerLength = abbrevMarker.length();\n         final int minAbbrevWidth = abbrevMarkerLength + 1;\n         final int minAbbrevWidthOffset = abbrevMarkerLength + abbrevMarkerLength + 1;\n",
  "test_patch" : "diff --git a/src/test/java/org/apache/commons/lang3/StringUtilsAbbreviateTest.java b/src/test/java/org/apache/commons/lang3/StringUtilsAbbreviateTest.java\nindex 49a188d06de..ccd2ad21168 100644\n--- a/src/test/java/org/apache/commons/lang3/StringUtilsAbbreviateTest.java\n+++ b/src/test/java/org/apache/commons/lang3/StringUtilsAbbreviateTest.java\n@@ -101,13 +101,16 @@ void testAbbreviate_StringIntInt() {\n         assertAbbreviateWithOffset(\"...ijklmno\", 15, 10);\n         assertAbbreviateWithOffset(\"...ijklmno\", 16, 10);\n         assertAbbreviateWithOffset(\"...ijklmno\", Integer.MAX_VALUE, 10);\n+\n+        // abbreviating a shorter string allows maxWidth < 7\n+        assertEquals(\"...efg\", StringUtils.abbreviate(\"abcdefg\", 5, 6));\n     }\n \n     @Test\n     void testAbbreviate_StringStringInt() {\n         assertNull(StringUtils.abbreviate(null, null, 10));\n         assertNull(StringUtils.abbreviate(null, \"...\", 10));\n-        assertEquals(\"paranaguacu\", StringUtils.abbreviate(\"paranaguacu\", null, 10));\n+        assertEquals(\"paranaguac\", StringUtils.abbreviate(\"paranaguacu\", null, 10));\n         assertEquals(\"\", StringUtils.abbreviate(\"\", \"...\", 2));\n         assertEquals(\"wai**\", StringUtils.abbreviate(\"waiheke\", \"**\", 5));\n         assertEquals(\"And af,,,,\", StringUtils.abbreviate(\"And after a long time, he finally met his son.\", \",,,,\", 10));\n@@ -130,6 +133,12 @@ void testAbbreviate_StringStringIntInt() {\n         assertNull(StringUtils.abbreviate(null, \"...\", 10, 12));\n         assertEquals(\"\", StringUtils.abbreviate(\"\", null, 0, 10));\n         assertEquals(\"\", StringUtils.abbreviate(\"\", \"...\", 2, 10));\n+        assertEquals(\"abcdefg\", StringUtils.abbreviate(\"abcdefg\", null, 2, 10));\n+        assertEquals(\"abcdefg\", StringUtils.abbreviate(\"abcdefg\", \"\", 2, 10));\n+        assertEquals(\"abc\", StringUtils.abbreviate(\"abcdefg\", null, 0, 3));\n+        assertEquals(\"cde\", StringUtils.abbreviate(\"abcdefg\", null, 2, 3));\n+        assertEquals(\"abc\", StringUtils.abbreviate(\"abcdefg\", \"\", 0, 3));\n+        assertEquals(\"cde\", StringUtils.abbreviate(\"abcdefg\", \"\", 2, 3));\n         assertIllegalArgumentException(() -> StringUtils.abbreviate(\"abcdefghij\", \"::\", 0, 2),\n                 \"StringUtils.abbreviate expecting IllegalArgumentException\");\n         assertIllegalArgumentException(() -> StringUtils.abbreviate(\"abcdefghij\", \"!!!\", 5, 6),\n@@ -157,6 +166,10 @@ void testAbbreviate_StringStringIntInt() {\n         assertAbbreviateWithAbbrevMarkerAndOffset(\"999ijklmno\", \"999\", 15, 10);\n         assertAbbreviateWithAbbrevMarkerAndOffset(\"_ghijklmno\", \"_\", 16, 10);\n         assertAbbreviateWithAbbrevMarkerAndOffset(\"+ghijklmno\", \"+\", Integer.MAX_VALUE, 10);\n+\n+        // abbreviating a shorter string allows maxWidth < abbrevMarker.length * 2 + 1\n+        assertEquals(\"..de\", StringUtils.abbreviate(\"abcde\", \"..\", 4, 4));\n+        assertEquals(\"....fg\", StringUtils.abbreviate(\"abcdefg\", \"....\", 5, 6));\n     }\n \n     // Fixed LANG-1463\n",
  "problem_statement" : "StringUtils.abbreviate(String, String, int) contract violations\n\nI have added unit tests showing incorrect behaviour of `StringUtils.abbreviate` on short strings (between `abbrevMarker.length + 1` and `abbrevMarker.length * 2`).\r\n\r\nThe documentation states that the offset character will always appear somewhere in the result, but when an offset is applied to a short string, it may not be.",
  "hints_text" : null,
  "created_at" : "Sat Nov 15 00:32:08 CET 2025",
  "version" : null,
  "FAIL_TO_PASS" : [ "StringUtilsAbbreviateTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=StringUtilsAbbreviateTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 1490,
  "metadata" : null
}, {
  "instance_id" : "apache-commons-lang-PR-1483",
  "repo" : "apache/commons-lang",
  "base_commit" : "ba85f5e5b3e98234fa0cf22f2155bf41466c10f5",
  "patch" : "diff --git a/pom.xml b/pom.xml\nindex ee6b49e96d0..e1f5ddc00ef 100644\n--- a/pom.xml\n+++ b/pom.xml\n@@ -162,7 +162,7 @@\n     <commons.distSvnStagingUrl>scm:svn:https://dist.apache.org/repos/dist/dev/commons/lang</commons.distSvnStagingUrl>\n     <!-- JaCoCo: Don't make code coverage worse than: -->\n     <commons.jacoco.haltOnFailure>true</commons.jacoco.haltOnFailure>\n-    <commons.jacoco.classRatio>0.99</commons.jacoco.classRatio>\n+    <commons.jacoco.classRatio>0.98</commons.jacoco.classRatio>\n     <commons.jacoco.instructionRatio>0.96</commons.jacoco.instructionRatio>\n     <commons.jacoco.methodRatio>0.96</commons.jacoco.methodRatio>\n     <commons.jacoco.branchRatio>0.92</commons.jacoco.branchRatio>\n@@ -482,6 +482,17 @@\n         </plugins>\n       </build>\n     </profile>\n+    <profile>\n+\t  <!-- Java 25 and up -->\n+      <id>java-25-up</id>\n+      <activation>\n+\t\t<jdk>[25,)</jdk>\n+\t  </activation>\n+      <properties>\n+        <!-- JaCoCo: Don't make code coverage worse than: -->\n+        <commons.jacoco.classRatio>0.99</commons.jacoco.classRatio>\n+      </properties>\n+    </profile>\n     <profile>\n       <id>benchmark</id>\n       <properties>\ndiff --git a/src/main/java/org/apache/commons/lang3/time/FastDateParser.java b/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\nindex 4a7083052fd..2c90cabdcad 100644\n--- a/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\n+++ b/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\n@@ -482,6 +482,7 @@ private StrategyAndWidth literal() {\n      * A strategy that handles a time zone field in the parsing pattern\n      */\n     static class TimeZoneStrategy extends PatternStrategy {\n+\n         private static final class TzInfo {\n             final TimeZone zone;\n             final int dstOffset;\n@@ -496,6 +497,7 @@ public String toString() {\n                 return \"TzInfo [zone=\" + zone + \", dstOffset=\" + dstOffset + \"]\";\n             }\n         }\n+\n         private static final String RFC_822_TIME_ZONE = \"[+-]\\\\d{4}\";\n \n         private static final String GMT_OPTION = TimeZones.GMT_ID + \"[+-]\\\\d{1,2}:\\\\d{2}\";\n@@ -505,6 +507,22 @@ public String toString() {\n          */\n         private static final int ID = 0;\n \n+        /**\n+         * Tests whether to skip the given time zone, true if TimeZone.getTimeZone().\n+         * <p>\n+         * On Java 25 and up, skips short IDs if {@code ignoreTimeZoneShortIDs} is true.\n+         * </p>\n+         * <p>\n+         * This method is package private only for testing.\n+         * </p>\n+         *\n+         * @param tzId the ID to test.\n+         * @return Whether to skip the given time zone ID.\n+         */\n+        static boolean skipTimeZone(final String tzId) {\n+            return tzId.equalsIgnoreCase(TimeZones.GMT_ID);\n+        }\n+\n         private final Locale locale;\n \n         /**\n@@ -514,9 +532,9 @@ public String toString() {\n         private final Map<String, TzInfo> tzNames = new TreeMap<>(String.CASE_INSENSITIVE_ORDER);\n \n         /**\n-         * Constructs a Strategy that parses a TimeZone\n+         * Constructs a Strategy that parses a TimeZone.\n          *\n-         * @param locale The Locale\n+         * @param locale The Locale.\n          */\n         TimeZoneStrategy(final Locale locale) {\n             this.locale = LocaleUtils.toLocale(locale);\n@@ -532,10 +550,10 @@ public String toString() {\n             for (final String[] zoneNames : zones) {\n                 // offset 0 is the time zone ID and is not localized\n                 final String tzId = zoneNames[ID];\n-                if (tzId.equalsIgnoreCase(TimeZones.GMT_ID)) {\n+                if (skipTimeZone(tzId)) {\n                     continue;\n                 }\n-                final TimeZone tz = TimeZone.getTimeZone(tzId);\n+                final TimeZone tz = TimeZones.getTimeZone(tzId);\n                 // offset 1 is long standard name\n                 // offset 2 is short standard name\n                 final TzInfo standard = new TzInfo(tz, false);\n@@ -561,10 +579,10 @@ public String toString() {\n             }\n             // Order is undefined.\n             for (final String tzId : ArraySorter.sort(TimeZone.getAvailableIDs())) {\n-                if (tzId.equalsIgnoreCase(TimeZones.GMT_ID)) {\n+                if (skipTimeZone(tzId)) {\n                     continue;\n                 }\n-                final TimeZone tz = TimeZone.getTimeZone(tzId);\n+                final TimeZone tz = TimeZones.getTimeZone(tzId);\n                 final String zoneName = tz.getDisplayName(locale);\n                 if (sorted.add(zoneName)) {\n                     tzNames.put(zoneName, new TzInfo(tz, tz.observesDaylightTime()));\ndiff --git a/src/main/java/org/apache/commons/lang3/time/FastTimeZone.java b/src/main/java/org/apache/commons/lang3/time/FastTimeZone.java\nindex f7bc16a9381..7c252fec89b 100644\n--- a/src/main/java/org/apache/commons/lang3/time/FastTimeZone.java\n+++ b/src/main/java/org/apache/commons/lang3/time/FastTimeZone.java\n@@ -77,7 +77,7 @@ public static TimeZone getTimeZone(final String id) {\n         if (tz != null) {\n             return tz;\n         }\n-        return TimeZone.getTimeZone(id);\n+        return TimeZones.getTimeZone(id);\n     }\n \n     private static int parseInt(final String group) {\ndiff --git a/src/main/java/org/apache/commons/lang3/time/TimeZones.java b/src/main/java/org/apache/commons/lang3/time/TimeZones.java\nindex c63e6595cfb..876b467c1ed 100644\n--- a/src/main/java/org/apache/commons/lang3/time/TimeZones.java\n+++ b/src/main/java/org/apache/commons/lang3/time/TimeZones.java\n@@ -17,9 +17,13 @@\n \n package org.apache.commons.lang3.time;\n \n+import java.time.ZoneId;\n import java.util.TimeZone;\n \n+import org.apache.commons.lang3.JavaVersion;\n import org.apache.commons.lang3.ObjectUtils;\n+import org.apache.commons.lang3.SystemProperties;\n+import org.apache.commons.lang3.SystemUtils;\n \n /**\n  * Helps dealing with {@link java.util.TimeZone}s.\n@@ -38,7 +42,34 @@ public class TimeZones {\n      *\n      * @since 3.13.0\n      */\n-    public static final TimeZone GMT = TimeZone.getTimeZone(GMT_ID);\n+    public static final TimeZone GMT = TimeZones.getTimeZone(GMT_ID);\n+\n+    private static final boolean JAVA_25 = SystemUtils.isJavaVersionAtLeast(JavaVersion.JAVA_25);\n+\n+    /**\n+     * Delegates to {@link TimeZone#getTimeZone(String)} after mapping an ID if it's in {@link ZoneId#SHORT_IDS}.\n+     * <p>\n+     * On Java 25, calling {@link TimeZone#getTimeZone(String)} with an ID in {@link ZoneId#SHORT_IDS} writes a message to {@link System#err} in the form:\n+     * </p>\n+     *\n+     * <pre>\n+     * WARNING: Use of the three-letter time zone ID \"the-short-id\" is deprecated and it will be removed in a future release\n+     * </pre>\n+     * <p>\n+     * You can disable mapping from {@link ZoneId#SHORT_IDS} by setting the system property {@code \"TimeZones.mapShortIDs=false\"}.\n+     * </p>\n+     *\n+     * @param id Same as {@link TimeZone#getTimeZone(String)}.\n+     * @return Same as {@link TimeZone#getTimeZone(String)}.\n+     * @since 3.20.0\n+     */\n+    public static TimeZone getTimeZone(final String id) {\n+        return TimeZone.getTimeZone(JAVA_25 && mapShortIDs() ? ZoneId.SHORT_IDS.getOrDefault(id, id) : id);\n+    }\n+\n+    private static boolean mapShortIDs() {\n+        return SystemProperties.getBoolean(TimeZones.class, \"mapShortIDs\", () -> true);\n+    }\n \n     /**\n      * Returns the given TimeZone if non-{@code null}, otherwise {@link TimeZone#getDefault()}.\n@@ -54,5 +85,4 @@ public static TimeZone toTimeZone(final TimeZone timeZone) {\n     /** Do not instantiate. */\n     private TimeZones() {\n     }\n-\n }\n",
  "test_patch" : "diff --git a/src/test/java/org/apache/commons/lang3/time/CalendarUtilsTest.java b/src/test/java/org/apache/commons/lang3/time/CalendarUtilsTest.java\nindex f5bf4fcd488..1010af6cfb1 100644\n--- a/src/test/java/org/apache/commons/lang3/time/CalendarUtilsTest.java\n+++ b/src/test/java/org/apache/commons/lang3/time/CalendarUtilsTest.java\n@@ -98,7 +98,7 @@ void testGetYear() {\n      */\n     @Test\n     void testToLocalDate() {\n-        final Calendar calendar = new GregorianCalendar(TimeZone.getTimeZone(TimeZones.GMT_ID));\n+        final Calendar calendar = new GregorianCalendar(TimeZones.getTimeZone(TimeZones.GMT_ID));\n         calendar.setTimeInMillis(-27078001200000L);\n         assertEquals(\"1111-12-08T05:00:00Z\", calendar.toInstant().toString());\n         assertEquals(LocalDate.of(1111, Month.DECEMBER, 8), new CalendarUtils(calendar).toLocalDate());\n@@ -109,7 +109,7 @@ void testToLocalDate() {\n     @ParameterizedTest\n     @MethodSource(TimeZonesTest.TIME_ZONE_GET_AVAILABLE_IDS)\n     void testToLocalDateTime(final String timeZoneId) {\n-        final TimeZone timeZone = TimeZone.getTimeZone(timeZoneId);\n+        final TimeZone timeZone = TimeZones.getTimeZone(timeZoneId);\n         final ZoneId zoneId = timeZone.toZoneId();\n         final Calendar calendar = new GregorianCalendar(timeZone);\n         calendar.setTimeInMillis(0);\n@@ -122,7 +122,7 @@ void testToLocalDateTime(final String timeZoneId) {\n     @ParameterizedTest\n     @MethodSource(TimeZonesTest.TIME_ZONE_GET_AVAILABLE_IDS)\n     void testToOffsetDateTime(final String timeZoneId) {\n-        final TimeZone timeZone = TimeZone.getTimeZone(timeZoneId);\n+        final TimeZone timeZone = TimeZones.getTimeZone(timeZoneId);\n         final ZoneId zoneId = timeZone.toZoneId();\n         final Calendar calendar = new GregorianCalendar(timeZone);\n         calendar.setTimeInMillis(0);\n@@ -135,7 +135,7 @@ void testToOffsetDateTime(final String timeZoneId) {\n     @ParameterizedTest\n     @MethodSource(TimeZonesTest.TIME_ZONE_GET_AVAILABLE_IDS)\n     void testToZonedDateTime(final String timeZoneId) {\n-        final TimeZone timeZone = TimeZone.getTimeZone(timeZoneId);\n+        final TimeZone timeZone = TimeZones.getTimeZone(timeZoneId);\n         final ZoneId zoneId = timeZone.toZoneId();\n         final Calendar calendar = new GregorianCalendar(timeZone);\n         calendar.setTimeInMillis(0);\ndiff --git a/src/test/java/org/apache/commons/lang3/time/DateFormatUtilsTest.java b/src/test/java/org/apache/commons/lang3/time/DateFormatUtilsTest.java\nindex e6e442cdeed..25cbcc7f4c7 100644\n--- a/src/test/java/org/apache/commons/lang3/time/DateFormatUtilsTest.java\n+++ b/src/test/java/org/apache/commons/lang3/time/DateFormatUtilsTest.java\n@@ -141,7 +141,7 @@ void testFormatUTC() {\n     }\n \n     private void testGmtMinus3(final String expectedValue, final String pattern) {\n-        final TimeZone timeZone = TimeZone.getTimeZone(\"GMT-3\");\n+        final TimeZone timeZone = TimeZones.getTimeZone(\"GMT-3\");\n         assertFormats(expectedValue, pattern, timeZone, createFebruaryTestDate(timeZone));\n     }\n \n@@ -153,10 +153,10 @@ void testLANG1000() throws Exception {\n \n     @Test\n     void testLANG1462() {\n-        final TimeZone timeZone = TimeZone.getTimeZone(\"GMT-3\");\n+        final TimeZone timeZone = TimeZones.getTimeZone(\"GMT-3\");\n         final Calendar calendar = createJuneTestDate(timeZone);\n         assertEquals(\"20030608101112\", DateFormatUtils.format(calendar, \"yyyyMMddHHmmss\"));\n-        calendar.setTimeZone(TimeZone.getTimeZone(\"JST\"));\n+        calendar.setTimeZone(TimeZones.getTimeZone(\"JST\"));\n         assertEquals(\"20030608221112\", DateFormatUtils.format(calendar, \"yyyyMMddHHmmss\"));\n     }\n \n@@ -179,35 +179,35 @@ void testLang530() throws ParseException {\n     @Test\n     void testLang916() {\n \n-        final Calendar cal = Calendar.getInstance(TimeZone.getTimeZone(\"Europe/Paris\"));\n+        final Calendar cal = Calendar.getInstance(TimeZones.getTimeZone(\"Europe/Paris\"));\n         cal.clear();\n         cal.set(2009, 9, 16, 8, 42, 16);\n \n         // Long.\n         {\n-            final String value = DateFormatUtils.format(cal.getTimeInMillis(), DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.getPattern(), TimeZone.getTimeZone(\"Europe/Paris\"));\n+            final String value = DateFormatUtils.format(cal.getTimeInMillis(), DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.getPattern(), TimeZones.getTimeZone(\"Europe/Paris\"));\n             assertEquals(\"2009-10-16T08:42:16+02:00\", value, \"long\");\n         }\n         {\n-            final String value = DateFormatUtils.format(cal.getTimeInMillis(), DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.getPattern(), TimeZone.getTimeZone(\"Asia/Kolkata\"));\n+            final String value = DateFormatUtils.format(cal.getTimeInMillis(), DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.getPattern(), TimeZones.getTimeZone(\"Asia/Kolkata\"));\n             assertEquals(\"2009-10-16T12:12:16+05:30\", value, \"long\");\n         }\n         {\n-            final String value = DateFormatUtils.format(cal.getTimeInMillis(), DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.getPattern(), TimeZone.getTimeZone(\"Europe/London\"));\n+            final String value = DateFormatUtils.format(cal.getTimeInMillis(), DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.getPattern(), TimeZones.getTimeZone(\"Europe/London\"));\n             assertEquals(\"2009-10-16T07:42:16+01:00\", value, \"long\");\n         }\n \n         // Calendar.\n         {\n-            final String value = DateFormatUtils.format(cal, DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.getPattern(), TimeZone.getTimeZone(\"Europe/Paris\"));\n+            final String value = DateFormatUtils.format(cal, DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.getPattern(), TimeZones.getTimeZone(\"Europe/Paris\"));\n             assertEquals(\"2009-10-16T08:42:16+02:00\", value, \"calendar\");\n         }\n         {\n-            final String value = DateFormatUtils.format(cal, DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.getPattern(), TimeZone.getTimeZone(\"Asia/Kolkata\"));\n+            final String value = DateFormatUtils.format(cal, DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.getPattern(), TimeZones.getTimeZone(\"Asia/Kolkata\"));\n             assertEquals(\"2009-10-16T12:12:16+05:30\", value, \"calendar\");\n         }\n         {\n-            final String value = DateFormatUtils.format(cal, DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.getPattern(), TimeZone.getTimeZone(\"Europe/London\"));\n+            final String value = DateFormatUtils.format(cal, DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.getPattern(), TimeZones.getTimeZone(\"Europe/London\"));\n             assertEquals(\"2009-10-16T07:42:16+01:00\", value, \"calendar\");\n         }\n     }\n@@ -215,7 +215,7 @@ void testLang916() {\n     @DefaultLocale(language = \"en\")\n     @Test\n     void testSMTP() {\n-        TimeZone timeZone = TimeZone.getTimeZone(\"GMT-3\");\n+        TimeZone timeZone = TimeZones.getTimeZone(\"GMT-3\");\n         Calendar june = createJuneTestDate(timeZone);\n \n         assertFormats(\"Sun, 08 Jun 2003 10:11:12 -0300\", DateFormatUtils.SMTP_DATETIME_FORMAT.getPattern(),\ndiff --git a/src/test/java/org/apache/commons/lang3/time/DateUtilsTest.java b/src/test/java/org/apache/commons/lang3/time/DateUtilsTest.java\nindex 5dac357771b..d4f7b0f5d81 100644\n--- a/src/test/java/org/apache/commons/lang3/time/DateUtilsTest.java\n+++ b/src/test/java/org/apache/commons/lang3/time/DateUtilsTest.java\n@@ -66,9 +66,9 @@\n @WritesDefaultLocale\n class DateUtilsTest extends AbstractLangTest {\n \n-    private static final TimeZone TIME_ZONE_NY = TimeZone.getTimeZone(\"America/New_York\");\n+    private static final TimeZone TIME_ZONE_NY = TimeZones.getTimeZone(\"America/New_York\");\n     private static final TimeZone TIME_ZONE_DEFAULT = TimeZone.getDefault();\n-    private static final TimeZone TIME_ZONE_MET = TimeZone.getTimeZone(\"MET\");\n+    private static final TimeZone TIME_ZONE_MET = TimeZones.getTimeZone(\"MET\");\n     private static Date BASE_DATE;\n \n     /**\n@@ -209,7 +209,7 @@ private static Stream<Arguments> testToLocalDateTimeTimeZone() {\n                 Arguments.of(\n                         LocalDateTime.of(2023, 1, 1, 14, 0),\n                         Date.from(LocalDateTime.of(2023, 1, 1, 0, 0).atOffset(ZoneOffset.UTC).toInstant()),\n-                        TimeZone.getTimeZone(\"Pacific/Kiritimati\")\n+                        TimeZones.getTimeZone(\"Pacific/Kiritimati\")\n                 )\n         );\n         // @formatter:on\n@@ -763,8 +763,8 @@ void testIsSameDay_DateNullNull() {\n \n     @Test\n     void testIsSameInstant_Cal() {\n-        final GregorianCalendar cala = new GregorianCalendar(TimeZone.getTimeZone(\"GMT+1\"));\n-        final GregorianCalendar calb = new GregorianCalendar(TimeZone.getTimeZone(\"GMT-1\"));\n+        final GregorianCalendar cala = new GregorianCalendar(TimeZones.getTimeZone(\"GMT+1\"));\n+        final GregorianCalendar calb = new GregorianCalendar(TimeZones.getTimeZone(\"GMT-1\"));\n         cala.set(2004, Calendar.JULY, 9, 13, 45, 0);\n         cala.set(Calendar.MILLISECOND, 0);\n         calb.set(2004, Calendar.JULY, 9, 13, 45, 0);\n@@ -820,8 +820,8 @@ void testIsSameInstant_DateNullNull() {\n \n     @Test\n     void testIsSameLocalTime_Cal() {\n-        final GregorianCalendar cala = new GregorianCalendar(TimeZone.getTimeZone(\"GMT+1\"));\n-        final GregorianCalendar calb = new GregorianCalendar(TimeZone.getTimeZone(\"GMT-1\"));\n+        final GregorianCalendar cala = new GregorianCalendar(TimeZones.getTimeZone(\"GMT+1\"));\n+        final GregorianCalendar calb = new GregorianCalendar(TimeZones.getTimeZone(\"GMT-1\"));\n         cala.set(2004, Calendar.JULY, 9, 13, 45, 0);\n         cala.set(Calendar.MILLISECOND, 0);\n         calb.set(2004, Calendar.JULY, 9, 13, 45, 0);\n@@ -1577,7 +1577,7 @@ void testTruncate_Bugzilla_31395() throws Exception {\n     @Test\n     void testTruncateLang59() {\n         // Set TimeZone to Mountain Time\n-        final TimeZone denverZone = TimeZone.getTimeZone(\"America/Denver\");\n+        final TimeZone denverZone = TimeZones.getTimeZone(\"America/Denver\");\n         TimeZone.setDefault(denverZone);\n         final DateFormat format = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss.SSS XXX\");\n         format.setTimeZone(denverZone);\ndiff --git a/src/test/java/org/apache/commons/lang3/time/DurationFormatUtilsTest.java b/src/test/java/org/apache/commons/lang3/time/DurationFormatUtilsTest.java\nindex 378b0ec2d36..b19911e6a9b 100644\n--- a/src/test/java/org/apache/commons/lang3/time/DurationFormatUtilsTest.java\n+++ b/src/test/java/org/apache/commons/lang3/time/DurationFormatUtilsTest.java\n@@ -481,7 +481,7 @@ void testFormatPeriodeStartGreaterEnd() {\n     @SuppressWarnings(\"deprecation\")\n     @Test\n     void testFormatPeriodISO() {\n-        final TimeZone timeZone = TimeZone.getTimeZone(\"GMT-3\");\n+        final TimeZone timeZone = TimeZones.getTimeZone(\"GMT-3\");\n         final Calendar base = Calendar.getInstance(timeZone);\n         base.set(1970, Calendar.JANUARY, 1, 0, 0, 0);\n         base.set(Calendar.MILLISECOND, 0);\ndiff --git a/src/test/java/org/apache/commons/lang3/time/FastDateFormatTest.java b/src/test/java/org/apache/commons/lang3/time/FastDateFormatTest.java\nindex 864c7ff44b0..08558c4ae70 100644\n--- a/src/test/java/org/apache/commons/lang3/time/FastDateFormatTest.java\n+++ b/src/test/java/org/apache/commons/lang3/time/FastDateFormatTest.java\n@@ -157,12 +157,12 @@ void test_getInstance_String() {\n         final FastDateFormat format1 = FastDateFormat.getInstance(\"MM/DD/yyyy\");\n         final FastDateFormat format2 = FastDateFormat.getInstance(\"MM-DD-yyyy\");\n         final FastDateFormat format3 = FastDateFormat.getInstance(\"MM-DD-yyyy\");\n-\n         assertNotSame(format1, format2);\n         assertSame(format2, format3);\n         assertEquals(\"MM/DD/yyyy\", format1.getPattern());\n         assertEquals(TimeZone.getDefault(), format1.getTimeZone());\n         assertEquals(TimeZone.getDefault(), format2.getTimeZone());\n+        assertNotNull(FastDateFormat.getInstance(\"yyyy-MM-dd'T'HH:mm:ssZ\"));\n     }\n \n     @DefaultLocale(language = \"en\", country = \"US\")\n@@ -183,7 +183,7 @@ void test_getInstance_String_Locale() {\n     void test_getInstance_String_TimeZone() {\n \n         final FastDateFormat format1 = FastDateFormat.getInstance(\"MM/DD/yyyy\",\n-                TimeZone.getTimeZone(\"Atlantic/Reykjavik\"));\n+                TimeZones.getTimeZone(\"Atlantic/Reykjavik\"));\n         final FastDateFormat format2 = FastDateFormat.getInstance(\"MM/DD/yyyy\");\n         final FastDateFormat format3 = FastDateFormat.getInstance(\"MM/DD/yyyy\", TimeZone.getDefault());\n         final FastDateFormat format4 = FastDateFormat.getInstance(\"MM/DD/yyyy\", TimeZone.getDefault());\n@@ -191,7 +191,7 @@ void test_getInstance_String_TimeZone() {\n         final FastDateFormat format6 = FastDateFormat.getInstance(\"MM-DD-yyyy\");\n \n         assertNotSame(format1, format2);\n-        assertEquals(TimeZone.getTimeZone(\"Atlantic/Reykjavik\"), format1.getTimeZone());\n+        assertEquals(TimeZones.getTimeZone(\"Atlantic/Reykjavik\"), format1.getTimeZone());\n         assertEquals(TimeZone.getDefault(), format2.getTimeZone());\n         assertSame(format3, format4);\n         assertNotSame(format3, format5);\n@@ -203,13 +203,13 @@ void test_getInstance_String_TimeZone() {\n     @Test\n     void test_getInstance_String_TimeZone_Locale() {\n         final FastDateFormat format1 = FastDateFormat.getInstance(\"MM/DD/yyyy\",\n-                TimeZone.getTimeZone(\"Atlantic/Reykjavik\"), Locale.GERMANY);\n+                TimeZones.getTimeZone(\"Atlantic/Reykjavik\"), Locale.GERMANY);\n         final FastDateFormat format2 = FastDateFormat.getInstance(\"MM/DD/yyyy\", Locale.GERMANY);\n         final FastDateFormat format3 = FastDateFormat.getInstance(\"MM/DD/yyyy\",\n                 TimeZone.getDefault(), Locale.GERMANY);\n \n         assertNotSame(format1, format2);\n-        assertEquals(TimeZone.getTimeZone(\"Atlantic/Reykjavik\"), format1.getTimeZone());\n+        assertEquals(TimeZones.getTimeZone(\"Atlantic/Reykjavik\"), format1.getTimeZone());\n         assertEquals(TimeZone.getDefault(), format2.getTimeZone());\n         assertEquals(TimeZone.getDefault(), format3.getTimeZone());\n         assertEquals(Locale.GERMANY, format1.getLocale());\n@@ -250,8 +250,8 @@ void testDateDefaults() {\n         assertEquals(FastDateFormat.getDateInstance(FastDateFormat.LONG, Locale.CANADA),\n                 FastDateFormat.getDateInstance(FastDateFormat.LONG, TimeZone.getDefault(), Locale.CANADA));\n \n-        assertEquals(FastDateFormat.getDateInstance(FastDateFormat.LONG, TimeZone.getTimeZone(\"America/New_York\")),\n-                FastDateFormat.getDateInstance(FastDateFormat.LONG, TimeZone.getTimeZone(\"America/New_York\"), Locale.getDefault()));\n+        assertEquals(FastDateFormat.getDateInstance(FastDateFormat.LONG, TimeZones.getTimeZone(\"America/New_York\")),\n+                FastDateFormat.getDateInstance(FastDateFormat.LONG, TimeZones.getTimeZone(\"America/New_York\"), Locale.getDefault()));\n \n         assertEquals(FastDateFormat.getDateInstance(FastDateFormat.LONG),\n                 FastDateFormat.getDateInstance(FastDateFormat.LONG, TimeZone.getDefault(), Locale.getDefault()));\n@@ -283,8 +283,8 @@ void testLang1641() {\n         assertSame(FastDateFormat.getInstance(ISO_8601_DATE_FORMAT, TimeZone.getDefault()),\n                 FastDateFormat.getInstance(ISO_8601_DATE_FORMAT, TimeZone.getDefault()));\n         // TimeZones that are identical in every way except ID\n-        assertNotSame(FastDateFormat.getInstance(ISO_8601_DATE_FORMAT, TimeZone.getTimeZone(\"Australia/Broken_Hill\")),\n-                FastDateFormat.getInstance(ISO_8601_DATE_FORMAT, TimeZone.getTimeZone(\"Australia/Yancowinna\")));\n+        assertNotSame(FastDateFormat.getInstance(ISO_8601_DATE_FORMAT, TimeZones.getTimeZone(\"Australia/Broken_Hill\")),\n+                FastDateFormat.getInstance(ISO_8601_DATE_FORMAT, TimeZones.getTimeZone(\"Australia/Yancowinna\")));\n     }\n \n     /**\n@@ -398,8 +398,8 @@ void testTimeDateDefaults() {\n         assertEquals(FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, Locale.CANADA),\n                 FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getDefault(), Locale.CANADA));\n \n-        assertEquals(FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getTimeZone(\"America/New_York\")),\n-                FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getTimeZone(\"America/New_York\"), Locale.getDefault()));\n+        assertEquals(FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZones.getTimeZone(\"America/New_York\")),\n+                FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZones.getTimeZone(\"America/New_York\"), Locale.getDefault()));\n \n         assertEquals(FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM),\n                 FastDateFormat.getDateTimeInstance(FastDateFormat.LONG, FastDateFormat.MEDIUM, TimeZone.getDefault(), Locale.getDefault()));\n@@ -410,8 +410,8 @@ void testTimeDefaults() {\n         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG, Locale.CANADA),\n                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getDefault(), Locale.CANADA));\n \n-        assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getTimeZone(\"America/New_York\")),\n-                FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getTimeZone(\"America/New_York\"), Locale.getDefault()));\n+        assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZones.getTimeZone(\"America/New_York\")),\n+                FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZones.getTimeZone(\"America/New_York\"), Locale.getDefault()));\n \n         assertEquals(FastDateFormat.getTimeInstance(FastDateFormat.LONG),\n                 FastDateFormat.getTimeInstance(FastDateFormat.LONG, TimeZone.getDefault(), Locale.getDefault()));\ndiff --git a/src/test/java/org/apache/commons/lang3/time/FastDateParserTest.java b/src/test/java/org/apache/commons/lang3/time/FastDateParserTest.java\nindex 3369ff38287..3c6ecf0116f 100644\n--- a/src/test/java/org/apache/commons/lang3/time/FastDateParserTest.java\n+++ b/src/test/java/org/apache/commons/lang3/time/FastDateParserTest.java\n@@ -103,9 +103,9 @@ private enum Expected1806 {\n     private static final String MDY_DASH = \"MM-DD-yyyy\";\n     private static final String MDY_SLASH = \"MM/DD/yyyy\";\n \n-    private static final TimeZone REYKJAVIK = TimeZone.getTimeZone(\"Atlantic/Reykjavik\");\n-    private static final TimeZone NEW_YORK = TimeZone.getTimeZone(\"America/New_York\");\n-    private static final TimeZone INDIA = TimeZone.getTimeZone(\"Asia/Calcutta\");\n+    private static final TimeZone REYKJAVIK = TimeZones.getTimeZone(\"Atlantic/Reykjavik\");\n+    private static final TimeZone NEW_YORK = TimeZones.getTimeZone(\"America/New_York\");\n+    private static final TimeZone INDIA = TimeZones.getTimeZone(\"Asia/Calcutta\");\n \n     private static final Locale SWEDEN = new Locale(\"sv\", \"SE\");\n \n@@ -383,7 +383,7 @@ void testLANG_832(final TriFunction<String, TimeZone, Locale, DateParser> dpProv\n     @ParameterizedTest\n     @MethodSource(DATE_PARSER_PARAMETERS)\n     void testLang1121(final TriFunction<String, TimeZone, Locale, DateParser> dpProvider) throws ParseException {\n-        final TimeZone kst = TimeZone.getTimeZone(\"KST\");\n+        final TimeZone kst = TimeZones.getTimeZone(\"KST\");\n         final DateParser fdp = getInstance(dpProvider, \"yyyyMMdd\", kst, Locale.KOREA);\n \n         assertThrows(ParseException.class, () -> fdp.parse(\"2015\"));\n@@ -434,7 +434,7 @@ void testLang303() throws ParseException {\n     void testLang538() throws ParseException {\n         final DateParser parser = getInstance(\"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\", TimeZones.GMT);\n \n-        final Calendar cal = Calendar.getInstance(TimeZone.getTimeZone(\"GMT-8\"));\n+        final Calendar cal = Calendar.getInstance(TimeZones.getTimeZone(\"GMT-8\"));\n         cal.clear();\n         cal.set(2009, Calendar.OCTOBER, 16, 8, 42, 16);\n \n@@ -591,12 +591,12 @@ void testParseZone(final TriFunction<String, TimeZone, Locale, DateParser> dpPro\n         assertEquals(cal.getTime(), fdf.parse(\"2003-07-10T16:33:20.000 Eastern Daylight Time\"));\n         assertEquals(cal.getTime(), fdf.parse(\"2003-07-10T16:33:20.000 EDT\"));\n \n-        cal.setTimeZone(TimeZone.getTimeZone(\"GMT-3\"));\n+        cal.setTimeZone(TimeZones.getTimeZone(\"GMT-3\"));\n         cal.set(2003, Calendar.FEBRUARY, 10, 9, 0, 0);\n \n         assertEquals(cal.getTime(), fdf.parse(\"2003-02-10T09:00:00.000 -0300\"));\n \n-        cal.setTimeZone(TimeZone.getTimeZone(\"GMT+5\"));\n+        cal.setTimeZone(TimeZones.getTimeZone(\"GMT+5\"));\n         cal.set(2003, Calendar.FEBRUARY, 10, 15, 5, 6);\n \n         assertEquals(cal.getTime(), fdf.parse(\"2003-02-10T15:05:06.000 +0500\"));\ndiff --git a/src/test/java/org/apache/commons/lang3/time/FastDateParser_MoreOrLessTest.java b/src/test/java/org/apache/commons/lang3/time/FastDateParser_MoreOrLessTest.java\nindex 79e31aa9657..77eae646a16 100644\n--- a/src/test/java/org/apache/commons/lang3/time/FastDateParser_MoreOrLessTest.java\n+++ b/src/test/java/org/apache/commons/lang3/time/FastDateParser_MoreOrLessTest.java\n@@ -31,7 +31,7 @@\n \n class FastDateParser_MoreOrLessTest extends AbstractLangTest {\n \n-    private static final TimeZone NEW_YORK = TimeZone.getTimeZone(\"America/New_York\");\n+    private static final TimeZone NEW_YORK = TimeZones.getTimeZone(\"America/New_York\");\n \n     @Test\n     void testInputHasLessCharacters() {\ndiff --git a/src/test/java/org/apache/commons/lang3/time/FastDateParser_TimeZoneStrategyTest.java b/src/test/java/org/apache/commons/lang3/time/FastDateParser_TimeZoneStrategyTest.java\nindex 8a4a137acae..99c3feaebf3 100644\n--- a/src/test/java/org/apache/commons/lang3/time/FastDateParser_TimeZoneStrategyTest.java\n+++ b/src/test/java/org/apache/commons/lang3/time/FastDateParser_TimeZoneStrategyTest.java\n@@ -141,7 +141,7 @@ void testTimeZoneStrategy_TimeZone(final Locale locale) {\n \n     private void testTimeZoneStrategyPattern(final String languageTag, final String source) throws ParseException {\n         final Locale locale = Locale.forLanguageTag(languageTag);\n-        final TimeZone timeZone = TimeZone.getTimeZone(\"Etc/UTC\");\n+        final TimeZone timeZone = TimeZones.getTimeZone(\"Etc/UTC\");\n         assumeFalse(LocaleUtils.isLanguageUndetermined(locale), () -> toFailureMessage(locale, languageTag, timeZone));\n         assumeTrue(LocaleUtils.isAvailableLocale(locale), () -> toFailureMessage(locale, languageTag, timeZone));\n         final FastDateParser parser = new FastDateParser(\"z\", timeZone, locale);\n@@ -217,7 +217,7 @@ private void testTimeZoneStrategyPattern_TimeZone_getAvailableIDs(final Locale l\n         assumeFalse(LocaleUtils.isLanguageUndetermined(locale), () -> toFailureMessage(locale, null, null));\n         assumeTrue(LocaleUtils.isAvailableLocale(locale), () -> toFailureMessage(locale, null, null));\n         for (final String id : ArraySorter.sort(TimeZone.getAvailableIDs())) {\n-            final TimeZone timeZone = TimeZone.getTimeZone(id);\n+            final TimeZone timeZone = TimeZones.getTimeZone(id);\n             final String displayName = timeZone.getDisplayName(locale);\n             final FastDateParser parser = new FastDateParser(\"z\", timeZone, locale);\n             try {\ndiff --git a/src/test/java/org/apache/commons/lang3/time/FastDatePrinterTest.java b/src/test/java/org/apache/commons/lang3/time/FastDatePrinterTest.java\nindex cb8c9deca01..2f25f26b439 100644\n--- a/src/test/java/org/apache/commons/lang3/time/FastDatePrinterTest.java\n+++ b/src/test/java/org/apache/commons/lang3/time/FastDatePrinterTest.java\n@@ -59,8 +59,8 @@ private enum Expected1806 {\n     }\n \n     private static final String YYYY_MM_DD = \"yyyy/MM/dd\";\n-    private static final TimeZone NEW_YORK = TimeZone.getTimeZone(\"America/New_York\");\n-    private static final TimeZone INDIA = TimeZone.getTimeZone(\"Asia/Calcutta\");\n+    private static final TimeZone NEW_YORK = TimeZones.getTimeZone(\"America/New_York\");\n+    private static final TimeZone INDIA = TimeZones.getTimeZone(\"Asia/Calcutta\");\n \n     private static final Locale SWEDEN = new Locale(\"sv\", \"SE\");\n \n@@ -259,7 +259,7 @@ void testLang303() {\n     void testLang538() {\n         // more commonly constructed with: cal = new GregorianCalendar(2009, 9, 16, 8, 42, 16)\n         // for the unit test to work in any time zone, constructing with GMT-8 rather than default locale time zone\n-        final GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone(\"GMT-8\"));\n+        final GregorianCalendar cal = new GregorianCalendar(TimeZones.getTimeZone(\"GMT-8\"));\n         cal.clear();\n         cal.set(2009, Calendar.OCTOBER, 16, 8, 42, 16);\n \n@@ -289,21 +289,21 @@ void testLang645() {\n     @Test\n     void testLang916() {\n \n-        final Calendar cal = Calendar.getInstance(TimeZone.getTimeZone(\"Europe/Paris\"));\n+        final Calendar cal = Calendar.getInstance(TimeZones.getTimeZone(\"Europe/Paris\"));\n         cal.clear();\n         cal.set(2009, 9, 16, 8, 42, 16);\n \n         // calendar fast.\n         {\n-            final String value = FastDateFormat.getInstance(\"yyyy-MM-dd'T'HH:mm:ss Z\", TimeZone.getTimeZone(\"Europe/Paris\")).format(cal);\n+            final String value = FastDateFormat.getInstance(\"yyyy-MM-dd'T'HH:mm:ss Z\", TimeZones.getTimeZone(\"Europe/Paris\")).format(cal);\n             assertEquals(\"2009-10-16T08:42:16 +0200\", value, \"calendar\");\n         }\n         {\n-            final String value = FastDateFormat.getInstance(\"yyyy-MM-dd'T'HH:mm:ss Z\", TimeZone.getTimeZone(\"Asia/Kolkata\")).format(cal);\n+            final String value = FastDateFormat.getInstance(\"yyyy-MM-dd'T'HH:mm:ss Z\", TimeZones.getTimeZone(\"Asia/Kolkata\")).format(cal);\n             assertEquals(\"2009-10-16T12:12:16 +0530\", value, \"calendar\");\n         }\n         {\n-            final String value = FastDateFormat.getInstance(\"yyyy-MM-dd'T'HH:mm:ss Z\", TimeZone.getTimeZone(\"Europe/London\")).format(cal);\n+            final String value = FastDateFormat.getInstance(\"yyyy-MM-dd'T'HH:mm:ss Z\", TimeZones.getTimeZone(\"Europe/London\")).format(cal);\n             assertEquals(\"2009-10-16T07:42:16 +0100\", value, \"calendar\");\n         }\n     }\ndiff --git a/src/test/java/org/apache/commons/lang3/time/FastDatePrinterTimeZonesTest.java b/src/test/java/org/apache/commons/lang3/time/FastDatePrinterTimeZonesTest.java\nindex fd046d053f1..c09726e9636 100644\n--- a/src/test/java/org/apache/commons/lang3/time/FastDatePrinterTimeZonesTest.java\n+++ b/src/test/java/org/apache/commons/lang3/time/FastDatePrinterTimeZonesTest.java\n@@ -32,7 +32,7 @@ class FastDatePrinterTimeZonesTest extends AbstractLangTest {\n     private static final String PATTERN = \"h:mma z\";\n \n     public static Stream<TimeZone> data() {\n-        return Stream.of(TimeZone.getAvailableIDs()).map(TimeZone::getTimeZone);\n+        return Stream.of(TimeZone.getAvailableIDs()).map(TimeZones::getTimeZone);\n     }\n \n     @ParameterizedTest\ndiff --git a/src/test/java/org/apache/commons/lang3/time/FastTimeZoneTest.java b/src/test/java/org/apache/commons/lang3/time/FastTimeZoneTest.java\nindex 08a883506b1..6135cebfaa6 100644\n--- a/src/test/java/org/apache/commons/lang3/time/FastTimeZoneTest.java\n+++ b/src/test/java/org/apache/commons/lang3/time/FastTimeZoneTest.java\n@@ -18,8 +18,6 @@\n \n import static org.junit.jupiter.api.Assertions.assertEquals;\n \n-import java.util.TimeZone;\n-\n import org.apache.commons.lang3.AbstractLangTest;\n import org.junit.jupiter.api.Test;\n \n@@ -71,7 +69,7 @@ void testHoursMinutes() {\n \n     @Test\n     void testOlson() {\n-        assertEquals(TimeZone.getTimeZone(\"America/New_York\"), FastTimeZone.getTimeZone(\"America/New_York\"));\n+        assertEquals(TimeZones.getTimeZone(\"America/New_York\"), FastTimeZone.getTimeZone(\"America/New_York\"));\n     }\n \n     @Test\n",
  "problem_statement" : "[LANG-1786] Map deprecated TimeZone short IDs and avoid JRE WARNINGs to the console\n\n[[LANG-1786] A lot of warnings on the console when using FastDateFormat\r\nwith JDK25](https://issues.apache.org/jira/browse/LANG-1786)\r\n\r\nAdd and use `TimeZones.getTimeZone(String)` as a way to avoid writing to the console on Java 25:\r\n```java\r\n    /**\r\n     * Delegates to {@link TimeZone#getTimeZone(String)} after mapping an ID if it's in {@link ZoneId#SHORT_IDS}.\r\n     * <p>\r\n     * On Java 25, calling {@link TimeZone#getTimeZone(String)} with an ID in {@link ZoneId#SHORT_IDS} writes a message to {@link System#err} in the form:\r\n     * </p>\r\n     *\r\n     * <pre>\r\n     * WARNING: Use of the three-letter time zone ID \"the-short-id\" is deprecated and it will be removed in a future release\r\n     * </pre>\r\n     * <p>\r\n     * You can disable mapping from {@link ZoneId#SHORT_IDS} by setting the system property {@code \"TimeZones.mapShortIDs=false\"}.\r\n     * </p>\r\n     *\r\n     * @param id Same as {@link TimeZone#getTimeZone(String)}.\r\n     * @return Same as {@link TimeZone#getTimeZone(String)}.\r\n     * @since 3.20.0\r\n     */\r\n    public static TimeZone getTimeZone(final String id) {\r\n        return TimeZone.getTimeZone(mapShortIDs() ? ZoneId.SHORT_IDS.getOrDefault(id, id) : id);\r\n    }\r\n```\r\n\r\nBefore you push a pull request, review this list:\r\n\r\n- [x] Read the [contribution guidelines](CONTRIBUTING.md) for this project.\r\n- [x] Read the [ASF Generative Tooling Guidance](https://www.apache.org/legal/generative-tooling.html) if you use Artificial Intelligence (AI).\r\n- [ ] I used AI to create any part of, or all of, this pull request.\r\n- [x] Run a successful build using the default [Maven](https://maven.apache.org/) goal with `mvn`; that's `mvn` on the command line by itself.\r\n- [x] Write unit tests that match behavioral changes, where the tests fail if the changes to the runtime are not applied. This may not always be possible, but it is a best practice.\r\n- [x] Write a pull request description that is detailed enough to understand what the pull request does, how, and why.\r\n- [x] Each commit in the pull request should have a meaningful subject line and body. Note that a maintainer may squash commits during the merge process.\r\n\r\n",
  "hints_text" : null,
  "created_at" : "Fri Nov 07 15:55:43 CET 2025",
  "version" : null,
  "FAIL_TO_PASS" : [ "CalendarUtilsTest", "FastDateParser_MoreOrLessTest", "DateFormatUtilsTest", "FastDatePrinterTest", "FastDateParser_TimeZoneStrategyTest", "FastDateFormatTest", "FastDatePrinterTimeZonesTest", "DateUtilsTest", "FastTimeZoneTest", "FastDateParserTest", "DurationFormatUtilsTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=CalendarUtilsTest,FastDateParser_MoreOrLessTest,DateFormatUtilsTest,FastDatePrinterTest,FastDateParser_TimeZoneStrategyTest,FastDateFormatTest,FastDatePrinterTimeZonesTest,DateUtilsTest,FastTimeZoneTest,FastDateParserTest,DurationFormatUtilsTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 1483,
  "metadata" : null
} ]