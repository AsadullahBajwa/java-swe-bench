diff --git a/src/main/java/org/apache/commons/collections4/bloomfilter/BitCountProducer.java b/src/main/java/org/apache/commons/collections4/bloomfilter/BitCountProducer.java
index aea07b36e7..e32313c7c2 100644
--- a/src/main/java/org/apache/commons/collections4/bloomfilter/BitCountProducer.java
+++ b/src/main/java/org/apache/commons/collections4/bloomfilter/BitCountProducer.java
@@ -18,8 +18,32 @@
 
 import java.util.function.IntPredicate;
 
-/**
- * Produces bit counts for counting type Bloom filters.
+/*
+ * Defines a mapping of index to counts.
+ *
+ * <p>Note that a BitCountProducer may return duplicate indices and may be unordered.
+ *
+ * <p>Implementations must guarantee that:
+ *
+ * <ul>
+ * <li>The mapping of index to counts is the combined sum of counts at each index.
+ * <li>For every unique value produced by the IndexProducer there will be at least one matching
+ * index and count produced by the BitCountProducer.
+ * <li>The BitCountProducer will not generate indices that are not output by the IndexProducer.
+ * </ul>
+ *
+ * <p>Note that implementations that do not output duplicate indices for BitCountProducer and
+ * do for IndexProducer, or vice versa, are consistent if the distinct indices from each are
+ * the same.
+ *
+ * <p>For example the mapping [(1,2),(2,3),(3,1)] can be output with many combinations including:
+ * <pre>
+ * [(1,2),(2,3),(3,1)]
+ * [(1,1),(1,1),(2,1),(2,1),(2,1),(3,1)]
+ * [(1,1),(3,1),(1,1),(2,1),(2,1),(2,1)]
+ * [(3,1),(1,1),(2,2),(1,1),(2,1)]
+ * ...
+ * </pre>
  *
  * @since 4.5
  */
@@ -32,14 +56,18 @@ public interface BitCountProducer extends IndexProducer {
      * index-count pair, if the consumer returns {@code false} the execution is stopped, {@code false}
      * is returned, and no further pairs are processed.
      *
-     * <p>Must only process each index once, and must process indexes in order.</p>
+     * Duplicate indices are not required to be aggregated. Duplicates may be output by the producer as
+     * noted in the class javadoc.
      *
      * @param consumer the action to be performed for each non-zero bit count
      * @return {@code true} if all count pairs return true from consumer, {@code false} otherwise.
-     * @throws NullPointerException if the specified action is null
+     * @throws NullPointerException if the specified consumer is null
      */
     boolean forEachCount(BitCountConsumer consumer);
 
+    /**
+     * The default implementation returns indices with ordering and uniqueness of {@code forEachCount()}.
+     */
     @Override
     default boolean forEachIndex(IntPredicate predicate) {
         return forEachCount((i, v) -> predicate.test(i));
@@ -47,7 +75,13 @@ default boolean forEachIndex(IntPredicate predicate) {
 
     /**
      * Creates a BitCountProducer from an IndexProducer.  The resulting
-     * producer will count each enabled bit once.
+     * producer will return every index from the IndexProducer with a count of 1.
+     *
+     * <p>Note that the BitCountProducer does not remove duplicates. Any use of the
+     * BitCountProducer to create an aggregate mapping of index to counts, such as a
+     * CountingBloomFilter, should use the same BitCountProducer in both add and
+     * subtract operations to maintain consistency.
+     * </p>
      * @param idx An index producer.
      * @return A BitCountProducer with the same indices as the IndexProducer.
      */
@@ -57,12 +91,22 @@ static BitCountProducer from(IndexProducer idx) {
             public boolean forEachCount(BitCountConsumer consumer) {
                 return idx.forEachIndex(i -> consumer.test(i, 1));
             }
+
+            @Override
+            public int[] asIndexArray() {
+                return idx.asIndexArray();
+            }
+
+            @Override
+            public boolean forEachIndex(IntPredicate predicate) {
+                return idx.forEachIndex(predicate);
+            }
         };
     }
 
     /**
      * Represents an operation that accepts an {@code <index, count>} pair representing
-     * the count for a bit index in a Bit Count Producer Bloom filter and returns {@code true}
+     * the count for a bit index. Returns {@code true}
      * if processing should continue, {@code false} otherwise.
      *
      * <p>Note: This is a functional interface as a specialization of
@@ -71,7 +115,7 @@ public boolean forEachCount(BitCountConsumer consumer) {
     @FunctionalInterface
     interface BitCountConsumer {
         /**
-         * Performs this operation on the given {@code <index, count>} pair.
+         * Performs an operation on the given {@code <index, count>} pair.
          *
          * @param index the bit index.
          * @param count the count at the specified bit index.
diff --git a/src/main/java/org/apache/commons/collections4/bloomfilter/Hasher.java b/src/main/java/org/apache/commons/collections4/bloomfilter/Hasher.java
index 82445a623d..573532e12e 100644
--- a/src/main/java/org/apache/commons/collections4/bloomfilter/Hasher.java
+++ b/src/main/java/org/apache/commons/collections4/bloomfilter/Hasher.java
@@ -49,7 +49,8 @@ public interface Hasher {
      * Creates an IndexProducer of unique indices for this hasher based on the Shape.
      *
      * <p>This is like the `indices(Shape)` method except that it adds the guarantee that no
-     * duplicate values will be returned</p>
+     * duplicate values will be returned.  The indices produced are equivalent to those returned
+     * from by a Bloom filter created from this hasher.</p>
      *
      * @param shape the shape of the desired Bloom filter.
      * @return the iterator of integers
diff --git a/src/main/java/org/apache/commons/collections4/bloomfilter/HasherCollection.java b/src/main/java/org/apache/commons/collections4/bloomfilter/HasherCollection.java
index 8483dfc300..56652ecbf7 100644
--- a/src/main/java/org/apache/commons/collections4/bloomfilter/HasherCollection.java
+++ b/src/main/java/org/apache/commons/collections4/bloomfilter/HasherCollection.java
@@ -90,6 +90,20 @@ public IndexProducer indices(final Shape shape) {
         return new HasherCollectionIndexProducer(shape);
     }
 
+    /**
+     * Creates an IndexProducer comprising the unique indices from each of the contained
+     * hashers.
+     *
+     * <p>This method may return duplicates if the collection of unique values from each of the contained
+     * hashers contain duplicates.  This is equivalent to creating Bloom filters for each contained hasher
+     * and returning an IndexProducer with the concatenated output indices from each filter.</p>
+     *
+     * <p>A BitCountProducer generated from this IndexProducer is equivalent to a BitCountProducer from a
+     * counting Bloom filter that was constructed from the contained hashers unique indices.<p>
+     *
+     * @param shape the shape of the desired Bloom filter.
+     * @return the iterator of integers
+     */
     @Override
     public IndexProducer uniqueIndices(final Shape shape) {
         Objects.requireNonNull(shape, "shape");
@@ -106,6 +120,27 @@ public boolean forEachIndex(IntPredicate consumer) {
         };
     }
 
+    /**
+     * Creates an IndexProducer comprising the unique indices across all the contained
+     * hashers.
+     *
+     * <p>This is equivalent to an IndexProducer created from a Bloom filter that comprises all
+     * the contained hashers.</p>
+     *
+     * @param shape the shape of the desired Bloom filter.
+     * @return the iterator of integers
+     */
+    public IndexProducer absoluteUniqueIndices(final Shape shape) {
+        int kCount = hashers.size() > 0 ? hashers.size() : 1;
+        return consumer -> {
+            Objects.requireNonNull(consumer, "consumer");
+            // shape must handle maximum unique indices
+            return uniqueIndices(shape).forEachIndex(IndexFilter.create(
+                    Shape.fromKM(shape.getNumberOfHashFunctions() * kCount,
+                                 shape.getNumberOfBits()), consumer));
+        };
+    }
+
     /**
      * Allow child classes access to the hashers.
      * @return hashers
@@ -141,29 +176,16 @@ public boolean forEachIndex(IntPredicate consumer) {
 
         @Override
         public int[] asIndexArray() {
-            List<int[]> lst = new ArrayList<>();
-            int[] count = new int[1];
-            /*
-             * This method needs to return duplicate indices
-             */
-            for (Hasher hasher : hashers) {
-                int[] ary = hasher.indices(shape).asIndexArray();
-                lst.add(ary);
-                count[0] += ary.length;
-            }
-            if (lst.isEmpty()) {
-                return new int[0];
-            }
-            if (lst.size() == 1) {
-                return lst.get(0);
-            }
-            int[] result = new int[count[0]];
-            int offset = 0;
-            for (int[] ary : lst) {
-                System.arraycopy(ary, 0, result, offset, ary.length);
-                offset += ary.length;
-            }
-            return result;
+            int[] result = new int[shape.getNumberOfHashFunctions() * hashers.size()];
+            int[] idx = new int[1];
+
+            // This method needs to return duplicate indices
+
+            forEachIndex(i -> {
+                result[idx[0]++] = i;
+                return true;
+            });
+            return Arrays.copyOf(result, idx[0]);
         }
     }
 }
diff --git a/src/main/java/org/apache/commons/collections4/bloomfilter/IndexFilter.java b/src/main/java/org/apache/commons/collections4/bloomfilter/IndexFilter.java
index 991d4d98f3..82e1103452 100644
--- a/src/main/java/org/apache/commons/collections4/bloomfilter/IndexFilter.java
+++ b/src/main/java/org/apache/commons/collections4/bloomfilter/IndexFilter.java
@@ -23,7 +23,7 @@
  *
  * <p><em>If the index is negative the behavior is not defined.</em></p>
  *
- * <p>This is conceptually a unique filter implemented as a {@code IntPredicate}.</p>
+ * <p>This is conceptually a unique filter implemented as an {@code IntPredicate}.</p>
  * @since 4.5
  */
 public final class IndexFilter {
diff --git a/src/main/java/org/apache/commons/collections4/bloomfilter/IndexProducer.java b/src/main/java/org/apache/commons/collections4/bloomfilter/IndexProducer.java
index 5789285bf8..11cb3dd8d3 100644
--- a/src/main/java/org/apache/commons/collections4/bloomfilter/IndexProducer.java
+++ b/src/main/java/org/apache/commons/collections4/bloomfilter/IndexProducer.java
@@ -64,6 +64,11 @@ public boolean forEachIndex(IntPredicate predicate) {
                 }
                 return true;
             }
+
+            @Override
+            public int[] asIndexArray() {
+                return values.clone();
+            }
         };
     }
 
@@ -110,6 +115,10 @@ public boolean test(long word) {
      * The default implementation of this method is slow.  It is recommended
      * that implementing classes reimplement this method.
      * </em></p>
+     *
+     * <p><em>
+     * The default implementation of this method returns unique values in order.
+     * </em></p>
      * @return An int array of the data.
      */
     default int[] asIndexArray() {
