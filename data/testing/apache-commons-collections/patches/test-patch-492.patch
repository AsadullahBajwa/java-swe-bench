diff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBitMapProducerTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBitMapExtractorTest.java
similarity index 59%
rename from src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBitMapProducerTest.java
rename to src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBitMapExtractorTest.java
index ed47f1ec08..0a631158f0 100644
--- a/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBitMapProducerTest.java
+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBitMapExtractorTest.java
@@ -25,7 +25,7 @@
 
 import org.junit.jupiter.api.Test;
 
-public abstract class AbstractBitMapProducerTest {
+public abstract class AbstractBitMapExtractorTest {
 
     /**
      * A testing consumer that always returns false.
@@ -38,16 +38,16 @@ public abstract class AbstractBitMapProducerTest {
     static final LongPredicate TRUE_CONSUMER = arg0 -> true;
 
     /**
-     * Creates an producer without data.
-     * @return a producer that has no data.
+     * Creates a BitMapExtractor without data.
+     * @return a BitMap extractor that has no data.
      */
-    protected abstract BitMapProducer createEmptyProducer();
+    protected abstract BitMapExtractor createEmptyExtractor();
 
     /**
-     * Creates a producer with some data.
-     * @return a producer with some data
+     * Creates a BitMapExtractor with some data.
+     * @return a BitMap extractor with some data
      */
-    protected abstract BitMapProducer createProducer();
+    protected abstract BitMapExtractor createExtractor();
 
     protected boolean emptyIsZeroLength() {
         return false;
@@ -55,32 +55,32 @@ protected boolean emptyIsZeroLength() {
 
     @Test
     public final void testAsBitMapArray() {
-        long[] array = createEmptyProducer().asBitMapArray();
+        long[] array = createEmptyExtractor().asBitMapArray();
         for (int i = 0; i < array.length; i++) {
             assertEquals(0, array[i], "Wrong value at " + i);
         }
 
-        array = createProducer().asBitMapArray();
+        array = createExtractor().asBitMapArray();
         assertFalse(array.length == 0);
     }
 
     @Test
     public final void testForEachBitMap() {
-        assertFalse(createProducer().forEachBitMap(FALSE_CONSUMER), "non-empty should be false");
+        assertFalse(createExtractor().processBitMaps(FALSE_CONSUMER), "non-empty should be false");
         if (emptyIsZeroLength()) {
-            assertTrue(createEmptyProducer().forEachBitMap(FALSE_CONSUMER), "empty should be true");
+            assertTrue(createEmptyExtractor().processBitMaps(FALSE_CONSUMER), "empty should be true");
         } else {
-            assertFalse(createEmptyProducer().forEachBitMap(FALSE_CONSUMER), "empty should be false");
+            assertFalse(createEmptyExtractor().processBitMaps(FALSE_CONSUMER), "empty should be false");
         }
 
-        assertTrue(createProducer().forEachBitMap(TRUE_CONSUMER), "non-empty should be true");
-        assertTrue(createEmptyProducer().forEachBitMap(TRUE_CONSUMER), "empty should be true");
+        assertTrue(createExtractor().processBitMaps(TRUE_CONSUMER), "non-empty should be true");
+        assertTrue(createEmptyExtractor().processBitMaps(TRUE_CONSUMER), "empty should be true");
     }
 
     @Test
     public void testForEachBitMapEarlyExit() {
         final int[] passes = new int[1];
-        assertFalse(createProducer().forEachBitMap(l -> {
+        assertFalse(createExtractor().processBitMaps(l -> {
             passes[0]++;
             return false;
         }));
@@ -88,13 +88,13 @@ public void testForEachBitMapEarlyExit() {
 
         passes[0] = 0;
         if (emptyIsZeroLength()) {
-            assertTrue(createEmptyProducer().forEachBitMap(l -> {
+            assertTrue(createEmptyExtractor().processBitMaps(l -> {
                 passes[0]++;
                 return false;
             }));
             assertEquals(0, passes[0]);
         } else {
-            assertFalse(createEmptyProducer().forEachBitMap(l -> {
+            assertFalse(createEmptyExtractor().processBitMaps(l -> {
                 passes[0]++;
                 return false;
             }));
@@ -105,12 +105,12 @@ public void testForEachBitMapEarlyExit() {
     @Test
     public final void testForEachBitMapPair() {
         final LongBiPredicate func = (x, y) -> x == y;
-        assertTrue(createEmptyProducer().forEachBitMapPair(createEmptyProducer(), func), "empty == empty failed");
-        assertFalse(createEmptyProducer().forEachBitMapPair(createProducer(), func), "empty == not_empty failed");
-        assertFalse(createProducer().forEachBitMapPair(createEmptyProducer(), func), "not_empty == empty passed");
-        assertTrue(createProducer().forEachBitMapPair(createProducer(), func), "not_empty == not_empty failed");
+        assertTrue(createEmptyExtractor().processBitMapPairs(createEmptyExtractor(), func), "empty == empty failed");
+        assertFalse(createEmptyExtractor().processBitMapPairs(createExtractor(), func), "empty == not_empty failed");
+        assertFalse(createExtractor().processBitMapPairs(createEmptyExtractor(), func), "not_empty == empty passed");
+        assertTrue(createExtractor().processBitMapPairs(createExtractor(), func), "not_empty == not_empty failed");
 
-        // test BitMapProducers of different length send 0 for missing values.
+        // test BitMapExtractors of different length send 0 for missing values.
         final int[] count = new int[3];
         final LongBiPredicate lbp = (x, y) -> {
             if (x == 0) {
@@ -122,38 +122,38 @@ public final void testForEachBitMapPair() {
             count[2]++;
             return true;
         };
-        createEmptyProducer().forEachBitMapPair(createProducer(), lbp);
+        createEmptyExtractor().processBitMapPairs(createExtractor(), lbp);
         assertEquals(count[2], count[0]);
 
         Arrays.fill(count, 0);
-        createProducer().forEachBitMapPair(createEmptyProducer(), lbp);
+        createExtractor().processBitMapPairs(createEmptyExtractor(), lbp);
         assertEquals(count[2], count[1]);
 
-        // test where the created producer does not process all records because the predicate function
+        // test where the created extractor does not process all records because the predicate function
         // returns false before the processing is completed.
         final int[] limit = new int[1];
         final LongBiPredicate shortFunc =  (x, y) -> {
             limit[0]++;
             return limit[0] < 2;
         };
-        final BitMapProducer shortProducer = l -> true;
-        assertFalse(createProducer().forEachBitMapPair(shortProducer, shortFunc));
+        final BitMapExtractor shortExtractor = l -> true;
+        assertFalse(createExtractor().processBitMapPairs(shortExtractor, shortFunc));
     }
 
     @Test
     public void testForEachBitMapPairEarlyExit() {
 
-        // test BitMapProducers of different length send 0 for missing values.
+        // test BitMapExtractir of different length send 0 for missing values.
         final int[] count = new int[1];
         final LongBiPredicate lbp = (x, y) -> {
             count[0]++;
             return false;
         };
-        createProducer().forEachBitMapPair(createEmptyProducer(), lbp);
+        createExtractor().processBitMapPairs(createEmptyExtractor(), lbp);
         assertEquals(1, count[0]);
 
         Arrays.fill(count, 0);
-        createEmptyProducer().forEachBitMapPair(createProducer(), lbp);
+        createEmptyExtractor().processBitMapPairs(createExtractor(), lbp);
         assertEquals(1, count[0]);
     }
 }
diff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBloomFilterProducerTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBloomFilterExtractorTest.java
similarity index 77%
rename from src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBloomFilterProducerTest.java
rename to src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBloomFilterExtractorTest.java
index 102ba9bcf4..7dd03625a2 100644
--- a/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBloomFilterProducerTest.java
+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBloomFilterExtractorTest.java
@@ -26,7 +26,7 @@
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 
-public abstract class AbstractBloomFilterProducerTest {
+public abstract class AbstractBloomFilterExtractorTest {
     private final Shape shape = Shape.fromKM(17, 72);
 
     BloomFilter one = new SimpleBloomFilter(shape);
@@ -46,16 +46,16 @@ public abstract class AbstractBloomFilterProducerTest {
         return true;
     };
 
-    private BloomFilterProducer createUnderTest() {
+    private BloomFilterExtractor createUnderTest() {
         return createUnderTest(one, two);
     }
 
     /**
-     * Creates a BloomFilterProducer that returns the filters (or their copy) in the order presented.
+     * Creates a BloomFilterExtractor that returns the filters (or their copy) in the order presented.
      * @param filters The filters to return.
-     * @return A BloomFilterProducer that returns the filters in order.
+     * @return A BloomFilterExtractor that returns the filters in order.
      */
-    protected abstract BloomFilterProducer createUnderTest(BloomFilter... filters);
+    protected abstract BloomFilterExtractor createUnderTest(BloomFilter... filters);
 
     /**
      * The shape of the Bloom filters for testing.
@@ -72,9 +72,9 @@ protected Shape getTestShape() {
     @BeforeEach
     public void setup() {
         one.clear();
-        one.merge(IndexProducer.fromIndexArray(1));
+        one.merge(IndexExtractor.fromIndexArray(1));
         two.clear();
-        two.merge(IndexProducer.fromIndexArray(2, 3));
+        two.merge(IndexExtractor.fromIndexArray(2, 3));
         nullCount[0] = 0;
         nullCount[1] = 0;
         equalityCount[0] = 0;
@@ -92,13 +92,13 @@ public void testAsBloomFilterArray() {
     public void testFlatten() {
         final BloomFilter underTest = createUnderTest().flatten();
         final BloomFilter expected = new SimpleBloomFilter(shape);
-        expected.merge(IndexProducer.fromIndexArray(1, 2, 3));
+        expected.merge(IndexExtractor.fromIndexArray(1, 2, 3));
         assertArrayEquals(expected.asBitMapArray(), underTest.asBitMapArray());
     }
 
     @Test
     public void testForEachPairArrayTooLong() {
-        assertTrue(createUnderTest().forEachBloomFilterPair(BloomFilterProducer.fromBloomFilterArray(one, two, one),
+        assertTrue(createUnderTest().processBloomFilterPair(BloomFilterExtractor.fromBloomFilterArray(one, two, one),
                 counter));
         assertEquals(1, nullCount[0]);
         assertEquals(0, nullCount[1]);
@@ -107,7 +107,7 @@ public void testForEachPairArrayTooLong() {
 
     @Test
     public void testForEachPairArrayTooShort() {
-        assertTrue(createUnderTest().forEachBloomFilterPair(BloomFilterProducer.fromBloomFilterArray(one), counter));
+        assertTrue(createUnderTest().processBloomFilterPair(BloomFilterExtractor.fromBloomFilterArray(one), counter));
         assertEquals(0, nullCount[0]);
         assertEquals(1, nullCount[1]);
         assertEquals(1, equalityCount[0]);
@@ -115,20 +115,20 @@ public void testForEachPairArrayTooShort() {
 
     @Test
     public void testForEachPairCompleteMatch() {
-        assertTrue(createUnderTest().forEachBloomFilterPair(createUnderTest(), counter));
+        assertTrue(createUnderTest().processBloomFilterPair(createUnderTest(), counter));
         assertArrayEquals(new int[] { 0, 0 }, nullCount);
         assertEquals(2, equalityCount[0]);
     }
 
     @Test
     public void testForEachPairReturnFalseEarly() {
-        assertFalse(createUnderTest().forEachBloomFilterPair(BloomFilterProducer.fromBloomFilterArray(one, two, one),
+        assertFalse(createUnderTest().processBloomFilterPair(BloomFilterExtractor.fromBloomFilterArray(one, two, one),
                 (x, y) -> false));
     }
 
     @Test
     public void testForEachPairReturnFalseLate() {
-        assertFalse(createUnderTest().forEachBloomFilterPair(BloomFilterProducer.fromBloomFilterArray(one, two, one),
+        assertFalse(createUnderTest().processBloomFilterPair(BloomFilterExtractor.fromBloomFilterArray(one, two, one),
                 counter.and((x, y) -> x != null && y != null)));
         assertEquals(1, nullCount[0]);
         assertEquals(0, nullCount[1]);
@@ -137,7 +137,7 @@ public void testForEachPairReturnFalseLate() {
 
     @Test
     public void testForEachPairReturnFalseLateShortArray() {
-        assertFalse(createUnderTest().forEachBloomFilterPair(BloomFilterProducer.fromBloomFilterArray(one),
+        assertFalse(createUnderTest().processBloomFilterPair(BloomFilterExtractor.fromBloomFilterArray(one),
                 counter.and((x, y) -> x != null && y != null)));
         assertEquals(0, nullCount[0]);
         assertEquals(1, nullCount[1]);
diff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBloomFilterTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBloomFilterTest.java
index a0eaa4a5c4..93646935a0 100644
--- a/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBloomFilterTest.java
+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBloomFilterTest.java
@@ -40,28 +40,28 @@ public abstract class AbstractBloomFilterTest<T extends BloomFilter> {
      */
     public static class BadHasher implements Hasher {
 
-        IndexProducer producer;
+        IndexExtractor extractor;
 
         public BadHasher(final int value) {
-            this.producer = IndexProducer.fromIndexArray(value);
+            this.extractor = IndexExtractor.fromIndexArray(value);
         }
 
         @Override
-        public IndexProducer indices(final Shape shape) {
-            return producer;
+        public IndexExtractor indices(final Shape shape) {
+            return extractor;
         }
     }
 
-    private void assertFailedIndexProducerConstructor(final Shape shape, final int[] values) {
-        final IndexProducer indices = IndexProducer.fromIndexArray(values);
+    private void assertFailedIndexExtractorConstructor(final Shape shape, final int[] values) {
+        final IndexExtractor indices = IndexExtractor.fromIndexArray(values);
         assertThrows(IllegalArgumentException.class, () -> createFilter(shape, indices));
     }
 
-    private void assertIndexProducerMerge(final Shape shape, final int[] values, final int[] expected) {
-        final IndexProducer indices = IndexProducer.fromIndexArray(values);
+    private void assertIndexExtractorMerge(final Shape shape, final int[] values, final int[] expected) {
+        final IndexExtractor indices = IndexExtractor.fromIndexArray(values);
         final BloomFilter filter = createFilter(shape, indices);
         final List<Integer> lst = new ArrayList<>();
-        filter.forEachIndex(x -> {
+        filter.processIndices(x -> {
             lst.add(x);
             return true;
         });
@@ -83,12 +83,12 @@ private void assertIndexProducerMerge(final Shape shape, final int[] values, fin
      * Create the BloomFilter implementation we are testing.
      *
      * @param shape the shape of the filter.
-     * @param producer A BitMap producer to build the filter with.
+     * @param extractor A BitMap extractor to build the filter with.
      * @return a BloomFilter implementation.
      */
-    protected final T createFilter(final Shape shape, final BitMapProducer producer) {
+    protected final T createFilter(final Shape shape, final BitMapExtractor extractor) {
         final T bf = createEmptyFilter(shape);
-        bf.merge(producer);
+        bf.merge(extractor);
         return bf;
     }
 
@@ -109,12 +109,12 @@ protected final T createFilter(final Shape shape, final Hasher hasher) {
      * Create the BloomFilter implementation we are testing.
      *
      * @param shape the shape of the filter.
-     * @param producer An Index producer to build the filter with.
+     * @param extractor An Index extractor to build the filter with.
      * @return a BloomFilter implementation.
      */
-    protected final T createFilter(final Shape shape, final IndexProducer producer) {
+    protected final T createFilter(final Shape shape, final IndexExtractor extractor) {
         final T bf = createEmptyFilter(shape);
-        bf.merge(producer);
+        bf.merge(extractor);
         return bf;
     }
 
@@ -146,20 +146,20 @@ public final void testAsBitMapArray() {
     }
 
     @Test
-    public void testBitMapProducerSize() {
+    public void testBitMapExtractorSize() {
         final int[] idx = new int[1];
-        createFilter(getTestShape(), TestingHashers.FROM1).forEachBitMap(i -> {
+        createFilter(getTestShape(), TestingHashers.FROM1).processBitMaps(i -> {
             idx[0]++;
             return true;
         });
-        assertEquals(BitMap.numberOfBitMaps(getTestShape().getNumberOfBits()), idx[0]);
+        assertEquals(BitMaps.numberOfBitMaps(getTestShape().getNumberOfBits()), idx[0]);
 
         idx[0] = 0;
-        createEmptyFilter(getTestShape()).forEachBitMap(i -> {
+        createEmptyFilter(getTestShape()).processBitMaps(i -> {
             idx[0]++;
             return true;
         });
-        assertEquals(BitMap.numberOfBitMaps(getTestShape().getNumberOfBits()), idx[0]);
+        assertEquals(BitMaps.numberOfBitMaps(getTestShape().getNumberOfBits()), idx[0]);
     }
 
     @Test
@@ -169,7 +169,7 @@ public void testCardinalityAndIsEmpty() {
 
     /**
      * Test cardinality and isEmpty. Bloom filter must be able to accept multiple
-     * IndexProducer merges until all the bits are populated.
+     * IndexExtractor merges until all the bits are populated.
      *
      * @param bf The Bloom filter to test.
      */
@@ -177,7 +177,7 @@ protected void testCardinalityAndIsEmpty(final BloomFilter bf) {
         assertTrue(bf.isEmpty());
         assertEquals(0, bf.cardinality());
         for (int i = 0; i < getTestShape().getNumberOfBits(); i++) {
-            bf.merge(IndexProducer.fromIndexArray(i));
+            bf.merge(IndexExtractor.fromIndexArray(i));
             assertFalse(bf.isEmpty(), "Wrong value at " + i);
             assertEquals(i + 1, bf.cardinality(), "Wrong value at " + i);
         }
@@ -187,7 +187,7 @@ protected void testCardinalityAndIsEmpty(final BloomFilter bf) {
         assertEquals(0, bf.cardinality());
         assertTrue(bf.isEmpty());
         for (int i = 0; i < getTestShape().getNumberOfBits(); i++) {
-            bf.merge(IndexProducer.fromIndexArray(i));
+            bf.merge(IndexExtractor.fromIndexArray(i));
             assertEquals(i + 1, bf.cardinality(), "Wrong value at " + i);
             assertFalse(bf.isEmpty(), "Wrong value at " + i);
         }
@@ -213,16 +213,16 @@ public final void testContains() {
         assertTrue(bf2.contains(new IncrementingHasher(1, 1)), "BF2 Should contain this hasher");
         assertFalse(bf2.contains(new IncrementingHasher(1, 3)), "BF2 Should not contain this hasher");
 
-        IndexProducer indexProducer = new IncrementingHasher(1, 1).indices(getTestShape());
-        assertTrue(bf2.contains(indexProducer), "BF2 Should contain this hasher");
-        indexProducer = new IncrementingHasher(1, 3).indices(getTestShape());
-        assertFalse(bf2.contains(indexProducer), "BF2 Should not contain this hasher");
+        IndexExtractor indexExtractor = new IncrementingHasher(1, 1).indices(getTestShape());
+        assertTrue(bf2.contains(indexExtractor), "BF2 Should contain this hasher");
+        indexExtractor = new IncrementingHasher(1, 3).indices(getTestShape());
+        assertFalse(bf2.contains(indexExtractor), "BF2 Should not contain this hasher");
 
-        BitMapProducer bitMapProducer = BitMapProducer.fromIndexProducer(new IncrementingHasher(1, 1).indices(getTestShape()),
+        BitMapExtractor bitMapExtractor = BitMapExtractor.fromIndexExtractor(new IncrementingHasher(1, 1).indices(getTestShape()),
                 getTestShape().getNumberOfBits());
-        assertTrue(bf2.contains(bitMapProducer), "BF2 Should contain this hasher");
-        bitMapProducer = BitMapProducer.fromIndexProducer(new IncrementingHasher(1, 3).indices(getTestShape()), getTestShape().getNumberOfBits());
-        assertFalse(bf2.contains(bitMapProducer), "BF2 Should not contain this hasher");
+        assertTrue(bf2.contains(bitMapExtractor), "BF2 Should contain this hasher");
+        bitMapExtractor = BitMapExtractor.fromIndexExtractor(new IncrementingHasher(1, 3).indices(getTestShape()), getTestShape().getNumberOfBits());
+        assertFalse(bf2.contains(bitMapExtractor), "BF2 Should not contain this hasher");
 
         // Test different lengths
         bf1 = createFilter(getTestShape(), TestingHashers.FROM1);
@@ -242,7 +242,7 @@ public void testEmptyAfterMergeWithNothing() {
         // test the case where is empty after merge
         // in this case the internal cardinality == -1
         final BloomFilter bf = createEmptyFilter(getTestShape());
-        bf.merge(IndexProducer.fromIndexArray());
+        bf.merge(IndexExtractor.fromIndexArray());
         assertTrue(bf.isEmpty());
     }
 
@@ -316,18 +316,18 @@ public final void testEstimateUnion() {
     }
 
     @Test
-    public void testIndexProducerMerge() {
+    public void testIndexExtractorMerge() {
         final Shape shape = Shape.fromKM(5, 10);
 
-        assertIndexProducerMerge(shape, new int[] {0, 2, 4, 6, 8}, new int[] {0, 2, 4, 6, 8});
+        assertIndexExtractorMerge(shape, new int[] {0, 2, 4, 6, 8}, new int[] {0, 2, 4, 6, 8});
         // test duplicate values
-        assertIndexProducerMerge(shape, new int[] {0, 2, 4, 2, 8}, new int[] {0, 2, 4, 8});
+        assertIndexExtractorMerge(shape, new int[] {0, 2, 4, 2, 8}, new int[] {0, 2, 4, 8});
         // test negative values
-        assertFailedIndexProducerConstructor(shape, new int[] {0, 2, 4, -2, 8});
+        assertFailedIndexExtractorConstructor(shape, new int[] {0, 2, 4, -2, 8});
         // test index too large
-        assertFailedIndexProducerConstructor(shape, new int[] {0, 2, 4, 12, 8});
+        assertFailedIndexExtractorConstructor(shape, new int[] {0, 2, 4, 12, 8});
         // test no indices
-        assertIndexProducerMerge(shape, new int[0], new int[0]);
+        assertIndexExtractorMerge(shape, new int[0], new int[0]);
     }
 
     /**
@@ -412,53 +412,53 @@ public void testMergeWithBadHasher() {
     }
 
     @Test
-    public void testMergeWithBitMapProducer() {
-        final int bitMapCount = BitMap.numberOfBitMaps(getTestShape().getNumberOfBits());
+    public void testMergeWithBitMapExtractor() {
+        final int bitMapCount = BitMaps.numberOfBitMaps(getTestShape().getNumberOfBits());
         for (int i = 0; i < 5; i++) {
             final long[] values = new long[bitMapCount];
-            for (final int idx : DefaultIndexProducerTest.generateIntArray(getTestShape().getNumberOfHashFunctions(), getTestShape().getNumberOfBits())) {
-                BitMap.set(values, idx);
+            for (final int idx : DefaultIndexExtractorTest.generateIntArray(getTestShape().getNumberOfHashFunctions(), getTestShape().getNumberOfBits())) {
+                BitMaps.set(values, idx);
             }
-            final BloomFilter f = createFilter(getTestShape(), BitMapProducer.fromBitMapArray(values));
+            final BloomFilter f = createFilter(getTestShape(), BitMapExtractor.fromBitMapArray(values));
             final List<Long> lst = new ArrayList<>();
             for (final long l : values) {
                 lst.add(l);
             }
-            assertTrue(f.forEachBitMap(l -> lst.remove(Long.valueOf(l))));
+            assertTrue(f.processBitMaps(l -> lst.remove(Long.valueOf(l))));
             assertTrue(lst.isEmpty());
         }
         // values too large
         final long[] values = new long[bitMapCount];
         Arrays.fill(values, Long.MAX_VALUE);
-        final BitMapProducer badProducer = BitMapProducer.fromBitMapArray(values);
+        final BitMapExtractor badExtractor = BitMapExtractor.fromBitMapArray(values);
         final BloomFilter bf = createEmptyFilter(getTestShape());
-        assertThrows(IllegalArgumentException.class, () -> bf.merge(badProducer));
+        assertThrows(IllegalArgumentException.class, () -> bf.merge(badExtractor));
 
         // test where merged bits exceed expected bits but both bitmaps are the same length.
-        final BitMapProducer badProducer2 = BitMapProducer.fromBitMapArray(0x80_00_00_00_00_00_00_00L);
+        final BitMapExtractor badExtractor2 = BitMapExtractor.fromBitMapArray(0x80_00_00_00_00_00_00_00L);
         final BloomFilter bf2 = createEmptyFilter(Shape.fromKM(3, 32));
-        assertThrows(IllegalArgumentException.class, () -> bf2.merge(badProducer2));
+        assertThrows(IllegalArgumentException.class, () -> bf2.merge(badExtractor2));
     }
 
     @Test
     public void testMergeWithHasher() {
         for (int i = 0; i < 5; i++) {
             final BloomFilter f = createEmptyFilter(getTestShape());
-            final int[] expected = DefaultIndexProducerTest.generateIntArray(getTestShape().getNumberOfHashFunctions(), getTestShape().getNumberOfBits());
+            final int[] expected = DefaultIndexExtractorTest.generateIntArray(getTestShape().getNumberOfHashFunctions(), getTestShape().getNumberOfBits());
             final Hasher hasher = new ArrayHasher(expected);
             f.merge(hasher);
             // create sorted unique array of expected values
-            assertArrayEquals(DefaultIndexProducerTest.unique(expected), f.asIndexArray());
+            assertArrayEquals(DefaultIndexExtractorTest.unique(expected), f.asIndexArray());
         }
     }
 
     @Test
-    public void testMergeWithIndexProducer() {
+    public void testMergeWithIndexExtractor() {
         for (int i = 0; i < 5; i++) {
-            final int[] values = DefaultIndexProducerTest.generateIntArray(getTestShape().getNumberOfHashFunctions(), getTestShape().getNumberOfBits());
-            final BloomFilter f = createFilter(getTestShape(), IndexProducer.fromIndexArray(values));
-            final BitSet uniqueValues = DefaultIndexProducerTest.uniqueSet(values);
-            assertTrue(f.forEachIndex(idx -> {
+            final int[] values = DefaultIndexExtractorTest.generateIntArray(getTestShape().getNumberOfHashFunctions(), getTestShape().getNumberOfBits());
+            final BloomFilter f = createFilter(getTestShape(), IndexExtractor.fromIndexArray(values));
+            final BitSet uniqueValues = DefaultIndexExtractorTest.uniqueSet(values);
+            assertTrue(f.processIndices(idx -> {
                 final boolean result = uniqueValues.get(idx);
                 uniqueValues.clear(idx);
                 return result;
@@ -468,17 +468,17 @@ public void testMergeWithIndexProducer() {
         // value to large
         final BloomFilter f1 = createEmptyFilter(getTestShape());
         assertThrows(IllegalArgumentException.class,
-                () -> f1.merge(IndexProducer.fromIndexArray(getTestShape().getNumberOfBits())));
+                () -> f1.merge(IndexExtractor.fromIndexArray(getTestShape().getNumberOfBits())));
         // negative value
         final BloomFilter f2 = createEmptyFilter(getTestShape());
         assertThrows(IllegalArgumentException.class,
-                () -> f2.merge(IndexProducer.fromIndexArray(-1)));
+                () -> f2.merge(IndexExtractor.fromIndexArray(-1)));
     }
 
     @Test
     public final void testNegativeIntersection() {
-        final IndexProducer p1 = IndexProducer.fromIndexArray(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 20, 26, 28, 30, 32, 34, 35, 36, 37, 39, 40, 41, 42, 43, 45, 46, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71);
-        final IndexProducer p2 = IndexProducer.fromIndexArray(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27);
+        final IndexExtractor p1 = IndexExtractor.fromIndexArray(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 20, 26, 28, 30, 32, 34, 35, 36, 37, 39, 40, 41, 42, 43, 45, 46, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71);
+        final IndexExtractor p2 = IndexExtractor.fromIndexArray(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27);
 
         final BloomFilter filter1 = createEmptyFilter(Shape.fromKM(17, 72));
         filter1.merge(p1);
diff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractCellProducerTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractCellExtractorTest.java
similarity index 67%
rename from src/test/java/org/apache/commons/collections4/bloomfilter/AbstractCellProducerTest.java
rename to src/test/java/org/apache/commons/collections4/bloomfilter/AbstractCellExtractorTest.java
index b48c0a8dda..02c00c6785 100644
--- a/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractCellProducerTest.java
+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractCellExtractorTest.java
@@ -25,33 +25,33 @@
 import java.util.Arrays;
 import java.util.BitSet;
 
-import org.apache.commons.collections4.bloomfilter.CellProducer.CellConsumer;
+import org.apache.commons.collections4.bloomfilter.CellExtractor.CellPredicate;
 import org.junit.jupiter.api.Test;
 
-public abstract class AbstractCellProducerTest extends AbstractIndexProducerTest {
+public abstract class AbstractCellExtractorTest extends AbstractIndexExtractorTest {
 
     /**
      * A testing CellConsumer that always returns true.
      */
-    private static final CellConsumer TRUE_CONSUMER = (i, j) -> true;
+    private static final CellPredicate TRUE_CONSUMER = (i, j) -> true;
     /**
      * A testing CellConsumer that always returns false.
      */
-    private static final CellConsumer FALSE_CONSUMER = (i, j) -> false;
+    private static final CellPredicate FALSE_CONSUMER = (i, j) -> false;
 
     /**
-     * Creates a producer without data.
-     * @return a producer that has no data.
+     * Creates a CellExtractor without data.
+     * @return a cell extractor that has no data.
      */
     @Override
-    protected abstract CellProducer createEmptyProducer();
+    protected abstract CellExtractor createEmptyExtractor();
 
     /**
-     * Creates a producer with some data.
-     * @return a producer with some data
+     * Creates a CellExtractor with some data.
+     * @return a cell extractor with some data
      */
     @Override
-    protected abstract CellProducer createProducer();
+    protected abstract CellExtractor createExtractor();
 
     @Override
     protected final int getAsIndexArrayBehaviour() {
@@ -61,19 +61,19 @@ protected final int getAsIndexArrayBehaviour() {
     /**
      * Creates an array of expected values that aligns with the expected indices entries.
      * @return an array of expected values.
-     * @see AbstractIndexProducerTest#getExpectedIndices()
+     * @see AbstractIndexExtractorTest#getExpectedIndices()
      */
     protected abstract int[] getExpectedValues();
 
     /**
-     * Test the behavior of {@link CellProducer#forEachCell(CellConsumer)} with respect
+     * Test the behavior of {@link CellExtractor#processCells(CellPredicate)} with respect
      * to ordered and distinct indices. Currently the behavior is assumed to be the same as
-     * {@link IndexProducer#forEachIndex(java.util.function.IntPredicate)}.
+     * {@link IndexExtractor#processIndices(java.util.function.IntPredicate)}.
      */
     @Test
     public final void testBehaviourForEachCell() {
         final IntList list = new IntList();
-        createProducer().forEachCell((i, j) -> list.add(i));
+        createExtractor().processCells((i, j) -> list.add(i));
         final int[] actual = list.toArray();
         // check order
         final int[] expected = Arrays.stream(actual).sorted().toArray();
@@ -84,11 +84,11 @@ public final void testBehaviourForEachCell() {
     }
 
     @Test
-    public final void testEmptyCellProducer() {
-        final CellProducer empty = createEmptyProducer();
+    public final void testEmptyCellExtractor() {
+        final CellExtractor empty = createEmptyExtractor();
         final int[] ary = empty.asIndexArray();
         assertEquals(0, ary.length);
-        assertTrue(empty.forEachCell((i, j) -> {
+        assertTrue(empty.processCells((i, j) -> {
             fail("forEachCell consumer should not be called");
             return false;
         }));
@@ -97,13 +97,13 @@ public final void testEmptyCellProducer() {
     @Test
     public void testForEachCellEarlyExit() {
         final int[] passes = new int[1];
-        assertTrue(createEmptyProducer().forEachCell((i, j) -> {
+        assertTrue(createEmptyExtractor().processCells((i, j) -> {
             passes[0]++;
             return false;
         }));
         assertEquals(0, passes[0]);
 
-        assertFalse(createProducer().forEachCell((i, j) -> {
+        assertFalse(createExtractor().processCells((i, j) -> {
             passes[0]++;
             return false;
         }));
@@ -112,14 +112,14 @@ public void testForEachCellEarlyExit() {
 
     @Test
     public final void testForEachCellPredicates() {
-        final CellProducer populated = createProducer();
-        final CellProducer empty = createEmptyProducer();
+        final CellExtractor populated = createExtractor();
+        final CellExtractor empty = createEmptyExtractor();
 
-        assertFalse(populated.forEachCell(FALSE_CONSUMER), "non-empty should be false");
-        assertTrue(empty.forEachCell(FALSE_CONSUMER), "empty should be true");
+        assertFalse(populated.processCells(FALSE_CONSUMER), "non-empty should be false");
+        assertTrue(empty.processCells(FALSE_CONSUMER), "empty should be true");
 
-        assertTrue(populated.forEachCell(TRUE_CONSUMER), "non-empty should be true");
-        assertTrue(empty.forEachCell(TRUE_CONSUMER), "empty should be true");
+        assertTrue(populated.processCells(TRUE_CONSUMER), "non-empty should be true");
+        assertTrue(empty.processCells(TRUE_CONSUMER), "empty should be true");
     }
 
     @Test
@@ -128,7 +128,7 @@ public void testForEachCellValues() {
         final int[] expectedValue = getExpectedValues();
         assertEquals(expectedIdx.length, expectedValue.length, "expected index length and value length do not match");
         final int[] idx = {0};
-        createProducer().forEachCell((i, j) -> {
+        createExtractor().processCells((i, j) -> {
             assertEquals(expectedIdx[idx[0]], i, "bad index at " + idx[0]);
             assertEquals(expectedValue[idx[0]], j, "bad value at " + idx[0]);
             idx[0]++;
@@ -138,14 +138,14 @@ public void testForEachCellValues() {
 
     @Test
     public final void testIndexConsistency() {
-        final CellProducer producer = createProducer();
+        final CellExtractor extractor = createExtractor();
         final BitSet bs1 = new BitSet();
         final BitSet bs2 = new BitSet();
-        producer.forEachIndex(i -> {
+        extractor.processIndices(i -> {
             bs1.set(i);
             return true;
         });
-        producer.forEachCell((i, j) -> {
+        extractor.processCells((i, j) -> {
             bs2.set(i);
             return true;
         });
diff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractCountingBloomFilterTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractCountingBloomFilterTest.java
index d67a0c8b56..2b3dc7ad86 100644
--- a/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractCountingBloomFilterTest.java
+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractCountingBloomFilterTest.java
@@ -48,7 +48,7 @@ public abstract class AbstractCountingBloomFilterTest<T extends CountingBloomFil
      */
     private static void assertCounts(final CountingBloomFilter bf, final int[] expected) {
         final Map<Integer, Integer> m = new HashMap<>();
-        bf.forEachCell((i, c) -> {
+        bf.processCells((i, c) -> {
             m.put(i, c);
             return true;
         });
@@ -65,7 +65,7 @@ private static void assertCounts(final CountingBloomFilter bf, final int[] expec
     }
 
     private void assertCell3(final CountingBloomFilter bf, final int value) {
-        bf.forEachCell((k, v) -> {
+        bf.processCells((k, v) -> {
             if (k == 3) {
                 assertEquals(value, v, "Mismatch at position 3");
             } else {
@@ -75,7 +75,7 @@ private void assertCell3(final CountingBloomFilter bf, final int value) {
         });
     }
 
-    protected final CellProducer getMaximumValueProducer(final int maxValue) {
+    protected final CellExtractor getMaximumValueExtractor(final int maxValue) {
         return consumer -> {
             for (int i = 1; i < 18; i++) {
                 if (!consumer.test(i, maxValue)) {
@@ -91,8 +91,8 @@ public void mergeIncrementsAllCellsTest() {
         final CountingBloomFilter f1 = createEmptyFilter(Shape.fromKM(1, 10));
         final CountingBloomFilter f2 = f1.copy();
         final CountingBloomFilter f3 = f1.copy();
-        // index producer produces 3 two times.
-        final IndexProducer ip = p -> {
+        // index extractor produces 3 two times.
+        final IndexExtractor ip = p -> {
             p.test(3);
             p.test(3);
             return true;
@@ -102,22 +102,22 @@ public void mergeIncrementsAllCellsTest() {
         assertCell3(f1, 1);
 
         // The add should increment cells 3 by 2
-        f2.add(CellProducer.from(ip));
+        f2.add(CellExtractor.from(ip));
         assertCell3(f2, 2);
     }
 
     @Test
     public void removeDecrementsAllCellsTest() {
         final CountingBloomFilter f1 = createEmptyFilter(Shape.fromKM(1, 10));
-        final CellProducer cp = p -> {
+        final CellExtractor cp = p -> {
             p.test(3, 3);
             return true;
         };
         f1.add(cp);
         final CountingBloomFilter f2 = f1.copy();
         final CountingBloomFilter f3 = f1.copy();
-        // index producer produces 3 two times.
-        final IndexProducer ip = p -> {
+        // index extractor produces 3 two times.
+        final IndexExtractor ip = p -> {
             p.test(3);
             p.test(3);
             return true;
@@ -127,11 +127,11 @@ public void removeDecrementsAllCellsTest() {
         assertCell3(f1, 2);
 
         // The add should decrement cells 3 by 2
-        f2.subtract(CellProducer.from(ip));
+        f2.subtract(CellExtractor.from(ip));
         assertCell3(f2, 1);
 
         // This merge will decrement by 1 as the round-trip makes the indices unique
-        f3.remove(IndexProducer.fromIndexArray(ip.asIndexArray()));
+        f3.remove(IndexExtractor.fromIndexArray(ip.asIndexArray()));
         assertCell3(f3, 2);
     }
 
@@ -150,7 +150,7 @@ public void testAdd() {
         // test overflow
 
         final CountingBloomFilter bf2 = createEmptyFilter(getTestShape());
-        assertTrue(bf2.add(getMaximumValueProducer(bf2.getMaxCell())), "Should add to empty");
+        assertTrue(bf2.add(getMaximumValueExtractor(bf2.getMaxCell())), "Should add to empty");
         assertTrue(bf2.isValid(), "Should be valid");
 
         assertFalse(bf2.add(createFilter(getTestShape(), TestingHashers.FROM1)), "Should not add");
@@ -167,8 +167,8 @@ public final void testCountingBloomFilterSpecificContains() {
         assertTrue(bf2.contains(bf2), "BF2 Should contain itself");
         assertFalse(bf.contains(bf2), "BF should not contain BF2");
         assertTrue(bf2.contains(bf), "BF2 should contain BF");
-        final BitMapProducer producer = bf2;
-        assertTrue(bf2.contains(producer), "BF2 should contain BF bitMapProducer");
+        final BitMapExtractor extractor = bf2;
+        assertTrue(bf2.contains(extractor), "BF2 should contain BF bitMapExtractor");
     }
 
     /**
@@ -180,7 +180,7 @@ public final void testCountingSpecificConstructor() {
         // verify hasher duplicates are counted.
         // bit hasher has duplicates for 11, 12,13,14,15,16, and 17
         final CountingBloomFilter bf = createFilter(getTestShape(), TestingHashers.FROM1);
-        bf.add(CellProducer.from(TestingHashers.FROM11.indices(getTestShape())));
+        bf.add(CellExtractor.from(TestingHashers.FROM11.indices(getTestShape())));
 
         final long[] lb = bf.asBitMapArray();
         assertEquals(2, lb.length);
@@ -214,7 +214,7 @@ public final void testCountingSpecificMerge() {
         // test overflow
 
         final CountingBloomFilter bf5 = createEmptyFilter(getTestShape());
-        assertTrue(bf5.add(getMaximumValueProducer(bf5.getMaxCell())), "Should add to empty");
+        assertTrue(bf5.add(getMaximumValueExtractor(bf5.getMaxCell())), "Should add to empty");
         assertTrue(bf5.isValid(), "Should be valid");
 
         final CountingBloomFilter bf6 = bf5.copy();
@@ -234,7 +234,7 @@ public void testExcludesDuplicates() {
 
         CountingBloomFilter bf1 = createFilter(shape, hasher);
         assertEquals(6, bf1.cardinality());
-        bf1.forEachCell((x, y) -> {
+        bf1.processCells((x, y) -> {
             assertEquals(1, y, "Hasher in constructor results in value not equal to 1");
             return true;
         });
@@ -242,7 +242,7 @@ public void testExcludesDuplicates() {
         bf1 = createEmptyFilter(shape);
         bf1.merge(hasher);
         assertEquals(6, bf1.cardinality());
-        bf1.forEachCell((x, y) -> {
+        bf1.processCells((x, y) -> {
             assertEquals(1, y, "Hasher in merge results in value not equal to 1");
             return true;
         });
@@ -251,7 +251,7 @@ public void testExcludesDuplicates() {
         bf1.merge(hasher);
         bf1.remove(hasher);
         assertEquals(0, bf1.cardinality());
-        assertTrue(bf1.forEachCell((x, y) -> false), "Hasher in removes results in value not equal to 0");
+        assertTrue(bf1.processCells((x, y) -> false), "Hasher in removes results in value not equal to 0");
     }
 
     @Test
@@ -284,7 +284,7 @@ public final void testRemove() {
         simple.merge(TestingHashers.FROM11);
 
         final CountingBloomFilter bf1 = createFilter(getTestShape(), TestingHashers.FROM1);
-        bf1.add(CellProducer.from(TestingHashers.FROM11.indices(getTestShape())));
+        bf1.add(CellExtractor.from(TestingHashers.FROM11.indices(getTestShape())));
 
         assertTrue(bf1.remove(simple), "Remove should work");
         assertFalse(bf1.contains(TestingHashers.FROM11), "Should not contain");
@@ -294,7 +294,7 @@ public final void testRemove() {
 
         // with hasher
         final CountingBloomFilter bf2 = createFilter(getTestShape(), TestingHashers.FROM1);
-        bf2.add(CellProducer.from(TestingHashers.FROM11.indices(getTestShape())));
+        bf2.add(CellExtractor.from(TestingHashers.FROM11.indices(getTestShape())));
 
         assertTrue(bf2.remove(TestingHashers.FROM11), "Remove should work");
         assertFalse(bf2.contains(TestingHashers.FROM11), "Should not contain");
@@ -311,11 +311,11 @@ public final void testRemove() {
 
         assertCounts(bf3, new int[] {0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1});
 
-        // with IndexProducer
-        final IndexProducer ip = TestingHashers.FROM11.indices(getTestShape());
+        // with IndexExtractor
+        final IndexExtractor ip = TestingHashers.FROM11.indices(getTestShape());
 
         final CountingBloomFilter bf4 = createFilter(getTestShape(), TestingHashers.FROM1);
-        bf4.add(CellProducer.from(TestingHashers.FROM11.indices(getTestShape())));
+        bf4.add(CellExtractor.from(TestingHashers.FROM11.indices(getTestShape())));
 
         assertTrue(bf4.remove(ip), "Remove should work");
         assertFalse(bf4.contains(TestingHashers.FROM11), "Should not contain");
@@ -323,10 +323,10 @@ public final void testRemove() {
 
         assertCounts(bf4, from1Counts);
 
-        // with BitMapProducer
-        final BitMapProducer bmp = BitMapProducer.fromIndexProducer(ip, getTestShape().getNumberOfBits());
+        // with BitMapExtractor
+        final BitMapExtractor bmp = BitMapExtractor.fromIndexExtractor(ip, getTestShape().getNumberOfBits());
         final CountingBloomFilter bf5 = createFilter(getTestShape(), TestingHashers.FROM1);
-        bf5.add(CellProducer.from(TestingHashers.FROM11.indices(getTestShape())));
+        bf5.add(CellExtractor.from(TestingHashers.FROM11.indices(getTestShape())));
 
         assertTrue(bf5.remove(bmp), "Remove should work");
         assertFalse(bf5.contains(TestingHashers.FROM11), "Should not contain");
@@ -334,13 +334,13 @@ public final void testRemove() {
 
         assertCounts(bf5, from1Counts);
 
-        // test producer errors
-        final IndexProducer ip2 = IndexProducer.fromIndexArray(1, 2, getTestShape().getNumberOfBits());
+        // test extractor errors
+        final IndexExtractor ip2 = IndexExtractor.fromIndexArray(1, 2, getTestShape().getNumberOfBits());
         final CountingBloomFilter bf6 = createFilter(getTestShape(), TestingHashers.FROM1);
         assertThrows(IllegalArgumentException.class, () -> bf6.remove(ip2));
 
         final CountingBloomFilter bf7 = createFilter(getTestShape(), TestingHashers.FROM1);
-        final BitMapProducer bmp2 = BitMapProducer.fromIndexProducer(ip2, getTestShape().getNumberOfBits());
+        final BitMapExtractor bmp2 = BitMapExtractor.fromIndexExtractor(ip2, getTestShape().getNumberOfBits());
         assertThrows(IllegalArgumentException.class, () -> bf7.remove(bmp2));
         assertThrows(IllegalArgumentException.class, () -> bf7.remove( new BadHasher(-1)));
         assertThrows(IllegalArgumentException.class, () -> bf7.remove( new BadHasher(getTestShape().getNumberOfBits())));
@@ -353,7 +353,7 @@ public final void testRemove() {
     @Test
     public final void testSubtract() {
         final CountingBloomFilter bf1 = createFilter(getTestShape(), TestingHashers.FROM1);
-        bf1.add(CellProducer.from(TestingHashers.FROM11.indices(getTestShape())));
+        bf1.add(CellExtractor.from(TestingHashers.FROM11.indices(getTestShape())));
 
         final CountingBloomFilter bf2 = createFilter(getTestShape(), TestingHashers.FROM11);
 
@@ -389,17 +389,17 @@ private void verifyMaxInsert(final CountingBloomFilter bf, final int from1, fina
 
         assertEquals(0, bf.getMaxInsert(new IncrementingHasher(0, 1)));
         assertEquals(0, bf.getMaxInsert(bfFrom0));
-        assertEquals(0, bf.getMaxInsert((BitMapProducer) bfFrom0));
-        assertEquals(0, bf.getMaxInsert((IndexProducer) bfFrom0));
+        assertEquals(0, bf.getMaxInsert((BitMapExtractor) bfFrom0));
+        assertEquals(0, bf.getMaxInsert((IndexExtractor) bfFrom0));
 
         assertEquals(from1, bf.getMaxInsert(TestingHashers.FROM1));
         assertEquals(from1, bf.getMaxInsert(bfFrom1));
-        assertEquals(from1, bf.getMaxInsert((BitMapProducer) bfFrom1));
-        assertEquals(from1, bf.getMaxInsert((IndexProducer) bfFrom1));
+        assertEquals(from1, bf.getMaxInsert((BitMapExtractor) bfFrom1));
+        assertEquals(from1, bf.getMaxInsert((IndexExtractor) bfFrom1));
 
         assertEquals(from11, bf.getMaxInsert(TestingHashers.FROM11));
         assertEquals(from11, bf.getMaxInsert(bfFrom11));
-        assertEquals(from11, bf.getMaxInsert((BitMapProducer) bfFrom11));
-        assertEquals(from11, bf.getMaxInsert((IndexProducer) bfFrom11));
+        assertEquals(from11, bf.getMaxInsert((BitMapExtractor) bfFrom11));
+        assertEquals(from11, bf.getMaxInsert((IndexExtractor) bfFrom11));
     }
 }
diff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractHasherTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractHasherTest.java
index 782d494513..98452c50a3 100644
--- a/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractHasherTest.java
+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractHasherTest.java
@@ -22,19 +22,19 @@
 import org.junit.jupiter.params.ParameterizedTest;
 import org.junit.jupiter.params.provider.CsvSource;
 
-public abstract class AbstractHasherTest extends AbstractIndexProducerTest {
+public abstract class AbstractHasherTest extends AbstractIndexExtractorTest {
 
     protected abstract Hasher createEmptyHasher();
 
     @Override
-    protected IndexProducer createEmptyProducer() {
+    protected IndexExtractor createEmptyExtractor() {
         return createEmptyHasher().indices(getTestShape());
     }
 
     protected abstract Hasher createHasher();
 
     @Override
-    protected IndexProducer createProducer() {
+    protected IndexExtractor createExtractor() {
         return createHasher().indices(getTestShape());
     }
 
@@ -68,7 +68,7 @@ protected final Shape getTestShape() {
     public void testHashing(final int k, final int m) {
         final int[] count = {0};
         final Hasher hasher = createHasher();
-        hasher.indices(Shape.fromKM(k, m)).forEachIndex(i -> {
+        hasher.indices(Shape.fromKM(k, m)).processIndices(i -> {
             assertTrue(i >= 0 && i < m, () -> "Out of range: " + i + ", m=" + m);
             count[0]++;
             return true;
@@ -78,7 +78,7 @@ public void testHashing(final int k, final int m) {
 
         // test early exit
         count[0] = 0;
-        hasher.indices(Shape.fromKM(k, m)).forEachIndex(i -> {
+        hasher.indices(Shape.fromKM(k, m)).processIndices(i -> {
             assertTrue(i >= 0 && i < m, () -> "Out of range: " + i + ", m=" + m);
             count[0]++;
             return false;
diff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractIndexProducerTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractIndexExtractorTest.java
similarity index 73%
rename from src/test/java/org/apache/commons/collections4/bloomfilter/AbstractIndexProducerTest.java
rename to src/test/java/org/apache/commons/collections4/bloomfilter/AbstractIndexExtractorTest.java
index c1a3d3aa30..455885014a 100644
--- a/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractIndexProducerTest.java
+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractIndexExtractorTest.java
@@ -29,9 +29,9 @@
 import org.junit.jupiter.api.Test;
 
 /**
- * Test for IndexProducer.
+ * Test for IndexExtractor.
  */
-public abstract class AbstractIndexProducerTest {
+public abstract class AbstractIndexExtractorTest {
 
     /**
      * An expandable list of int values.
@@ -66,26 +66,26 @@ int[] toArray() {
     private static final IntPredicate TRUE_PREDICATE = i -> true;
 
     private static final IntPredicate FALSE_PREDICATE = i -> false;
-    /** Flag to indicate the indices are ordered, e.g. from {@link IndexProducer#forEachIndex(IntPredicate)}. */
+    /** Flag to indicate the indices are ordered, e.g. from {@link IndexExtractor#processIndices(IntPredicate)}. */
     protected static final int ORDERED = 0x1;
 
-    /** Flag to indicate the indices are distinct, e.g. from {@link IndexProducer#forEachIndex(IntPredicate)}. */
+    /** Flag to indicate the indices are distinct, e.g. from {@link IndexExtractor#processIndices(IntPredicate)}. */
     protected static final int DISTINCT = 0x2;
 
     /**
-     * Creates an producer without data.
-     * @return a producer that has no data.
+     * Creates an extractor without data.
+     * @return an IndexExtractor that has no data.
      */
-    protected abstract IndexProducer createEmptyProducer();
+    protected abstract IndexExtractor createEmptyExtractor();
 
     /**
-     * Creates a producer with some data.
-     * @return a producer with some data
+     * Creates an extractor with some data.
+     * @return an IndexExtractor with some data
      */
-    protected abstract IndexProducer createProducer();
+    protected abstract IndexExtractor createExtractor();
 
     /**
-     * Gets the behavior of the {@link IndexProducer#asIndexArray()} method.
+     * Gets the behavior of the {@link IndexExtractor#asIndexArray()} method.
      * @return the behavior.
      * @see #ORDERED
      * @see #DISTINCT
@@ -94,13 +94,13 @@ int[] toArray() {
 
     /**
      * Creates an array of expected indices.
-     * The expected indices are dependent upon the producer created in the {@code createProducer()} method.
+     * The expected indices are dependent upon the extractor created in the {@code createExtractor()} method.
      * @return an array of expected indices.
      */
     protected abstract int[] getExpectedIndices();
 
     /**
-     * Gets the behavior of the {@link IndexProducer#forEachIndex(IntPredicate)} method.
+     * Gets the behavior of the {@link IndexExtractor#processIndices(IntPredicate)} method.
      * By default returns the value of {@code getAsIndexArrayBehaviour()} method.
      * @return the behavior.
      * @see #ORDERED
@@ -116,14 +116,14 @@ protected int getForEachIndexBehaviour() {
     @Test
     public final void testAsIndexArrayValues() {
         final BitSet bs = new BitSet();
-        Arrays.stream(createProducer().asIndexArray()).forEach(bs::set);
+        Arrays.stream(createExtractor().asIndexArray()).forEach(bs::set);
         for (final int i : getExpectedIndices()) {
             assertTrue(bs.get(i), () -> "Missing " + i);
         }
     }
 
     /**
-     * Tests the behavior of {@code IndexProducer.asIndexArray()}.
+     * Tests the behavior of {@code IndexExtractor.asIndexArray()}.
      * The expected behavior is defined by the {@code getBehaviour()} method.
      * The index array may be Ordered, Distinct or both.
      * If the index array is not distinct then all elements returned by the {@code getExpectedIndices()}
@@ -132,7 +132,7 @@ public final void testAsIndexArrayValues() {
     @Test
     public final void testBehaviourAsIndexArray() {
         final int flags = getAsIndexArrayBehaviour();
-        final int[] actual = createProducer().asIndexArray();
+        final int[] actual = createExtractor().asIndexArray();
         if ((flags & ORDERED) != 0) {
             final int[] expected = Arrays.stream(actual).sorted().toArray();
             assertArrayEquals(expected, actual);
@@ -151,15 +151,15 @@ public final void testBehaviourAsIndexArray() {
     }
 
     /**
-     * Tests the behavior of {@code IndexProducer.forEachIndex()}.
+     * Tests the behavior of {@code IndexExtractor.forEachIndex()}.
      * The expected behavior is defined by the {@code getBehaviour()} method.
-     * The order is assumed to follow the order produced by {@code IndexProducer.asIndexArray()}.
+     * The order is assumed to follow the order produced by {@code IndexExtractor.asIndexArray()}.
      */
     @Test
     public final void testBehaviourForEachIndex() {
         final int flags = getForEachIndexBehaviour();
         final IntList list = new IntList();
-        createProducer().forEachIndex(list::add);
+        createExtractor().processIndices(list::add);
         final int[] actual = list.toArray();
         if ((flags & ORDERED) != 0) {
             final int[] expected = Arrays.stream(actual).sorted().toArray();
@@ -178,15 +178,15 @@ public final void testBehaviourForEachIndex() {
     }
 
     /**
-     * Test the distinct indices output from the producer are consistent.
+     * Test the distinct indices output from the extractor are consistent.
      */
     @Test
     public final void testConsistency() {
-        final IndexProducer producer = createProducer();
+        final IndexExtractor extractor = createExtractor();
         final BitSet bs1 = new BitSet();
         final BitSet bs2 = new BitSet();
-        Arrays.stream(producer.asIndexArray()).forEach(bs1::set);
-        producer.forEachIndex(i -> {
+        Arrays.stream(extractor.asIndexArray()).forEach(bs1::set);
+        extractor.processIndices(i -> {
             bs2.set(i);
             return true;
         });
@@ -194,24 +194,24 @@ public final void testConsistency() {
     }
 
     @Test
-    public final void testEmptyProducer() {
-        final IndexProducer empty = createEmptyProducer();
+    public final void testEmptyExtractor() {
+        final IndexExtractor empty = createEmptyExtractor();
         final int[] ary = empty.asIndexArray();
         assertEquals(0, ary.length);
-        assertTrue(empty.forEachIndex(i -> {
-            throw new AssertionError("forEach predictate should not be called");
+        assertTrue(empty.processIndices(i -> {
+            throw new AssertionError("processIndices predictate should not be called");
         }));
     }
 
     /**
-     * Test to ensure that for each index returns each expected index at least once.
+     * Test to ensure that processIndices returns each expected index at least once.
      */
     @Test
     public final void testForEachIndex() {
         final BitSet bs1 = new BitSet();
         final BitSet bs2 = new BitSet();
         Arrays.stream(getExpectedIndices()).forEach(bs1::set);
-        createProducer().forEachIndex(i -> {
+        createExtractor().processIndices(i -> {
             bs2.set(i);
             return true;
         });
@@ -221,14 +221,14 @@ public final void testForEachIndex() {
     @Test
     public void testForEachIndexEarlyExit() {
         final int[] passes = new int[1];
-        assertFalse(createProducer().forEachIndex(i -> {
+        assertFalse(createExtractor().processIndices(i -> {
             passes[0]++;
             return false;
         }));
         assertEquals(1, passes[0]);
 
         passes[0] = 0;
-        assertTrue(createEmptyProducer().forEachIndex(i -> {
+        assertTrue(createEmptyExtractor().processIndices(i -> {
             passes[0]++;
             return false;
         }));
@@ -237,19 +237,19 @@ public void testForEachIndexEarlyExit() {
 
     @Test
     public final void testForEachIndexPredicates() {
-        final IndexProducer populated = createProducer();
-        final IndexProducer empty = createEmptyProducer();
+        final IndexExtractor populated = createExtractor();
+        final IndexExtractor empty = createEmptyExtractor();
 
-        assertFalse(populated.forEachIndex(FALSE_PREDICATE), "non-empty should be false");
-        assertTrue(empty.forEachIndex(FALSE_PREDICATE), "empty should be true");
+        assertFalse(populated.processIndices(FALSE_PREDICATE), "non-empty should be false");
+        assertTrue(empty.processIndices(FALSE_PREDICATE), "empty should be true");
 
-        assertTrue(populated.forEachIndex(TRUE_PREDICATE), "non-empty should be true");
-        assertTrue(empty.forEachIndex(TRUE_PREDICATE), "empty should be true");
+        assertTrue(populated.processIndices(TRUE_PREDICATE), "non-empty should be true");
+        assertTrue(empty.processIndices(TRUE_PREDICATE), "empty should be true");
     }
 
     @Test
     public void testUniqueReturnsSelf() {
-        final IndexProducer expected = createProducer().uniqueIndices();
+        final IndexExtractor expected = createExtractor().uniqueIndices();
         assertSame(expected, expected.uniqueIndices());
     }
 }
diff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/ArrayHasher.java b/src/test/java/org/apache/commons/collections4/bloomfilter/ArrayHasher.java
index 239947e7ee..f65fdadf16 100644
--- a/src/test/java/org/apache/commons/collections4/bloomfilter/ArrayHasher.java
+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/ArrayHasher.java
@@ -25,15 +25,15 @@
  * <p>To be used for testing only.</p>
  */
 public final class ArrayHasher implements Hasher {
-    private final class Producer implements IndexProducer {
+    private final class Extractor implements IndexExtractor {
         Shape shape;
 
-        Producer(final Shape shape) {
+        Extractor(final Shape shape) {
             this.shape = shape;
         }
 
         @Override
-        public boolean forEachIndex(final IntPredicate consumer) {
+        public boolean processIndices(final IntPredicate consumer) {
             Objects.requireNonNull(consumer, "consumer");
 
             int pos = 0;
@@ -55,8 +55,8 @@ public ArrayHasher(final int... values) {
     }
 
     @Override
-    public IndexProducer indices(final Shape shape) {
+    public IndexExtractor indices(final Shape shape) {
         Objects.requireNonNull(shape, "shape");
-        return new Producer(shape);
+        return new Extractor(shape);
     }
 }
diff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/BitMapProducerFromArrayCountingBloomFilterTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/BitMapExtractorFromArrayCountingBloomFilterTest.java
similarity index 85%
rename from src/test/java/org/apache/commons/collections4/bloomfilter/BitMapProducerFromArrayCountingBloomFilterTest.java
rename to src/test/java/org/apache/commons/collections4/bloomfilter/BitMapExtractorFromArrayCountingBloomFilterTest.java
index 63ec52a667..e7c341bcf7 100644
--- a/src/test/java/org/apache/commons/collections4/bloomfilter/BitMapProducerFromArrayCountingBloomFilterTest.java
+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/BitMapExtractorFromArrayCountingBloomFilterTest.java
@@ -16,17 +16,17 @@
  */
 package org.apache.commons.collections4.bloomfilter;
 
-public class BitMapProducerFromArrayCountingBloomFilterTest extends AbstractBitMapProducerTest {
+public class BitMapExtractorFromArrayCountingBloomFilterTest extends AbstractBitMapExtractorTest {
 
     protected Shape shape = Shape.fromKM(17, 72);
 
     @Override
-    protected BitMapProducer createEmptyProducer() {
+    protected BitMapExtractor createEmptyExtractor() {
         return new ArrayCountingBloomFilter(shape);
     }
 
     @Override
-    protected BitMapProducer createProducer() {
+    protected BitMapExtractor createExtractor() {
         final ArrayCountingBloomFilter filter = new ArrayCountingBloomFilter(shape);
         final Hasher hasher = new IncrementingHasher(0, 1);
         filter.merge(hasher);
diff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/BitMapProducerFromIndexProducerTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/BitMapExtractorFromIndexExtractorTest.java
similarity index 57%
rename from src/test/java/org/apache/commons/collections4/bloomfilter/BitMapProducerFromIndexProducerTest.java
rename to src/test/java/org/apache/commons/collections4/bloomfilter/BitMapExtractorFromIndexExtractorTest.java
index 38b336cbde..e0a91ea79d 100644
--- a/src/test/java/org/apache/commons/collections4/bloomfilter/BitMapProducerFromIndexProducerTest.java
+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/BitMapExtractorFromIndexExtractorTest.java
@@ -23,31 +23,31 @@
 
 import org.junit.jupiter.api.Test;
 
-public class BitMapProducerFromIndexProducerTest extends AbstractBitMapProducerTest {
+public class BitMapExtractorFromIndexExtractorTest extends AbstractBitMapExtractorTest {
 
     @Override
-    protected BitMapProducer createEmptyProducer() {
-        final IndexProducer iProducer = consumer -> true;
-        return BitMapProducer.fromIndexProducer(iProducer, 200);
+    protected BitMapExtractor createEmptyExtractor() {
+        final IndexExtractor indexExtractor = consumer -> true;
+        return BitMapExtractor.fromIndexExtractor(indexExtractor, 200);
     }
 
     @Override
-    protected BitMapProducer createProducer() {
-        final IndexProducer iProducer = consumer -> consumer.test(0) && consumer.test(1) && consumer.test(63) && consumer.test(64)
+    protected BitMapExtractor createExtractor() {
+        final IndexExtractor indexExtractor = consumer -> consumer.test(0) && consumer.test(1) && consumer.test(63) && consumer.test(64)
                 && consumer.test(127) && consumer.test(128);
-        return BitMapProducer.fromIndexProducer(iProducer, 200);
+        return BitMapExtractor.fromIndexExtractor(indexExtractor, 200);
     }
 
     @Test
-    public final void testFromIndexProducer() {
+    public final void testFromIndexExtractor() {
         final List<Long> lst = new ArrayList<>();
-        createProducer().forEachBitMap(lst::add);
+        createExtractor().processBitMaps(lst::add);
         final long[] buckets = lst.stream().mapToLong(Long::longValue).toArray();
-        assertTrue(BitMap.contains(buckets, 0));
-        assertTrue(BitMap.contains(buckets, 1));
-        assertTrue(BitMap.contains(buckets, 63));
-        assertTrue(BitMap.contains(buckets, 64));
-        assertTrue(BitMap.contains(buckets, 127));
-        assertTrue(BitMap.contains(buckets, 128));
+        assertTrue(BitMaps.contains(buckets, 0));
+        assertTrue(BitMaps.contains(buckets, 1));
+        assertTrue(BitMaps.contains(buckets, 63));
+        assertTrue(BitMaps.contains(buckets, 64));
+        assertTrue(BitMaps.contains(buckets, 127));
+        assertTrue(BitMaps.contains(buckets, 128));
     }
 }
diff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/BitMapProducerFromLayeredBloomFilterTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/BitMapExtractorFromLayeredBloomFilterTest.java
similarity index 85%
rename from src/test/java/org/apache/commons/collections4/bloomfilter/BitMapProducerFromLayeredBloomFilterTest.java
rename to src/test/java/org/apache/commons/collections4/bloomfilter/BitMapExtractorFromLayeredBloomFilterTest.java
index 246ef518cc..b191aa09a6 100644
--- a/src/test/java/org/apache/commons/collections4/bloomfilter/BitMapProducerFromLayeredBloomFilterTest.java
+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/BitMapExtractorFromLayeredBloomFilterTest.java
@@ -16,17 +16,17 @@
  */
 package org.apache.commons.collections4.bloomfilter;
 
-public class BitMapProducerFromLayeredBloomFilterTest extends AbstractBitMapProducerTest {
+public class BitMapExtractorFromLayeredBloomFilterTest extends AbstractBitMapExtractorTest {
 
     protected Shape shape = Shape.fromKM(17, 72);
 
     @Override
-    protected BitMapProducer createEmptyProducer() {
+    protected BitMapExtractor createEmptyExtractor() {
         return LayeredBloomFilterTest.fixed(shape, 10);
     }
 
     @Override
-    protected BitMapProducer createProducer() {
+    protected BitMapExtractor createExtractor() {
         final Hasher hasher = new IncrementingHasher(0, 1);
         final BloomFilter bf = LayeredBloomFilterTest.fixed(shape, 10);
         bf.merge(hasher);
diff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/BitMapProducerFromLongArrayTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/BitMapExtractorFromLongArrayTest.java
similarity index 77%
rename from src/test/java/org/apache/commons/collections4/bloomfilter/BitMapProducerFromLongArrayTest.java
rename to src/test/java/org/apache/commons/collections4/bloomfilter/BitMapExtractorFromLongArrayTest.java
index 165ea404c0..7a2c684613 100644
--- a/src/test/java/org/apache/commons/collections4/bloomfilter/BitMapProducerFromLongArrayTest.java
+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/BitMapExtractorFromLongArrayTest.java
@@ -23,12 +23,12 @@
 
 import org.junit.jupiter.api.Test;
 
-public class BitMapProducerFromLongArrayTest extends AbstractBitMapProducerTest {
+public class BitMapExtractorFromLongArrayTest extends AbstractBitMapExtractorTest {
 
     @Test
     public void constructorTest() {
         final List<Long> lst = new ArrayList<>();
-        createProducer().forEachBitMap(lst::add);
+        createExtractor().processBitMaps(lst::add);
         assertEquals(Long.valueOf(1), lst.get(0));
         assertEquals(Long.valueOf(2), lst.get(1));
         assertEquals(Long.valueOf(3), lst.get(2));
@@ -37,14 +37,14 @@ public void constructorTest() {
     }
 
     @Override
-    protected BitMapProducer createEmptyProducer() {
-        return BitMapProducer.fromBitMapArray();
+    protected BitMapExtractor createEmptyExtractor() {
+        return BitMapExtractor.fromBitMapArray();
     }
 
     @Override
-    protected BitMapProducer createProducer() {
+    protected BitMapExtractor createExtractor() {
         final long[] ary = {1L, 2L, 3L, 4L, 5L};
-        return BitMapProducer.fromBitMapArray(ary);
+        return BitMapExtractor.fromBitMapArray(ary);
     }
 
     @Override
@@ -53,9 +53,9 @@ protected boolean emptyIsZeroLength() {
     }
 
     @Test
-    public void testFromIndexProducer() {
+    public void testFromIndexExtractor() {
         final int limit = Integer.SIZE + Long.SIZE;
-        final IndexProducer iProducer = consumer -> {
+        final IndexExtractor indexExtractor = consumer -> {
             for (int i = 0; i < limit; i++) {
                 if (!consumer.test(i)) {
                     return false;
@@ -63,9 +63,9 @@ public void testFromIndexProducer() {
             }
             return true;
         };
-        final BitMapProducer producer = BitMapProducer.fromIndexProducer(iProducer, limit);
+        final BitMapExtractor bitMapExtractor = BitMapExtractor.fromIndexExtractor(indexExtractor, limit);
         final List<Long> lst = new ArrayList<>();
-        producer.forEachBitMap(lst::add);
+        bitMapExtractor.processBitMaps(lst::add);
         long expected = ~0L;
         assertEquals(expected, lst.get(0).longValue());
         expected &= 0XFFFFFFFFL;
diff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/BitMapProducerFromSimpleBloomFilterTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/BitMapExtractorFromSimpleBloomFilterTest.java
similarity index 85%
rename from src/test/java/org/apache/commons/collections4/bloomfilter/BitMapProducerFromSimpleBloomFilterTest.java
rename to src/test/java/org/apache/commons/collections4/bloomfilter/BitMapExtractorFromSimpleBloomFilterTest.java
index 8e1d2ca202..5ed9acdad0 100644
--- a/src/test/java/org/apache/commons/collections4/bloomfilter/BitMapProducerFromSimpleBloomFilterTest.java
+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/BitMapExtractorFromSimpleBloomFilterTest.java
@@ -16,17 +16,17 @@
  */
 package org.apache.commons.collections4.bloomfilter;
 
-public class BitMapProducerFromSimpleBloomFilterTest extends AbstractBitMapProducerTest {
+public class BitMapExtractorFromSimpleBloomFilterTest extends AbstractBitMapExtractorTest {
 
     protected Shape shape = Shape.fromKM(17, 72);
 
     @Override
-    protected BitMapProducer createEmptyProducer() {
+    protected BitMapExtractor createEmptyExtractor() {
         return new SimpleBloomFilter(shape);
     }
 
     @Override
-    protected BitMapProducer createProducer() {
+    protected BitMapExtractor createExtractor() {
         final Hasher hasher = new IncrementingHasher(0, 1);
         final BloomFilter bf = new SimpleBloomFilter(shape);
         bf.merge(hasher);
diff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/BitMapProducerFromSparseBloomFilterTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/BitMapExtractorFromSparseBloomFilterTest.java
similarity index 85%
rename from src/test/java/org/apache/commons/collections4/bloomfilter/BitMapProducerFromSparseBloomFilterTest.java
rename to src/test/java/org/apache/commons/collections4/bloomfilter/BitMapExtractorFromSparseBloomFilterTest.java
index 6c15eda45d..638a0350f0 100644
--- a/src/test/java/org/apache/commons/collections4/bloomfilter/BitMapProducerFromSparseBloomFilterTest.java
+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/BitMapExtractorFromSparseBloomFilterTest.java
@@ -16,17 +16,17 @@
  */
 package org.apache.commons.collections4.bloomfilter;
 
-public class BitMapProducerFromSparseBloomFilterTest extends AbstractBitMapProducerTest {
+public class BitMapExtractorFromSparseBloomFilterTest extends AbstractBitMapExtractorTest {
 
     protected Shape shape = Shape.fromKM(17, 72);
 
     @Override
-    protected BitMapProducer createEmptyProducer() {
+    protected BitMapExtractor createEmptyExtractor() {
         return new SparseBloomFilter(shape);
     }
 
     @Override
-    protected BitMapProducer createProducer() {
+    protected BitMapExtractor createExtractor() {
         final Hasher hasher = new IncrementingHasher(0, 1);
         final BloomFilter bf = new SparseBloomFilter(shape);
         bf.merge(hasher);
diff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/BitMapProducerFromWrappedBloomFilterTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/BitMapExtractorFromWrappedBloomFilterTest.java
similarity index 90%
rename from src/test/java/org/apache/commons/collections4/bloomfilter/BitMapProducerFromWrappedBloomFilterTest.java
rename to src/test/java/org/apache/commons/collections4/bloomfilter/BitMapExtractorFromWrappedBloomFilterTest.java
index 9716dd4082..4040efb95f 100644
--- a/src/test/java/org/apache/commons/collections4/bloomfilter/BitMapProducerFromWrappedBloomFilterTest.java
+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/BitMapExtractorFromWrappedBloomFilterTest.java
@@ -16,12 +16,12 @@
  */
 package org.apache.commons.collections4.bloomfilter;
 
-public class BitMapProducerFromWrappedBloomFilterTest extends AbstractBitMapProducerTest {
+public class BitMapExtractorFromWrappedBloomFilterTest extends AbstractBitMapExtractorTest {
 
     protected Shape shape = Shape.fromKM(17, 72);
 
     @Override
-    protected BitMapProducer createEmptyProducer() {
+    protected BitMapExtractor createEmptyExtractor() {
         return new WrappedBloomFilter(new DefaultBloomFilterTest.SparseDefaultBloomFilter(shape)) {
             @Override
             public BloomFilter copy() {
@@ -33,7 +33,7 @@ public BloomFilter copy() {
     }
 
     @Override
-    protected BitMapProducer createProducer() {
+    protected BitMapExtractor createExtractor() {
         final Hasher hasher = new IncrementingHasher(0, 1);
         final BloomFilter bf = new WrappedBloomFilter(new DefaultBloomFilterTest.SparseDefaultBloomFilter(shape)) {
             @Override
diff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/BitMapTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/BitMapsTest.java
similarity index 64%
rename from src/test/java/org/apache/commons/collections4/bloomfilter/BitMapTest.java
rename to src/test/java/org/apache/commons/collections4/bloomfilter/BitMapsTest.java
index 2997a8683d..274614f01e 100644
--- a/src/test/java/org/apache/commons/collections4/bloomfilter/BitMapTest.java
+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/BitMapsTest.java
@@ -24,10 +24,10 @@
 
 import org.junit.jupiter.api.Test;
 
-public class BitMapTest {
+public class BitMapsTest {
 
     /**
-     * Assert the {@link BitMap#mod(long, int)} method functions as an unsigned modulus.
+     * Assert the {@link BitMaps#mod(long, int)} method functions as an unsigned modulus.
      *
      * @param dividend the dividend
      * @param divisor the divisor
@@ -35,7 +35,7 @@ public class BitMapTest {
     private void assertMod(final long dividend, final int divisor) {
         assertTrue(divisor > 0 && divisor <= Integer.MAX_VALUE,
             "Incorrect usage. Divisor must be strictly positive.");
-        assertEquals((int) Long.remainderUnsigned(dividend, divisor), BitMap.mod(dividend, divisor),
+        assertEquals((int) Long.remainderUnsigned(dividend, divisor), BitMaps.mod(dividend, divisor),
             () -> String.format("failure with dividend=%s and divisor=%s.", dividend, divisor));
     }
 
@@ -45,12 +45,12 @@ public final void testContains() {
 
         for (int i = 0; i < 64; i++) {
             bitMaps[0] = 0L;
-            BitMap.set(bitMaps, i);
+            BitMaps.set(bitMaps, i);
             for (int j = 0; j < 64; j++) {
                 if (j == i) {
-                    assertTrue(BitMap.contains(bitMaps, j), String.format("Failed at index: %d for %d", i, j));
+                    assertTrue(BitMaps.contains(bitMaps, j), String.format("Failed at index: %d for %d", i, j));
                 } else {
-                    assertFalse(BitMap.contains(bitMaps, j), String.format("Failed at index %d for %d", i, j));
+                    assertFalse(BitMaps.contains(bitMaps, j), String.format("Failed at index %d for %d", i, j));
                 }
             }
         }
@@ -59,38 +59,38 @@ public final void testContains() {
         long[] ary = new long[1];
 
         final long[] aryT = ary;
-        assertThrows(ArrayIndexOutOfBoundsException.class, () -> BitMap.contains(aryT, -1));
-        assertFalse(BitMap.contains(ary, 0));
+        assertThrows(ArrayIndexOutOfBoundsException.class, () -> BitMaps.contains(aryT, -1));
+        assertFalse(BitMaps.contains(ary, 0));
         ary[0] = 0x01;
-        assertTrue(BitMap.contains(ary, 0));
+        assertTrue(BitMaps.contains(ary, 0));
 
-        assertFalse(BitMap.contains(ary, 63));
+        assertFalse(BitMaps.contains(ary, 63));
         ary[0] = 1L << 63;
-        assertTrue(BitMap.contains(ary, 63));
-        assertThrows(ArrayIndexOutOfBoundsException.class, () -> BitMap.contains(aryT, 64));
+        assertTrue(BitMaps.contains(ary, 63));
+        assertThrows(ArrayIndexOutOfBoundsException.class, () -> BitMaps.contains(aryT, 64));
 
         ary = new long[2];
-        assertFalse(BitMap.contains(ary, 64));
+        assertFalse(BitMaps.contains(ary, 64));
         ary[1] = 1;
-        assertTrue(BitMap.contains(ary, 64));
+        assertTrue(BitMaps.contains(ary, 64));
     }
 
     @Test
     public final void testGetLongBit() {
-        assertEquals(1, BitMap.getLongBit(0));
-        assertEquals(0x8000000000000000L, BitMap.getLongBit(63));
-        assertEquals(1, BitMap.getLongBit(64));
-        assertEquals(0x8000000000000000L, BitMap.getLongBit(127));
-        assertEquals(1, BitMap.getLongBit(128));
+        assertEquals(1, BitMaps.getLongBit(0));
+        assertEquals(0x8000000000000000L, BitMaps.getLongBit(63));
+        assertEquals(1, BitMaps.getLongBit(64));
+        assertEquals(0x8000000000000000L, BitMaps.getLongBit(127));
+        assertEquals(1, BitMaps.getLongBit(128));
     }
 
     @Test
     public final void testGetLongIndex() {
-        assertEquals(0, BitMap.getLongIndex(0));
-        assertEquals(0, BitMap.getLongIndex(63));
-        assertEquals(1, BitMap.getLongIndex(64));
-        assertEquals(1, BitMap.getLongIndex(127));
-        assertEquals(2, BitMap.getLongIndex(128));
+        assertEquals(0, BitMaps.getLongIndex(0));
+        assertEquals(0, BitMaps.getLongIndex(63));
+        assertEquals(1, BitMaps.getLongIndex(64));
+        assertEquals(1, BitMaps.getLongIndex(127));
+        assertEquals(2, BitMaps.getLongIndex(128));
     }
 
     @Test
@@ -106,29 +106,29 @@ public void testMod() {
     @Test
     public void testModEdgeCases() {
         for (final long dividend : new long[] {0, -1, 1, Long.MAX_VALUE}) {
-            assertThrows(ArithmeticException.class, () -> BitMap.mod(dividend, 0));
+            assertThrows(ArithmeticException.class, () -> BitMaps.mod(dividend, 0));
         }
-        assertNotEquals(Math.floorMod(5, -1), BitMap.mod(5, -1));
+        assertNotEquals(Math.floorMod(5, -1), BitMaps.mod(5, -1));
     }
 
     @Test
     public final void testNumberOfBitMaps() {
-        assertEquals(0, BitMap.numberOfBitMaps(0), "Number of bits 0");
+        assertEquals(0, BitMaps.numberOfBitMaps(0), "Number of bits 0");
         for (int i = 1; i < 65; i++) {
-            assertEquals(1, BitMap.numberOfBitMaps(i), String.format("Number of bits %d", i));
+            assertEquals(1, BitMaps.numberOfBitMaps(i), String.format("Number of bits %d", i));
         }
         for (int i = 65; i < 129; i++) {
-            assertEquals(2, BitMap.numberOfBitMaps(i), String.format("Number of bits %d", i));
+            assertEquals(2, BitMaps.numberOfBitMaps(i), String.format("Number of bits %d", i));
         }
-        assertEquals(3, BitMap.numberOfBitMaps(129), "Number of bits 129");
+        assertEquals(3, BitMaps.numberOfBitMaps(129), "Number of bits 129");
     }
 
     @Test
     public final void testSet() {
-        final long[] bitMaps = new long[BitMap.numberOfBitMaps(129)];
+        final long[] bitMaps = new long[BitMaps.numberOfBitMaps(129)];
         for (int i = 0; i < 129; i++) {
-            BitMap.set(bitMaps, i);
-            assertTrue(BitMap.contains(bitMaps, i), String.format("Failed at index: %d", i));
+            BitMaps.set(bitMaps, i);
+            assertTrue(BitMaps.contains(bitMaps, i), String.format("Failed at index: %d", i));
         }
         assertEquals(0xFFFFFFFFFFFFFFFFL, bitMaps[0]);
         assertEquals(0xFFFFFFFFFFFFFFFFL, bitMaps[1]);
diff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/BloomFilterProducerFromLayeredBloomFilterTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/BloomFilteExtractorFromLayeredBloomFilterTest.java
similarity index 88%
rename from src/test/java/org/apache/commons/collections4/bloomfilter/BloomFilterProducerFromLayeredBloomFilterTest.java
rename to src/test/java/org/apache/commons/collections4/bloomfilter/BloomFilteExtractorFromLayeredBloomFilterTest.java
index 1c298f80ee..f66522d29d 100644
--- a/src/test/java/org/apache/commons/collections4/bloomfilter/BloomFilterProducerFromLayeredBloomFilterTest.java
+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/BloomFilteExtractorFromLayeredBloomFilterTest.java
@@ -16,10 +16,10 @@
  */
 package org.apache.commons.collections4.bloomfilter;
 
-public class BloomFilterProducerFromLayeredBloomFilterTest extends AbstractBloomFilterProducerTest {
+public class BloomFilteExtractorFromLayeredBloomFilterTest extends AbstractBloomFilterExtractorTest {
 
     @Override
-    protected BloomFilterProducer createUnderTest(final BloomFilter... filters) {
+    protected BloomFilterExtractor createUnderTest(final BloomFilter... filters) {
         final Shape shape = filters[0].getShape();
         final LayerManager layerManager = LayerManager.builder().setSupplier(() -> new SimpleBloomFilter(shape))
                 .setExtendCheck(LayerManager.ExtendCheck.advanceOnPopulated()).setCleanup(LayerManager.Cleanup.noCleanup()).build();
diff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/BloomFilterProducerFromBloomFilterArrayTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/BloomFilterExtractorFromBloomFilterArrayTest.java
similarity index 77%
rename from src/test/java/org/apache/commons/collections4/bloomfilter/BloomFilterProducerFromBloomFilterArrayTest.java
rename to src/test/java/org/apache/commons/collections4/bloomfilter/BloomFilterExtractorFromBloomFilterArrayTest.java
index f18025e5b3..c3419335d5 100644
--- a/src/test/java/org/apache/commons/collections4/bloomfilter/BloomFilterProducerFromBloomFilterArrayTest.java
+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/BloomFilterExtractorFromBloomFilterArrayTest.java
@@ -16,10 +16,10 @@
  */
 package org.apache.commons.collections4.bloomfilter;
 
-public class BloomFilterProducerFromBloomFilterArrayTest extends AbstractBloomFilterProducerTest {
+public class BloomFilterExtractorFromBloomFilterArrayTest extends AbstractBloomFilterExtractorTest {
 
     @Override
-    protected BloomFilterProducer createUnderTest(final BloomFilter... filters) {
-        return BloomFilterProducer.fromBloomFilterArray(filters);
+    protected BloomFilterExtractor createUnderTest(final BloomFilter... filters) {
+        return BloomFilterExtractor.fromBloomFilterArray(filters);
     }
 }
diff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/CellProducerFromArrayCountingBloomFilterTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/CellExtractorFromArrayCountingBloomFilterTest.java
similarity index 88%
rename from src/test/java/org/apache/commons/collections4/bloomfilter/CellProducerFromArrayCountingBloomFilterTest.java
rename to src/test/java/org/apache/commons/collections4/bloomfilter/CellExtractorFromArrayCountingBloomFilterTest.java
index 7f054fcc60..43571a17f0 100644
--- a/src/test/java/org/apache/commons/collections4/bloomfilter/CellProducerFromArrayCountingBloomFilterTest.java
+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/CellExtractorFromArrayCountingBloomFilterTest.java
@@ -16,17 +16,17 @@
  */
 package org.apache.commons.collections4.bloomfilter;
 
-public class CellProducerFromArrayCountingBloomFilterTest extends AbstractCellProducerTest {
+public class CellExtractorFromArrayCountingBloomFilterTest extends AbstractCellExtractorTest {
 
     protected Shape shape = Shape.fromKM(17, 72);
 
     @Override
-    protected CellProducer createEmptyProducer() {
+    protected CellExtractor createEmptyExtractor() {
         return new ArrayCountingBloomFilter(shape);
     }
 
     @Override
-    protected CellProducer createProducer() {
+    protected CellExtractor createExtractor() {
         final ArrayCountingBloomFilter filter = new ArrayCountingBloomFilter(shape);
         filter.merge(new IncrementingHasher(0, 1));
         filter.merge(new IncrementingHasher(5, 1));
diff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/CellProducerFromDefaultIndexProducerTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/CellExtractorFromDefaultIndexExtractorTest.java
similarity index 78%
rename from src/test/java/org/apache/commons/collections4/bloomfilter/CellProducerFromDefaultIndexProducerTest.java
rename to src/test/java/org/apache/commons/collections4/bloomfilter/CellExtractorFromDefaultIndexExtractorTest.java
index c8a819c55f..3543fb39ab 100644
--- a/src/test/java/org/apache/commons/collections4/bloomfilter/CellProducerFromDefaultIndexProducerTest.java
+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/CellExtractorFromDefaultIndexExtractorTest.java
@@ -16,20 +16,20 @@
  */
 package org.apache.commons.collections4.bloomfilter;
 
-public class CellProducerFromDefaultIndexProducerTest extends AbstractCellProducerTest {
+public class CellExtractorFromDefaultIndexExtractorTest extends AbstractCellExtractorTest {
 
     int[] data = {0, 63, 1, 64, 128, 1, 127};
     int[] indices = {0, 1, 63, 64, 127, 128};
     int[] values = {1, 2, 1, 1, 1, 1 };
 
     @Override
-    protected CellProducer createEmptyProducer() {
-        return CellProducer.from(IndexProducer.fromIndexArray());
+    protected CellExtractor createEmptyExtractor() {
+        return CellExtractor.from(IndexExtractor.fromIndexArray());
     }
 
     @Override
-    protected CellProducer createProducer() {
-        return CellProducer.from(IndexProducer.fromIndexArray(data));
+    protected CellExtractor createExtractor() {
+        return CellExtractor.from(IndexExtractor.fromIndexArray(data));
     }
 
     @Override
diff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/CellProducerFromLayeredBloomFilterTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/CellExtractorFromLayeredBloomFilterTest.java
similarity index 82%
rename from src/test/java/org/apache/commons/collections4/bloomfilter/CellProducerFromLayeredBloomFilterTest.java
rename to src/test/java/org/apache/commons/collections4/bloomfilter/CellExtractorFromLayeredBloomFilterTest.java
index ad3fa8c1c0..7b0b001458 100644
--- a/src/test/java/org/apache/commons/collections4/bloomfilter/CellProducerFromLayeredBloomFilterTest.java
+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/CellExtractorFromLayeredBloomFilterTest.java
@@ -16,21 +16,21 @@
  */
 package org.apache.commons.collections4.bloomfilter;
 
-public class CellProducerFromLayeredBloomFilterTest extends AbstractCellProducerTest {
+public class CellExtractorFromLayeredBloomFilterTest extends AbstractCellExtractorTest {
 
     protected Shape shape = Shape.fromKM(17, 72);
 
     @Override
-    protected CellProducer createEmptyProducer() {
-        return CellProducer.from(LayeredBloomFilterTest.fixed(shape, 10));
+    protected CellExtractor createEmptyExtractor() {
+        return CellExtractor.from(LayeredBloomFilterTest.fixed(shape, 10));
     }
 
     @Override
-    protected CellProducer createProducer() {
+    protected CellExtractor createExtractor() {
         final Hasher hasher = new IncrementingHasher(3, 2);
         final BloomFilter bf = LayeredBloomFilterTest.fixed(shape, 10);
         bf.merge(hasher);
-        return CellProducer.from(bf);
+        return CellExtractor.from(bf);
     }
 
     @Override
diff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/CountingPredicateTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/CountingPredicateTest.java
index 2e925db0a4..59ba2bfc65 100644
--- a/src/test/java/org/apache/commons/collections4/bloomfilter/CountingPredicateTest.java
+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/CountingPredicateTest.java
@@ -55,17 +55,17 @@ public void testPredicateLonger() {
         assertTrue(cp.test(Integer.valueOf(3)));
         assertEquals(expected, result);
         expected.add(Pair.of(2, null));
-        assertTrue(cp.forEachRemaining());
+        assertTrue(cp.processRemaining());
         assertEquals(expected, result);
 
         // if the other array is zero length then cp.test() will not be called so
-        // we can just call cp.forEachRemaining() here.
+        // we can just call cp.processRemaining() here.
         expected.clear();
         expected.add(Pair.of(1, null));
         expected.add(Pair.of(2, null));
         result.clear();
         cp = new CountingPredicate<>(ary, makeFunc((x, y) -> x != null, result));
-        assertTrue(cp.forEachRemaining());
+        assertTrue(cp.processRemaining());
         assertEquals(expected, result);
 
         // If a test fails then the result should be false and the rest of the list should
@@ -74,7 +74,7 @@ public void testPredicateLonger() {
         expected.add(Pair.of(1, null));
         result.clear();
         cp = new CountingPredicate<>(ary, makeFunc((x, y) -> x == Integer.valueOf(1), result));
-        assertFalse(cp.forEachRemaining());
+        assertFalse(cp.processRemaining());
         assertEquals(expected, result);
     }
 
@@ -92,7 +92,7 @@ public void testPredicateSameLength() {
         assertTrue(cp.test(3));
         assertTrue(cp.test(3));
         assertEquals(expected, result);
-        assertTrue(cp.forEachRemaining());
+        assertTrue(cp.processRemaining());
         assertEquals(expected, result);
     }
 
@@ -112,7 +112,7 @@ public void testPredicateShorter() {
             assertTrue(cp.test(i));
         }
         assertEquals(expected, result);
-        assertTrue(cp.forEachRemaining());
+        assertTrue(cp.processRemaining());
         assertEquals(expected, result);
     }
 }
diff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/DefaultBitMapProducerTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/DefaultBitMapExtractorTest.java
similarity index 68%
rename from src/test/java/org/apache/commons/collections4/bloomfilter/DefaultBitMapProducerTest.java
rename to src/test/java/org/apache/commons/collections4/bloomfilter/DefaultBitMapExtractorTest.java
index 3f45b81456..d0a5e20c9a 100644
--- a/src/test/java/org/apache/commons/collections4/bloomfilter/DefaultBitMapProducerTest.java
+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/DefaultBitMapExtractorTest.java
@@ -24,17 +24,17 @@
 
 import org.junit.jupiter.api.Test;
 
-public class DefaultBitMapProducerTest extends AbstractBitMapProducerTest {
+public class DefaultBitMapExtractorTest extends AbstractBitMapExtractorTest {
 
-    class DefaultBitMapProducer implements BitMapProducer {
+    class DefaultBitMapExtractor implements BitMapExtractor {
         long[] bitMaps;
 
-        DefaultBitMapProducer(final long[] bitMaps) {
+        DefaultBitMapExtractor(final long[] bitMaps) {
             this.bitMaps = bitMaps;
         }
 
         @Override
-        public boolean forEachBitMap(final LongPredicate predicate) {
+        public boolean processBitMaps(final LongPredicate predicate) {
             for (final long bitmap : bitMaps) {
                 if (!predicate.test(bitmap)) {
                     return false;
@@ -56,13 +56,13 @@ static long[] generateLongArray(final int size) {
     long[] values = generateLongArray(5);
 
     @Override
-    protected BitMapProducer createEmptyProducer() {
-        return new DefaultBitMapProducer(new long[0]);
+    protected BitMapExtractor createEmptyExtractor() {
+        return new DefaultBitMapExtractor(new long[0]);
     }
 
     @Override
-    protected BitMapProducer createProducer() {
-        return new DefaultBitMapProducer(values);
+    protected BitMapExtractor createExtractor() {
+        return new DefaultBitMapExtractor(values);
     }
 
     @Override
@@ -73,7 +73,7 @@ protected boolean emptyIsZeroLength() {
     @Test
     public void testAsBitMapArrayLargeArray() {
         final long[] expected = generateLongArray(32);
-        final BitMapProducer producer = predicate -> {
+        final BitMapExtractor bitMapExtractor = predicate -> {
             for (final long l : expected) {
                 if (!predicate.test(l)) {
                     return false;
@@ -81,25 +81,25 @@ public void testAsBitMapArrayLargeArray() {
             }
             return true;
         };
-        final long[] ary = producer.asBitMapArray();
+        final long[] ary = bitMapExtractor.asBitMapArray();
         assertArrayEquals(expected, ary);
     }
 
     @Test
     public void testFromBitMapArray() {
-        final int nOfBitMaps = BitMap.numberOfBitMaps(256);
+        final int nOfBitMaps = BitMaps.numberOfBitMaps(256);
         final long[] expected = generateLongArray(nOfBitMaps);
-        final long[] ary = BitMapProducer.fromBitMapArray(expected).asBitMapArray();
+        final long[] ary = BitMapExtractor.fromBitMapArray(expected).asBitMapArray();
         assertArrayEquals(expected, ary);
     }
 
     @Test
-    public void testFromIndexProducer() {
-        final int[] expected = DefaultIndexProducerTest.generateIntArray(10, 256);
-        final IndexProducer ip = IndexProducer.fromIndexArray(expected);
-        final long[] ary = BitMapProducer.fromIndexProducer(ip, 256).asBitMapArray();
+    public void testFromIndexExtractor() {
+        final int[] expected = DefaultIndexExtractorTest.generateIntArray(10, 256);
+        final IndexExtractor indexExtractor = IndexExtractor.fromIndexArray(expected);
+        final long[] ary = BitMapExtractor.fromIndexExtractor(indexExtractor, 256).asBitMapArray();
         for (final int idx : expected) {
-            assertTrue(BitMap.contains(ary, idx));
+            assertTrue(BitMaps.contains(ary, idx));
         }
     }
 }
diff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/DefaultBloomFilterProducerTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/DefaultBloomFilterExtractorTest.java
similarity index 86%
rename from src/test/java/org/apache/commons/collections4/bloomfilter/DefaultBloomFilterProducerTest.java
rename to src/test/java/org/apache/commons/collections4/bloomfilter/DefaultBloomFilterExtractorTest.java
index d588fafade..4de666477a 100644
--- a/src/test/java/org/apache/commons/collections4/bloomfilter/DefaultBloomFilterProducerTest.java
+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/DefaultBloomFilterExtractorTest.java
@@ -16,10 +16,10 @@
  */
 package org.apache.commons.collections4.bloomfilter;
 
-public class DefaultBloomFilterProducerTest extends AbstractBloomFilterProducerTest {
+public class DefaultBloomFilterExtractorTest extends AbstractBloomFilterExtractorTest {
 
     @Override
-    protected BloomFilterProducer createUnderTest(final BloomFilter... filters) {
+    protected BloomFilterExtractor createUnderTest(final BloomFilter... filters) {
         return bloomFilterPredicate -> {
             for (final BloomFilter bf : filters) {
                 if (!bloomFilterPredicate.test(bf)) {
diff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/DefaultBloomFilterTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/DefaultBloomFilterTest.java
index 480bb89e39..e67201043d 100644
--- a/src/test/java/org/apache/commons/collections4/bloomfilter/DefaultBloomFilterTest.java
+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/DefaultBloomFilterTest.java
@@ -64,22 +64,22 @@ public void clear() {
         }
 
         @Override
-        public boolean contains(final BitMapProducer bitMapProducer) {
-            return contains(IndexProducer.fromBitMapProducer(bitMapProducer));
+        public boolean contains(final BitMapExtractor bitMapExtractor) {
+            return contains(IndexExtractor.fromBitMapExtractor(bitMapExtractor));
         }
 
         @Override
-        public boolean contains(final IndexProducer indexProducer) {
-            return indexProducer.forEachIndex(indices::contains);
+        public boolean contains(final IndexExtractor indexExtractor) {
+            return indexExtractor.processIndices(indices::contains);
         }
 
         @Override
-        public boolean forEachBitMap(final LongPredicate consumer) {
-            return BitMapProducer.fromIndexProducer(this, shape.getNumberOfBits()).forEachBitMap(consumer);
+        public boolean processBitMaps(final LongPredicate consumer) {
+            return BitMapExtractor.fromIndexExtractor(this, shape.getNumberOfBits()).processBitMaps(consumer);
         }
 
         @Override
-        public boolean forEachIndex(final IntPredicate consumer) {
+        public boolean processIndices(final IntPredicate consumer) {
             for (final Integer i : indices) {
                 if (!consumer.test(i)) {
                     return false;
@@ -94,13 +94,13 @@ public Shape getShape() {
         }
 
         @Override
-        public boolean merge(final BitMapProducer bitMapProducer) {
-            return merge(IndexProducer.fromBitMapProducer(bitMapProducer));
+        public boolean merge(final BitMapExtractor bitMapExtractor) {
+            return merge(IndexExtractor.fromBitMapExtractor(bitMapExtractor));
         }
 
         @Override
-        public boolean merge(final IndexProducer indexProducer) {
-            final boolean result = indexProducer.forEachIndex(x -> {
+        public boolean merge(final IndexExtractor indexExtractor) {
+            final boolean result = indexExtractor.processIndices(x -> {
                 indices.add(x);
                 return true;
             });
@@ -193,7 +193,7 @@ public void testEstimateLargeN() {
         final Shape s = Shape.fromKM(1, Integer.MAX_VALUE);
         // create a very large filter with Integer.MAX_VALUE-1 bits set.
         final BloomFilter bf1 = new SimpleBloomFilter(s);
-        bf1.merge((BitMapProducer) predicate -> {
+        bf1.merge((BitMapExtractor) predicate -> {
             int limit = Integer.MAX_VALUE - 1;
             while (limit > 64) {
                 predicate.test(0xFFFFFFFFFFFFFFFFL);
@@ -201,7 +201,7 @@ public void testEstimateLargeN() {
             }
             long last = 0L;
             for (int i = 0; i < limit; i++) {
-                last |= BitMap.getLongBit(i);
+                last |= BitMaps.getLongBit(i);
             }
             predicate.test(last);
             return true;
@@ -224,13 +224,13 @@ public void testHasherBasedMergeWithDifferingSparseness() {
 
         BloomFilter bf1 = new NonSparseDefaultBloomFilter(getTestShape());
         bf1.merge(hasher);
-        assertTrue(BitMapProducer.fromIndexProducer(hasher.indices(getTestShape()), getTestShape().getNumberOfBits())
-                .forEachBitMapPair(bf1, (x, y) -> x == y));
+        assertTrue(BitMapExtractor.fromIndexExtractor(hasher.indices(getTestShape()), getTestShape().getNumberOfBits())
+                .processBitMapPairs(bf1, (x, y) -> x == y));
 
         bf1 = new SparseDefaultBloomFilter(getTestShape());
         bf1.merge(hasher);
-        assertTrue(BitMapProducer.fromIndexProducer(hasher.indices(getTestShape()), getTestShape().getNumberOfBits())
-                .forEachBitMapPair(bf1, (x, y) -> x == y));
+        assertTrue(BitMapExtractor.fromIndexExtractor(hasher.indices(getTestShape()), getTestShape().getNumberOfBits())
+                .processBitMapPairs(bf1, (x, y) -> x == y));
     }
 
     @Test
@@ -238,7 +238,7 @@ public void testIntersectionLimit() {
         final Shape s = Shape.fromKM(1, Integer.MAX_VALUE);
         // create a very large filter with Integer.MAX_VALUE-1 bit set.
         final BloomFilter bf1 = new SimpleBloomFilter(s);
-        bf1.merge((BitMapProducer) predicate -> {
+        bf1.merge((BitMapExtractor) predicate -> {
             int limit = Integer.MAX_VALUE - 1;
             while (limit > 64) {
                 predicate.test(0xFFFFFFFFFFFFFFFFL);
@@ -246,7 +246,7 @@ public void testIntersectionLimit() {
             }
             long last = 0L;
             for (int i = 0; i < limit; i++) {
-                last |= BitMap.getLongBit(i);
+                last |= BitMaps.getLongBit(i);
             }
             predicate.test(last);
             return true;
diff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/DefaultCellProducerTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/DefaultCellExtractorTest.java
similarity index 90%
rename from src/test/java/org/apache/commons/collections4/bloomfilter/DefaultCellProducerTest.java
rename to src/test/java/org/apache/commons/collections4/bloomfilter/DefaultCellExtractorTest.java
index eb6c18417f..5711360cea 100644
--- a/src/test/java/org/apache/commons/collections4/bloomfilter/DefaultCellProducerTest.java
+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/DefaultCellExtractorTest.java
@@ -16,19 +16,19 @@
  */
 package org.apache.commons.collections4.bloomfilter;
 
-public class DefaultCellProducerTest extends AbstractCellProducerTest {
+public class DefaultCellExtractorTest extends AbstractCellExtractorTest {
 
     /** Make forEachIndex unordered and contain duplicates. */
     private final int[] indices = {1, 2, 3, 5};
     private final int[] values = {1, 4, 9, 25};
 
     @Override
-    protected CellProducer createEmptyProducer() {
+    protected CellExtractor createEmptyExtractor() {
         return consumer -> true;
     }
 
     @Override
-    protected CellProducer createProducer() {
+    protected CellExtractor createExtractor() {
         return consumer -> {
             for (int i = 0; i < indices.length; i++) {
                 if (!consumer.test(indices[i], values[i] )) {
diff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/DefaultIndexProducerTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/DefaultIndexExtractorTest.java
similarity index 85%
rename from src/test/java/org/apache/commons/collections4/bloomfilter/DefaultIndexProducerTest.java
rename to src/test/java/org/apache/commons/collections4/bloomfilter/DefaultIndexExtractorTest.java
index 8fa0a3db9f..0d58fbcda1 100644
--- a/src/test/java/org/apache/commons/collections4/bloomfilter/DefaultIndexProducerTest.java
+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/DefaultIndexExtractorTest.java
@@ -28,7 +28,7 @@
 import org.junit.jupiter.params.ParameterizedTest;
 import org.junit.jupiter.params.provider.ValueSource;
 
-public class DefaultIndexProducerTest extends AbstractIndexProducerTest {
+public class DefaultIndexExtractorTest extends AbstractIndexExtractorTest {
 
     /**
      * Generates an array of integers.
@@ -64,7 +64,7 @@ public static BitSet uniqueSet(final int[] ary) {
     private final int[] values = {10, 1, 10, 1};
 
     @Override
-    protected IndexProducer createEmptyProducer() {
+    protected IndexExtractor createEmptyExtractor() {
         return predicate -> {
             Objects.requireNonNull(predicate);
             return true;
@@ -72,7 +72,7 @@ protected IndexProducer createEmptyProducer() {
     }
 
     @Override
-    protected IndexProducer createProducer() {
+    protected IndexExtractor createExtractor() {
         return predicate -> {
             Objects.requireNonNull(predicate);
             for (final int i : values) {
@@ -104,7 +104,7 @@ protected int getForEachIndexBehaviour() {
     @ValueSource(ints = {32, 33})
     public void testEntries(final int size) {
         final int[] values = IntStream.range(0, size).toArray();
-        final IndexProducer producer =  predicate -> {
+        final IndexExtractor indexExtractor = predicate -> {
             Objects.requireNonNull(predicate);
             for (final int i : values) {
                 if (!predicate.test(i)) {
@@ -113,19 +113,19 @@ public void testEntries(final int size) {
             }
             return true;
         };
-        final int[] other = producer.asIndexArray();
+        final int[] other = indexExtractor.asIndexArray();
         assertArrayEquals(values, other);
     }
 
     @Test
-    public void testFromBitMapProducer() {
+    public void testFromBitMapExtractor() {
         for (int i = 0; i < 5; i++) {
             final int[] expected = generateIntArray(7, 256);
-            final long[] bits = new long[BitMap.numberOfBitMaps(256)];
+            final long[] bits = new long[BitMaps.numberOfBitMaps(256)];
             for (final int bitIndex : expected) {
-                BitMap.set(bits, bitIndex);
+                BitMaps.set(bits, bitIndex);
             }
-            final IndexProducer ip = IndexProducer.fromBitMapProducer(BitMapProducer.fromBitMapArray(bits));
+            final IndexExtractor ip = IndexExtractor.fromBitMapExtractor(BitMapExtractor.fromBitMapArray(bits));
             assertArrayEquals(unique(expected), ip.asIndexArray());
         }
     }
@@ -134,7 +134,7 @@ public void testFromBitMapProducer() {
     public void testFromIndexArray() {
         for (int i = 0; i < 5; i++) {
             final int[] expected = generateIntArray(10, 256);
-            final IndexProducer ip = IndexProducer.fromIndexArray(expected);
+            final IndexExtractor ip = IndexExtractor.fromIndexArray(expected);
             assertArrayEquals(expected, ip.asIndexArray());
         }
     }
diff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/IncrementingHasher.java b/src/test/java/org/apache/commons/collections4/bloomfilter/IncrementingHasher.java
index b7f9b62717..778a9d541d 100644
--- a/src/test/java/org/apache/commons/collections4/bloomfilter/IncrementingHasher.java
+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/IncrementingHasher.java
@@ -52,10 +52,10 @@ public IncrementingHasher(final long initial, final long increment) {
     }
 
     @Override
-    public IndexProducer indices(final Shape shape) {
+    public IndexExtractor indices(final Shape shape) {
         Objects.requireNonNull(shape, "shape");
 
-        return new IndexProducer() {
+        return new IndexExtractor() {
             @Override
             public int[] asIndexArray() {
                 final int[] result = new int[shape.getNumberOfHashFunctions()];
@@ -63,7 +63,7 @@ public int[] asIndexArray() {
 
                 // This method needs to return duplicate indices
 
-                forEachIndex(i -> {
+                processIndices(i -> {
                     result[idx[0]++] = i;
                     return true;
                 });
@@ -71,7 +71,7 @@ public int[] asIndexArray() {
             }
 
             @Override
-            public boolean forEachIndex(final IntPredicate consumer) {
+            public boolean processIndices(final IntPredicate consumer) {
                 Objects.requireNonNull(consumer, "consumer");
                 final int bits = shape.getNumberOfBits();
 
@@ -80,8 +80,8 @@ public boolean forEachIndex(final IntPredicate consumer) {
                 // This avoids any modulus operation inside the while loop. It uses a long index
                 // to avoid overflow.
 
-                long index = BitMap.mod(initial, bits);
-                final int inc = BitMap.mod(increment, bits);
+                long index = BitMaps.mod(initial, bits);
+                final int inc = BitMaps.mod(increment, bits);
 
                 for (int functionalCount = 0; functionalCount < shape.getNumberOfHashFunctions(); functionalCount++) {
                     if (!consumer.test((int) index)) {
diff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromArrayCountingBloomFilterTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/IndexExtractorFromArrayCountingBloomFilterTest.java
similarity index 88%
rename from src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromArrayCountingBloomFilterTest.java
rename to src/test/java/org/apache/commons/collections4/bloomfilter/IndexExtractorFromArrayCountingBloomFilterTest.java
index 857c1f51e3..118a2ec46a 100644
--- a/src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromArrayCountingBloomFilterTest.java
+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/IndexExtractorFromArrayCountingBloomFilterTest.java
@@ -16,17 +16,17 @@
  */
 package org.apache.commons.collections4.bloomfilter;
 
-public class IndexProducerFromArrayCountingBloomFilterTest extends AbstractIndexProducerTest {
+public class IndexExtractorFromArrayCountingBloomFilterTest extends AbstractIndexExtractorTest {
 
     protected Shape shape = Shape.fromKM(17, 72);
 
     @Override
-    protected IndexProducer createEmptyProducer() {
+    protected IndexExtractor createEmptyExtractor() {
         return new ArrayCountingBloomFilter(shape);
     }
 
     @Override
-    protected IndexProducer createProducer() {
+    protected IndexExtractor createExtractor() {
         final ArrayCountingBloomFilter filter = new ArrayCountingBloomFilter(shape);
         filter.merge(new IncrementingHasher(0, 1));
         filter.merge(new IncrementingHasher(5, 1));
diff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromBitmapProducerTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/IndexExtractorFromBitmapExtractorTest.java
similarity index 67%
rename from src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromBitmapProducerTest.java
rename to src/test/java/org/apache/commons/collections4/bloomfilter/IndexExtractorFromBitmapExtractorTest.java
index 3de474b9a3..0c8cd27c71 100644
--- a/src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromBitmapProducerTest.java
+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/IndexExtractorFromBitmapExtractorTest.java
@@ -24,17 +24,17 @@
 
 import org.junit.jupiter.api.Test;
 
-public class IndexProducerFromBitmapProducerTest extends AbstractIndexProducerTest {
+public class IndexExtractorFromBitmapExtractorTest extends AbstractIndexExtractorTest {
 
-    private static final class TestingBitMapProducer implements BitMapProducer {
+    private static final class TestingBitMapExtractor implements BitMapExtractor {
         long[] values;
 
-        TestingBitMapProducer(final long[] values) {
+        TestingBitMapExtractor(final long[] values) {
             this.values = values;
         }
 
         @Override
-        public boolean forEachBitMap(final LongPredicate consumer) {
+        public boolean processBitMaps(final LongPredicate consumer) {
             for (final long l : values) {
                 if (!consumer.test(l)) {
                     return false;
@@ -45,14 +45,14 @@ public boolean forEachBitMap(final LongPredicate consumer) {
     }
 
     @Override
-    protected IndexProducer createEmptyProducer() {
-        final TestingBitMapProducer producer = new TestingBitMapProducer(new long[0]);
-        return IndexProducer.fromBitMapProducer(producer);
+    protected IndexExtractor createEmptyExtractor() {
+        final TestingBitMapExtractor testingBitMapExtractor = new TestingBitMapExtractor(new long[0]);
+        return IndexExtractor.fromBitMapExtractor(testingBitMapExtractor);
     }
 
     @Override
-    protected IndexProducer createProducer() {
-        /* Creates an index producer that produces the values:
+    protected IndexExtractor createExtractor() {
+        /* Creates an index testingBitMapExtractor that produces the values:
          * 0, 65, 128, and 129
          @formatter:off
                 Index2    Index1     Index0
@@ -63,8 +63,8 @@ protected IndexProducer createProducer() {
          3L => ...0011
          @formatter:on
          */
-        final TestingBitMapProducer producer = new TestingBitMapProducer(new long[] {1L, 2L, 3L});
-        return IndexProducer.fromBitMapProducer(producer);
+        final TestingBitMapExtractor testingBitMapExtractor = new TestingBitMapExtractor(new long[] {1L, 2L, 3L});
+        return IndexExtractor.fromBitMapExtractor(testingBitMapExtractor);
     }
 
     @Override
@@ -79,22 +79,22 @@ protected int[] getExpectedIndices() {
     }
 
     @Test
-    public final void testFromBitMapProducerTest() {
-        IndexProducer underTest = createProducer();
+    public final void testFromBitMapExtractor() {
+        IndexExtractor underTest = createExtractor();
         List<Integer> lst = new ArrayList<>();
 
-        underTest.forEachIndex(lst::add);
+        underTest.processIndices(lst::add);
         assertEquals(4, lst.size());
         assertEquals(Integer.valueOf(0), lst.get(0));
         assertEquals(Integer.valueOf(1 + 64), lst.get(1));
         assertEquals(Integer.valueOf(0 + 128), lst.get(2));
         assertEquals(Integer.valueOf(1 + 128), lst.get(3));
 
-        final BitMapProducer producer = new TestingBitMapProducer(new long[] {0xFFFFFFFFFFFFFFFFL});
-        underTest = IndexProducer.fromBitMapProducer(producer);
+        final BitMapExtractor bitMapExtractor = new TestingBitMapExtractor(new long[] {0xFFFFFFFFFFFFFFFFL});
+        underTest = IndexExtractor.fromBitMapExtractor(bitMapExtractor);
         lst = new ArrayList<>();
 
-        underTest.forEachIndex(lst::add);
+        underTest.processIndices(lst::add);
 
         assertEquals(64, lst.size());
         for (int i = 0; i < 64; i++) {
diff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromHasherTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/IndexExtractorFromHasherTest.java
similarity index 87%
rename from src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromHasherTest.java
rename to src/test/java/org/apache/commons/collections4/bloomfilter/IndexExtractorFromHasherTest.java
index c617146b6e..c647e80845 100644
--- a/src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromHasherTest.java
+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/IndexExtractorFromHasherTest.java
@@ -16,15 +16,15 @@
  */
 package org.apache.commons.collections4.bloomfilter;
 
-public class IndexProducerFromHasherTest extends AbstractIndexProducerTest {
+public class IndexExtractorFromHasherTest extends AbstractIndexExtractorTest {
 
     @Override
-    protected IndexProducer createEmptyProducer() {
+    protected IndexExtractor createEmptyExtractor() {
         return NullHasher.INSTANCE.indices(Shape.fromKM(17, 72));
     }
 
     @Override
-    protected IndexProducer createProducer() {
+    protected IndexExtractor createExtractor() {
         // hasher has collisions and wraps
         return new IncrementingHasher(4, 8).indices(Shape.fromKM(17, 72));
     }
diff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromIntArrayTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/IndexExtractorFromIntArrayTest.java
similarity index 79%
rename from src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromIntArrayTest.java
rename to src/test/java/org/apache/commons/collections4/bloomfilter/IndexExtractorFromIntArrayTest.java
index b813a0caf4..1bab6146a4 100644
--- a/src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromIntArrayTest.java
+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/IndexExtractorFromIntArrayTest.java
@@ -16,18 +16,18 @@
  */
 package org.apache.commons.collections4.bloomfilter;
 
-public class IndexProducerFromIntArrayTest extends AbstractIndexProducerTest {
+public class IndexExtractorFromIntArrayTest extends AbstractIndexExtractorTest {
 
     int[] data = {6, 8, 1, 2, 4, 4, 5};
 
     @Override
-    protected IndexProducer createEmptyProducer() {
-        return IndexProducer.fromIndexArray();
+    protected IndexExtractor createEmptyExtractor() {
+        return IndexExtractor.fromIndexArray();
     }
 
     @Override
-    protected IndexProducer createProducer() {
-        return IndexProducer.fromIndexArray(data);
+    protected IndexExtractor createExtractor() {
+        return IndexExtractor.fromIndexArray(data);
     }
 
     @Override
diff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromSimpleBloomFilterTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/IndexExtractorFromSimpleBloomFilterTest.java
similarity index 88%
rename from src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromSimpleBloomFilterTest.java
rename to src/test/java/org/apache/commons/collections4/bloomfilter/IndexExtractorFromSimpleBloomFilterTest.java
index 75e14a7beb..aa13658ac0 100644
--- a/src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromSimpleBloomFilterTest.java
+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/IndexExtractorFromSimpleBloomFilterTest.java
@@ -16,17 +16,17 @@
  */
 package org.apache.commons.collections4.bloomfilter;
 
-public class IndexProducerFromSimpleBloomFilterTest extends AbstractIndexProducerTest {
+public class IndexExtractorFromSimpleBloomFilterTest extends AbstractIndexExtractorTest {
 
     protected Shape shape = Shape.fromKM(17, 72);
 
     @Override
-    protected IndexProducer createEmptyProducer() {
+    protected IndexExtractor createEmptyExtractor() {
         return new SimpleBloomFilter(shape);
     }
 
     @Override
-    protected IndexProducer createProducer() {
+    protected IndexExtractor createExtractor() {
         final Hasher hasher = new IncrementingHasher(3, 2);
         final BloomFilter bf = new SimpleBloomFilter(shape);
         bf.merge(hasher);
diff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromSparseBloomFilterTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/IndexExtractorFromSparseBloomFilterTest.java
similarity index 88%
rename from src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromSparseBloomFilterTest.java
rename to src/test/java/org/apache/commons/collections4/bloomfilter/IndexExtractorFromSparseBloomFilterTest.java
index 6ad25e4400..e7febe1aae 100644
--- a/src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromSparseBloomFilterTest.java
+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/IndexExtractorFromSparseBloomFilterTest.java
@@ -16,17 +16,17 @@
  */
 package org.apache.commons.collections4.bloomfilter;
 
-public class IndexProducerFromSparseBloomFilterTest extends AbstractIndexProducerTest {
+public class IndexExtractorFromSparseBloomFilterTest extends AbstractIndexExtractorTest {
 
     protected Shape shape = Shape.fromKM(17, 72);
 
     @Override
-    protected IndexProducer createEmptyProducer() {
+    protected IndexExtractor createEmptyExtractor() {
         return new SparseBloomFilter(shape);
     }
 
     @Override
-    protected IndexProducer createProducer() {
+    protected IndexExtractor createExtractor() {
         final Hasher hasher = new IncrementingHasher(4, 7);
         final BloomFilter bf = new SparseBloomFilter(shape);
         bf.merge(hasher);
diff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromUniqueHasherTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/IndexExtractorFromUniqueHasherTest.java
similarity index 87%
rename from src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromUniqueHasherTest.java
rename to src/test/java/org/apache/commons/collections4/bloomfilter/IndexExtractorFromUniqueHasherTest.java
index ccddd9d4b1..f1a8ff3f62 100644
--- a/src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromUniqueHasherTest.java
+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/IndexExtractorFromUniqueHasherTest.java
@@ -16,15 +16,15 @@
  */
 package org.apache.commons.collections4.bloomfilter;
 
-public class IndexProducerFromUniqueHasherTest extends AbstractIndexProducerTest {
+public class IndexExtractorFromUniqueHasherTest extends AbstractIndexExtractorTest {
 
     @Override
-    protected IndexProducer createEmptyProducer() {
+    protected IndexExtractor createEmptyExtractor() {
         return NullHasher.INSTANCE.indices(Shape.fromKM(17, 72));
     }
 
     @Override
-    protected IndexProducer createProducer() {
+    protected IndexExtractor createExtractor() {
         // hasher has collisions and wraps
         return new IncrementingHasher(4, 8).indices(Shape.fromKM(17, 72)).uniqueIndices();
     }
diff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/IndexExtractorTest.java
similarity index 74%
rename from src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerTest.java
rename to src/test/java/org/apache/commons/collections4/bloomfilter/IndexExtractorTest.java
index a8343d94db..82010ca490 100644
--- a/src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerTest.java
+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/IndexExtractorTest.java
@@ -27,17 +27,17 @@
 import org.junit.jupiter.params.ParameterizedTest;
 import org.junit.jupiter.params.provider.ValueSource;
 
-public class IndexProducerTest {
+public class IndexExtractorTest {
 
-    private static final class TestingBitMapProducer implements BitMapProducer {
+    private static final class TestingBitMapExtractor implements BitMapExtractor {
         long[] values;
 
-        TestingBitMapProducer(final long[] values) {
+        TestingBitMapExtractor(final long[] values) {
             this.values = values;
         }
 
         @Override
-        public boolean forEachBitMap(final LongPredicate consumer) {
+        public boolean processBitMaps(final LongPredicate consumer) {
             for (final long l : values) {
                 if (!consumer.test(l)) {
                     return false;
@@ -48,23 +48,23 @@ public boolean forEachBitMap(final LongPredicate consumer) {
     }
 
     @Test
-    public void fromBitMapProducerTest() {
-        TestingBitMapProducer producer = new TestingBitMapProducer(new long[] {1L, 2L, 3L});
-        IndexProducer underTest = IndexProducer.fromBitMapProducer(producer);
+    public void testFromBitMapExtractor() {
+        TestingBitMapExtractor testingBitMapExtractor = new TestingBitMapExtractor(new long[] {1L, 2L, 3L});
+        IndexExtractor underTest = IndexExtractor.fromBitMapExtractor(testingBitMapExtractor);
         List<Integer> lst = new ArrayList<>();
 
-        underTest.forEachIndex(lst::add);
+        underTest.processIndices(lst::add);
         assertEquals(4, lst.size());
         assertEquals(Integer.valueOf(0), lst.get(0));
         assertEquals(Integer.valueOf(1 + 64), lst.get(1));
         assertEquals(Integer.valueOf(0 + 128), lst.get(2));
         assertEquals(Integer.valueOf(1 + 128), lst.get(3));
 
-        producer = new TestingBitMapProducer(new long[] {0xFFFFFFFFFFFFFFFFL});
-        underTest = IndexProducer.fromBitMapProducer(producer);
+        testingBitMapExtractor = new TestingBitMapExtractor(new long[] {0xFFFFFFFFFFFFFFFFL});
+        underTest = IndexExtractor.fromBitMapExtractor(testingBitMapExtractor);
         lst = new ArrayList<>();
 
-        underTest.forEachIndex(lst::add);
+        underTest.processIndices(lst::add);
 
         assertEquals(64, lst.size());
         for (int i = 0; i < 64; i++) {
@@ -75,7 +75,7 @@ public void fromBitMapProducerTest() {
     @ParameterizedTest
     @ValueSource(ints = {32, 33})
     void testAsIndexArray(final int n) {
-        final IndexProducer ip = i -> {
+        final IndexExtractor ip = i -> {
             for (int j = 0; j < n; j++) {
                 // Always test index zero
                 i.test(0);
diff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/LayerManagerTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/LayerManagerTest.java
index 09ffac2e74..ca90f0d0d6 100644
--- a/src/test/java/org/apache/commons/collections4/bloomfilter/LayerManagerTest.java
+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/LayerManagerTest.java
@@ -134,7 +134,7 @@ public void testCopy() {
 
         assertEquals(underTest.getDepth(), copy.getDepth());
         assertTrue(
-                underTest.forEachBloomFilterPair(copy, (x, y) -> Arrays.equals(x.asBitMapArray(), y.asBitMapArray())));
+                underTest.processBloomFilterPair(copy, (x, y) -> Arrays.equals(x.asBitMapArray(), y.asBitMapArray())));
     }
 
     @Test
@@ -150,7 +150,7 @@ public void testForEachBloomFilter() {
             underTest.getTarget().merge(bf);
         }
         final List<BloomFilter> lst2 = new ArrayList<>();
-        underTest.forEachBloomFilter(lst2::add);
+        underTest.processBloomFilters(lst2::add);
         assertEquals(10, lst.size());
         assertEquals(10, lst2.size());
         for (int i = 0; i < lst.size(); i++) {
@@ -242,7 +242,7 @@ public void testRemoveEmptyTarget() {
         assertTrue(list.isEmpty());
 
         // does not remove a populated filter.
-        bf.merge(IndexProducer.fromIndexArray(1));
+        bf.merge(IndexExtractor.fromIndexArray(1));
         list.add(bf);
         assertEquals(bf, list.get(0));
         underTest.accept(list);
diff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/LayeredBloomFilterTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/LayeredBloomFilterTest.java
index 32a47c17c7..24a143b85a 100644
--- a/src/test/java/org/apache/commons/collections4/bloomfilter/LayeredBloomFilterTest.java
+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/LayeredBloomFilterTest.java
@@ -201,14 +201,14 @@ protected BloomFilter makeFilter(final Hasher h) {
         return bf;
     }
 
-    protected BloomFilter makeFilter(final IndexProducer p) {
+    protected BloomFilter makeFilter(final IndexExtractor p) {
         final BloomFilter bf = new SparseBloomFilter(getTestShape());
         bf.merge(p);
         return bf;
     }
 
     protected BloomFilter makeFilter(final int... values) {
-        return makeFilter(IndexProducer.fromIndexArray(values));
+        return makeFilter(IndexExtractor.fromIndexArray(values));
     }
 
     private LayeredBloomFilter<BloomFilter> setupFindTest() {
@@ -291,7 +291,7 @@ public void testExpiration() throws InterruptedException {
         for (int i = 0; i < 10; i++) {
             underTest.merge(TestingHashers.randomHasher());
         }
-        underTest.forEachBloomFilter(dbg.and(x -> lst.add(((TimestampedBloomFilter) x).timestamp)));
+        underTest.processBloomFilters(dbg.and(x -> lst.add(((TimestampedBloomFilter) x).timestamp)));
         assertTrue(underTest.getDepth() > 1);
 
         Thread.sleep(300);
@@ -299,38 +299,38 @@ public void testExpiration() throws InterruptedException {
             underTest.merge(TestingHashers.randomHasher());
         }
         dbgInstrument.add("=== AFTER 300 milliseconds ====\n");
-        underTest.forEachBloomFilter(dbg);
+        underTest.processBloomFilters(dbg);
 
         Thread.sleep(150);
         for (int i = 0; i < 10; i++) {
             underTest.merge(TestingHashers.randomHasher());
         }
         dbgInstrument.add("=== AFTER 450 milliseconds ====\n");
-        underTest.forEachBloomFilter(dbg);
+        underTest.processBloomFilters(dbg);
 
         // sleep 200 milliseconds to ensure we cross the 600 millisecond boundary
         Thread.sleep(200);
         underTest.merge(TestingHashers.randomHasher());
         dbgInstrument.add("=== AFTER 600 milliseconds ====\n");
-        assertTrue(underTest.forEachBloomFilter(dbg.and(x -> !lst.contains(((TimestampedBloomFilter) x).timestamp))),
+        assertTrue(underTest.processBloomFilters(dbg.and(x -> !lst.contains(((TimestampedBloomFilter) x).timestamp))),
                 "Found filter that should have been deleted: " + dbgInstrument.get(dbgInstrument.size() - 1));
     }
 
     @Test
-    public void testFindBitMapProducer() {
+    public void testFindBitMapExtractor() {
         final LayeredBloomFilter<BloomFilter> filter = setupFindTest();
 
-        IndexProducer idxProducer = TestingHashers.FROM1.indices(getTestShape());
-        BitMapProducer producer = BitMapProducer.fromIndexProducer(idxProducer, getTestShape().getNumberOfBits());
+        IndexExtractor indexExtractor = TestingHashers.FROM1.indices(getTestShape());
+        BitMapExtractor bitMapExtractor = BitMapExtractor.fromIndexExtractor(indexExtractor, getTestShape().getNumberOfBits());
 
         int[] expected = {0, 3};
-        int[] result = filter.find(producer);
+        int[] result = filter.find(bitMapExtractor);
         assertArrayEquals(expected, result);
 
         expected = new int[]{1, 3};
-        idxProducer = TestingHashers.FROM11.indices(getTestShape());
-        producer = BitMapProducer.fromIndexProducer(idxProducer, getTestShape().getNumberOfBits());
-        result = filter.find(producer);
+        indexExtractor = TestingHashers.FROM11.indices(getTestShape());
+        bitMapExtractor = BitMapExtractor.fromIndexExtractor(indexExtractor, getTestShape().getNumberOfBits());
+        result = filter.find(bitMapExtractor);
         assertArrayEquals(expected, result);
     }
 
@@ -346,17 +346,17 @@ public void testFindBloomFilter() {
     }
 
     @Test
-    public void testFindIndexProducer() {
-        IndexProducer producer = TestingHashers.FROM1.indices(getTestShape());
+    public void testFindIndexExtractor() {
+        IndexExtractor indexExtractor = TestingHashers.FROM1.indices(getTestShape());
         final LayeredBloomFilter<BloomFilter> filter = setupFindTest();
 
         int[] expected = {0, 3};
-        int[] result = filter.find(producer);
+        int[] result = filter.find(indexExtractor);
         assertArrayEquals(expected, result);
 
         expected = new int[] {1, 3};
-        producer = TestingHashers.FROM11.indices(getTestShape());
-        result = filter.find(producer);
+        indexExtractor = TestingHashers.FROM11.indices(getTestShape());
+        result = filter.find(indexExtractor);
         assertArrayEquals(expected, result);
     }
 
diff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/NullHasher.java b/src/test/java/org/apache/commons/collections4/bloomfilter/NullHasher.java
index 1bafc5ea9f..290eaf7c1a 100644
--- a/src/test/java/org/apache/commons/collections4/bloomfilter/NullHasher.java
+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/NullHasher.java
@@ -31,14 +31,14 @@ final class NullHasher implements Hasher {
      */
     static final NullHasher INSTANCE = new NullHasher();
 
-    private static final IndexProducer PRODUCER = new IndexProducer() {
+    private static final IndexExtractor INDEX_EXTRACTOR = new IndexExtractor() {
         @Override
         public int[] asIndexArray() {
             return new int[0];
         }
 
         @Override
-        public boolean forEachIndex(final IntPredicate consumer) {
+        public boolean processIndices(final IntPredicate consumer) {
             Objects.requireNonNull(consumer, "consumer");
             return true;
         }
@@ -49,8 +49,8 @@ private NullHasher() {
     }
 
     @Override
-    public IndexProducer indices(final Shape shape) {
+    public IndexExtractor indices(final Shape shape) {
         Objects.requireNonNull(shape, "shape");
-        return PRODUCER;
+        return INDEX_EXTRACTOR;
     }
 }
diff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/SetOperationsTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/SetOperationsTest.java
index 075cddb729..5abb6bfbe7 100644
--- a/src/test/java/org/apache/commons/collections4/bloomfilter/SetOperationsTest.java
+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/SetOperationsTest.java
@@ -48,25 +48,25 @@ private BloomFilter createFilter(final Shape shape, final Hasher hasher) {
         return bf;
     }
 
-    private BloomFilter createFilter(final Shape shape, final IndexProducer producer) {
+    private BloomFilter createFilter(final Shape shape, final IndexExtractor indexExtractor) {
         final BloomFilter bf = new SparseBloomFilter(shape);
-        bf.merge(producer);
+        bf.merge(indexExtractor);
         return bf;
     }
 
     @Test
     public final void testAndCardinality() {
         final Shape shape = Shape.fromKM(3, 128);
-        BloomFilter filter1 = createFilter(shape, IndexProducer.fromIndexArray(1, 63, 64));
-        BloomFilter filter2 = createFilter(shape, IndexProducer.fromIndexArray(5, 64, 69));
+        BloomFilter filter1 = createFilter(shape, IndexExtractor.fromIndexArray(1, 63, 64));
+        BloomFilter filter2 = createFilter(shape, IndexExtractor.fromIndexArray(5, 64, 69));
         assertSymmetricOperation(1, SetOperations::andCardinality, filter1, filter2);
 
-        filter1 = createFilter(shape, IndexProducer.fromIndexArray(1, 63));
-        filter2 = createFilter(shape, IndexProducer.fromIndexArray(5, 64, 69));
+        filter1 = createFilter(shape, IndexExtractor.fromIndexArray(1, 63));
+        filter2 = createFilter(shape, IndexExtractor.fromIndexArray(5, 64, 69));
         assertSymmetricOperation(0, SetOperations::andCardinality, filter1, filter2);
 
-        filter1 = createFilter(shape, IndexProducer.fromIndexArray(5, 63));
-        filter2 = createFilter(shape, IndexProducer.fromIndexArray(5, 64, 69));
+        filter1 = createFilter(shape, IndexExtractor.fromIndexArray(5, 63));
+        filter2 = createFilter(shape, IndexExtractor.fromIndexArray(5, 64, 69));
         assertSymmetricOperation(1, SetOperations::andCardinality, filter1, filter2);
     }
 
@@ -74,23 +74,23 @@ public final void testAndCardinality() {
     public final void testAndCardinalityWithDifferentLengthFilters() {
         final Shape shape = Shape.fromKM(3, 128);
         final Shape shape2 = Shape.fromKM(3, 192);
-        BloomFilter filter1 = createFilter(shape, IndexProducer.fromIndexArray(1, 63, 64));
-        BloomFilter filter2 = createFilter(shape2, IndexProducer.fromIndexArray(5, 64, 169));
+        BloomFilter filter1 = createFilter(shape, IndexExtractor.fromIndexArray(1, 63, 64));
+        BloomFilter filter2 = createFilter(shape2, IndexExtractor.fromIndexArray(5, 64, 169));
         assertSymmetricOperation(1, SetOperations::andCardinality, filter1, filter2);
 
-        filter1 = createFilter(shape, IndexProducer.fromIndexArray(1, 63));
-        filter2 = createFilter(shape2, IndexProducer.fromIndexArray(5, 64, 169));
+        filter1 = createFilter(shape, IndexExtractor.fromIndexArray(1, 63));
+        filter2 = createFilter(shape2, IndexExtractor.fromIndexArray(5, 64, 169));
         assertSymmetricOperation(0, SetOperations::andCardinality, filter1, filter2);
 
-        filter1 = createFilter(shape, IndexProducer.fromIndexArray(5, 63));
-        filter2 = createFilter(shape2, IndexProducer.fromIndexArray(5, 64, 169));
+        filter1 = createFilter(shape, IndexExtractor.fromIndexArray(5, 63));
+        filter2 = createFilter(shape2, IndexExtractor.fromIndexArray(5, 64, 169));
         assertSymmetricOperation(1, SetOperations::andCardinality, filter1, filter2);
     }
 
     @Test
     public final void testCommutativityOnMismatchedSizes() {
-        final BitMapProducer p1 = BitMapProducer.fromBitMapArray(0x3L, 0x5L);
-        final BitMapProducer p2 = BitMapProducer.fromBitMapArray(0x1L);
+        final BitMapExtractor p1 = BitMapExtractor.fromBitMapArray(0x3L, 0x5L);
+        final BitMapExtractor p2 = BitMapExtractor.fromBitMapArray(0x1L);
 
         assertEquals(SetOperations.orCardinality(p1, p2), SetOperations.orCardinality(p2, p1));
         assertEquals(SetOperations.xorCardinality(p1, p2), SetOperations.xorCardinality(p2, p1));
@@ -256,16 +256,16 @@ public final void testJaccardSimilarity() {
     @Test
     public final void testOrCardinality() {
         final Shape shape = Shape.fromKM(3, 128);
-        BloomFilter filter1 = createFilter(shape, IndexProducer.fromIndexArray(1, 63, 64));
-        BloomFilter filter2 = createFilter(shape, IndexProducer.fromIndexArray(5, 64, 69));
+        BloomFilter filter1 = createFilter(shape, IndexExtractor.fromIndexArray(1, 63, 64));
+        BloomFilter filter2 = createFilter(shape, IndexExtractor.fromIndexArray(5, 64, 69));
         assertSymmetricOperation(5, SetOperations::orCardinality, filter1, filter2);
 
-        filter1 = createFilter(shape, IndexProducer.fromIndexArray(1, 63));
-        filter2 = createFilter(shape, IndexProducer.fromIndexArray(5, 64, 69));
+        filter1 = createFilter(shape, IndexExtractor.fromIndexArray(1, 63));
+        filter2 = createFilter(shape, IndexExtractor.fromIndexArray(5, 64, 69));
         assertSymmetricOperation(5, SetOperations::orCardinality, filter1, filter2);
 
-        filter1 = createFilter(shape, IndexProducer.fromIndexArray(5, 63));
-        filter2 = createFilter(shape, IndexProducer.fromIndexArray(5, 64, 69));
+        filter1 = createFilter(shape, IndexExtractor.fromIndexArray(5, 63));
+        filter2 = createFilter(shape, IndexExtractor.fromIndexArray(5, 64, 69));
         assertSymmetricOperation(4, SetOperations::orCardinality, filter1, filter2);
     }
 
@@ -273,37 +273,37 @@ public final void testOrCardinality() {
     public final void testOrCardinalityWithDifferentLengthFilters() {
         final Shape shape = Shape.fromKM(3, 128);
         final Shape shape2 = Shape.fromKM(3, 192);
-        BloomFilter filter1 = createFilter(shape, IndexProducer.fromIndexArray(1, 63, 64));
-        BloomFilter filter2 = createFilter(shape2, IndexProducer.fromIndexArray(5, 64, 169));
+        BloomFilter filter1 = createFilter(shape, IndexExtractor.fromIndexArray(1, 63, 64));
+        BloomFilter filter2 = createFilter(shape2, IndexExtractor.fromIndexArray(5, 64, 169));
         assertSymmetricOperation(5, SetOperations::orCardinality, filter1, filter2);
 
-        filter1 = createFilter(shape, IndexProducer.fromIndexArray(1, 63));
-        filter2 = createFilter(shape2, IndexProducer.fromIndexArray(5, 64, 169));
+        filter1 = createFilter(shape, IndexExtractor.fromIndexArray(1, 63));
+        filter2 = createFilter(shape2, IndexExtractor.fromIndexArray(5, 64, 169));
         assertSymmetricOperation(5, SetOperations::orCardinality, filter1, filter2);
 
-        filter1 = createFilter(shape, IndexProducer.fromIndexArray(5, 63));
-        filter2 = createFilter(shape2, IndexProducer.fromIndexArray(5, 64, 169));
+        filter1 = createFilter(shape, IndexExtractor.fromIndexArray(5, 63));
+        filter2 = createFilter(shape2, IndexExtractor.fromIndexArray(5, 64, 169));
         assertSymmetricOperation(4, SetOperations::orCardinality, filter1, filter2);
     }
 
     @Test
     public final void testXorCardinality() {
         final Shape shape = Shape.fromKM(3, 128);
-        BloomFilter filter1 = createFilter(shape, IndexProducer.fromIndexArray(1, 63, 64));
-        BloomFilter filter2 = createFilter(shape, IndexProducer.fromIndexArray(5, 64, 69));
+        BloomFilter filter1 = createFilter(shape, IndexExtractor.fromIndexArray(1, 63, 64));
+        BloomFilter filter2 = createFilter(shape, IndexExtractor.fromIndexArray(5, 64, 69));
         assertSymmetricOperation(4, SetOperations::xorCardinality, filter1, filter2);
 
-        filter1 = createFilter(shape, IndexProducer.fromIndexArray(1, 63));
-        filter2 = createFilter(shape, IndexProducer.fromIndexArray(5, 64, 69));
+        filter1 = createFilter(shape, IndexExtractor.fromIndexArray(1, 63));
+        filter2 = createFilter(shape, IndexExtractor.fromIndexArray(5, 64, 69));
         assertSymmetricOperation(5, SetOperations::xorCardinality, filter1, filter2);
 
-        filter1 = createFilter(shape, IndexProducer.fromIndexArray(5, 63));
-        filter2 = createFilter(shape, IndexProducer.fromIndexArray(5, 64, 69));
+        filter1 = createFilter(shape, IndexExtractor.fromIndexArray(5, 63));
+        filter2 = createFilter(shape, IndexExtractor.fromIndexArray(5, 64, 69));
         assertSymmetricOperation(3, SetOperations::xorCardinality, filter1, filter2);
 
         final Shape bigShape = Shape.fromKM(3, 192);
-        filter1 = createFilter(bigShape, IndexProducer.fromIndexArray(1, 63, 185));
-        filter2 = createFilter(shape, IndexProducer.fromIndexArray(5, 63, 69));
+        filter1 = createFilter(bigShape, IndexExtractor.fromIndexArray(1, 63, 185));
+        filter2 = createFilter(shape, IndexExtractor.fromIndexArray(5, 63, 69));
         assertSymmetricOperation(4, SetOperations::xorCardinality, filter1, filter2);
     }
 
@@ -312,16 +312,16 @@ public final void testXorCardinalityWithDifferentLengthFilters() {
         final Shape shape = Shape.fromKM(3, 128);
         final Shape shape2 = Shape.fromKM(3, 192);
 
-        BloomFilter filter1 = createFilter(shape, IndexProducer.fromIndexArray(1, 63, 64));
-        BloomFilter filter2 = createFilter(shape2, IndexProducer.fromIndexArray(5, 64, 169));
+        BloomFilter filter1 = createFilter(shape, IndexExtractor.fromIndexArray(1, 63, 64));
+        BloomFilter filter2 = createFilter(shape2, IndexExtractor.fromIndexArray(5, 64, 169));
         assertSymmetricOperation(4, SetOperations::xorCardinality, filter1, filter2);
 
-        filter1 = createFilter(shape, IndexProducer.fromIndexArray(1, 63));
-        filter2 = createFilter(shape2, IndexProducer.fromIndexArray(5, 64, 169));
+        filter1 = createFilter(shape, IndexExtractor.fromIndexArray(1, 63));
+        filter2 = createFilter(shape2, IndexExtractor.fromIndexArray(5, 64, 169));
         assertSymmetricOperation(5, SetOperations::xorCardinality, filter1, filter2);
 
-        filter1 = createFilter(shape, IndexProducer.fromIndexArray(5, 63));
-        filter2 = createFilter(shape2, IndexProducer.fromIndexArray(5, 64, 169));
+        filter1 = createFilter(shape, IndexExtractor.fromIndexArray(5, 63));
+        filter2 = createFilter(shape2, IndexExtractor.fromIndexArray(5, 64, 169));
         assertSymmetricOperation(3, SetOperations::xorCardinality, filter1, filter2);
     }
 }
diff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/SimpleBloomFilterTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/SimpleBloomFilterTest.java
index 1552e9c763..5710a4ca13 100644
--- a/src/test/java/org/apache/commons/collections4/bloomfilter/SimpleBloomFilterTest.java
+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/SimpleBloomFilterTest.java
@@ -31,12 +31,12 @@ protected SimpleBloomFilter createEmptyFilter(final Shape shape) {
     }
 
     @Test
-    public void testMergeShortBitMapProducer() {
+    public void testMergeShortBitMapExtractor() {
         final SimpleBloomFilter filter = createEmptyFilter(getTestShape());
-        // create a producer that returns too few values
+        // create a bitMapExtractor that returns too few values
         // shape expects 2 longs we are sending 1.
-        final BitMapProducer producer = p -> p.test(2L);
-        assertTrue(filter.merge(producer));
+        final BitMapExtractor bitMapExtractor = p -> p.test(2L);
+        assertTrue(filter.merge(bitMapExtractor));
         assertEquals(1, filter.cardinality());
     }
 }
diff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/SparseBloomFilterTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/SparseBloomFilterTest.java
index aa9a4cd6db..eb5483dd91 100644
--- a/src/test/java/org/apache/commons/collections4/bloomfilter/SparseBloomFilterTest.java
+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/SparseBloomFilterTest.java
@@ -32,22 +32,22 @@ protected SparseBloomFilter createEmptyFilter(final Shape shape) {
     }
 
     @Test
-    public void testBitMapProducerEdgeCases() {
+    public void testBitMapExtractorEdgeCases() {
         int[] values = {1, 2, 3, 4, 5, 6, 7, 8, 9, 65, 66, 67, 68, 69, 70, 71};
-        BloomFilter bf = createFilter(getTestShape(), IndexProducer.fromIndexArray(values));
+        BloomFilter bf = createFilter(getTestShape(), IndexExtractor.fromIndexArray(values));
 
         // verify exit early before bitmap boundary
         final int[] passes = new int[1];
-        assertFalse(bf.forEachBitMap(l -> {
+        assertFalse(bf.processBitMaps(l -> {
             passes[0]++;
             return false;
         }));
         assertEquals(1, passes[0]);
 
         // verify exit early at bitmap boundary
-        bf = createFilter(getTestShape(), IndexProducer.fromIndexArray(values));
+        bf = createFilter(getTestShape(), IndexExtractor.fromIndexArray(values));
         passes[0] = 0;
-        assertFalse(bf.forEachBitMap(l -> {
+        assertFalse(bf.processBitMaps(l -> {
             final boolean result = passes[0] == 0;
             if (result) {
                 passes[0]++;
@@ -58,9 +58,9 @@ public void testBitMapProducerEdgeCases() {
 
         // verify add extra if all values in first bitmap
         values = new int[] {1, 2, 3, 4};
-        bf = createFilter(getTestShape(), IndexProducer.fromIndexArray(values));
+        bf = createFilter(getTestShape(), IndexExtractor.fromIndexArray(values));
         passes[0] = 0;
-        assertTrue(bf.forEachBitMap(l -> {
+        assertTrue(bf.processBitMaps(l -> {
             passes[0]++;
             return true;
         }));
@@ -69,9 +69,9 @@ public void testBitMapProducerEdgeCases() {
         // verify exit early if all values in first bitmap and predicate returns false
         // on 2nd block
         values = new int[] {1, 2, 3, 4};
-        bf = createFilter(getTestShape(), IndexProducer.fromIndexArray(values));
+        bf = createFilter(getTestShape(), IndexExtractor.fromIndexArray(values));
         passes[0] = 0;
-        assertFalse(bf.forEachBitMap(l -> {
+        assertFalse(bf.processBitMaps(l -> {
             final boolean result = passes[0] == 0;
             if (result) {
                 passes[0]++;
@@ -87,6 +87,6 @@ public void testBloomFilterBasedMergeEdgeCases() {
         final BloomFilter bf2 = new SimpleBloomFilter(getTestShape());
         bf2.merge(TestingHashers.FROM1);
         bf1.merge(bf2);
-        assertTrue(bf2.forEachBitMapPair(bf1, (x, y) -> x == y));
+        assertTrue(bf2.processBitMapPairs(bf1, (x, y) -> x == y));
     }
 }
diff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/TestingHashers.java b/src/test/java/org/apache/commons/collections4/bloomfilter/TestingHashers.java
index 78f95ace20..391444c54c 100644
--- a/src/test/java/org/apache/commons/collections4/bloomfilter/TestingHashers.java
+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/TestingHashers.java
@@ -75,7 +75,7 @@ public static <T extends BloomFilter> T populateFromHashersFrom1AndFrom11(final
      * @return {@code filter} for chaining
      */
     public static <T extends BloomFilter> T populateRange(final T filter, final int start, final int end) {
-        filter.merge((IndexProducer) p -> {
+        filter.merge((IndexExtractor) p -> {
             for (int i = start; i <= end; i++) {
                 if (!p.test(i)) {
                     return false;
