diff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/BitMapProducerFromLayeredBloomFilterTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/BitMapProducerFromLayeredBloomFilterTest.java
index bd71067bbe..246ef518cc 100644
--- a/src/test/java/org/apache/commons/collections4/bloomfilter/BitMapProducerFromLayeredBloomFilterTest.java
+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/BitMapProducerFromLayeredBloomFilterTest.java
@@ -22,13 +22,13 @@ public class BitMapProducerFromLayeredBloomFilterTest extends AbstractBitMapProd
 
     @Override
     protected BitMapProducer createEmptyProducer() {
-        return LayeredBloomFilter.fixed(shape, 10);
+        return LayeredBloomFilterTest.fixed(shape, 10);
     }
 
     @Override
     protected BitMapProducer createProducer() {
         final Hasher hasher = new IncrementingHasher(0, 1);
-        final BloomFilter bf = LayeredBloomFilter.fixed(shape, 10);
+        final BloomFilter bf = LayeredBloomFilterTest.fixed(shape, 10);
         bf.merge(hasher);
         return bf;
     }
diff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/BitMapProducerFromWrappedBloomFilterTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/BitMapProducerFromWrappedBloomFilterTest.java
index ebb78ab43d..27befb1e60 100644
--- a/src/test/java/org/apache/commons/collections4/bloomfilter/BitMapProducerFromWrappedBloomFilterTest.java
+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/BitMapProducerFromWrappedBloomFilterTest.java
@@ -23,6 +23,12 @@ public class BitMapProducerFromWrappedBloomFilterTest extends AbstractBitMapProd
     @Override
     protected BitMapProducer createEmptyProducer() {
         return new WrappedBloomFilter(new DefaultBloomFilterTest.SparseDefaultBloomFilter(shape)) {
+            @Override
+            public BloomFilter copy() {
+                BloomFilter result = new DefaultBloomFilterTest.SparseDefaultBloomFilter(shape);
+                result.merge(getWrapped());
+                return result;
+            }
         };
     }
 
@@ -30,6 +36,12 @@ protected BitMapProducer createEmptyProducer() {
     protected BitMapProducer createProducer() {
         final Hasher hasher = new IncrementingHasher(0, 1);
         final BloomFilter bf = new WrappedBloomFilter(new DefaultBloomFilterTest.SparseDefaultBloomFilter(shape)) {
+            @Override
+            public BloomFilter copy() {
+                BloomFilter result = new DefaultBloomFilterTest.SparseDefaultBloomFilter(shape);
+                result.merge(getWrapped());
+                return result;
+            }
         };
         bf.merge(hasher);
         return bf;
diff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/CellProducerFromLayeredBloomFilterTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/CellProducerFromLayeredBloomFilterTest.java
index 0c340061c4..ad3fa8c1c0 100644
--- a/src/test/java/org/apache/commons/collections4/bloomfilter/CellProducerFromLayeredBloomFilterTest.java
+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/CellProducerFromLayeredBloomFilterTest.java
@@ -22,13 +22,13 @@ public class CellProducerFromLayeredBloomFilterTest extends AbstractCellProducer
 
     @Override
     protected CellProducer createEmptyProducer() {
-        return CellProducer.from(LayeredBloomFilter.fixed(shape, 10));
+        return CellProducer.from(LayeredBloomFilterTest.fixed(shape, 10));
     }
 
     @Override
     protected CellProducer createProducer() {
         final Hasher hasher = new IncrementingHasher(3, 2);
-        final BloomFilter bf = LayeredBloomFilter.fixed(shape, 10);
+        final BloomFilter bf = LayeredBloomFilterTest.fixed(shape, 10);
         bf.merge(hasher);
         return CellProducer.from(bf);
     }
diff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/LayerManagerTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/LayerManagerTest.java
index 4ee438b89f..74e8b98e59 100644
--- a/src/test/java/org/apache/commons/collections4/bloomfilter/LayerManagerTest.java
+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/LayerManagerTest.java
@@ -16,9 +16,9 @@
  */
 package org.apache.commons.collections4.bloomfilter;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotEquals;
-import static org.junit.Assert.assertNotSame;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertNotEquals;
+import static org.junit.jupiter.api.Assertions.assertNotSame;
 import static org.junit.jupiter.api.Assertions.assertArrayEquals;
 import static org.junit.jupiter.api.Assertions.assertFalse;
 import static org.junit.jupiter.api.Assertions.assertSame;
@@ -27,6 +27,7 @@
 
 import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.Deque;
 import java.util.LinkedList;
 import java.util.List;
 import java.util.NoSuchElementException;
@@ -39,13 +40,13 @@
 
 public class LayerManagerTest {
 
-    private Shape shape = Shape.fromKM(17, 72);
+    private final Shape shape = Shape.fromKM(17, 72);
 
     @ParameterizedTest
     @ValueSource(ints = {4, 10, 2, 1})
     public void testAdvanceOnCount(int breakAt) {
-        Predicate<LayerManager> underTest = LayerManager.ExtendCheck.advanceOnCount(breakAt);
-        LayerManager layerManager = testingBuilder().build();
+        Predicate<LayerManager<BloomFilter>> underTest = LayerManager.ExtendCheck.advanceOnCount(breakAt);
+        LayerManager<BloomFilter> layerManager = testingBuilder().build();
         for (int i = 0; i < breakAt - 1; i++) {
             assertFalse(underTest.test(layerManager), "at " + i);
             layerManager.getTarget().merge(TestingHashers.FROM1);
@@ -61,8 +62,8 @@ public void testAdvanceOnCountInvalidArguments() {
 
     @Test
     public void testAdvanceOnPopulated() {
-        Predicate<LayerManager> underTest = LayerManager.ExtendCheck.advanceOnPopulated();
-        LayerManager layerManager = testingBuilder().build();
+        Predicate<LayerManager<BloomFilter>> underTest = LayerManager.ExtendCheck.advanceOnPopulated();
+        LayerManager<BloomFilter> layerManager = testingBuilder().build();
         assertFalse(underTest.test(layerManager));
         layerManager.getTarget().merge(TestingHashers.FROM1);
         assertTrue(underTest.test(layerManager));
@@ -70,10 +71,10 @@ public void testAdvanceOnPopulated() {
 
     @Test
     public void testAdvanceOnSaturation() {
-        Double maxN = shape.estimateMaxN();
+        double maxN = shape.estimateMaxN();
         int hashStart = 0;
-        Predicate<LayerManager> underTest = LayerManager.ExtendCheck.advanceOnSaturation(maxN);
-        LayerManager layerManager = testingBuilder().build();
+        Predicate<LayerManager<BloomFilter>> underTest = LayerManager.ExtendCheck.advanceOnSaturation(maxN);
+        LayerManager<BloomFilter> layerManager = testingBuilder().build();
         while (layerManager.getTarget().getShape().estimateN(layerManager.getTarget().cardinality()) < maxN) {
             assertFalse(underTest.test(layerManager));
             layerManager.getTarget().merge(new IncrementingHasher(hashStart, shape.getNumberOfHashFunctions()));
@@ -86,15 +87,15 @@ public void testAdvanceOnSaturation() {
 
     @Test
     public void testBuilder() {
-        LayerManager.Builder underTest = LayerManager.builder();
-        NullPointerException npe = assertThrows(NullPointerException.class, () -> underTest.build());
+        LayerManager.Builder<BloomFilter> underTest = LayerManager.builder();
+        NullPointerException npe = assertThrows(NullPointerException.class, underTest::build);
         assertTrue(npe.getMessage().contains("Supplier must not be null"));
         underTest.setSupplier(() -> null).setCleanup(null);
-        npe = assertThrows(NullPointerException.class, () -> underTest.build());
+        npe = assertThrows(NullPointerException.class, underTest::build);
         assertTrue(npe.getMessage().contains("Cleanup must not be null"));
         underTest.setCleanup(x -> {
         }).setExtendCheck(null);
-        npe = assertThrows(NullPointerException.class, () -> underTest.build());
+        npe = assertThrows(NullPointerException.class, underTest::build);
         assertTrue(npe.getMessage().contains("ExtendCheck must not be null"));
 
         npe = assertThrows(NullPointerException.class, () -> LayerManager.builder().setSupplier(() -> null).build());
@@ -104,7 +105,7 @@ public void testBuilder() {
 
     @Test
     public void testClear() {
-        LayerManager underTest = LayerManager.builder().setSupplier(() -> new SimpleBloomFilter(shape)).build();
+        LayerManager<BloomFilter> underTest = LayerManager.builder().setSupplier(() -> new SimpleBloomFilter(shape)).build();
         underTest.getTarget().merge(TestingHashers.randomHasher());
         underTest.next();
         underTest.getTarget().merge(TestingHashers.randomHasher());
@@ -118,7 +119,7 @@ public void testClear() {
 
     @Test
     public void testCopy() {
-        LayerManager underTest = LayerManager.builder().setSupplier(() -> new SimpleBloomFilter(shape)).build();
+        LayerManager<BloomFilter> underTest = LayerManager.builder().setSupplier(() -> new SimpleBloomFilter(shape)).build();
         underTest.getTarget().merge(TestingHashers.randomHasher());
         underTest.next();
         underTest.getTarget().merge(TestingHashers.randomHasher());
@@ -126,7 +127,7 @@ public void testCopy() {
         underTest.getTarget().merge(TestingHashers.randomHasher());
         assertEquals(3, underTest.getDepth());
 
-        LayerManager copy = underTest.copy();
+        LayerManager<BloomFilter> copy = underTest.copy();
         assertNotSame(underTest, copy);
         // object equals not implemented
         assertNotEquals(underTest, copy);
@@ -138,7 +139,7 @@ public void testCopy() {
 
     @Test
     public void testForEachBloomFilter() {
-        LayerManager underTest = LayerManager.builder().setSupplier(() -> new SimpleBloomFilter(shape))
+        LayerManager<BloomFilter> underTest = LayerManager.builder().setSupplier(() -> new SimpleBloomFilter(shape))
                 .setExtendCheck(LayerManager.ExtendCheck.advanceOnPopulated()).build();
 
         List<BloomFilter> lst = new ArrayList<>();
@@ -160,21 +161,21 @@ public void testForEachBloomFilter() {
     @Test
     public void testGet() {
         SimpleBloomFilter f = new SimpleBloomFilter(shape);
-        LayerManager underTest = LayerManager.builder().setSupplier(() -> f).build();
+        LayerManager<BloomFilter> underTest = LayerManager.builder().setSupplier(() -> f).build();
         assertEquals(1, underTest.getDepth());
         assertSame(f, underTest.get(0));
         assertThrows(NoSuchElementException.class, () -> underTest.get(-1));
         assertThrows(NoSuchElementException.class, () -> underTest.get(1));
     }
 
-    private LayerManager.Builder testingBuilder() {
+    private LayerManager.Builder<BloomFilter> testingBuilder() {
         return LayerManager.builder().setSupplier(() -> new SimpleBloomFilter(shape));
     }
 
     @Test
     public void testNeverAdvance() {
-        Predicate<LayerManager> underTest = LayerManager.ExtendCheck.neverAdvance();
-        LayerManager layerManager = testingBuilder().build();
+        Predicate<LayerManager<BloomFilter>> underTest = LayerManager.ExtendCheck.neverAdvance();
+        LayerManager<BloomFilter> layerManager = testingBuilder().build();
         assertFalse(underTest.test(layerManager));
         for (int i = 0; i < 10; i++) {
             layerManager.getTarget().merge(TestingHashers.randomHasher());
@@ -184,7 +185,7 @@ public void testNeverAdvance() {
 
     @Test
     public void testNextAndGetDepth() {
-        LayerManager underTest = LayerManager.builder().setSupplier(() -> new SimpleBloomFilter(shape)).build();
+        LayerManager<BloomFilter> underTest = LayerManager.builder().setSupplier(() -> new SimpleBloomFilter(shape)).build();
         assertEquals(1, underTest.getDepth());
         underTest.getTarget().merge(TestingHashers.randomHasher());
         assertEquals(1, underTest.getDepth());
@@ -194,8 +195,8 @@ public void testNextAndGetDepth() {
 
     @Test
     public void testNoCleanup() {
-        Consumer<LinkedList<BloomFilter>> underTest = LayerManager.Cleanup.noCleanup();
-        LinkedList<BloomFilter> list = new LinkedList<>();
+        Consumer<Deque<BloomFilter>> underTest = LayerManager.Cleanup.noCleanup();
+        Deque<BloomFilter> list = new LinkedList<>();
         for (int i = 0; i < 20; i++) {
             assertEquals(i, list.size());
             list.add(new SimpleBloomFilter(shape));
@@ -206,7 +207,7 @@ public void testNoCleanup() {
     @ParameterizedTest
     @ValueSource(ints = {5, 100, 2, 1})
     public void testOnMaxSize(int maxSize) {
-        Consumer<LinkedList<BloomFilter>> underTest = LayerManager.Cleanup.onMaxSize(maxSize);
+        Consumer<Deque<BloomFilter>> underTest = LayerManager.Cleanup.onMaxSize(maxSize);
         LinkedList<BloomFilter> list = new LinkedList<>();
         for (int i = 0; i < maxSize; i++) {
             assertEquals(i, list.size());
@@ -230,7 +231,7 @@ public void testOnMaxSizeIllegalValues() {
 
     @Test
     public void testRemoveEmptyTarget() {
-        Consumer<LinkedList<BloomFilter>> underTest = LayerManager.Cleanup.removeEmptyTarget();
+        Consumer<Deque<BloomFilter>> underTest = LayerManager.Cleanup.removeEmptyTarget();
         LinkedList<BloomFilter> list = new LinkedList<>();
 
         // removes an empty filter
@@ -265,7 +266,6 @@ public void testRemoveEmptyTarget() {
         underTest.accept(list);
         assertEquals(2, list.size());
         assertEquals(bf, list.get(0));
-
     }
 
     @Test
@@ -273,7 +273,7 @@ public void testTarget() {
         boolean[] extendCheckCalled = { false };
         boolean[] cleanupCalled = { false };
         int[] supplierCount = { 0 };
-        LayerManager underTest = LayerManager.builder().setSupplier(() -> {
+        LayerManager<BloomFilter> underTest = LayerManager.builder().setSupplier(() -> {
             supplierCount[0]++;
             return new SimpleBloomFilter(shape);
         }).setExtendCheck(lm -> {
@@ -291,13 +291,4 @@ public void testTarget() {
         assertEquals(2, supplierCount[0]);
     }
 
-    static class NumberedBloomFilter extends WrappedBloomFilter {
-        int value;
-        int sequence;
-        NumberedBloomFilter(Shape shape, int value, int sequence) {
-            super(new SimpleBloomFilter(shape));
-            this.value = value;
-            this.sequence = sequence;
-        }
-    }
 }
diff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/LayeredBloomFilterTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/LayeredBloomFilterTest.java
index 0859e58c65..25f807a80d 100644
--- a/src/test/java/org/apache/commons/collections4/bloomfilter/LayeredBloomFilterTest.java
+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/LayeredBloomFilterTest.java
@@ -16,30 +16,60 @@
  */
 package org.apache.commons.collections4.bloomfilter;
 
-import static org.junit.Assert.assertEquals;
 import static org.junit.jupiter.api.Assertions.assertArrayEquals;
 import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.junit.jupiter.api.Assertions.assertFalse;
 import static org.junit.jupiter.api.Assertions.assertTrue;
 
 import java.util.ArrayList;
-import java.util.LinkedList;
+import java.util.Deque;
+import java.util.Iterator;
 import java.util.List;
 import java.util.concurrent.TimeUnit;
 import java.util.function.Consumer;
 import java.util.function.Predicate;
+import java.util.function.Supplier;
 
 import org.apache.commons.collections4.bloomfilter.LayerManager.Cleanup;
 import org.apache.commons.collections4.bloomfilter.LayerManager.ExtendCheck;
-import org.apache.commons.collections4.bloomfilter.LayerManagerTest.NumberedBloomFilter;
 import org.junit.jupiter.api.Test;
 
-public class LayeredBloomFilterTest extends AbstractBloomFilterTest<LayeredBloomFilter> {
+public class LayeredBloomFilterTest extends AbstractBloomFilterTest<LayeredBloomFilter<?>> {
+
+    /**
+     * Creates a fixed size layered bloom filter that adds new filters to the list,
+     * but never merges them. List will never exceed maxDepth. As additional filters
+     * are added earlier filters are removed.  Uses SimpleBloomFilters.
+     *
+     * @param shape    The shape for the enclosed Bloom filters.
+     * @param maxDepth The maximum depth of layers.
+     * @return An empty layered Bloom filter of the specified shape and depth.
+     */
+    public static  LayeredBloomFilter<BloomFilter> fixed(final Shape shape, int maxDepth) {
+        return fixed(shape, maxDepth, () -> new SimpleBloomFilter(shape));
+    }
+
+    /**
+     * Creates a fixed size layered bloom filter that adds new filters to the list,
+     * but never merges them. List will never exceed maxDepth. As additional filters
+     * are added earlier filters are removed.
+     *
+     * @param shape    The shape for the enclosed Bloom filters.
+     * @param maxDepth The maximum depth of layers.
+     * @param supplier A supplier of the Bloom filters to create layers with.
+     * @return An empty layered Bloom filter of the specified shape and depth.
+     */
+    public static <T extends BloomFilter> LayeredBloomFilter<T> fixed(final Shape shape, int maxDepth, Supplier<T> supplier) {
+        LayerManager.Builder<T> builder = LayerManager.builder();
+        builder.setExtendCheck(LayerManager.ExtendCheck.advanceOnPopulated())
+                .setCleanup(LayerManager.Cleanup.onMaxSize(maxDepth)).setSupplier(supplier);
+        return new LayeredBloomFilter<>(shape, builder.build());
+    }
 
     /**
      * A Predicate that advances after a quantum of time.
      */
-    static class AdvanceOnTimeQuanta implements Predicate<LayerManager> {
+    static class AdvanceOnTimeQuanta implements Predicate<LayerManager<TimestampedBloomFilter>> {
         long quanta;
 
         AdvanceOnTimeQuanta(long quanta, TimeUnit unit) {
@@ -47,10 +77,9 @@ static class AdvanceOnTimeQuanta implements Predicate<LayerManager> {
         }
 
         @Override
-        public boolean test(LayerManager lm) {
+        public boolean test(LayerManager<TimestampedBloomFilter> lm) {
             // can not use getTarget() as it causes recursion.
-            TimestampedBloomFilter bf = (TimestampedBloomFilter) lm.get(lm.getDepth() - 1);
-            return bf.timestamp + quanta < System.currentTimeMillis();
+            return lm.last().timestamp + quanta < System.currentTimeMillis();
         }
     }
 
@@ -58,7 +87,7 @@ public boolean test(LayerManager lm) {
      * A Consumer that cleans the list based on how long each filters has been in
      * the list.
      */
-    static class CleanByTime implements Consumer<LinkedList<BloomFilter>> {
+    static class CleanByTime<T extends TimestampedBloomFilter> implements Consumer<List<T>> {
         long elapsedTime;
 
         CleanByTime(long duration, TimeUnit unit) {
@@ -66,13 +95,18 @@ static class CleanByTime implements Consumer<LinkedList<BloomFilter>> {
         }
 
         @Override
-        public void accept(LinkedList<BloomFilter> t) {
+        public void accept(List<T> t) {
             long min = System.currentTimeMillis() - elapsedTime;
-            while (!t.isEmpty() && ((TimestampedBloomFilter) t.getFirst()).getTimestamp() < min) {
-                TimestampedBloomFilter bf = (TimestampedBloomFilter) t.getFirst();
-                dbgInstrument.add(String.format("Removing old entry: T:%s (Aged: %s) \n", bf.getTimestamp(),
-                        (min - bf.getTimestamp())));
-                t.removeFirst();
+            Iterator<T> iter = t.iterator();
+            while (iter.hasNext()) {
+                TimestampedBloomFilter bf = iter.next();
+                if (bf.getTimestamp() < min) {
+                    dbgInstrument.add(String.format("Removing old entry: T:%s (Aged: %s) \n", bf.getTimestamp(),
+                            (min - bf.getTimestamp())));
+                    iter.remove();
+                } else {
+                    return;
+                }
             }
         }
     }
@@ -80,7 +114,7 @@ public void accept(LinkedList<BloomFilter> t) {
     /**
      * A Bloomfilter implementation that tracks the creation time.
      */
-    static class TimestampedBloomFilter extends WrappedBloomFilter {
+    public static class TimestampedBloomFilter extends WrappedBloomFilter {
         final long timestamp;
 
         TimestampedBloomFilter(BloomFilter bf) {
@@ -88,13 +122,23 @@ static class TimestampedBloomFilter extends WrappedBloomFilter {
             this.timestamp = System.currentTimeMillis();
         }
 
+        TimestampedBloomFilter(BloomFilter bf, long timestamp) {
+            super(bf);
+            this.timestamp = timestamp;
+        }
+
         public long getTimestamp() {
             return timestamp;
         }
+
+        @Override
+        public TimestampedBloomFilter copy() {
+            return new TimestampedBloomFilter(this.getWrapped().copy(), timestamp);
+        }
     }
 
     // ***example of instrumentation ***
-    private static List<String> dbgInstrument = new ArrayList<>();
+    private static final List<String> dbgInstrument = new ArrayList<>();
 
     /**
      * Creates a LayeredBloomFilter that retains enclosed filters for
@@ -109,19 +153,21 @@ public long getTimestamp() {
      * @param qUnit    the unit of time to apply to quanta.
      * @return LayeredBloomFilter with the above properties.
      */
-    static LayeredBloomFilter createTimedLayeredFilter(Shape shape, long duration, TimeUnit dUnit, long quanta,
+    static LayeredBloomFilter<TimestampedBloomFilter> createTimedLayeredFilter(Shape shape, long duration, TimeUnit dUnit, long quanta,
             TimeUnit qUnit) {
-        LayerManager layerManager = LayerManager.builder()
+        LayerManager.Builder<TimestampedBloomFilter> builder = LayerManager.builder();
+        Consumer<Deque<TimestampedBloomFilter>> cleanup = Cleanup.removeEmptyTarget().andThen(new CleanByTime(duration, dUnit));
+        LayerManager<TimestampedBloomFilter> layerManager = builder
                 .setSupplier(() -> new TimestampedBloomFilter(new SimpleBloomFilter(shape)))
-                .setCleanup(Cleanup.removeEmptyTarget().andThen(new CleanByTime(duration, dUnit)))
+                .setCleanup(cleanup)
                 .setExtendCheck(new AdvanceOnTimeQuanta(quanta, qUnit)
                         .or(LayerManager.ExtendCheck.advanceOnSaturation(shape.estimateMaxN())))
                 .build();
-        return new LayeredBloomFilter(shape, layerManager);
+        return new LayeredBloomFilter<>(shape, layerManager);
     }
 
     // instrumentation to record timestamps in dbgInstrument list
-    private Predicate<BloomFilter> dbg = (bf) -> {
+    private final Predicate<BloomFilter> dbg = (bf) -> {
         TimestampedBloomFilter tbf = (TimestampedBloomFilter) bf;
         long ts = System.currentTimeMillis();
         dbgInstrument.add(String.format("T:%s (Elapsed:%s)- EstN:%s (Card:%s)\n", tbf.timestamp, ts - tbf.timestamp,
@@ -131,8 +177,8 @@ static LayeredBloomFilter createTimedLayeredFilter(Shape shape, long duration, T
     // *** end of instrumentation ***
 
     @Override
-    protected LayeredBloomFilter createEmptyFilter(Shape shape) {
-        return LayeredBloomFilter.fixed(shape, 10);
+    protected LayeredBloomFilter<BloomFilter> createEmptyFilter(Shape shape) {
+        return LayeredBloomFilterTest.fixed(shape, 10);
     }
 
     protected BloomFilter makeFilter(Hasher h) {
@@ -151,8 +197,8 @@ protected BloomFilter makeFilter(int... values) {
         return makeFilter(IndexProducer.fromIndexArray(values));
     }
 
-    private LayeredBloomFilter setupFindTest() {
-        LayeredBloomFilter filter = LayeredBloomFilter.fixed(getTestShape(), 10);
+    private LayeredBloomFilter<BloomFilter> setupFindTest() {
+        LayeredBloomFilter<BloomFilter> filter = LayeredBloomFilterTest.fixed(getTestShape(), 10);
         filter.merge(TestingHashers.FROM1);
         filter.merge(TestingHashers.FROM11);
         filter.merge(new IncrementingHasher(11, 2));
@@ -163,9 +209,9 @@ private LayeredBloomFilter setupFindTest() {
     @Override
     @Test
     public void testCardinalityAndIsEmpty() {
-        LayerManager layerManager = LayerManager.builder().setExtendCheck(ExtendCheck.neverAdvance())
+        LayerManager<BloomFilter> layerManager = LayerManager.builder().setExtendCheck(ExtendCheck.neverAdvance())
                 .setSupplier(() -> new SimpleBloomFilter(getTestShape())).build();
-        testCardinalityAndIsEmpty(new LayeredBloomFilter(getTestShape(), layerManager));
+        testCardinalityAndIsEmpty(new LayeredBloomFilter<>(getTestShape(), layerManager));
     }
 
     /**
@@ -194,7 +240,7 @@ public void testExpiration() throws InterruptedException {
 
         // create a filter that removes filters that are 4 seconds old
         // and quantises time to 1 second intervals.
-        LayeredBloomFilter underTest = createTimedLayeredFilter(shape, 600, TimeUnit.MILLISECONDS, 150,
+        LayeredBloomFilter<TimestampedBloomFilter> underTest = createTimedLayeredFilter(shape, 600, TimeUnit.MILLISECONDS, 150,
                 TimeUnit.MILLISECONDS);
 
         for (int i = 0; i < 10; i++) {
@@ -226,7 +272,7 @@ public void testExpiration() throws InterruptedException {
     }
     @Test
     public void testFindBitMapProducer() {
-        LayeredBloomFilter filter = setupFindTest();
+        LayeredBloomFilter<BloomFilter> filter = setupFindTest();
 
         IndexProducer idxProducer = TestingHashers.FROM1.indices(getTestShape());
         BitMapProducer producer = BitMapProducer.fromIndexProducer(idxProducer, getTestShape().getNumberOfBits());
@@ -244,7 +290,7 @@ public void testFindBitMapProducer() {
 
     @Test
     public void testFindBloomFilter() {
-        LayeredBloomFilter filter = setupFindTest();
+        LayeredBloomFilter<BloomFilter> filter = setupFindTest();
         int[] expected = {0, 3};
         int[] result = filter.find(TestingHashers.FROM1);
         assertArrayEquals(expected, result);
@@ -256,7 +302,7 @@ public void testFindBloomFilter() {
     @Test
     public void testFindIndexProducer() {
         IndexProducer producer = TestingHashers.FROM1.indices(getTestShape());
-        LayeredBloomFilter filter = setupFindTest();
+        LayeredBloomFilter<BloomFilter> filter = setupFindTest();
 
         int[] expected = {0, 3};
         int[] result = filter.find(producer);
@@ -272,7 +318,7 @@ public void testFindIndexProducer() {
     public final void testGetLayer() {
         BloomFilter bf = new SimpleBloomFilter(getTestShape());
         bf.merge(TestingHashers.FROM11);
-        LayeredBloomFilter filter = LayeredBloomFilter.fixed(getTestShape(), 10);
+        LayeredBloomFilter<BloomFilter> filter = LayeredBloomFilterTest.fixed(getTestShape(), 10);
         filter.merge(TestingHashers.FROM1);
         filter.merge(TestingHashers.FROM11);
         filter.merge(new IncrementingHasher(11, 2));
@@ -282,7 +328,7 @@ public final void testGetLayer() {
 
     @Test
     public void testMultipleFilters() {
-        LayeredBloomFilter filter = LayeredBloomFilter.fixed(getTestShape(), 10);
+        LayeredBloomFilter<BloomFilter> filter = LayeredBloomFilterTest.fixed(getTestShape(), 10);
         filter.merge(TestingHashers.FROM1);
         filter.merge(TestingHashers.FROM11);
         assertEquals(2, filter.getDepth());
@@ -296,10 +342,10 @@ public void testMultipleFilters() {
 
     @Test
     public final void testNext() {
-        LayerManager layerManager = LayerManager.builder().setSupplier(() -> new SimpleBloomFilter(getTestShape()))
+        LayerManager<BloomFilter> layerManager = LayerManager.builder().setSupplier(() -> new SimpleBloomFilter(getTestShape()))
                 .build();
 
-        LayeredBloomFilter filter = new LayeredBloomFilter(getTestShape(), layerManager);
+        LayeredBloomFilter<BloomFilter> filter = new LayeredBloomFilter<>(getTestShape(), layerManager);
         filter.merge(TestingHashers.FROM1);
         filter.merge(TestingHashers.FROM11);
         assertEquals(1, filter.getDepth());
@@ -345,4 +391,19 @@ public void testCleanup() {
         f = (NumberedBloomFilter) underTest.get(0);
         assertEquals(3, f.sequence);  // it is a new one.
     }
+
+    static class NumberedBloomFilter extends WrappedBloomFilter {
+        int value;
+        int sequence;
+        NumberedBloomFilter(Shape shape, int value, int sequence) {
+            super(new SimpleBloomFilter(shape));
+            this.value = value;
+            this.sequence = sequence;
+        }
+
+        @Override
+        public BloomFilter copy() {
+            return new NumberedBloomFilter(getShape(), value, sequence);
+        }
+    }
 }
diff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/WrappedBloomFilterTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/WrappedBloomFilterTest.java
index eca4a21a3b..5e346b95a2 100644
--- a/src/test/java/org/apache/commons/collections4/bloomfilter/WrappedBloomFilterTest.java
+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/WrappedBloomFilterTest.java
@@ -26,6 +26,12 @@ public class WrappedBloomFilterTest extends AbstractBloomFilterTest<WrappedBloom
     @Override
     protected WrappedBloomFilter createEmptyFilter(Shape shape) {
         return new WrappedBloomFilter(new DefaultBloomFilterTest.SparseDefaultBloomFilter(shape)) {
+            @Override
+            public BloomFilter copy() {
+                BloomFilter result = new DefaultBloomFilterTest.SparseDefaultBloomFilter(shape);
+                result.merge(this.getWrapped());
+                return result;
+            }
         };
     }
 
@@ -39,7 +45,14 @@ public int characteristics() {
                 return characteristics;
             }
         };
-        WrappedBloomFilter underTest = new WrappedBloomFilter(inner) {};
+        WrappedBloomFilter underTest = new WrappedBloomFilter(inner) {
+            @Override
+            public BloomFilter copy() {
+                BloomFilter result = new DefaultBloomFilterTest.SparseDefaultBloomFilter(shape);
+                result.merge(this.getWrapped());
+                return result;
+            }
+        };
         assertEquals(characteristics, underTest.characteristics());
     }
 }
