diff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBloomFilterProducerTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBloomFilterProducerTest.java
new file mode 100644
index 0000000000..3d445add96
--- /dev/null
+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBloomFilterProducerTest.java
@@ -0,0 +1,146 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.collections4.bloomfilter;
+
+import static org.junit.Assert.assertFalse;
+import static org.junit.jupiter.api.Assertions.assertArrayEquals;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+
+import java.util.function.BiPredicate;
+
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+
+public abstract class AbstractBloomFilterProducerTest {
+    private Shape shape = Shape.fromKM(17, 72);
+
+    BloomFilter one = new SimpleBloomFilter(shape);
+    BloomFilter two = new SimpleBloomFilter(shape);
+    int[] nullCount = { 0, 0 };
+    int[] equalityCount = { 0 };
+    BiPredicate<BloomFilter, BloomFilter> counter = (x, y) -> {
+        if (x == null) {
+            nullCount[0]++;
+        }
+        if (y == null) {
+            nullCount[1]++;
+        }
+        if (x != null && y != null && x.cardinality() == y.cardinality()) {
+            equalityCount[0]++;
+        }
+        return true;
+    };
+
+    /**
+     * The shape of the Bloom filters for testing.
+     * <ul>
+     *  <li>Hash functions (k) = 17
+     *  <li>Number of bits (m) = 72
+     * </ul>
+     * @return the testing shape.
+     */
+    protected Shape getTestShape() {
+        return shape;
+    }
+
+    @BeforeEach
+    public void setup() {
+        one.clear();
+        one.merge(IndexProducer.fromIndexArray(1));
+        two.clear();
+        two.merge(IndexProducer.fromIndexArray(2, 3));
+        nullCount[0] = 0;
+        nullCount[1] = 0;
+        equalityCount[0] = 0;
+    }
+
+    /**
+     * Creates a BloomFilterProducer that returns the filters (or their copy) in the order presented.
+     * @param filters The filters to return.
+     * @return A BloomFilterProducer that returns the filters in order.
+     */
+    protected abstract BloomFilterProducer createUnderTest(BloomFilter... filters);
+
+    private BloomFilterProducer createUnderTest() {
+        return createUnderTest(one, two);
+    }
+
+    @Test
+    public void testAsBloomFilterArray() {
+        BloomFilter[] result = createUnderTest().asBloomFilterArray();
+        assertEquals(2, result.length);
+        assertEquals(1, result[0].cardinality());
+        assertEquals(2, result[1].cardinality());
+    }
+
+    @Test
+    public void testForEachPairCompleteMatch() {
+        assertTrue(createUnderTest().forEachBloomFilterPair(createUnderTest(), counter));
+        assertArrayEquals(new int[] { 0, 0 }, nullCount);
+        assertEquals(2, equalityCount[0]);
+    }
+
+    @Test
+    public void testForEachPairArrayTooShort() {
+        assertTrue(createUnderTest().forEachBloomFilterPair(BloomFilterProducer.fromBloomFilterArray(one), counter));
+        assertEquals(0, nullCount[0]);
+        assertEquals(1, nullCount[1]);
+        assertEquals(1, equalityCount[0]);
+    }
+
+    @Test
+    public void testForEachPairArrayTooLong() {
+        assertTrue(createUnderTest().forEachBloomFilterPair(BloomFilterProducer.fromBloomFilterArray(one, two, one),
+                counter));
+        assertEquals(1, nullCount[0]);
+        assertEquals(0, nullCount[1]);
+        assertEquals(2, equalityCount[0]);
+    }
+
+    @Test
+    public void testForEachPairReturnFalseLate() {
+        assertFalse(createUnderTest().forEachBloomFilterPair(BloomFilterProducer.fromBloomFilterArray(one, two, one),
+                counter.and((x, y) -> x != null && y != null)));
+        assertEquals(1, nullCount[0]);
+        assertEquals(0, nullCount[1]);
+        assertEquals(2, equalityCount[0]);
+    }
+
+    @Test
+    public void testForEachPairReturnFalseLateShortArray() {
+        assertFalse(createUnderTest().forEachBloomFilterPair(BloomFilterProducer.fromBloomFilterArray(one),
+                counter.and((x, y) -> x != null && y != null)));
+        assertEquals(0, nullCount[0]);
+        assertEquals(1, nullCount[1]);
+        assertEquals(1, equalityCount[0]);
+    }
+
+    @Test
+    public void testForEachPairReturnFalseEarly() {
+        assertFalse(createUnderTest().forEachBloomFilterPair(BloomFilterProducer.fromBloomFilterArray(one, two, one),
+                (x, y) -> false));
+    }
+
+    @Test
+    public void testFlatten() {
+        BloomFilter underTest = createUnderTest().flatten();
+        BloomFilter expected = new SimpleBloomFilter(shape);
+        expected.merge(IndexProducer.fromIndexArray(1, 2, 3));
+        assertArrayEquals(expected.asBitMapArray(), underTest.asBitMapArray());
+    }
+}
diff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBloomFilterTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBloomFilterTest.java
index 3d332146d5..32cb95d262 100644
--- a/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBloomFilterTest.java
+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBloomFilterTest.java
@@ -174,10 +174,10 @@ public final void testContains() {
         BloomFilter bf1 = createFilter(getTestShape(), TestingHashers.FROM1);
         final BloomFilter bf2 = TestingHashers.populateFromHashersFrom1AndFrom11(createEmptyFilter(getTestShape()));
 
-        assertTrue(bf1.contains(bf1), "BF Should contain itself");
+        assertTrue(bf1.contains(bf1), "BF1 Should contain itself");
         assertTrue(bf2.contains(bf2), "BF2 Should contain itself");
-        assertFalse(bf1.contains(bf2), "BF should not contain BF2");
-        assertTrue(bf2.contains(bf1), "BF2 should contain BF");
+        assertFalse(bf1.contains(bf2), "BF1 should not contain BF2");
+        assertTrue(bf2.contains(bf1), "BF2 should contain BF1");
 
         assertTrue(bf2.contains(new IncrementingHasher(1, 1)), "BF2 Should contain this hasher");
         assertFalse(bf2.contains(new IncrementingHasher(1, 3)), "BF2 Should not contain this hasher");
@@ -433,6 +433,46 @@ public void testBitMapProducerSize() {
         assertEquals(BitMap.numberOfBitMaps(getTestShape().getNumberOfBits()), idx[0]);
     }
 
+    /**
+     * Test cardinality and isEmpty. Bloom filter must be able to accept multiple
+     * IndexProducer merges until all the bits are populated.
+     *
+     * @param bf The Bloom filter to test.
+     */
+    protected void testCardinalityAndIsEmpty(BloomFilter bf) {
+        assertTrue(bf.isEmpty());
+        assertEquals(0, bf.cardinality());
+        for (int i = 0; i < getTestShape().getNumberOfBits(); i++) {
+            bf.merge(IndexProducer.fromIndexArray(i));
+            assertFalse(bf.isEmpty(), "Wrong value at " + i);
+            assertEquals(i + 1, bf.cardinality(), "Wrong value at " + i);
+        }
+
+        // check operations in reverse order
+        bf.clear();
+        assertEquals(0, bf.cardinality());
+        assertTrue(bf.isEmpty());
+        for (int i = 0; i < getTestShape().getNumberOfBits(); i++) {
+            bf.merge(IndexProducer.fromIndexArray(i));
+            assertEquals(i + 1, bf.cardinality(), "Wrong value at " + i);
+            assertFalse(bf.isEmpty(), "Wrong value at " + i);
+        }
+    }
+
+    @Test
+    public void testCardinalityAndIsEmpty() {
+        testCardinalityAndIsEmpty(createEmptyFilter(getTestShape()));
+    }
+
+    @Test
+    public void testEmptyAfterMergeWithNothing() {
+        // test the case where is empty after merge
+        // in this case the internal cardinality == -1
+        BloomFilter bf = createEmptyFilter(getTestShape());
+        bf.merge(IndexProducer.fromIndexArray());
+        assertTrue(bf.isEmpty());
+    }
+
     /**
      * Testing class returns the value as the only value.
      */
diff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractIndexProducerTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractIndexProducerTest.java
index faa66ead7b..044dcd1721 100644
--- a/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractIndexProducerTest.java
+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractIndexProducerTest.java
@@ -16,10 +16,10 @@
  */
 package org.apache.commons.collections4.bloomfilter;
 
-import static org.junit.Assert.assertSame;
 import static org.junit.jupiter.api.Assertions.assertArrayEquals;
 import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.junit.jupiter.api.Assertions.assertFalse;
+import static org.junit.jupiter.api.Assertions.assertSame;
 import static org.junit.jupiter.api.Assertions.assertTrue;
 
 import java.util.Arrays;
diff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/BitMapProducerFromLayeredBloomFilterTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/BitMapProducerFromLayeredBloomFilterTest.java
new file mode 100644
index 0000000000..e8a2d0c78b
--- /dev/null
+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/BitMapProducerFromLayeredBloomFilterTest.java
@@ -0,0 +1,35 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.collections4.bloomfilter;
+
+public class BitMapProducerFromLayeredBloomFilterTest extends AbstractBitMapProducerTest {
+
+    protected Shape shape = Shape.fromKM(17, 72);
+
+    @Override
+    protected BitMapProducer createProducer() {
+        final Hasher hasher = new IncrementingHasher(0, 1);
+        final BloomFilter bf = LayeredBloomFilter.fixed(shape, 10);
+        bf.merge(hasher);
+        return bf;
+    }
+
+    @Override
+    protected BitMapProducer createEmptyProducer() {
+        return LayeredBloomFilter.fixed(shape, 10);
+    }
+}
diff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/BitMapProducerFromWrappedBloomFilterTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/BitMapProducerFromWrappedBloomFilterTest.java
new file mode 100644
index 0000000000..b665bc9e94
--- /dev/null
+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/BitMapProducerFromWrappedBloomFilterTest.java
@@ -0,0 +1,38 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.collections4.bloomfilter;
+
+public class BitMapProducerFromWrappedBloomFilterTest extends AbstractBitMapProducerTest {
+
+    protected Shape shape = Shape.fromKM(17, 72);
+
+    @Override
+    protected BitMapProducer createProducer() {
+        final Hasher hasher = new IncrementingHasher(0, 1);
+        final BloomFilter bf = new WrappedBloomFilter(new DefaultBloomFilterTest.SparseDefaultBloomFilter(shape)) {
+        };
+        bf.merge(hasher);
+        return bf;
+    }
+
+    @Override
+    protected BitMapProducer createEmptyProducer() {
+        return new WrappedBloomFilter(new DefaultBloomFilterTest.SparseDefaultBloomFilter(shape)) {
+        };
+    }
+
+}
diff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/BloomFilterProducerFromBloomFilterArrayTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/BloomFilterProducerFromBloomFilterArrayTest.java
new file mode 100644
index 0000000000..8a6eba7de0
--- /dev/null
+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/BloomFilterProducerFromBloomFilterArrayTest.java
@@ -0,0 +1,25 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.collections4.bloomfilter;
+
+public class BloomFilterProducerFromBloomFilterArrayTest extends AbstractBloomFilterProducerTest{
+
+    @Override
+    protected BloomFilterProducer createUnderTest(BloomFilter... filters) {
+        return BloomFilterProducer.fromBloomFilterArray(filters);
+    }
+}
diff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/BloomFilterProducerFromLayeredBloomFilterTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/BloomFilterProducerFromLayeredBloomFilterTest.java
new file mode 100644
index 0000000000..de93190931
--- /dev/null
+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/BloomFilterProducerFromLayeredBloomFilterTest.java
@@ -0,0 +1,33 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.collections4.bloomfilter;
+
+public class BloomFilterProducerFromLayeredBloomFilterTest extends AbstractBloomFilterProducerTest{
+
+    @Override
+    protected BloomFilterProducer createUnderTest(BloomFilter... filters) {
+        Shape shape = filters[0].getShape();
+        LayerManager layerManager = LayerManager.builder().setSupplier( () -> new SimpleBloomFilter(shape) )
+                .setExtendCheck( LayerManager.ExtendCheck.advanceOnPopulated())
+                .setCleanup(LayerManager.Cleanup.noCleanup()).build();
+        LayeredBloomFilter underTest = new LayeredBloomFilter(shape, layerManager);
+        for (BloomFilter bf : filters) {
+            underTest.merge(bf);
+        }
+        return underTest;
+    }
+}
diff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/CellProducerFromLayeredBloomFilterTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/CellProducerFromLayeredBloomFilterTest.java
new file mode 100644
index 0000000000..6c22b37f86
--- /dev/null
+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/CellProducerFromLayeredBloomFilterTest.java
@@ -0,0 +1,45 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.collections4.bloomfilter;
+
+public class CellProducerFromLayeredBloomFilterTest extends AbstractCellProducerTest {
+
+    protected Shape shape = Shape.fromKM(17, 72);
+
+    @Override
+    protected CellProducer createProducer() {
+        final Hasher hasher = new IncrementingHasher(3, 2);
+        final BloomFilter bf = LayeredBloomFilter.fixed(shape, 10);
+        bf.merge(hasher);
+        return CellProducer.from(bf);
+    }
+
+    @Override
+    protected CellProducer createEmptyProducer() {
+        return CellProducer.from(LayeredBloomFilter.fixed(shape, 10));
+    }
+
+    @Override
+    protected int[] getExpectedIndices() {
+        return new int[] {3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35};
+    }
+
+    @Override
+    protected int[] getExpectedValues() {
+        return new int[] {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};
+    }
+}
diff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/CountingPredicateTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/CountingPredicateTest.java
new file mode 100644
index 0000000000..d03c94d180
--- /dev/null
+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/CountingPredicateTest.java
@@ -0,0 +1,118 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.collections4.bloomfilter;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.function.BiPredicate;
+
+import org.apache.commons.lang3.tuple.Pair;
+import org.junit.jupiter.api.Test;
+
+public class CountingPredicateTest {
+
+    private Integer[] ary = {Integer.valueOf(1), Integer.valueOf(2)};
+
+    private BiPredicate<Integer, Integer> makeFunc(BiPredicate<Integer, Integer> inner, List<Pair<Integer, Integer>> result) {
+        return (x, y) -> {
+            if (inner.test(x, y)) {
+                result.add(Pair.of(x, y));
+                return true;
+            }
+            return false;
+        };
+    }
+
+    /**
+     * Test when the predicate array is shorter than other array as determined by the number
+     * of times cp.test() is called and all other values result in a true statement.
+     */
+    @Test
+    public void testPredicateShorter() {
+        List<Pair<Integer, Integer>> expected = new ArrayList<>();
+        List<Pair<Integer, Integer>> result = new ArrayList<>();
+        Integer[] shortAry = {Integer.valueOf(3)};
+        expected.add(Pair.of(3, 1));
+        expected.add(Pair.of(null, 2));
+        CountingPredicate<Integer> cp = new CountingPredicate<>(shortAry, makeFunc((x, y) -> true, result));
+        for (Integer i : ary) {
+            assertTrue(cp.test(i));
+        }
+        assertEquals(expected, result);
+        assertTrue(cp.forEachRemaining());
+        assertEquals(expected, result);
+    }
+
+    /**
+     * Test when the predicate array is shorter than other array as determined by the number
+     * of times cp.test() is called and all other values result in a true statement.
+     */
+    @Test
+    public void testPredicateSameLength() {
+        List<Pair<Integer, Integer>> expected = new ArrayList<>();
+        List<Pair<Integer, Integer>> result = new ArrayList<>();
+        expected.add( Pair.of(1, 3));
+        expected.add( Pair.of(2, 3));
+        CountingPredicate<Integer> cp = new CountingPredicate<>(ary, makeFunc((x, y) -> true, result));
+        assertTrue(cp.test(3));
+        assertTrue(cp.test(3));
+        assertEquals(expected, result);
+        assertTrue(cp.forEachRemaining());
+        assertEquals(expected, result);
+    }
+
+    /**
+     * Test when the predicate array is longer than other array as determined by the number
+     * of times cp.test() is called and all other values result in a true statement.
+     */
+    @Test
+    public void testPredicateLonger() {
+        List<Pair<Integer, Integer>> expected = new ArrayList<>();
+        List<Pair<Integer, Integer>> result = new ArrayList<>();
+        expected.add(Pair.of(1, 3));
+
+        CountingPredicate<Integer> cp = new CountingPredicate<>(ary, makeFunc((x, y) -> x!=null, result));
+        assertTrue(cp.test(Integer.valueOf(3)));
+        assertEquals(expected, result);
+        expected.add(Pair.of(2, null));
+        assertTrue(cp.forEachRemaining());
+        assertEquals(expected, result);
+
+        // if the other array is zero length then cp.test() will not be called so
+        // we can just call cp.forEachRemaining() here.
+        expected.clear();
+        expected.add(Pair.of(1, null));
+        expected.add(Pair.of(2, null));
+        result.clear();
+        cp = new CountingPredicate<>(ary, makeFunc((x, y) -> x!=null, result));
+        assertTrue(cp.forEachRemaining());
+        assertEquals( expected, result);
+
+        // If a test fails then the result should be false and the rest of the list should
+        // not be processed.
+        expected.clear();
+        expected.add(Pair.of(1, null));
+        result.clear();
+        cp = new CountingPredicate<>(ary,  makeFunc((x, y) -> x == Integer.valueOf(1), result));
+        assertFalse(cp.forEachRemaining());
+        assertEquals(expected, result);
+    }
+}
diff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/DefaultBloomFilterProducerTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/DefaultBloomFilterProducerTest.java
new file mode 100644
index 0000000000..81d41abf99
--- /dev/null
+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/DefaultBloomFilterProducerTest.java
@@ -0,0 +1,37 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.collections4.bloomfilter;
+
+import java.util.function.Predicate;
+
+public class DefaultBloomFilterProducerTest extends AbstractBloomFilterProducerTest {
+
+    @Override
+    protected BloomFilterProducer createUnderTest(BloomFilter... filters) {
+        return new BloomFilterProducer() {
+            @Override
+            public boolean forEachBloomFilter(Predicate<BloomFilter> bloomFilterPredicate) {
+                for (BloomFilter bf : filters) {
+                    if (!bloomFilterPredicate.test(bf)) {
+                        return false;
+                    }
+                }
+                return true;
+            }
+        };
+    }
+}
diff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/DefaultBloomFilterTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/DefaultBloomFilterTest.java
index e716c42b56..bd7456c709 100644
--- a/src/test/java/org/apache/commons/collections4/bloomfilter/DefaultBloomFilterTest.java
+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/DefaultBloomFilterTest.java
@@ -215,9 +215,12 @@ public int cardinality() {
         }
     }
 
-    static class SparseDefaultBloomFilter extends AbstractDefaultBloomFilter {
+    /**
+     * A default implementation of a Sparse bloom filter.
+     */
+    public static class SparseDefaultBloomFilter extends AbstractDefaultBloomFilter {
 
-        SparseDefaultBloomFilter(final Shape shape) {
+        public SparseDefaultBloomFilter(final Shape shape) {
             super(shape);
         }
 
@@ -234,9 +237,12 @@ public AbstractDefaultBloomFilter copy() {
         }
     }
 
-    static class NonSparseDefaultBloomFilter extends AbstractDefaultBloomFilter {
+    /**
+     * A default implementation of a non-sparse Bloom filter.
+     */
+    public static class NonSparseDefaultBloomFilter extends AbstractDefaultBloomFilter {
 
-        NonSparseDefaultBloomFilter(final Shape shape) {
+        public NonSparseDefaultBloomFilter(final Shape shape) {
             super(shape);
         }
 
diff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/LayerManagerTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/LayerManagerTest.java
new file mode 100644
index 0000000000..c7023b1703
--- /dev/null
+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/LayerManagerTest.java
@@ -0,0 +1,294 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.collections4.bloomfilter;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotEquals;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.jupiter.api.Assertions.assertArrayEquals;
+import static org.junit.jupiter.api.Assertions.assertFalse;
+import static org.junit.jupiter.api.Assertions.assertSame;
+import static org.junit.jupiter.api.Assertions.assertThrows;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.NoSuchElementException;
+import java.util.function.Consumer;
+import java.util.function.Predicate;
+
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.ValueSource;
+
+public class LayerManagerTest {
+
+    private Shape shape = Shape.fromKM(17, 72);
+
+    private LayerManager.Builder testingBuilder() {
+        return LayerManager.builder().setSupplier(() -> new SimpleBloomFilter(shape));
+    }
+
+    @Test
+    public void testAdvanceOnPopulated() {
+        Predicate<LayerManager> underTest = LayerManager.ExtendCheck.advanceOnPopulated();
+        LayerManager layerManager = testingBuilder().build();
+        assertFalse(underTest.test(layerManager));
+        layerManager.getTarget().merge(TestingHashers.FROM1);
+        assertTrue(underTest.test(layerManager));
+    }
+
+    @Test
+    public void testNeverAdvance() {
+        Predicate<LayerManager> underTest = LayerManager.ExtendCheck.neverAdvance();
+        LayerManager layerManager = testingBuilder().build();
+        assertFalse(underTest.test(layerManager));
+        for (int i = 0; i < 10; i++) {
+            layerManager.getTarget().merge(TestingHashers.randomHasher());
+            assertFalse(underTest.test(layerManager));
+        }
+    }
+
+    @ParameterizedTest
+    @ValueSource(ints = {4, 10, 2, 1})
+    public void testAdvanceOnCount(int breakAt) {
+        Predicate<LayerManager> underTest = LayerManager.ExtendCheck.advanceOnCount(breakAt);
+        LayerManager layerManager = testingBuilder().build();
+        for (int i = 0; i < breakAt - 1; i++) {
+            assertFalse(underTest.test(layerManager), "at " + i);
+            layerManager.getTarget().merge(TestingHashers.FROM1);
+        }
+        assertTrue(underTest.test(layerManager));
+    }
+
+    @Test
+    public void testAdvanceOnCountInvalidArguments() {
+        assertThrows(IllegalArgumentException.class, () -> LayerManager.ExtendCheck.advanceOnCount(0));
+        assertThrows(IllegalArgumentException.class, () -> LayerManager.ExtendCheck.advanceOnCount(-1));
+    }
+
+    @Test
+    public void testAdvanceOnSaturation() {
+        Double maxN = shape.estimateMaxN();
+        int hashStart = 0;
+        Predicate<LayerManager> underTest = LayerManager.ExtendCheck.advanceOnSaturation(maxN);
+        LayerManager layerManager = testingBuilder().build();
+        while (layerManager.getTarget().getShape().estimateN(layerManager.getTarget().cardinality()) < maxN) {
+            assertFalse(underTest.test(layerManager));
+            layerManager.getTarget().merge(new IncrementingHasher(hashStart, shape.getNumberOfHashFunctions()));
+            hashStart+=shape.getNumberOfHashFunctions();
+        }
+        assertTrue(underTest.test(layerManager));
+        assertThrows(IllegalArgumentException.class, () -> LayerManager.ExtendCheck.advanceOnSaturation(0));
+        assertThrows(IllegalArgumentException.class, () -> LayerManager.ExtendCheck.advanceOnSaturation(-1));
+    }
+
+    @ParameterizedTest
+    @ValueSource(ints = {5, 100, 2, 1})
+    public void testOnMaxSize(int maxSize) {
+        Consumer<LinkedList<BloomFilter>> underTest = LayerManager.Cleanup.onMaxSize(maxSize);
+        LinkedList<BloomFilter> list = new LinkedList<>();
+        for (int i = 0; i < maxSize; i++) {
+            assertEquals(i, list.size());
+            list.add(new SimpleBloomFilter(shape));
+            underTest.accept(list);
+        }
+        assertEquals(maxSize, list.size());
+
+        for (int i = 0; i < maxSize; i++) {
+            list.add(new SimpleBloomFilter(shape));
+            underTest.accept(list);
+            assertEquals(maxSize, list.size());
+        }
+    }
+
+    @Test
+    public void testOnMaxSizeIllegalValues() {
+        assertThrows(IllegalArgumentException.class, () -> LayerManager.Cleanup.onMaxSize(0));
+        assertThrows(IllegalArgumentException.class, () -> LayerManager.Cleanup.onMaxSize(-1));
+    }
+
+    @Test
+    public void testNoCleanup() {
+        Consumer<LinkedList<BloomFilter>> underTest = LayerManager.Cleanup.noCleanup();
+        LinkedList<BloomFilter> list = new LinkedList<>();
+        for (int i = 0; i < 20; i++) {
+            assertEquals(i, list.size());
+            list.add(new SimpleBloomFilter(shape));
+            underTest.accept(list);
+        }
+    }
+
+    @Test
+    public void testRemoveEmptyTarget() {
+        Consumer<LinkedList<BloomFilter>> underTest = LayerManager.Cleanup.removeEmptyTarget();
+        LinkedList<BloomFilter> list = new LinkedList<>();
+
+        // removes an empty filter
+        BloomFilter bf = new SimpleBloomFilter(shape);
+        list.add(bf);
+        assertEquals(bf, list.get(0));
+        underTest.accept(list);
+        assertTrue(list.isEmpty());
+
+        // does not remove a populated filter.
+        bf.merge(IndexProducer.fromIndexArray(1));
+        list.add(bf);
+        assertEquals(bf, list.get(0));
+        underTest.accept(list);
+        assertEquals(bf, list.get(0));
+
+        // does not remove an empty filter followed by a populated filter.
+        list.clear();
+        list.add(new SimpleBloomFilter(shape));
+        list.add(bf);
+        assertEquals(2, list.size());
+        underTest.accept(list);
+        assertEquals(2, list.size());
+
+        // does not remove multiple empty filters at the end of the list, just the last
+        // one.
+        list.clear();
+        list.add(bf);
+        list.add(new SimpleBloomFilter(shape));
+        list.add(new SimpleBloomFilter(shape));
+        assertEquals(3, list.size());
+        underTest.accept(list);
+        assertEquals(2, list.size());
+        assertEquals(bf, list.get(0));
+
+    }
+
+    @Test
+    public void testCopy() {
+        LayerManager underTest = LayerManager.builder().setSupplier(() -> new SimpleBloomFilter(shape)).build();
+        underTest.getTarget().merge(TestingHashers.randomHasher());
+        underTest.next();
+        underTest.getTarget().merge(TestingHashers.randomHasher());
+        underTest.next();
+        underTest.getTarget().merge(TestingHashers.randomHasher());
+        assertEquals(3, underTest.getDepth());
+
+        LayerManager copy = underTest.copy();
+        assertNotSame(underTest, copy);
+        // object equals not implemented
+        assertNotEquals(underTest, copy);
+
+        assertEquals(underTest.getDepth(), copy.getDepth());
+        assertTrue(
+                underTest.forEachBloomFilterPair(copy, (x, y) -> Arrays.equals(x.asBitMapArray(), y.asBitMapArray())));
+    }
+
+    @Test
+    public void testBuilder() {
+        LayerManager.Builder underTest = LayerManager.builder();
+        NullPointerException npe = assertThrows(NullPointerException.class, () -> underTest.build());
+        assertTrue(npe.getMessage().contains("Supplier must not be null"));
+        underTest.setSupplier(() -> null).setCleanup(null);
+        npe = assertThrows(NullPointerException.class, () -> underTest.build());
+        assertTrue(npe.getMessage().contains("Cleanup must not be null"));
+        underTest.setCleanup(x -> {
+        }).setExtendCheck(null);
+        npe = assertThrows(NullPointerException.class, () -> underTest.build());
+        assertTrue(npe.getMessage().contains("ExtendCheck must not be null"));
+
+        npe = assertThrows(NullPointerException.class, () -> LayerManager.builder().setSupplier(() -> null).build());
+        assertTrue(npe.getMessage().contains("filterSupplier returned null."));
+
+    }
+
+    @Test
+    public void testClear() {
+        LayerManager underTest = LayerManager.builder().setSupplier(() -> new SimpleBloomFilter(shape)).build();
+        underTest.getTarget().merge(TestingHashers.randomHasher());
+        underTest.next();
+        underTest.getTarget().merge(TestingHashers.randomHasher());
+        underTest.next();
+        underTest.getTarget().merge(TestingHashers.randomHasher());
+        assertEquals(3, underTest.getDepth());
+        underTest.clear();
+        assertEquals(1, underTest.getDepth());
+        assertEquals(0, underTest.getTarget().cardinality());
+    }
+
+    @Test
+    public void testNextAndGetDepth() {
+        LayerManager underTest = LayerManager.builder().setSupplier(() -> new SimpleBloomFilter(shape)).build();
+        assertEquals(1, underTest.getDepth());
+        underTest.getTarget().merge(TestingHashers.randomHasher());
+        assertEquals(1, underTest.getDepth());
+        underTest.next();
+        assertEquals(2, underTest.getDepth());
+    }
+
+    @Test
+    public void testGet() {
+        SimpleBloomFilter f = new SimpleBloomFilter(shape);
+        LayerManager underTest = LayerManager.builder().setSupplier(() -> f).build();
+        assertEquals(1, underTest.getDepth());
+        assertSame(f, underTest.get(0));
+        assertThrows(NoSuchElementException.class, () -> underTest.get(-1));
+        assertThrows(NoSuchElementException.class, () -> underTest.get(1));
+    }
+
+    @Test
+    public void testTarget() {
+        boolean[] extendCheckCalled = { false };
+        boolean[] cleanupCalled = { false };
+        int[] supplierCount = { 0 };
+        LayerManager underTest = LayerManager.builder().setSupplier(() -> {
+            supplierCount[0]++;
+            return new SimpleBloomFilter(shape);
+        }).setExtendCheck(lm -> {
+            extendCheckCalled[0] = true;
+            return true;
+        }).setCleanup(ll -> {
+            cleanupCalled[0] = true;
+        }).build();
+        assertFalse(extendCheckCalled[0]);
+        assertFalse(cleanupCalled[0]);
+        assertEquals(1, supplierCount[0]);
+        underTest.getTarget();
+        assertTrue(extendCheckCalled[0]);
+        assertTrue(cleanupCalled[0]);
+        assertEquals(2, supplierCount[0]);
+    }
+
+    @Test
+    public void testForEachBloomFilter() {
+        LayerManager underTest = LayerManager.builder().setSupplier(() -> new SimpleBloomFilter(shape))
+                .setExtendCheck(LayerManager.ExtendCheck.advanceOnPopulated()).build();
+
+        List<BloomFilter> lst = new ArrayList<>();
+        for (int i = 0; i < 10; i++) {
+            BloomFilter bf = new SimpleBloomFilter(shape);
+            bf.merge(TestingHashers.randomHasher());
+            lst.add(bf);
+            underTest.getTarget().merge(bf);
+        }
+        List<BloomFilter> lst2 = new ArrayList<>();
+        underTest.forEachBloomFilter(lst2::add);
+        assertEquals(10, lst.size());
+        assertEquals(10, lst2.size());
+        for (int i = 0; i < lst.size(); i++) {
+            assertArrayEquals(lst.get(i).asBitMapArray(), lst2.get(i).asBitMapArray());
+        }
+    }
+
+}
diff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/LayeredBloomFilterTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/LayeredBloomFilterTest.java
new file mode 100644
index 0000000000..11164eca06
--- /dev/null
+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/LayeredBloomFilterTest.java
@@ -0,0 +1,315 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.collections4.bloomfilter;
+
+import static org.junit.jupiter.api.Assertions.assertArrayEquals;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertFalse;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+
+import java.util.ArrayList;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.concurrent.TimeUnit;
+import java.util.function.Consumer;
+import java.util.function.Predicate;
+
+import org.apache.commons.collections4.bloomfilter.LayerManager.Cleanup;
+import org.apache.commons.collections4.bloomfilter.LayerManager.ExtendCheck;
+import org.junit.jupiter.api.Test;
+
+public class LayeredBloomFilterTest extends AbstractBloomFilterTest<LayeredBloomFilter> {
+
+    @Override
+    protected LayeredBloomFilter createEmptyFilter(Shape shape) {
+        return LayeredBloomFilter.fixed(shape, 10);
+    }
+
+    protected BloomFilter makeFilter(int... values) {
+        return makeFilter(IndexProducer.fromIndexArray(values));
+    }
+
+    protected BloomFilter makeFilter(IndexProducer p) {
+        BloomFilter bf = new SparseBloomFilter(getTestShape());
+        bf.merge(p);
+        return bf;
+    }
+
+    protected BloomFilter makeFilter(Hasher h) {
+        BloomFilter bf = new SparseBloomFilter(getTestShape());
+        bf.merge(h);
+        return bf;
+    }
+
+    @Test
+    public void testMultipleFilters() {
+        LayeredBloomFilter filter = LayeredBloomFilter.fixed(getTestShape(), 10);
+        filter.merge(TestingHashers.FROM1);
+        filter.merge(TestingHashers.FROM11);
+        assertEquals(2, filter.getDepth());
+        assertTrue(filter.contains(makeFilter(TestingHashers.FROM1)));
+        assertTrue(filter.contains(makeFilter(TestingHashers.FROM11)));
+        BloomFilter t1 = makeFilter(6, 7, 17, 18, 19);
+        assertFalse(filter.contains(t1));
+        assertFalse(filter.copy().contains(t1));
+        assertTrue(filter.flatten().contains(t1));
+    }
+
+    private LayeredBloomFilter setupFindTest() {
+        LayeredBloomFilter filter = LayeredBloomFilter.fixed(getTestShape(), 10);
+        filter.merge(TestingHashers.FROM1);
+        filter.merge(TestingHashers.FROM11);
+        filter.merge(new IncrementingHasher(11, 2));
+        filter.merge(TestingHashers.populateFromHashersFrom1AndFrom11(new SimpleBloomFilter(getTestShape())));
+        return filter;
+    }
+
+    @Test
+    public void testFindBloomFilter() {
+        LayeredBloomFilter filter = setupFindTest();
+        int[] expected = {0, 3};
+        int[] result = filter.find(TestingHashers.FROM1);
+        assertArrayEquals(expected, result);
+        expected = new int[] {1, 3};
+        result = filter.find(TestingHashers.FROM11);
+        assertArrayEquals(expected, result);
+    }
+
+    @Test
+    public void testFindBitMapProducer() {
+        LayeredBloomFilter filter = setupFindTest();
+
+        IndexProducer idxProducer = TestingHashers.FROM1.indices(getTestShape());
+        BitMapProducer producer = BitMapProducer.fromIndexProducer(idxProducer, getTestShape().getNumberOfBits());
+
+        int[] expected = {0, 3};
+        int[] result = filter.find(producer);
+        assertArrayEquals(expected, result);
+
+        expected = new int[]{1, 3};
+        idxProducer = TestingHashers.FROM11.indices(getTestShape());
+        producer = BitMapProducer.fromIndexProducer(idxProducer, getTestShape().getNumberOfBits());
+        result = filter.find(producer);
+        assertArrayEquals(expected, result);
+    }
+
+    @Test
+    public void testFindIndexProducer() {
+        IndexProducer producer = TestingHashers.FROM1.indices(getTestShape());
+        LayeredBloomFilter filter = setupFindTest();
+
+        int[] expected = {0, 3};
+        int[] result = filter.find(producer);
+        assertArrayEquals(expected, result);
+
+        expected = new int[] {1, 3};
+        producer = TestingHashers.FROM11.indices(getTestShape());
+        result = filter.find(producer);
+        assertArrayEquals(expected, result);
+    }
+
+    /**
+     * Tests that the estimated union calculations are correct.
+     */
+    @Test
+    public final void testEstimateUnionCrossTypes() {
+        final BloomFilter bf = createFilter(getTestShape(), TestingHashers.FROM1);
+        final BloomFilter bf2 = new DefaultBloomFilterTest.SparseDefaultBloomFilter(getTestShape());
+        bf2.merge(TestingHashers.FROM11);
+
+        assertEquals(2, bf.estimateUnion(bf2));
+        assertEquals(2, bf2.estimateUnion(bf));
+    }
+
+    @Test
+    public final void testGetLayer() {
+        BloomFilter bf = new SimpleBloomFilter(getTestShape());
+        bf.merge(TestingHashers.FROM11);
+        LayeredBloomFilter filter = LayeredBloomFilter.fixed(getTestShape(), 10);
+        filter.merge(TestingHashers.FROM1);
+        filter.merge(TestingHashers.FROM11);
+        filter.merge(new IncrementingHasher(11, 2));
+        filter.merge(TestingHashers.populateFromHashersFrom1AndFrom11(new SimpleBloomFilter(getTestShape())));
+        assertArrayEquals(bf.asBitMapArray(), filter.get(1).asBitMapArray());
+    }
+
+    @Test
+    public final void testNext() {
+        LayerManager layerManager = LayerManager.builder().setSupplier(() -> new SimpleBloomFilter(getTestShape()))
+                .build();
+
+        LayeredBloomFilter filter = new LayeredBloomFilter(getTestShape(), layerManager);
+        filter.merge(TestingHashers.FROM1);
+        filter.merge(TestingHashers.FROM11);
+        assertEquals(1, filter.getDepth());
+        filter.next();
+        filter.merge(new IncrementingHasher(11, 2));
+        assertEquals(2, filter.getDepth());
+        assertTrue(filter.get(0).contains(TestingHashers.FROM1));
+        assertTrue(filter.get(0).contains(TestingHashers.FROM11));
+        assertFalse(filter.get(0).contains(new IncrementingHasher(11, 2)));
+        assertFalse(filter.get(1).contains(TestingHashers.FROM1));
+        assertFalse(filter.get(1).contains(TestingHashers.FROM11));
+        assertTrue(filter.get(1).contains(new IncrementingHasher(11, 2)));
+    }
+
+    @Override
+    @Test
+    public void testCardinalityAndIsEmpty() {
+        LayerManager layerManager = LayerManager.builder().setExtendCheck(ExtendCheck.neverAdvance())
+                .setSupplier(() -> new SimpleBloomFilter(getTestShape())).build();
+        testCardinalityAndIsEmpty(new LayeredBloomFilter(getTestShape(), layerManager));
+    }
+
+    // ***** TESTS THAT CHECK LAYERED PROCESSING ******
+
+    // ***example of instrumentation ***
+    private static List<String> dbgInstrument = new ArrayList<>();
+    // instrumentation to record timestamps in dbgInstrument list
+    private Predicate<BloomFilter> dbg = (bf) -> {
+        TimestampedBloomFilter tbf = (TimestampedBloomFilter) bf;
+        long ts = System.currentTimeMillis();
+        dbgInstrument.add(String.format("T:%s (Elapsed:%s)- EstN:%s (Card:%s)\n", tbf.timestamp, ts - tbf.timestamp,
+                tbf.estimateN(), tbf.cardinality()));
+        return true;
+    };
+    // *** end of instrumentation ***
+
+    /**
+     * Creates a LayeredBloomFilter that retains enclosed filters for
+     * {@code duration} and limits the contents of each enclosed filter to a time
+     * {@code quanta}. This filter uses the timestamped Bloom filter internally.
+     *
+     * @param shape    The shape of the Bloom filters.
+     * @param duration The length of time to keep filters in the list.
+     * @param dUnit    The unit of time to apply to duration.
+     * @param quanta   The quantization factor for each filter. Individual filters
+     *                 will span at most this much time.
+     * @param qUnit    the unit of time to apply to quanta.
+     * @return LayeredBloomFilter with the above properties.
+     */
+    static LayeredBloomFilter createTimedLayeredFilter(Shape shape, long duration, TimeUnit dUnit, long quanta,
+            TimeUnit qUnit) {
+        LayerManager layerManager = LayerManager.builder()
+                .setSupplier(() -> new TimestampedBloomFilter(new SimpleBloomFilter(shape)))
+                .setCleanup(Cleanup.removeEmptyTarget().andThen(new CleanByTime(duration, dUnit)))
+                .setExtendCheck(new AdvanceOnTimeQuanta(quanta, qUnit)
+                        .or(LayerManager.ExtendCheck.advanceOnSaturation(shape.estimateMaxN())))
+                .build();
+        return new LayeredBloomFilter(shape, layerManager);
+    }
+
+    /**
+     * A Predicate that advances after a quantum of time.
+     */
+    static class AdvanceOnTimeQuanta implements Predicate<LayerManager> {
+        long quanta;
+
+        AdvanceOnTimeQuanta(long quanta, TimeUnit unit) {
+            this.quanta = unit.toMillis(quanta);
+        }
+
+        @Override
+        public boolean test(LayerManager lm) {
+            // can not use getTarget() as it causes recursion.
+            TimestampedBloomFilter bf = (TimestampedBloomFilter) lm.get(lm.getDepth() - 1);
+            return bf.timestamp + quanta < System.currentTimeMillis();
+        }
+    }
+
+    /**
+     * A Consumer that cleans the list based on how long each filters has been in
+     * the list.
+     *
+     */
+    static class CleanByTime implements Consumer<LinkedList<BloomFilter>> {
+        long elapsedTime;
+
+        CleanByTime(long duration, TimeUnit unit) {
+            elapsedTime = unit.toMillis(duration);
+        }
+
+        @Override
+        public void accept(LinkedList<BloomFilter> t) {
+            long min = System.currentTimeMillis() - elapsedTime;
+            while (!t.isEmpty() && ((TimestampedBloomFilter) t.getFirst()).getTimestamp() < min) {
+                TimestampedBloomFilter bf = (TimestampedBloomFilter) t.getFirst();
+                dbgInstrument.add(String.format("Removing old entry: T:%s (Aged: %s) \n", bf.getTimestamp(),
+                        (min - bf.getTimestamp())));
+                t.removeFirst();
+            }
+        }
+    }
+
+    /**
+     * A Bloomfilter implementation that tracks the creation time.
+     */
+    static class TimestampedBloomFilter extends WrappedBloomFilter {
+        final long timestamp;
+
+        TimestampedBloomFilter(BloomFilter bf) {
+            super(bf);
+            this.timestamp = System.currentTimeMillis();
+        }
+
+        public long getTimestamp() {
+            return timestamp;
+        }
+    }
+
+    @Test
+    public void testExpiration() throws InterruptedException {
+        // this test uses the instrumentation noted above to track changes for debugging
+        // purposes.
+
+        // list of timestamps that are expected to be expired.
+        List<Long> lst = new ArrayList<>();
+        Shape shape = Shape.fromNM(4, 64);
+
+        // create a filter that removes filters that are 4 seconds old
+        // and quantises time to 1 second intervals.
+        LayeredBloomFilter underTest = createTimedLayeredFilter(shape, 600, TimeUnit.MILLISECONDS, 150,
+                TimeUnit.MILLISECONDS);
+
+        for (int i = 0; i < 10; i++) {
+            underTest.merge(TestingHashers.randomHasher());
+        }
+        underTest.forEachBloomFilter(dbg.and(x -> lst.add(((TimestampedBloomFilter) x).timestamp)));
+        assertTrue(underTest.getDepth() > 1);
+
+        Thread.sleep(300);
+        for (int i = 0; i < 10; i++) {
+            underTest.merge(TestingHashers.randomHasher());
+        }
+        dbgInstrument.add("=== AFTER 300 milliseconds ====\n");
+        underTest.forEachBloomFilter(dbg);
+
+        Thread.sleep(150);
+        for (int i = 0; i < 10; i++) {
+            underTest.merge(TestingHashers.randomHasher());
+        }
+        dbgInstrument.add("=== AFTER 450 milliseconds ====\n");
+        underTest.forEachBloomFilter(dbg);
+
+        // sleep 200 milliseconds to ensure we cross the 600 millisecond boundary
+        Thread.sleep(200);
+        underTest.merge(TestingHashers.randomHasher());
+        dbgInstrument.add("=== AFTER 600 milliseconds ====\n");
+        assertTrue(underTest.forEachBloomFilter(dbg.and(x -> !lst.contains(((TimestampedBloomFilter) x).timestamp))),
+                "Found filter that should have been deleted: " + dbgInstrument.get(dbgInstrument.size() - 1));
+    }
+}
diff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/TestingHashers.java b/src/test/java/org/apache/commons/collections4/bloomfilter/TestingHashers.java
index 8222d4c253..bf9ab41de5 100644
--- a/src/test/java/org/apache/commons/collections4/bloomfilter/TestingHashers.java
+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/TestingHashers.java
@@ -16,6 +16,8 @@
  */
 package org.apache.commons.collections4.bloomfilter;
 
+import java.util.concurrent.ThreadLocalRandom;
+
 /**
  * A collection of methods and statics that represent standard hashers in testing.
  */
@@ -88,4 +90,11 @@ public static <T extends BloomFilter> T populateRange(final T filter, final int
         });
         return filter;
     }
+
+    /**
+     * Creates an EnhancedDoubleHasher hasher from 2 random longs.
+     */
+    public static Hasher randomHasher() {
+        return new EnhancedDoubleHasher( ThreadLocalRandom.current().nextLong(), ThreadLocalRandom.current().nextLong() );
+    }
 }
diff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/WrappedBloomFilterTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/WrappedBloomFilterTest.java
new file mode 100644
index 0000000000..eca4a21a3b
--- /dev/null
+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/WrappedBloomFilterTest.java
@@ -0,0 +1,45 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.collections4.bloomfilter;
+
+import static org.junit.jupiter.api.Assertions.assertEquals;
+
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.ValueSource;
+
+public class WrappedBloomFilterTest extends AbstractBloomFilterTest<WrappedBloomFilter> {
+
+    @Override
+    protected WrappedBloomFilter createEmptyFilter(Shape shape) {
+        return new WrappedBloomFilter(new DefaultBloomFilterTest.SparseDefaultBloomFilter(shape)) {
+        };
+    }
+
+    @ParameterizedTest
+    @ValueSource(ints = {0, 1, 34})
+    public void testCharacteristics(int characteristics) {
+        Shape shape = getTestShape();
+        BloomFilter inner = new DefaultBloomFilterTest.SparseDefaultBloomFilter(shape) {
+            @Override
+            public int characteristics() {
+                return characteristics;
+            }
+        };
+        WrappedBloomFilter underTest = new WrappedBloomFilter(inner) {};
+        assertEquals(characteristics, underTest.characteristics());
+    }
+}
