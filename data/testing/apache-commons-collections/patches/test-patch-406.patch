diff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBitCountProducerTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBitCountProducerTest.java
deleted file mode 100644
index 2a5aa0a622..0000000000
--- a/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBitCountProducerTest.java
+++ /dev/null
@@ -1,168 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.commons.collections4.bloomfilter;
-
-import static org.junit.jupiter.api.Assertions.assertArrayEquals;
-import static org.junit.jupiter.api.Assertions.assertEquals;
-import static org.junit.jupiter.api.Assertions.assertFalse;
-import static org.junit.jupiter.api.Assertions.assertTrue;
-import static org.junit.jupiter.api.Assertions.fail;
-import static org.junit.jupiter.api.Assumptions.assumeTrue;
-
-import java.util.Arrays;
-import java.util.BitSet;
-
-import org.apache.commons.collections4.bag.TreeBag;
-import org.apache.commons.collections4.bloomfilter.BitCountProducer.BitCountConsumer;
-import org.junit.jupiter.api.Test;
-
-public abstract class AbstractBitCountProducerTest extends AbstractIndexProducerTest {
-
-    /**
-     * A testing BitCountConsumer that always returns true.
-     */
-    private static final BitCountConsumer TRUE_CONSUMER = (i, j) -> true;
-    /**
-     * A testing BitCountConsumer that always returns false.
-     */
-    private static final BitCountConsumer FALSE_CONSUMER = (i, j) -> false;
-
-    /**
-     * Creates an array of integer pairs comprising the index and the expected count for the index.
-     * The order and count for each index is dependent upon the producer created by the {@code createProducer()}
-     * method.
-     * By default returns the each {@code getExpectedIndices()} value paired with 1 (one).
-     * @return an array of integer pairs comprising the index and the expected count for the index.
-     */
-    protected int[][] getExpectedBitCount() {
-        return Arrays.stream(getExpectedIndices()).mapToObj(x -> new int[] {x, 1}).toArray(int[][]::new);
-    }
-
-    /**
-     * Creates a producer with some data.
-     * @return a producer with some data
-     */
-    @Override
-    protected abstract BitCountProducer createProducer();
-
-    /**
-     * Creates a producer without data.
-     * @return a producer that has no data.
-     */
-    @Override
-    protected abstract BitCountProducer createEmptyProducer();
-
-    /**
-     * Gets the behavior of the {@link BitCountProducer#forEachCount(BitCountConsumer)} method.
-     * By default returns the value of {@code getAsIndexArrayBehaviour()} method.
-     * @return the behavior.
-     */
-    protected int getForEachCountBehaviour() {
-        return getAsIndexArrayBehaviour();
-    }
-
-    @Test
-    public final void testForEachCountPredicates() {
-        final BitCountProducer populated = createProducer();
-        final BitCountProducer empty = createEmptyProducer();
-
-        assertFalse(populated.forEachCount(FALSE_CONSUMER), "non-empty should be false");
-        assertTrue(empty.forEachCount(FALSE_CONSUMER), "empty should be true");
-
-        assertTrue(populated.forEachCount(TRUE_CONSUMER), "non-empty should be true");
-        assertTrue(empty.forEachCount(TRUE_CONSUMER), "empty should be true");
-    }
-
-    @Test
-    public final void testEmptyBitCountProducer() {
-        final BitCountProducer empty = createEmptyProducer();
-        final int ary[] = empty.asIndexArray();
-        assertEquals(0, ary.length);
-        assertTrue(empty.forEachCount((i, j) -> {
-            fail("forEachCount consumer should not be called");
-            return false;
-        }));
-    }
-
-    @Test
-    public final void testIndexConsistency() {
-        final BitCountProducer producer = createProducer();
-        final BitSet bs1 = new BitSet();
-        final BitSet bs2 = new BitSet();
-        producer.forEachIndex(i -> {
-            bs1.set(i);
-            return true;
-        });
-        producer.forEachCount((i, j) -> {
-            bs2.set(i);
-            return true;
-        });
-        assertEquals(bs1, bs2);
-    }
-
-    @Test
-    public void testForEachCountValues() {
-        // Assumes the collections bag works. Could be replaced with Map<Integer,Integer> with more work.
-        final TreeBag<Integer> expected = new TreeBag<>();
-        Arrays.stream(getExpectedBitCount()).forEach(c -> expected.add(c[0], c[1]));
-        final TreeBag<Integer> actual = new TreeBag<>();
-        // can not return actual.add as it returns false on duplicate 'i'
-        createProducer().forEachCount((i, j) -> {
-            actual.add(i, j);
-            return true;
-        });
-        assertEquals(expected, actual);
-    }
-
-    /**
-     * Test the behavior of {@link BitCountProducer#forEachCount(BitCountConsumer)} with respect
-     * to ordered and distinct indices. Currently the behavior is assumed to be the same as
-     * {@link IndexProducer#forEachIndex(java.util.function.IntPredicate)}.
-     */
-    @Test
-    public final void testBehaviourForEachCount() {
-        final int flags = getForEachCountBehaviour();
-        assumeTrue((flags & (ORDERED | DISTINCT)) != 0);
-        final IntList list = new IntList();
-        createProducer().forEachCount((i, j) -> list.add(i));
-        final int[] actual = list.toArray();
-        if ((flags & ORDERED) != 0) {
-            final int[] expected = Arrays.stream(actual).sorted().toArray();
-            assertArrayEquals(expected, actual);
-        }
-        if ((flags & DISTINCT) != 0) {
-            final long count = Arrays.stream(actual).distinct().count();
-            assertEquals(count, actual.length);
-        }
-    }
-
-    @Test
-    public void testForEachCountEarlyExit() {
-        final int[] passes = new int[1];
-        assertTrue(createEmptyProducer().forEachCount((i, j) -> {
-            passes[0]++;
-            return false;
-        }));
-        assertEquals(0, passes[0]);
-
-        assertFalse(createProducer().forEachCount((i, j) -> {
-            passes[0]++;
-            return false;
-        }));
-        assertEquals(1, passes[0]);
-    }
-}
diff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBloomFilterTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBloomFilterTest.java
index 7e1666a074..e4a9082771 100644
--- a/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBloomFilterTest.java
+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBloomFilterTest.java
@@ -94,9 +94,6 @@ protected final T createFilter(final Shape shape, final IndexProducer producer)
         return bf;
     }
 
-    /**
-     *
-     */
     @Test
     public void testMergeWithBadHasher() {
         // value too large
@@ -451,10 +448,5 @@ public BadHasher(final int value) {
         public IndexProducer indices(final Shape shape) {
             return producer;
         }
-
-        @Override
-        public IndexProducer uniqueIndices(final Shape shape) {
-            return producer;
-        }
     }
 }
diff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractCellProducerTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractCellProducerTest.java
new file mode 100644
index 0000000000..8433161d1d
--- /dev/null
+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractCellProducerTest.java
@@ -0,0 +1,155 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.collections4.bloomfilter;
+
+import static org.junit.jupiter.api.Assertions.assertArrayEquals;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertFalse;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+import static org.junit.jupiter.api.Assertions.fail;
+
+import java.util.Arrays;
+import java.util.BitSet;
+
+import org.apache.commons.collections4.bloomfilter.CellProducer.CellConsumer;
+import org.junit.jupiter.api.Test;
+
+public abstract class AbstractCellProducerTest extends AbstractIndexProducerTest {
+
+    /**
+     * A testing CellConsumer that always returns true.
+     */
+    private static final CellConsumer TRUE_CONSUMER = (i, j) -> true;
+    /**
+     * A testing CellConsumer that always returns false.
+     */
+    private static final CellConsumer FALSE_CONSUMER = (i, j) -> false;
+
+    /**
+     * Creates an array of expected values that aligns with the expected indices entries.
+     * @return an array of expected values.
+     * @see AbstractIndexProducerTest#getExpectedIndices()
+     */
+    protected abstract int[] getExpectedValues();
+
+    @Override
+    protected final int getAsIndexArrayBehaviour() {
+        return ORDERED | DISTINCT;
+    }
+
+    /**
+     * Creates a producer with some data.
+     * @return a producer with some data
+     */
+    @Override
+    protected abstract CellProducer createProducer();
+
+    /**
+     * Creates a producer without data.
+     * @return a producer that has no data.
+     */
+    @Override
+    protected abstract CellProducer createEmptyProducer();
+
+    @Test
+    public final void testForEachCellPredicates() {
+        final CellProducer populated = createProducer();
+        final CellProducer empty = createEmptyProducer();
+
+        assertFalse(populated.forEachCell(FALSE_CONSUMER), "non-empty should be false");
+        assertTrue(empty.forEachCell(FALSE_CONSUMER), "empty should be true");
+
+        assertTrue(populated.forEachCell(TRUE_CONSUMER), "non-empty should be true");
+        assertTrue(empty.forEachCell(TRUE_CONSUMER), "empty should be true");
+    }
+
+    @Test
+    public final void testEmptyCellProducer() {
+        final CellProducer empty = createEmptyProducer();
+        final int ary[] = empty.asIndexArray();
+        assertEquals(0, ary.length);
+        assertTrue(empty.forEachCell((i, j) -> {
+            fail("forEachCell consumer should not be called");
+            return false;
+        }));
+    }
+
+    @Test
+    public final void testIndexConsistency() {
+        final CellProducer producer = createProducer();
+        final BitSet bs1 = new BitSet();
+        final BitSet bs2 = new BitSet();
+        producer.forEachIndex(i -> {
+            bs1.set(i);
+            return true;
+        });
+        producer.forEachCell((i, j) -> {
+            bs2.set(i);
+            return true;
+        });
+        assertEquals(bs1, bs2);
+    }
+
+    @Test
+    public void testForEachCellValues() {
+        int[] expectedIdx = getExpectedIndices();
+        int[] expectedValue = getExpectedValues();
+        assertEquals(expectedIdx.length, expectedValue.length, "expected index length and value length do not match");
+        int[] idx = {0};
+        createProducer().forEachCell((i, j) -> {
+            assertEquals(expectedIdx[idx[0]], i, "bad index at " + idx[0]);
+            assertEquals(expectedValue[idx[0]], j, "bad value at " + idx[0]);
+            idx[0]++;
+            return true;
+        });
+    }
+
+    /**
+     * Test the behavior of {@link CellProducer#forEachCell(CellConsumer)} with respect
+     * to ordered and distinct indices. Currently the behavior is assumed to be the same as
+     * {@link IndexProducer#forEachIndex(java.util.function.IntPredicate)}.
+     */
+    @Test
+    public final void testBehaviourForEachCell() {
+        final IntList list = new IntList();
+        createProducer().forEachCell((i, j) -> list.add(i));
+        final int[] actual = list.toArray();
+        // check order
+        final int[] expected = Arrays.stream(actual).sorted().toArray();
+        assertArrayEquals(expected, actual);
+        // check distinct
+        final long count = Arrays.stream(actual).distinct().count();
+        assertEquals(count, actual.length);
+    }
+
+    @Test
+    public void testForEachCellEarlyExit() {
+        final int[] passes = new int[1];
+        assertTrue(createEmptyProducer().forEachCell((i, j) -> {
+            passes[0]++;
+            return false;
+        }));
+        assertEquals(0, passes[0]);
+
+        assertFalse(createProducer().forEachCell((i, j) -> {
+            passes[0]++;
+            return false;
+        }));
+        assertEquals(1, passes[0]);
+    }
+}
+
diff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractCountingBloomFilterTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractCountingBloomFilterTest.java
index de424111f0..6d489d8d13 100644
--- a/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractCountingBloomFilterTest.java
+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractCountingBloomFilterTest.java
@@ -39,14 +39,16 @@ public abstract class AbstractCountingBloomFilterTest<T extends CountingBloomFil
 
     private static final long bigHashValue = 0xffffffeL;
 
-    protected final BitCountProducer maximumValueProducer = consumer -> {
-        for (int i = 1; i < 18; i++) {
-            if (!consumer.test(i, Integer.MAX_VALUE)) {
-                return false;
+    protected final CellProducer getMaximumValueProducer(int maxValue) {
+        return consumer -> {
+            for (int i = 1; i < 18; i++) {
+                if (!consumer.test(i, maxValue)) {
+                    return false;
+                }
             }
-        }
-        return true;
-    };
+            return true;
+        };
+    }
 
     /**
      * Assert the counts match the expected values. Values are for indices starting
@@ -57,7 +59,7 @@ public abstract class AbstractCountingBloomFilterTest<T extends CountingBloomFil
      */
     private static void assertCounts(final CountingBloomFilter bf, final int[] expected) {
         final Map<Integer, Integer> m = new HashMap<>();
-        bf.forEachCount((i, c) -> {
+        bf.forEachCell((i, c) -> {
             m.put(i, c);
             return true;
         });
@@ -82,7 +84,7 @@ public final void testCountingSpecificConstructor() {
         // verify hasher duplicates are counted.
         // bit hasher has duplicates for 11, 12,13,14,15,16, and 17
         final CountingBloomFilter bf = createFilter(getTestShape(), TestingHashers.FROM1);
-        bf.add(BitCountProducer.from(TestingHashers.FROM11.indices(getTestShape())));
+        bf.add(CellProducer.from(TestingHashers.FROM11.indices(getTestShape())));
 
         final long[] lb = bf.asBitMapArray();
         assertEquals(2, lb.length);
@@ -130,7 +132,7 @@ public final void testCountingSpecificMerge() {
         // test overflow
 
         final CountingBloomFilter bf5 = createEmptyFilter(getTestShape());
-        assertTrue(bf5.add(maximumValueProducer), "Should add to empty");
+        assertTrue(bf5.add(getMaximumValueProducer(bf5.getMaxCell())), "Should add to empty");
         assertTrue(bf5.isValid(), "Should be valid");
 
         final CountingBloomFilter bf6 = bf5.copy();
@@ -155,7 +157,7 @@ public void testAdd() {
         // test overflow
 
         final CountingBloomFilter bf2 = createEmptyFilter(getTestShape());
-        assertTrue(bf2.add(maximumValueProducer), "Should add to empty");
+        assertTrue(bf2.add(getMaximumValueProducer(bf2.getMaxCell())), "Should add to empty");
         assertTrue(bf2.isValid(), "Should be valid");
 
         assertFalse(bf2.add(createFilter(getTestShape(), TestingHashers.FROM1)), "Should not add");
@@ -169,7 +171,7 @@ public void testAdd() {
     @Test
     public final void testSubtract() {
         final CountingBloomFilter bf1 = createFilter(getTestShape(), TestingHashers.FROM1);
-        bf1.add(BitCountProducer.from(TestingHashers.FROM11.indices(getTestShape())));
+        bf1.add(CellProducer.from(TestingHashers.FROM11.indices(getTestShape())));
 
         final CountingBloomFilter bf2 = createFilter(getTestShape(), TestingHashers.FROM11);
 
@@ -190,6 +192,9 @@ public final void testSubtract() {
         assertFalse(bf3.contains(bf4), "Should not contain");
 
         assertCounts(bf3, new int[] {0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0});
+
+        assertThrows(IllegalArgumentException.class, () -> bf3.remove( new BadHasher(-1)));
+        assertThrows(IllegalArgumentException.class, () -> bf3.remove( new BadHasher(getTestShape().getNumberOfBits())));;
     }
 
     /**
@@ -202,7 +207,7 @@ public final void testRemove() {
         simple.merge(TestingHashers.FROM11);
 
         final CountingBloomFilter bf1 = createFilter(getTestShape(), TestingHashers.FROM1);
-        bf1.add(BitCountProducer.from(TestingHashers.FROM11.indices(getTestShape())));
+        bf1.add(CellProducer.from(TestingHashers.FROM11.indices(getTestShape())));
 
         assertTrue(bf1.remove(simple), "Remove should work");
         assertFalse(bf1.contains(TestingHashers.FROM11), "Should not contain");
@@ -212,7 +217,7 @@ public final void testRemove() {
 
         // with hasher
         final CountingBloomFilter bf2 = createFilter(getTestShape(), TestingHashers.FROM1);
-        bf2.add(BitCountProducer.from(TestingHashers.FROM11.indices(getTestShape())));
+        bf2.add(CellProducer.from(TestingHashers.FROM11.indices(getTestShape())));
 
         assertTrue(bf2.remove(TestingHashers.FROM11), "Remove should work");
         assertFalse(bf2.contains(TestingHashers.FROM11), "Should not contain");
@@ -233,7 +238,7 @@ public final void testRemove() {
         final IndexProducer ip = TestingHashers.FROM11.indices(getTestShape());
 
         final CountingBloomFilter bf4 = createFilter(getTestShape(), TestingHashers.FROM1);
-        bf4.add(BitCountProducer.from(TestingHashers.FROM11.indices(getTestShape())));
+        bf4.add(CellProducer.from(TestingHashers.FROM11.indices(getTestShape())));
 
         assertTrue(bf4.remove(ip), "Remove should work");
         assertFalse(bf4.contains(TestingHashers.FROM11), "Should not contain");
@@ -244,7 +249,7 @@ public final void testRemove() {
         // with BitMapProducer
         final BitMapProducer bmp = BitMapProducer.fromIndexProducer(ip, getTestShape().getNumberOfBits());
         final CountingBloomFilter bf5 = createFilter(getTestShape(), TestingHashers.FROM1);
-        bf5.add(BitCountProducer.from(TestingHashers.FROM11.indices(getTestShape())));
+        bf5.add(CellProducer.from(TestingHashers.FROM11.indices(getTestShape())));
 
         assertTrue(bf5.remove(bmp), "Remove should work");
         assertFalse(bf5.contains(TestingHashers.FROM11), "Should not contain");
@@ -260,6 +265,8 @@ public final void testRemove() {
         final CountingBloomFilter bf7 = createFilter(getTestShape(), TestingHashers.FROM1);
         final BitMapProducer bmp2 = BitMapProducer.fromIndexProducer(ip2, getTestShape().getNumberOfBits());
         assertThrows(IllegalArgumentException.class, () -> bf7.remove(bmp2));
+        assertThrows(IllegalArgumentException.class, () -> bf7.remove( new BadHasher(-1)));
+        assertThrows(IllegalArgumentException.class, () -> bf7.remove( new BadHasher(getTestShape().getNumberOfBits())));;
     }
 
     @Test
@@ -272,7 +279,7 @@ public void testExcludesDuplicates() {
 
         CountingBloomFilter bf1 = createFilter(shape, hasher);
         assertEquals(6, bf1.cardinality());
-        bf1.forEachCount((x, y) -> {
+        bf1.forEachCell((x, y) -> {
             assertEquals(1, y, "Hasher in constructor results in value not equal to 1");
             return true;
         });
@@ -280,7 +287,7 @@ public void testExcludesDuplicates() {
         bf1 = createEmptyFilter(shape);
         bf1.merge(hasher);
         assertEquals(6, bf1.cardinality());
-        bf1.forEachCount((x, y) -> {
+        bf1.forEachCell((x, y) -> {
             assertEquals(1, y, "Hasher in merge results in value not equal to 1");
             return true;
         });
@@ -289,6 +296,110 @@ public void testExcludesDuplicates() {
         bf1.merge(hasher);
         bf1.remove(hasher);
         assertEquals(0, bf1.cardinality());
-        assertTrue(bf1.forEachCount((x, y) -> false), "Hasher in removes results in value not equal to 0");
+        assertTrue(bf1.forEachCell((x, y) -> false), "Hasher in removes results in value not equal to 0");
+    }
+
+    private void verifyMaxInsert(CountingBloomFilter bf, int from1, int from11) {
+        BloomFilter bfFrom0 = new DefaultBloomFilterTest.SparseDefaultBloomFilter(getTestShape());
+        bfFrom0.merge(new IncrementingHasher(0, 1));
+        BloomFilter bfFrom1 = new DefaultBloomFilterTest.SparseDefaultBloomFilter(getTestShape());
+        bfFrom1.merge(TestingHashers.FROM1);
+        BloomFilter bfFrom11 = new DefaultBloomFilterTest.SparseDefaultBloomFilter(getTestShape());
+        bfFrom11.merge(TestingHashers.FROM11);
+
+        assertEquals(0, bf.getMaxInsert(new IncrementingHasher(0, 1)));
+        assertEquals(0, bf.getMaxInsert(bfFrom0));
+        assertEquals(0, bf.getMaxInsert((BitMapProducer) bfFrom0));
+        assertEquals(0, bf.getMaxInsert((IndexProducer) bfFrom0));
+
+        assertEquals(from1, bf.getMaxInsert(TestingHashers.FROM1));
+        assertEquals(from1, bf.getMaxInsert(bfFrom1));
+        assertEquals(from1, bf.getMaxInsert((BitMapProducer) bfFrom1));
+        assertEquals(from1, bf.getMaxInsert((IndexProducer) bfFrom1));
+
+        assertEquals(from11, bf.getMaxInsert(TestingHashers.FROM11));
+        assertEquals(from11, bf.getMaxInsert(bfFrom11));
+        assertEquals(from11, bf.getMaxInsert((BitMapProducer) bfFrom11));
+        assertEquals(from11, bf.getMaxInsert((IndexProducer) bfFrom11));
+    }
+
+    @Test
+    public void testGetMaxInsert() {
+        CountingBloomFilter bf = createEmptyFilter(getTestShape());
+        verifyMaxInsert(bf, 0, 0);
+        bf.merge(TestingHashers.FROM1);
+        verifyMaxInsert(bf, 1, 0);
+        bf.merge(TestingHashers.FROM1);
+        verifyMaxInsert(bf, 2, 0);
+        bf.merge(TestingHashers.FROM11);
+        verifyMaxInsert(bf, 2, 1);
+        bf.remove(TestingHashers.FROM1);
+        verifyMaxInsert(bf, 1, 1);
+        // verify remove false positive works
+        // Incrementing hasher 5,1 spans the single count cells for both FROM1 and FROM11
+        assertEquals(1, bf.getMaxInsert(new IncrementingHasher(5, 1)));
+        bf.remove(new IncrementingHasher(5, 1));
+        verifyMaxInsert(bf, 0, 0);
+        assertEquals(0, bf.getMaxInsert(new IncrementingHasher(5, 1)));
+    }
+
+    private void assertCell3(CountingBloomFilter bf, int value) {
+        bf.forEachCell((k, v) -> {
+            if (k == 3) {
+                assertEquals(value, v, "Mismatch at position 3");
+            } else {
+                assertEquals(0, v, "Mismatch at position " + k);
+            }
+            return true;
+        });
+    }
+
+    @Test
+    public void mergeIncrementsAllCellsTest() {
+        CountingBloomFilter f1 = createEmptyFilter(Shape.fromKM(1, 10));
+        CountingBloomFilter f2 = f1.copy();
+        CountingBloomFilter f3 = f1.copy();
+        // index producer produces 3 two times.
+        IndexProducer ip = p -> {
+            p.test(3);
+            p.test(3);
+            return true;
+        };
+        // The merge should increment cell 3 by 1
+        f1.merge(ip);
+        assertCell3(f1, 1);
+
+        // The add should increment cells 3 by 2
+        f2.add(CellProducer.from(ip));
+        assertCell3(f2, 2);
+    }
+
+    @Test
+    public void removeDecrementsAllCellsTest() {
+        CountingBloomFilter f1 = createEmptyFilter(Shape.fromKM(1, 10));
+        CellProducer cp = p -> {
+            p.test(3, 3);
+            return true;
+        };
+        f1.add(cp);
+        CountingBloomFilter f2 = f1.copy();
+        CountingBloomFilter f3 = f1.copy();
+        // index producer produces 3 two times.
+        IndexProducer ip = p -> {
+            p.test(3);
+            p.test(3);
+            return true;
+        };
+        // The merge should decrement cell 3 by 1
+        f1.remove(ip);
+        assertCell3(f1, 2);
+
+        // The add should decrement cells 3 by 2
+        f2.subtract(CellProducer.from(ip));
+        assertCell3(f2, 1);
+
+        // This merge will decrement by 1 as the round-trip makes the indices unique
+        f3.remove(IndexProducer.fromIndexArray(ip.asIndexArray()));
+        assertCell3(f3, 2);
     }
 }
diff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractIndexProducerTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractIndexProducerTest.java
index 542f9a6875..917f361a2d 100644
--- a/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractIndexProducerTest.java
+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractIndexProducerTest.java
@@ -16,6 +16,7 @@
  */
 package org.apache.commons.collections4.bloomfilter;
 
+import static org.junit.Assert.assertSame;
 import static org.junit.jupiter.api.Assertions.assertArrayEquals;
 import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.junit.jupiter.api.Assertions.assertFalse;
@@ -245,4 +246,10 @@ public void testForEachIndexEarlyExit() {
         }));
         assertEquals(0, passes[0]);
     }
+
+    @Test
+    public void testUniqueReturnsSelf() {
+        IndexProducer expected = createProducer().uniqueIndices();
+        assertSame(expected, expected.uniqueIndices());
+    }
 }
diff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/ArrayHasher.java b/src/test/java/org/apache/commons/collections4/bloomfilter/ArrayHasher.java
index f2a18c426a..753decc6e2 100644
--- a/src/test/java/org/apache/commons/collections4/bloomfilter/ArrayHasher.java
+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/ArrayHasher.java
@@ -37,12 +37,6 @@ public IndexProducer indices(final Shape shape) {
         return new Producer(shape);
     }
 
-    @Override
-    public IndexProducer uniqueIndices(final Shape shape) {
-        Objects.requireNonNull(shape, "shape");
-        return new Producer(shape);
-    }
-
     private class Producer implements IndexProducer {
         Shape shape;
 
diff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/BitCountProducerFromHasherTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/BitCountProducerFromHasherTest.java
deleted file mode 100644
index 8c1e846989..0000000000
--- a/src/test/java/org/apache/commons/collections4/bloomfilter/BitCountProducerFromHasherTest.java
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.commons.collections4.bloomfilter;
-
-public class BitCountProducerFromHasherTest extends AbstractBitCountProducerTest {
-
-    @Override
-    protected BitCountProducer createProducer() {
-        // hasher has collisions and wraps
-        return BitCountProducer.from(new IncrementingHasher(4, 8).indices(Shape.fromKM(17, 72)));
-    }
-
-    @Override
-    protected BitCountProducer createEmptyProducer() {
-        return BitCountProducer.from(NullHasher.INSTANCE.indices(Shape.fromKM(17, 72)));
-    }
-
-    @Override
-    protected int getAsIndexArrayBehaviour() {
-        // Hasher allows duplicates and may be unordered
-        return 0;
-    }
-
-    @Override
-    protected int[] getExpectedIndices() {
-        return new int[] {4, 12, 20, 28, 36, 44, 52, 60, 68, 4, 12, 20, 28, 36, 44, 52, 60};
-    }
-
-    @Override
-    protected int[][] getExpectedBitCount() {
-        return new int[][] {{4, 2}, {12, 2}, {20, 2}, {28, 2}, {36, 2}, {44, 2}, {52, 2}, {60, 2}, {68, 1}};
-    }
-}
diff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/CellProducerFromArrayCountingBloomFilterTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/CellProducerFromArrayCountingBloomFilterTest.java
new file mode 100644
index 0000000000..454e16492a
--- /dev/null
+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/CellProducerFromArrayCountingBloomFilterTest.java
@@ -0,0 +1,45 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.collections4.bloomfilter;
+
+public class CellProducerFromArrayCountingBloomFilterTest extends AbstractCellProducerTest {
+
+    protected Shape shape = Shape.fromKM(17, 72);
+
+    @Override
+    protected CellProducer createProducer() {
+        final ArrayCountingBloomFilter filter = new ArrayCountingBloomFilter(shape);
+        filter.merge(new IncrementingHasher(0, 1));
+        filter.merge(new IncrementingHasher(5, 1));
+        return filter;
+    }
+
+    @Override
+    protected CellProducer createEmptyProducer() {
+        return new ArrayCountingBloomFilter(shape);
+    }
+
+    @Override
+    protected int[] getExpectedIndices() {
+        return new int[] {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21};
+    }
+
+    @Override
+    protected int[] getExpectedValues() {
+        return new int[] {1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1};
+    }
+}
diff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/CellProducerFromDefaultIndexProducerTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/CellProducerFromDefaultIndexProducerTest.java
new file mode 100644
index 0000000000..8f97d8388d
--- /dev/null
+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/CellProducerFromDefaultIndexProducerTest.java
@@ -0,0 +1,45 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.collections4.bloomfilter;
+
+public class CellProducerFromDefaultIndexProducerTest extends AbstractCellProducerTest {
+
+    int[] data = {0, 63, 1, 64, 128, 1, 127};
+    int[] indices = {0, 1, 63, 64, 127, 128};
+    int[] values = {1, 2, 1, 1, 1, 1 };
+
+    @Override
+    protected CellProducer createProducer() {
+        return CellProducer.from(IndexProducer.fromIndexArray(data));
+    }
+
+    @Override
+    protected CellProducer createEmptyProducer() {
+        return CellProducer.from(IndexProducer.fromIndexArray(new int[0]));
+    }
+
+    @Override
+    protected int[] getExpectedIndices() {
+        return indices;
+    }
+
+    @Override
+    protected int[] getExpectedValues() {
+        return values;
+    }
+
+}
diff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/DefaultBitCountProducerTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/DefaultCellProducerTest.java
similarity index 69%
rename from src/test/java/org/apache/commons/collections4/bloomfilter/DefaultBitCountProducerTest.java
rename to src/test/java/org/apache/commons/collections4/bloomfilter/DefaultCellProducerTest.java
index a85b90b29d..e99a9aaeb4 100644
--- a/src/test/java/org/apache/commons/collections4/bloomfilter/DefaultBitCountProducerTest.java
+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/DefaultCellProducerTest.java
@@ -16,21 +16,27 @@
  */
 package org.apache.commons.collections4.bloomfilter;
 
-public class DefaultBitCountProducerTest extends AbstractBitCountProducerTest {
+public class DefaultCellProducerTest extends AbstractCellProducerTest {
 
     /** Make forEachIndex unordered and contain duplicates. */
-    private final int[] values = {10, 1, 10, 1};
+    private final int[] indices = {1, 2, 3, 5};
+    private final int[] values = {1, 4, 9, 25};
 
     @Override
     protected int[] getExpectedIndices() {
+        return indices;
+    }
+
+    @Override
+    protected int[] getExpectedValues() {
         return values;
     }
 
     @Override
-    protected BitCountProducer createProducer() {
+    protected CellProducer createProducer() {
         return consumer -> {
-            for (final int i : values) {
-                if (!consumer.test(i, 1)) {
+            for (int i = 0; i < indices.length; i++) {
+                if (!consumer.test(indices[i], values[i] )) {
                     return false;
                 }
             }
@@ -39,25 +45,13 @@ protected BitCountProducer createProducer() {
     }
 
     @Override
-    protected BitCountProducer createEmptyProducer() {
+    protected CellProducer createEmptyProducer() {
         return consumer -> true;
     }
 
-    @Override
-    protected int getAsIndexArrayBehaviour() {
-        // The default method streams a BitSet so is distinct and ordered.
-        return ORDERED | DISTINCT;
-    }
-
     @Override
     protected int getForEachIndexBehaviour() {
         // The default method has the same behavior as the forEachCount() method.
         return 0;
     }
-
-    @Override
-    protected int getForEachCountBehaviour() {
-        // The implemented method returns unordered duplicates.
-        return 0;
-    }
 }
diff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/DefaultIndexProducerTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/DefaultIndexProducerTest.java
index 2682a96a7e..73a3a58dc9 100644
--- a/src/test/java/org/apache/commons/collections4/bloomfilter/DefaultIndexProducerTest.java
+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/DefaultIndexProducerTest.java
@@ -22,8 +22,11 @@
 import java.util.BitSet;
 import java.util.Objects;
 import java.util.concurrent.ThreadLocalRandom;
+import java.util.stream.IntStream;
 
 import org.junit.jupiter.api.Test;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.ValueSource;
 
 public class DefaultIndexProducerTest extends AbstractIndexProducerTest {
 
@@ -58,8 +61,7 @@ protected IndexProducer createEmptyProducer() {
 
     @Override
     protected int getAsIndexArrayBehaviour() {
-        // The default method streams a BitSet so is distinct and ordered.
-        return DISTINCT | ORDERED;
+        return 0;
     }
 
     @Override
@@ -119,4 +121,21 @@ public void testFromIndexArray() {
             assertArrayEquals(expected, ip.asIndexArray());
         }
     }
+
+    @ParameterizedTest
+    @ValueSource(ints = {32, 33})
+    public void testEntries(int size) {
+        int[] values = IntStream.range(0, size).toArray();
+        IndexProducer producer =  predicate -> {
+            Objects.requireNonNull(predicate);
+            for (final int i : values) {
+                if (!predicate.test(i)) {
+                    return false;
+                }
+            }
+            return true;
+        };
+        int[] other = producer.asIndexArray();
+        assertArrayEquals(values, other);
+    }
 }
diff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/BitCountProducerFromArrayCountingBloomFilterTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromArrayCountingBloomFilterTest.java
similarity index 71%
rename from src/test/java/org/apache/commons/collections4/bloomfilter/BitCountProducerFromArrayCountingBloomFilterTest.java
rename to src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromArrayCountingBloomFilterTest.java
index 1cfe291a50..f9d7f18fcf 100644
--- a/src/test/java/org/apache/commons/collections4/bloomfilter/BitCountProducerFromArrayCountingBloomFilterTest.java
+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromArrayCountingBloomFilterTest.java
@@ -16,12 +16,12 @@
  */
 package org.apache.commons.collections4.bloomfilter;
 
-public class BitCountProducerFromArrayCountingBloomFilterTest extends AbstractBitCountProducerTest {
+public class IndexProducerFromArrayCountingBloomFilterTest extends AbstractIndexProducerTest {
 
     protected Shape shape = Shape.fromKM(17, 72);
 
     @Override
-    protected BitCountProducer createProducer() {
+    protected IndexProducer createProducer() {
         final ArrayCountingBloomFilter filter = new ArrayCountingBloomFilter(shape);
         filter.merge(new IncrementingHasher(0, 1));
         filter.merge(new IncrementingHasher(5, 1));
@@ -29,25 +29,18 @@ protected BitCountProducer createProducer() {
     }
 
     @Override
-    protected BitCountProducer createEmptyProducer() {
+    protected IndexProducer createEmptyProducer() {
         return new ArrayCountingBloomFilter(shape);
     }
 
     @Override
-    protected int getAsIndexArrayBehaviour() {
-        // CountingBloomFilter based on an array will be distinct and ordered
-        return DISTINCT | ORDERED;
+    protected int[] getExpectedIndices() {
+        return new int[] {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21};
     }
 
     @Override
-    protected int[][] getExpectedBitCount() {
-        return new int[][] {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 2}, {6, 2}, {7, 2},
-            {8, 2}, {9, 2}, {10, 2}, {11, 2}, {12, 2}, {13, 2}, {14, 2}, {15, 2}, {16, 2},
-            {17, 1}, {18, 1}, {19, 1}, {20, 1}, {21, 1}};
+    protected int getAsIndexArrayBehaviour() {
+        return DISTINCT | ORDERED;
     }
 
-    @Override
-    protected int[] getExpectedIndices() {
-        return new int[] {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21};
-    }
 }
diff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/BitCountProducerFromDefaultIndexProducerTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromHasherTest.java
similarity index 69%
rename from src/test/java/org/apache/commons/collections4/bloomfilter/BitCountProducerFromDefaultIndexProducerTest.java
rename to src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromHasherTest.java
index 56a5c792a6..f6fdd91008 100644
--- a/src/test/java/org/apache/commons/collections4/bloomfilter/BitCountProducerFromDefaultIndexProducerTest.java
+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromHasherTest.java
@@ -16,27 +16,26 @@
  */
 package org.apache.commons.collections4.bloomfilter;
 
-public class BitCountProducerFromDefaultIndexProducerTest extends AbstractBitCountProducerTest {
-
-    int[] data = {0, 63, 1, 1, 64, 127, 128};
+public class IndexProducerFromHasherTest extends AbstractIndexProducerTest {
 
     @Override
-    protected BitCountProducer createProducer() {
-        return BitCountProducer.from(IndexProducer.fromIndexArray(data));
+    protected int getAsIndexArrayBehaviour() {
+        return 0;
     }
 
     @Override
-    protected BitCountProducer createEmptyProducer() {
-        return BitCountProducer.from(IndexProducer.fromIndexArray(new int[0]));
+    protected IndexProducer createProducer() {
+        // hasher has collisions and wraps
+        return new IncrementingHasher(4, 8).indices(Shape.fromKM(17, 72));
     }
 
     @Override
-    protected int getAsIndexArrayBehaviour() {
-        return 0;
+    protected IndexProducer createEmptyProducer() {
+        return NullHasher.INSTANCE.indices(Shape.fromKM(17, 72));
     }
 
     @Override
     protected int[] getExpectedIndices() {
-        return data;
+        return new int[] {4, 12, 20, 28, 36, 44, 52, 60, 68, 4, 12, 20, 28, 36, 44, 52, 60};
     }
 }
diff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/BitCountProducerFromIntArrayTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromIntArrayTest.java
similarity index 76%
rename from src/test/java/org/apache/commons/collections4/bloomfilter/BitCountProducerFromIntArrayTest.java
rename to src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromIntArrayTest.java
index d0a598a17d..4b0281dccc 100644
--- a/src/test/java/org/apache/commons/collections4/bloomfilter/BitCountProducerFromIntArrayTest.java
+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromIntArrayTest.java
@@ -16,27 +16,28 @@
  */
 package org.apache.commons.collections4.bloomfilter;
 
-public class BitCountProducerFromIntArrayTest extends AbstractBitCountProducerTest {
+public class IndexProducerFromIntArrayTest extends AbstractIndexProducerTest {
 
     int[] data = {6, 8, 1, 2, 4, 4, 5};
 
     @Override
-    protected BitCountProducer createEmptyProducer() {
-        return BitCountProducer.from(IndexProducer.fromIndexArray(new int[0]));
+    protected IndexProducer createEmptyProducer() {
+        return IndexProducer.fromIndexArray(new int[0]);
     }
 
     @Override
-    protected BitCountProducer createProducer() {
-        return BitCountProducer.from(IndexProducer.fromIndexArray(data));
+    protected IndexProducer createProducer() {
+        return IndexProducer.fromIndexArray(data);
     }
 
     @Override
-    protected int getAsIndexArrayBehaviour() {
-        return 0;
+    protected int[] getExpectedIndices() {
+        return data;
     }
 
     @Override
-    protected int[] getExpectedIndices() {
-        return data;
+    protected int getAsIndexArrayBehaviour() {
+        return 0;
     }
+
 }
diff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/BitCountProducerFromSimpleBloomFilterTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromSimpleBloomFilterTest.java
similarity index 77%
rename from src/test/java/org/apache/commons/collections4/bloomfilter/BitCountProducerFromSimpleBloomFilterTest.java
rename to src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromSimpleBloomFilterTest.java
index a6b2be2099..b2f3e947a6 100644
--- a/src/test/java/org/apache/commons/collections4/bloomfilter/BitCountProducerFromSimpleBloomFilterTest.java
+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromSimpleBloomFilterTest.java
@@ -16,31 +16,30 @@
  */
 package org.apache.commons.collections4.bloomfilter;
 
-public class BitCountProducerFromSimpleBloomFilterTest extends AbstractBitCountProducerTest {
+public class IndexProducerFromSimpleBloomFilterTest extends AbstractIndexProducerTest {
 
     protected Shape shape = Shape.fromKM(17, 72);
 
     @Override
-    protected BitCountProducer createProducer() {
+    protected IndexProducer createProducer() {
         final Hasher hasher = new IncrementingHasher(3, 2);
         final BloomFilter bf = new SimpleBloomFilter(shape);
         bf.merge(hasher);
-        return BitCountProducer.from(bf);
+        return bf;
     }
 
     @Override
-    protected BitCountProducer createEmptyProducer() {
-        return BitCountProducer.from(new SimpleBloomFilter(shape));
+    protected IndexProducer createEmptyProducer() {
+        return new SimpleBloomFilter(shape);
     }
 
     @Override
-    protected int getAsIndexArrayBehaviour() {
-        // BloomFilter based on a bit map array will be distinct and ordered
-        return DISTINCT | ORDERED;
+    protected int[] getExpectedIndices() {
+        return new int[] {3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35};
     }
 
     @Override
-    protected int[] getExpectedIndices() {
-        return new int[] {3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35};
+    protected int getAsIndexArrayBehaviour() {
+        return DISTINCT | ORDERED;
     }
 }
diff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/BitCountProducerFromSparseBloomFilterTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromSparseBloomFilterTest.java
similarity index 70%
rename from src/test/java/org/apache/commons/collections4/bloomfilter/BitCountProducerFromSparseBloomFilterTest.java
rename to src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromSparseBloomFilterTest.java
index 7e05bb9961..d7bf45cba9 100644
--- a/src/test/java/org/apache/commons/collections4/bloomfilter/BitCountProducerFromSparseBloomFilterTest.java
+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromSparseBloomFilterTest.java
@@ -16,33 +16,30 @@
  */
 package org.apache.commons.collections4.bloomfilter;
 
-public class BitCountProducerFromSparseBloomFilterTest extends AbstractBitCountProducerTest {
+public class IndexProducerFromSparseBloomFilterTest extends AbstractIndexProducerTest {
 
     protected Shape shape = Shape.fromKM(17, 72);
 
     @Override
-    protected BitCountProducer createProducer() {
+    protected IndexProducer createProducer() {
         final Hasher hasher = new IncrementingHasher(4, 7);
         final BloomFilter bf = new SparseBloomFilter(shape);
         bf.merge(hasher);
-        return BitCountProducer.from(bf);
+        return bf;
     }
 
     @Override
-    protected BitCountProducer createEmptyProducer() {
-        return BitCountProducer.from(new SparseBloomFilter(shape));
+    protected IndexProducer createEmptyProducer() {
+        return new SparseBloomFilter(shape);
     }
 
     @Override
-    protected int getAsIndexArrayBehaviour() {
-        // A sparse BloomFilter will be distinct but it may not be ordered.
-        // Currently the ordered behavior is asserted as the implementation uses
-        // an ordered TreeSet. This may change in the future.
-        return DISTINCT | ORDERED;
+    protected int[] getExpectedIndices() {
+        return new int[] {2, 4, 9, 11, 16, 18, 23, 25, 30, 32, 37, 39, 44, 46, 53, 60, 67};
     }
 
     @Override
-    protected int[] getExpectedIndices() {
-        return new int[] {2, 4, 9, 11, 16, 18, 23, 25, 30, 32, 37, 39, 44, 46, 53, 60, 67};
+    protected int getAsIndexArrayBehaviour() {
+        return DISTINCT |ORDERED;
     }
 }
diff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/BitCountProducerFromUniqueHasherTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromUniqueHasherTest.java
similarity index 73%
rename from src/test/java/org/apache/commons/collections4/bloomfilter/BitCountProducerFromUniqueHasherTest.java
rename to src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromUniqueHasherTest.java
index 18e7f7936d..c7cbd217cb 100644
--- a/src/test/java/org/apache/commons/collections4/bloomfilter/BitCountProducerFromUniqueHasherTest.java
+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromUniqueHasherTest.java
@@ -16,27 +16,26 @@
  */
 package org.apache.commons.collections4.bloomfilter;
 
-public class BitCountProducerFromUniqueHasherTest extends AbstractBitCountProducerTest {
+public class IndexProducerFromUniqueHasherTest extends AbstractIndexProducerTest {
 
     @Override
-    protected BitCountProducer createProducer() {
+    protected IndexProducer createProducer() {
         // hasher has collisions and wraps
-        return BitCountProducer.from(new IncrementingHasher(4, 8).uniqueIndices(Shape.fromKM(17, 72)));
+        return new IncrementingHasher(4, 8).indices(Shape.fromKM(17, 72)).uniqueIndices();
     }
 
     @Override
-    protected BitCountProducer createEmptyProducer() {
-        return BitCountProducer.from(NullHasher.INSTANCE.indices(Shape.fromKM(17, 72)));
+    protected IndexProducer createEmptyProducer() {
+        return NullHasher.INSTANCE.indices(Shape.fromKM(17, 72));
     }
 
     @Override
-    protected int getAsIndexArrayBehaviour() {
-        // Hasher may be unordered
-        return DISTINCT;
+    protected int[] getExpectedIndices() {
+        return new int[] {4, 12, 20, 28, 36, 44, 52, 60, 68};
     }
 
     @Override
-    protected int[] getExpectedIndices() {
-        return new int[] {4, 12, 20, 28, 36, 44, 52, 60, 68};
+    protected int getAsIndexArrayBehaviour() {
+        return DISTINCT;
     }
 }
diff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerTest.java
index 52f557a834..655dfeed9d 100644
--- a/src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerTest.java
+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerTest.java
@@ -22,7 +22,10 @@
 import java.util.List;
 import java.util.function.LongPredicate;
 
+import org.junit.jupiter.api.Assertions;
 import org.junit.jupiter.api.Test;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.ValueSource;
 
 public class IndexProducerTest {
 
@@ -68,4 +71,17 @@ public boolean forEachBitMap(final LongPredicate consumer) {
             return true;
         }
     }
+
+    @ParameterizedTest
+    @ValueSource(ints = {32, 33})
+    void testAsIndexArray(int n) {
+        IndexProducer ip = i -> {
+            for (int j = 0; j < n; j++) {
+                // Always test index zero
+                i.test(0);
+            }
+            return true;
+        };
+        Assertions.assertArrayEquals(new int[n], ip.asIndexArray());
+    }
 }
diff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/NullHasher.java b/src/test/java/org/apache/commons/collections4/bloomfilter/NullHasher.java
index 9ab0fb76d5..6ac6d04eae 100644
--- a/src/test/java/org/apache/commons/collections4/bloomfilter/NullHasher.java
+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/NullHasher.java
@@ -53,10 +53,4 @@ public IndexProducer indices(final Shape shape) {
         Objects.requireNonNull(shape, "shape");
         return PRODUCER;
     }
-
-    @Override
-    public IndexProducer uniqueIndices(final Shape shape) {
-        Objects.requireNonNull(shape, "shape");
-        return PRODUCER;
-    }
 }
