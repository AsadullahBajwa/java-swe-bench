diff --git a/src/main/java/org/apache/commons/collections4/bloomfilter/ArrayCountingBloomFilter.java b/src/main/java/org/apache/commons/collections4/bloomfilter/ArrayCountingBloomFilter.java
index 746c5bf6eb..aac95f77e9 100644
--- a/src/main/java/org/apache/commons/collections4/bloomfilter/ArrayCountingBloomFilter.java
+++ b/src/main/java/org/apache/commons/collections4/bloomfilter/ArrayCountingBloomFilter.java
@@ -46,7 +46,7 @@
  * consumption of approximately 8 GB.
  *
  * @see Shape
- * @see CellProducer
+ * @see CellExtractor
  * @since 4.5
  */
 public final class ArrayCountingBloomFilter implements CountingBloomFilter {
@@ -105,9 +105,9 @@ public ArrayCountingBloomFilter(final Shape shape) {
     }
 
     @Override
-    public boolean add(final CellProducer other) {
+    public boolean add(final CellExtractor other) {
         Objects.requireNonNull(other, "other");
-        other.forEachCell(this::add);
+        other.processCells(this::add);
         return isValid();
     }
 
@@ -151,13 +151,13 @@ public void clear() {
     }
 
     @Override
-    public boolean contains(final BitMapProducer bitMapProducer) {
-        return contains(IndexProducer.fromBitMapProducer(bitMapProducer));
+    public boolean contains(final BitMapExtractor bitMapExtractor) {
+        return contains(IndexExtractor.fromBitMapExtractor(bitMapExtractor));
     }
 
     @Override
-    public boolean contains(final IndexProducer indexProducer) {
-        return indexProducer.forEachIndex(idx -> this.cells[idx] != 0);
+    public boolean contains(final IndexExtractor indexExtractor) {
+        return indexExtractor.processIndices(idx -> this.cells[idx] != 0);
     }
 
     @Override
@@ -166,9 +166,9 @@ public ArrayCountingBloomFilter copy() {
     }
 
     @Override
-    public boolean forEachBitMap(final LongPredicate consumer) {
+    public boolean processBitMaps(final LongPredicate consumer) {
         Objects.requireNonNull(consumer, "consumer");
-        final int blocksm1 = BitMap.numberOfBitMaps(cells.length) - 1;
+        final int blocksm1 = BitMaps.numberOfBitMaps(cells.length) - 1;
         int i = 0;
         long value;
         // must break final block separate as the number of bits may not fall on the long boundary
@@ -176,7 +176,7 @@ public boolean forEachBitMap(final LongPredicate consumer) {
             value = 0;
             for (int k = 0; k < Long.SIZE; k++) {
                 if (cells[i++] != 0) {
-                    value |= BitMap.getLongBit(k);
+                    value |= BitMaps.getLongBit(k);
                 }
             }
             if (!consumer.test(value)) {
@@ -187,14 +187,14 @@ public boolean forEachBitMap(final LongPredicate consumer) {
         value = 0;
         for (int k = 0; i < cells.length; k++) {
             if (cells[i++] != 0) {
-                value |= BitMap.getLongBit(k);
+                value |= BitMaps.getLongBit(k);
             }
         }
         return consumer.test(value);
     }
 
     @Override
-    public boolean forEachCell(final CellProducer.CellConsumer consumer) {
+    public boolean processCells(final CellPredicate consumer) {
         Objects.requireNonNull(consumer, "consumer");
         for (int i = 0; i < cells.length; i++) {
             if (cells[i] != 0 && !consumer.test(i, cells[i])) {
@@ -205,7 +205,7 @@ public boolean forEachCell(final CellProducer.CellConsumer consumer) {
     }
 
     @Override
-    public boolean forEachIndex(final IntPredicate consumer) {
+    public boolean processIndices(final IntPredicate consumer) {
         Objects.requireNonNull(consumer, "consumer");
         for (int i = 0; i < cells.length; i++) {
             if (cells[i] != 0 && !consumer.test(i)) {
@@ -221,9 +221,9 @@ public int getMaxCell() {
     }
 
     @Override
-    public int getMaxInsert(final CellProducer cellProducer) {
+    public int getMaxInsert(final CellExtractor cellExtractor) {
         final int[] max = {Integer.MAX_VALUE};
-        cellProducer.forEachCell( (x, y) -> {
+        cellExtractor.processCells( (x, y) -> {
             final int count = cells[x] / y;
             if (count < max[0]) {
                 max[0] = count;
@@ -250,7 +250,7 @@ public Shape getShape() {
      * generated invalid cells can be reversed by using the complement of the
      * original operation with the same Bloom filter. This will restore the cells
      * to the state prior to the invalid operation. Cells can then be extracted
-     * using {@link #forEachCell(CellConsumer)}.</p>
+     * using {@link #processCells(CellPredicate)}.</p>
      */
     @Override
     public boolean isValid() {
@@ -258,9 +258,9 @@ public boolean isValid() {
     }
 
     @Override
-    public boolean subtract(final CellProducer other) {
+    public boolean subtract(final CellExtractor other) {
         Objects.requireNonNull(other, "other");
-        other.forEachCell(this::subtract);
+        other.processCells(this::subtract);
         return isValid();
     }
 
diff --git a/src/main/java/org/apache/commons/collections4/bloomfilter/BitMapProducer.java b/src/main/java/org/apache/commons/collections4/bloomfilter/BitMapExtractor.java
similarity index 70%
rename from src/main/java/org/apache/commons/collections4/bloomfilter/BitMapProducer.java
rename to src/main/java/org/apache/commons/collections4/bloomfilter/BitMapExtractor.java
index 6ef8c5ecea..84659fc1dd 100644
--- a/src/main/java/org/apache/commons/collections4/bloomfilter/BitMapProducer.java
+++ b/src/main/java/org/apache/commons/collections4/bloomfilter/BitMapExtractor.java
@@ -36,22 +36,22 @@
  * @since 4.5
  */
 @FunctionalInterface
-public interface BitMapProducer {
+public interface BitMapExtractor {
 
     /**
-     * Creates a BitMapProducer from an array of Long.
+     * Creates a BitMapExtractor from an array of Long.
      * @param bitMaps the bit maps to return.
-     * @return a BitMapProducer.
+     * @return a BitMapExtractor.
      */
-    static BitMapProducer fromBitMapArray(final long... bitMaps) {
-        return new BitMapProducer() {
+    static BitMapExtractor fromBitMapArray(final long... bitMaps) {
+        return new BitMapExtractor() {
             @Override
             public long[] asBitMapArray() {
                 return Arrays.copyOf(bitMaps, bitMaps.length);
             }
 
             @Override
-            public boolean forEachBitMap(final LongPredicate predicate) {
+            public boolean processBitMaps(final LongPredicate predicate) {
                 for (final long word : bitMaps) {
                     if (!predicate.test(word)) {
                         return false;
@@ -61,33 +61,32 @@ public boolean forEachBitMap(final LongPredicate predicate) {
             }
 
             @Override
-            public boolean forEachBitMapPair(final BitMapProducer other, final LongBiPredicate func) {
+            public boolean processBitMapPairs(final BitMapExtractor other, final LongBiPredicate func) {
                 final CountingLongPredicate p = new CountingLongPredicate(bitMaps, func);
-                return other.forEachBitMap(p) && p.forEachRemaining();
+                return other.processBitMaps(p) && p.processRemaining();
             }
         };
     }
 
     /**
-     * Creates a BitMapProducer from an IndexProducer.
-     * @param producer the IndexProducer that specifies the indexes of the bits to enable.
+     * Creates a BitMapExtractor from an IndexExtractor.
+     * @param extractor the IndexExtractor that specifies the indexes of the bits to enable.
      * @param numberOfBits the number of bits in the Bloom filter.
-     * @return A BitMapProducer that produces the bit maps equivalent of the Indices from the producer.
+     * @return A BitMapExtractor that produces the bit maps equivalent of the Indices from the extractor.
      */
-    static BitMapProducer fromIndexProducer(final IndexProducer producer, final int numberOfBits) {
-        Objects.requireNonNull(producer, "producer");
-        Objects.requireNonNull(numberOfBits, "numberOfBits");
+    static BitMapExtractor fromIndexExtractor(final IndexExtractor extractor, final int numberOfBits) {
+        Objects.requireNonNull(extractor, "extractor");
 
-        final long[] result = new long[BitMap.numberOfBitMaps(numberOfBits)];
-        producer.forEachIndex(i -> {
-            BitMap.set(result, i);
+        final long[] result = new long[BitMaps.numberOfBitMaps(numberOfBits)];
+        extractor.processIndices(i -> {
+            BitMaps.set(result, i);
             return true;
         });
         return fromBitMapArray(result);
     }
 
     /**
-     * Return a copy of the BitMapProducer data as a bit map array.
+     * Return a copy of the BitMapExtractor data as a bit map array.
      * <p>
      * The default implementation of this method is slow. It is recommended
      * that implementing classes reimplement this method.
@@ -95,7 +94,7 @@ static BitMapProducer fromIndexProducer(final IndexProducer producer, final int
      * @return An array of bit map data.
      */
     default long[] asBitMapArray() {
-        class Bits {
+        final class Bits {
             private long[] data = new long[16];
             private int size;
 
@@ -117,7 +116,7 @@ long[] toArray() {
             }
         }
         final Bits bits = new Bits();
-        forEachBitMap(bits::add);
+        processBitMaps(bits::add);
         return bits.toArray();
     }
 
@@ -126,7 +125,7 @@ long[] toArray() {
      * bit map value, if the predicate returns {@code false} the execution is stopped, {@code false}
      * is returned, and no further bit maps are processed.
      *
-     * <p>If the producer is empty this method will return true.</p>
+     * <p>If the extractor is empty this method will return true.</p>
      *
      * <p>Any exceptions thrown by the action are relayed to the caller.</p>
      *
@@ -134,22 +133,22 @@ long[] toArray() {
      * @return {@code true} if all bit maps returned {@code true}, {@code false} otherwise.
      * @throws NullPointerException if the specified consumer is null
      */
-    boolean forEachBitMap(LongPredicate predicate);
+    boolean processBitMaps(LongPredicate predicate);
 
     /**
      * Applies the {@code func} to each bit map pair in order. Will apply all of the bit maps from the other
-     * BitMapProducer to this producer. If this producer does not have as many bit maps it will provide 0 (zero)
+     * BitMapExtractor to this extractor. If this extractor does not have as many bit maps it will provide 0 (zero)
      * for all excess calls to the LongBiPredicate.
      * <p>
      * <em>The default implementation of this method uses {@code asBitMapArray()}. It is recommended that implementations
-     * of BitMapProducer that have local arrays reimplement this method.</em></p>
+     * of BitMapExtractor that have local arrays reimplement this method.</em></p>
      *
-     * @param other The other BitMapProducer that provides the y values in the (x,y) pair.
+     * @param other The other BitMapExtractor that provides the y values in the (x,y) pair.
      * @param func The function to apply.
-     * @return A LongPredicate that tests this BitMapProducers bitmap values in order.
+     * @return A LongPredicate that tests this BitMapExtractor's bitmap values in order.
      */
-    default boolean forEachBitMapPair(final BitMapProducer other, final LongBiPredicate func) {
+    default boolean processBitMapPairs(final BitMapExtractor other, final LongBiPredicate func) {
         final CountingLongPredicate p = new CountingLongPredicate(asBitMapArray(), func);
-        return other.forEachBitMap(p) && p.forEachRemaining();
+        return other.processBitMaps(p) && p.processRemaining();
     }
 }
diff --git a/src/main/java/org/apache/commons/collections4/bloomfilter/BitMap.java b/src/main/java/org/apache/commons/collections4/bloomfilter/BitMaps.java
similarity index 98%
rename from src/main/java/org/apache/commons/collections4/bloomfilter/BitMap.java
rename to src/main/java/org/apache/commons/collections4/bloomfilter/BitMaps.java
index 99fd96fd80..f08d3ad191 100644
--- a/src/main/java/org/apache/commons/collections4/bloomfilter/BitMap.java
+++ b/src/main/java/org/apache/commons/collections4/bloomfilter/BitMaps.java
@@ -20,11 +20,11 @@
  * Contains functions to convert {@code int} indices into Bloom filter bit positions and visa versa.
  *
  * <p>The functions view an array of longs as a collection of bit maps each containing 64 bits. The bits are arranged
- * in memory as a little-endian long value. This matches the requirements of the BitMapProducer interface.</p>
+ * in memory as a little-endian long value. This matches the requirements of the BitMapExtractor interface.</p>
  *
  * @since 4.5
  */
-public class BitMap {
+public class BitMaps {
     /** A bit shift to apply to an integer to divided by 64 (2^6). */
     private static final int DIVIDE_BY_64 = 6;
 
@@ -136,6 +136,6 @@ public static void set(final long[] bitMaps, final int bitIndex) {
     }
 
     /** Do not instantiate. */
-    private BitMap() {
+    private BitMaps() {
     }
 }
diff --git a/src/main/java/org/apache/commons/collections4/bloomfilter/BloomFilter.java b/src/main/java/org/apache/commons/collections4/bloomfilter/BloomFilter.java
index 41ec91058b..3fcdf6c94e 100644
--- a/src/main/java/org/apache/commons/collections4/bloomfilter/BloomFilter.java
+++ b/src/main/java/org/apache/commons/collections4/bloomfilter/BloomFilter.java
@@ -21,13 +21,13 @@
 /**
  * The interface that describes a Bloom filter.
  * <p>
- * <em>See implementation notes for BitMapProducer and IndexProducer.</em>
+ * <em>See implementation notes for BitMapExtractor and IndexExtractor.</em>
  * </p>
- * @see BitMapProducer
- * @see IndexProducer
+ * @see BitMapExtractor
+ * @see IndexExtractor
  * @since 4.5
  */
-public interface BloomFilter extends IndexProducer, BitMapProducer {
+public interface BloomFilter extends IndexExtractor, BitMapExtractor {
 
     /**
      * The sparse characteristic used to determine the best method for matching.
@@ -64,13 +64,13 @@ public interface BloomFilter extends IndexProducer, BitMapProducer {
 
     /**
      * Returns {@code true} if this filter contains the bits specified in the bit maps produced by the
-     * bitMapProducer.
+     * bitMapExtractor.
      *
-     * @param bitMapProducer the {@code BitMapProducer} to provide the bit maps.
+     * @param bitMapExtractor the {@code BitMapExtractor} to provide the bit maps.
      * @return {@code true} if this filter is enabled for all bits specified by the bit maps
      */
-    default boolean contains(final BitMapProducer bitMapProducer) {
-        return forEachBitMapPair(bitMapProducer, (x, y) -> (x & y) == y);
+    default boolean contains(final BitMapExtractor bitMapExtractor) {
+        return processBitMapPairs(bitMapExtractor, (x, y) -> (x & y) == y);
     }
 
     /**
@@ -86,7 +86,7 @@ default boolean contains(final BitMapProducer bitMapProducer) {
      */
     default boolean contains(final BloomFilter other) {
         Objects.requireNonNull(other, "other");
-        return (characteristics() & SPARSE) != 0 ? contains((IndexProducer) other) : contains((BitMapProducer) other);
+        return (characteristics() & SPARSE) != 0 ? contains((IndexExtractor) other) : contains((BitMapExtractor) other);
     }
 
     /**
@@ -106,15 +106,15 @@ default boolean contains(final Hasher hasher) {
     }
 
     /**
-     * Returns {@code true} if this filter contains the indices specified IndexProducer.
+     * Returns {@code true} if this filter contains the indices specified IndexExtractor.
      *
      * <p>Specifically this returns {@code true} if this filter is enabled for all bit indexes
-     * identified by the {@code IndexProducer}.</p>
+     * identified by the {@code IndexExtractor}.</p>
      *
-     * @param indexProducer the IndexProducer to provide the indexes
-     * @return {@code true} if this filter is enabled for all bits specified by the IndexProducer
+     * @param indexExtractor the IndexExtractor to provide the indexes
+     * @return {@code true} if this filter is enabled for all bits specified by the IndexExtractor
      */
-    boolean contains(IndexProducer indexProducer);
+    boolean contains(IndexExtractor indexExtractor);
 
     /**
      * Creates a new instance of the BloomFilter with the same properties as the current one.
@@ -245,7 +245,7 @@ default int estimateUnion(final BloomFilter other) {
      * @return {@code true} if no bits are enabled, {@code false} otherwise.
      */
     default boolean isEmpty() {
-        return forEachBitMap(y -> y == 0);
+        return processBitMaps(y -> y == 0);
     }
 
     /**
@@ -261,18 +261,18 @@ default boolean isFull() {
 
     /**
      * Merges the specified hasher into this Bloom filter. Specifically all
-     * bit indexes that are identified by the {@code producer} will be enabled in this filter.
+     * bit indexes that are identified by the {@code bitMapExtractor} will be enabled in this filter.
      *
      * <p><em>Note: This method should return {@code true} even if no additional bit indexes were
      * enabled. A {@code false} result indicates that this filter may or may not contain all the indexes
-     * enabled in the {@code producer}.</em>  This state may occur in complex Bloom filter implementations like
+     * enabled in the {@code bitMapExtractor}.</em>  This state may occur in complex Bloom filter implementations like
      * counting Bloom filters.</p>
      *
-     * @param bitMapProducer The producer to merge.
+     * @param bitMapExtractor The BitMapExtractor to merge.
      * @return true if the merge was successful
-     * @throws IllegalArgumentException if producer sends illegal value.
+     * @throws IllegalArgumentException if bitMapExtractor sends illegal value.
      */
-    boolean merge(BitMapProducer bitMapProducer);
+    boolean merge(BitMapExtractor bitMapExtractor);
 
     /**
      * Merges the specified Bloom filter into this Bloom filter.
@@ -289,7 +289,7 @@ default boolean isFull() {
      * @return true if the merge was successful
      */
     default boolean merge(final BloomFilter other) {
-        return (characteristics() & SPARSE) != 0 ? merge((IndexProducer) other) : merge((BitMapProducer) other);
+        return (characteristics() & SPARSE) != 0 ? merge((IndexExtractor) other) : merge((BitMapExtractor) other);
     }
 
     /**
@@ -311,25 +311,25 @@ default boolean merge(final Hasher hasher) {
     }
 
     /**
-     * Merges the specified IndexProducer into this Bloom filter. Specifically all
-     * bit indexes that are identified by the {@code producer} will be enabled in this filter.
+     * Merges the specified IndexExtractor into this Bloom filter. Specifically all
+     * bit indexes that are identified by the {@code indexExtractor} will be enabled in this filter.
      *
      * <p><em>Note: This method should return {@code true} even if no additional bit indexes were
      * enabled. A {@code false} result indicates that this filter may or may not contain all the indexes of
-     * the {@code producer}.</em>  This state may occur in complex Bloom filter implementations like
+     * the {@code indexExtractor}.</em>  This state may occur in complex Bloom filter implementations like
      * counting Bloom filters.</p>
      *
-     * @param indexProducer The IndexProducer to merge.
+     * @param indexExtractor The IndexExtractor to merge.
      * @return true if the merge was successful
-     * @throws IllegalArgumentException if producer sends illegal value.
+     * @throws IllegalArgumentException if indexExtractor sends illegal value.
      */
-    boolean merge(IndexProducer indexProducer);
+    boolean merge(IndexExtractor indexExtractor);
 
     /**
-     * Most Bloom filters create unique IndexProducers.
+     * Most Bloom filters create unique IndexExtractors.
      */
     @Override
-    default IndexProducer uniqueIndices() {
+    default IndexExtractor uniqueIndices() {
         return this;
     }
 }
diff --git a/src/main/java/org/apache/commons/collections4/bloomfilter/BloomFilterProducer.java b/src/main/java/org/apache/commons/collections4/bloomfilter/BloomFilterExtractor.java
similarity index 76%
rename from src/main/java/org/apache/commons/collections4/bloomfilter/BloomFilterProducer.java
rename to src/main/java/org/apache/commons/collections4/bloomfilter/BloomFilterExtractor.java
index 280813ff72..7ad82713e6 100644
--- a/src/main/java/org/apache/commons/collections4/bloomfilter/BloomFilterProducer.java
+++ b/src/main/java/org/apache/commons/collections4/bloomfilter/BloomFilterExtractor.java
@@ -27,10 +27,11 @@
  *
  * @since 4.5
  */
-public interface BloomFilterProducer {
+@FunctionalInterface
+public interface BloomFilterExtractor {
 
     /**
-     * Creates a BloomFilterProducer from an array of Bloom filters.
+     * Creates a BloomFilterExtractor from an array of Bloom filters.
      *
      * <ul>
      * <li>The asBloomFilterArray() method returns a copy of the original array
@@ -39,12 +40,12 @@ public interface BloomFilterProducer {
      * </ul>
      * <p><em>All modifications to the Bloom filters are reflected in the original filters</em></p>
      *
-     * @param filters The filters to be returned by the producer.
-     * @return THe BloomFilterProducer containing the filters.
+     * @param filters The filters to be returned by the extractor.
+     * @return THe BloomFilterExtractor containing the filters.
      */
-    static BloomFilterProducer fromBloomFilterArray(final BloomFilter... filters) {
+    static BloomFilterExtractor fromBloomFilterArray(final BloomFilter... filters) {
         Objects.requireNonNull(filters, "filters");
-        return new BloomFilterProducer() {
+        return new BloomFilterExtractor() {
             /**
              * This implementation returns a copy the original array, the contained Bloom filters
              * are references to the originals, any modifications to them are reflected in the original
@@ -56,7 +57,7 @@ public BloomFilter[] asBloomFilterArray() {
             }
 
             @Override
-            public boolean forEachBloomFilter(final Predicate<BloomFilter> predicate) {
+            public boolean processBloomFilters(final Predicate<BloomFilter> predicate) {
                 for (final BloomFilter filter : filters) {
                     if (!predicate.test(filter)) {
                         return false;
@@ -70,10 +71,10 @@ public boolean forEachBloomFilter(final Predicate<BloomFilter> predicate) {
              * filters are reflected in the originals.
              */
             @Override
-            public boolean forEachBloomFilterPair(final BloomFilterProducer other,
-                    final BiPredicate<BloomFilter, BloomFilter> func) {
+            public boolean processBloomFilterPair(final BloomFilterExtractor other,
+                                                  final BiPredicate<BloomFilter, BloomFilter> func) {
                 final CountingPredicate<BloomFilter> p = new CountingPredicate<>(filters, func);
-                return other.forEachBloomFilter(p) && p.forEachRemaining();
+                return other.processBloomFilters(p) && p.processRemaining();
             }
         };
     }
@@ -88,7 +89,7 @@ public boolean forEachBloomFilterPair(final BloomFilterProducer other,
      */
     default BloomFilter[] asBloomFilterArray() {
         final List<BloomFilter> filters = new ArrayList<>();
-        forEachBloomFilter(f -> filters.add(f.copy()));
+        processBloomFilters(f -> filters.add(f.copy()));
         return filters.toArray(new BloomFilter[0]);
     }
 
@@ -100,7 +101,7 @@ default BloomFilter[] asBloomFilterArray() {
      */
     default BloomFilter flatten() {
         final BloomFilter[] bf = {null};
-        forEachBloomFilter( x -> {
+        processBloomFilters(x -> {
             if (bf[0] == null) {
                 bf[0] = new SimpleBloomFilter( x.getShape());
             }
@@ -117,27 +118,27 @@ default BloomFilter flatten() {
      * @return {@code false} when the first filter fails the predicate test. Returns
      *         {@code true} if all filters pass the test.
      */
-    boolean forEachBloomFilter(Predicate<BloomFilter> bloomFilterPredicate);
+    boolean processBloomFilters(Predicate<BloomFilter> bloomFilterPredicate);
 
     /**
      * Applies the {@code func} to each Bloom filter pair in order. Will apply all
-     * of the Bloom filters from the other BloomFilterProducer to this producer. If
-     * either {@code this} producer or {@code other} producer has fewer BloomFilters
+     * of the Bloom filters from the other BloomFilterExtractor to this extractor. If
+     * either {@code this} extractor or {@code other} extractor has fewer BloomFilters
      * ths method will provide {@code null} for all excess calls to the {@code func}.
      *
      * <p><em>This implementation returns references to the Bloom filter.  Other implementations
      * should specify if the array contains deep copies, immutable instances,
      * or references to the filters in the collection.</em></p>
      *
-     * @param other The other BloomFilterProducer that provides the y values in the
+     * @param other The other BloomFilterExtractor that provides the y values in the
      *              (x,y) pair.
      * @param func  The function to apply.
      * @return {@code true} if the {@code func} returned {@code true} for every pair,
      *         {@code false} otherwise.
      */
-    default boolean forEachBloomFilterPair(final BloomFilterProducer other,
-            final BiPredicate<BloomFilter, BloomFilter> func) {
+    default boolean processBloomFilterPair(final BloomFilterExtractor other,
+                                           final BiPredicate<BloomFilter, BloomFilter> func) {
         final CountingPredicate<BloomFilter> p = new CountingPredicate<>(asBloomFilterArray(), func);
-        return other.forEachBloomFilter(p) && p.forEachRemaining();
+        return other.processBloomFilters(p) && p.processRemaining();
     }
 }
diff --git a/src/main/java/org/apache/commons/collections4/bloomfilter/CellProducer.java b/src/main/java/org/apache/commons/collections4/bloomfilter/CellExtractor.java
similarity index 74%
rename from src/main/java/org/apache/commons/collections4/bloomfilter/CellProducer.java
rename to src/main/java/org/apache/commons/collections4/bloomfilter/CellExtractor.java
index 928f1d4e66..6ff79374ec 100644
--- a/src/main/java/org/apache/commons/collections4/bloomfilter/CellProducer.java
+++ b/src/main/java/org/apache/commons/collections4/bloomfilter/CellExtractor.java
@@ -22,26 +22,26 @@
 
 /**
  * Some Bloom filter implementations use a count rather than a bit flag. The term {@code Cell} is used to
- * refer to these counts and their associated index.  This class is the equivalent of the index producer except
+ * refer to these counts and their associated index.  This class is the equivalent of the index extractor except
  * that it produces cells.
  *
- * <p>Note that a CellProducer must not return duplicate indices and must be ordered.</p>
+ * <p>Note that a CellExtractor must not return duplicate indices and must be ordered.</p>
  *
  * <p>Implementations must guarantee that:</p>
  *
  * <ul>
- * <li>The IndexProducer implementation returns unique ordered indices.</li>
- * <li>The cells are produced in IndexProducer order.</li>
- * <li>For every value produced by the IndexProducer there will be only one matching
- * cell produced by the CellProducer.</li>
- * <li>The CellProducer will not generate cells with indices that are not output by the IndexProducer.</li>
- * <li>The IndexProducer will not generate indices that have a zero count for the cell.</li>
+ * <li>The IndexExtractor implementation returns unique ordered indices.</li>
+ * <li>The cells are produced in IndexExtractor order.</li>
+ * <li>For every value produced by the IndexExtractor there will be only one matching
+ * cell produced by the CellExtractor.</li>
+ * <li>The CellExtractor will not generate cells with indices that are not output by the IndexExtractor.</li>
+ * <li>The IndexExtractor will not generate indices that have a zero count for the cell.</li>
  * </ul>
  *
  * @since 4.5
  */
 @FunctionalInterface
-public interface CellProducer extends IndexProducer {
+public interface CellExtractor extends IndexExtractor {
 
     /**
      * Represents an operation that accepts an {@code <index, count>} pair.
@@ -51,7 +51,7 @@ public interface CellProducer extends IndexProducer {
      * {@link java.util.function.BiPredicate} for {@code int}.</p>
      */
     @FunctionalInterface
-    interface CellConsumer {
+    interface CellPredicate {
         /**
          * Performs an operation on the given {@code <index, count>} pair.
          *
@@ -63,15 +63,15 @@ interface CellConsumer {
     }
 
     /**
-     * Creates a CellProducer from an IndexProducer.
+     * Creates a CellExtractor from an IndexExtractor.
      *
      * <p>Note the following properties:
      * <ul>
-     * <li>Each index returned from the IndexProducer is assumed to have a cell value of 1.</li>
-     * <li>The CellProducer aggregates duplicate indices from the IndexProducer.</li>
+     * <li>Each index returned from the IndexExtractor is assumed to have a cell value of 1.</li>
+     * <li>The CellExtractor aggregates duplicate indices from the IndexExtractor.</li>
      * </ul>
      *
-     * <p>A CellProducer that outputs the mapping [(1,2),(2,3),(3,1)] can be created from many combinations
+     * <p>A CellExtractor that outputs the mapping [(1,2),(2,3),(3,1)] can be created from many combinations
      * of indices including:
      * <pre>
      * [1, 1, 2, 2, 2, 3]
@@ -80,11 +80,11 @@ interface CellConsumer {
      * ...
      * </pre>
      *
-     * @param producer An index producer.
-     * @return A CellProducer with the same indices as the IndexProducer.
+     * @param indexExtractor An index indexExtractor.
+     * @return A CellExtractor with the same indices as the IndexExtractor.
      */
-    static CellProducer from(final IndexProducer producer) {
-        return new CellProducer() {
+    static CellExtractor from(final IndexExtractor indexExtractor) {
+        return new CellExtractor() {
             /**
              * Class to track cell values in the TreeMap.
              */
@@ -112,7 +112,7 @@ public int[] asIndexArray() {
             }
 
             @Override
-            public boolean forEachCell(final CellConsumer consumer) {
+            public boolean processCells(final CellPredicate consumer) {
                 populate();
                 for (final CounterCell cell : counterCells.values()) {
                     if (!consumer.test(cell.idx, cell.count)) {
@@ -124,7 +124,7 @@ public boolean forEachCell(final CellConsumer consumer) {
 
             private void populate() {
                 if (counterCells.isEmpty()) {
-                    producer.forEachIndex( idx -> {
+                    indexExtractor.processIndices(idx -> {
                         final CounterCell cell = new CounterCell(idx, 1);
                         final CounterCell counter = counterCells.get(cell);
                         if (counter == null) {
@@ -153,18 +153,18 @@ private void populate() {
      * @return {@code true} if all cells return true from consumer, {@code false} otherwise.
      * @throws NullPointerException if the specified consumer is null
      */
-    boolean forEachCell(CellConsumer consumer);
+    boolean processCells(CellPredicate consumer);
 
     /**
      * The default implementation returns distinct and ordered indices for all cells with a non-zero count.
      */
     @Override
-    default boolean forEachIndex(final IntPredicate predicate) {
-        return forEachCell((i, v) -> predicate.test(i));
+    default boolean processIndices(final IntPredicate predicate) {
+        return processCells((i, v) -> predicate.test(i));
     }
 
     @Override
-    default IndexProducer uniqueIndices() {
+    default IndexExtractor uniqueIndices() {
         return this;
     }
 }
diff --git a/src/main/java/org/apache/commons/collections4/bloomfilter/CountingBloomFilter.java b/src/main/java/org/apache/commons/collections4/bloomfilter/CountingBloomFilter.java
index 503bde72d1..af1ef43287 100644
--- a/src/main/java/org/apache/commons/collections4/bloomfilter/CountingBloomFilter.java
+++ b/src/main/java/org/apache/commons/collections4/bloomfilter/CountingBloomFilter.java
@@ -51,15 +51,15 @@
  * of the filter after such an operation. For example are the cells not updated,
  * partially updated or updated entirely before the exception is raised.</p>
  *
- * @see CellProducer
+ * @see CellExtractor
  * @since 4.5
  */
-public interface CountingBloomFilter extends BloomFilter, CellProducer {
+public interface CountingBloomFilter extends BloomFilter, CellExtractor {
 
     // Query Operations
 
     /**
-     * Adds the specified CellProducer to this Bloom filter.
+     * Adds the specified CellExtractor to this Bloom filter.
      *
      * <p>Specifically
      * all cells for the indexes identified by the {@code other} will be incremented
@@ -67,12 +67,12 @@ public interface CountingBloomFilter extends BloomFilter, CellProducer {
      *
      * <p>This method will return {@code true} if the filter is valid after the operation.</p>
      *
-     * @param other the CellProducer to add.
+     * @param other the CellExtractor to add.
      * @return {@code true} if the addition was successful and the state is valid
      * @see #isValid()
-     * @see #subtract(CellProducer)
+     * @see #subtract(CellExtractor)
      */
-    boolean add(CellProducer other);
+    boolean add(CellExtractor other);
 
     /**
      * Creates a new instance of the CountingBloomFilter with the same properties as the current one.
@@ -88,19 +88,19 @@ public interface CountingBloomFilter extends BloomFilter, CellProducer {
     int getMaxCell();
 
     /**
-     * Determines the maximum number of times the BitMapProducer could have been merged into this
+     * Determines the maximum number of times the BitMapExtractor could have been merged into this
      * counting filter.
-     * @param bitMapProducer the BitMapProducer to provide the indices.
-     * @return the maximum number of times the BitMapProducer could have been inserted.
+     * @param bitMapExtractor the BitMapExtractor to provide the indices.
+     * @return the maximum number of times the BitMapExtractor could have been inserted.
      */
-    default int getMaxInsert(final BitMapProducer bitMapProducer) {
-        if (!contains(bitMapProducer)) {
+    default int getMaxInsert(final BitMapExtractor bitMapExtractor) {
+        if (!contains(bitMapExtractor)) {
             return 0;
         }
-        final long[] bitMaps = bitMapProducer.asBitMapArray();
+        final long[] bitMaps = bitMapExtractor.asBitMapArray();
         final int[] max = { Integer.MAX_VALUE };
-        forEachCell((x, y) -> {
-            if ((bitMaps[BitMap.getLongIndex(x)] & BitMap.getLongBit(x)) != 0) {
+        processCells((x, y) -> {
+            if ((bitMaps[BitMaps.getLongIndex(x)] & BitMaps.getLongBit(x)) != 0) {
                 max[0] = max[0] <= y ? max[0] : y;
             }
             return true;
@@ -115,15 +115,15 @@ default int getMaxInsert(final BitMapProducer bitMapProducer) {
      * @return the maximum number of times the Bloom filter could have been inserted.
      */
     default int getMaxInsert(final BloomFilter bloomFilter) {
-        return getMaxInsert((BitMapProducer) bloomFilter);
+        return getMaxInsert((BitMapExtractor) bloomFilter);
     }
 
     /**
-     * Determines the maximum number of times the Cell Producer could have been add.
-     * @param cellProducer the producer of cells.
-     * @return the maximum number of times the CellProducer could have been inserted.
+     * Determines the maximum number of times the Cell Extractor could have been added.
+     * @param cellExtractor the extractor of cells.
+     * @return the maximum number of times the CellExtractor could have been inserted.
      */
-    int getMaxInsert(CellProducer cellProducer);
+    int getMaxInsert(CellExtractor cellExtractor);
 
     /**
      * Determines the maximum number of times the Hasher could have been merged into this
@@ -138,16 +138,16 @@ default int getMaxInsert(final Hasher hasher) {
     // Modification Operations
 
     /**
-     * Determines the maximum number of times the IndexProducer could have been merged
+     * Determines the maximum number of times the IndexExtractor could have been merged
      * into this counting filter.
-     * <p>To determine how many times an indxProducer could have been added create a CellProducer
-     * from the indexProducer and check that</p>
-     * @param idxProducer the producer to drive the count check.
-     * @return the maximum number of times the IndexProducer could have been inserted.
-     * @see #getMaxInsert(CellProducer)
+     * <p>To determine how many times an indexExtractor could have been added create a CellExtractor
+     * from the indexExtractor and check that</p>
+     * @param indexExtractor the extractor to drive the count check.
+     * @return the maximum number of times the IndexExtractor could have been inserted.
+     * @see #getMaxInsert(CellExtractor)
      */
-    default int getMaxInsert(final IndexProducer idxProducer) {
-        return getMaxInsert(CellProducer.from(idxProducer.uniqueIndices()) );
+    default int getMaxInsert(final IndexExtractor indexExtractor) {
+        return getMaxInsert(CellExtractor.from(indexExtractor.uniqueIndices()) );
     }
 
     /**
@@ -172,21 +172,20 @@ default int getMaxInsert(final IndexProducer idxProducer) {
     boolean isValid();
 
     /**
-     * Merges the specified BitMap producer into this Bloom filter.
+     * Merges the specified BitMap extractor into this Bloom filter.
      *
-     * <p>Specifically: all cells for the indexes identified by the {@code bitMapProducer} will be incremented by 1.</p>
+     * <p>Specifically: all cells for the indexes identified by the {@code bitMapExtractor} will be incremented by 1.</p>
      *
      * <p>This method will return {@code true} if the filter is valid after the operation.</p>
      *
-     * @param bitMapProducer the BitMapProducer
+     * @param bitMapExtractor the BitMapExtractor
      * @return {@code true} if the removal was successful and the state is valid
      * @see #isValid()
-     * @see #add(CellProducer)
+     * @see #add(CellExtractor)
      */
     @Override
-    default boolean merge(final BitMapProducer bitMapProducer) {
-        Objects.requireNonNull(bitMapProducer, "bitMapProducer");
-        return merge(IndexProducer.fromBitMapProducer(bitMapProducer));
+    default boolean merge(final BitMapExtractor bitMapExtractor) {
+        return merge(IndexExtractor.fromBitMapExtractor(bitMapExtractor));
     }
 
     /**
@@ -195,19 +194,19 @@ default boolean merge(final BitMapProducer bitMapProducer) {
      * <p>Specifically: all cells for the indexes identified by the {@code other} filter will be incremented by 1.</p>
      *
      * <p>Note: If the other filter is a counting Bloom filter the other filter's cells are ignored and it is treated as an
-     * IndexProducer.</p>
+     * IndexExtractor.</p>
      *
      * <p>This method will return {@code true} if the filter is valid after the operation.</p>
      *
      * @param other the other Bloom filter
      * @return {@code true} if the removal was successful and the state is valid
      * @see #isValid()
-     * @see #add(CellProducer)
+     * @see #add(CellExtractor)
      */
     @Override
     default boolean merge(final BloomFilter other) {
         Objects.requireNonNull(other, "other");
-        return merge((IndexProducer) other);
+        return merge((IndexExtractor) other);
     }
 
     /**
@@ -220,7 +219,7 @@ default boolean merge(final BloomFilter other) {
      * @param hasher the hasher
      * @return {@code true} if the removal was successful and the state is valid
      * @see #isValid()
-     * @see #add(CellProducer)
+     * @see #add(CellExtractor)
      */
     @Override
     default boolean merge(final Hasher hasher) {
@@ -229,25 +228,28 @@ default boolean merge(final Hasher hasher) {
     }
 
     /**
-     * Merges the specified index producer into this Bloom filter.
+     * Merges the specified index extractor into this Bloom filter.
      *
-     * <p>Specifically: all unique cells for the indices identified by the {@code indexProducer} will be incremented by 1.</p>
+     * <p>Specifically: all unique cells for the indices identified by the {@code indexExtractor} will be incremented by 1.</p>
      *
      * <p>This method will return {@code true} if the filter is valid after the operation.</p>
      *
-     * <p>Note: If indices that are returned multiple times should be incremented multiple times convert the IndexProducer
-     * to a CellProducer and add that.</p>
-     *
-     * @param indexProducer the IndexProducer
+     * <p>Notes:</p>
+     * <ul>
+     * <li>If indices that are returned multiple times should be incremented multiple times convert the IndexExtractor
+     * to a CellExtractor and add that.</li>
+     * <li>Implementations should throw {@code IllegalArgumentException} and no other exception on bad input.</li>
+     * </ul>
+     * @param indexExtractor the IndexExtractor
      * @return {@code true} if the removal was successful and the state is valid
      * @see #isValid()
-     * @see #add(CellProducer)
+     * @see #add(CellExtractor)
      */
     @Override
-    default boolean merge(final IndexProducer indexProducer) {
-        Objects.requireNonNull(indexProducer, "indexProducer");
+    default boolean merge(final IndexExtractor indexExtractor) {
+        Objects.requireNonNull(indexExtractor, "indexExtractor");
         try {
-            return add(CellProducer.from(indexProducer.uniqueIndices()));
+            return add(CellExtractor.from(indexExtractor.uniqueIndices()));
         } catch (final IndexOutOfBoundsException e) {
             throw new IllegalArgumentException(
                     String.format("Filter only accepts values in the [0,%d) range", getShape().getNumberOfBits()), e);
@@ -255,21 +257,20 @@ default boolean merge(final IndexProducer indexProducer) {
     }
 
     /**
-     * Removes the specified BitMapProducer from this Bloom filter.
+     * Removes the specified BitMapExtractor from this Bloom filter.
      *
-     * <p>Specifically all cells for the indices produced by the {@code bitMapProducer} will be
+     * <p>Specifically all cells for the indices produced by the {@code bitMapExtractor} will be
      * decremented by 1.</p>
      *
      * <p>This method will return {@code true} if the filter is valid after the operation.</p>
      *
-     * @param bitMapProducer the BitMapProducer to provide the indexes
+     * @param bitMapExtractor the BitMapExtractor to provide the indexes
      * @return {@code true} if the removal was successful and the state is valid
      * @see #isValid()
-     * @see #subtract(CellProducer)
+     * @see #subtract(CellExtractor)
      */
-    default boolean remove(final BitMapProducer bitMapProducer) {
-        Objects.requireNonNull(bitMapProducer, "bitMapProducer");
-        return remove(IndexProducer.fromBitMapProducer(bitMapProducer));
+    default boolean remove(final BitMapExtractor bitMapExtractor) {
+        return remove(IndexExtractor.fromBitMapExtractor(bitMapExtractor));
     }
 
     /**
@@ -278,18 +279,17 @@ default boolean remove(final BitMapProducer bitMapProducer) {
      * <p>Specifically: all cells for the indexes identified by the {@code other} filter will be decremented by 1.</p>
      *
      * <p>Note: If the other filter is a counting Bloom filter the other filter's cells are ignored and it is treated as an
-     * IndexProducer.</p>
+     * IndexExtractor.</p>
      *
      * <p>This method will return {@code true} if the filter is valid after the operation.</p>
      *
      * @param other the other Bloom filter
      * @return {@code true} if the removal was successful and the state is valid
      * @see #isValid()
-     * @see #subtract(CellProducer)
+     * @see #subtract(CellExtractor)
      */
     default boolean remove(final BloomFilter other) {
-        Objects.requireNonNull(other, "other");
-        return remove((IndexProducer) other);
+        return remove((IndexExtractor) other);
     }
 
     /**
@@ -303,7 +303,7 @@ default boolean remove(final BloomFilter other) {
      * @param hasher the hasher to provide the indexes
      * @return {@code true} if the removal was successful and the state is valid
      * @see #isValid()
-     * @see #subtract(CellProducer)
+     * @see #subtract(CellExtractor)
      */
     default boolean remove(final Hasher hasher) {
         Objects.requireNonNull(hasher, "hasher");
@@ -311,25 +311,25 @@ default boolean remove(final Hasher hasher) {
     }
 
     /**
-     * Removes the values from the specified IndexProducer from the Bloom filter from this Bloom filter.
+     * Removes the values from the specified IndexExtractor from the Bloom filter from this Bloom filter.
      *
      * <p>Specifically all cells for the unique indices produced by the {@code hasher} will be
      * decremented by 1.</p>
      *
      * <p>This method will return {@code true} if the filter is valid after the operation.</p>
      *
-     * <p>Note: If indices that are returned multiple times should be decremented multiple times convert the IndexProducer
-     * to a CellProducer and subtract that.</p>
+     * <p>Note: If indices that are returned multiple times should be decremented multiple times convert the IndexExtractor
+     * to a CellExtractor and subtract that.</p>
      *
-     * @param indexProducer the IndexProducer to provide the indexes
+     * @param indexExtractor the IndexExtractor to provide the indexes
      * @return {@code true} if the removal was successful and the state is valid
      * @see #isValid()
-     * @see #subtract(CellProducer)
+     * @see #subtract(CellExtractor)
      */
-    default boolean remove(final IndexProducer indexProducer) {
-        Objects.requireNonNull(indexProducer, "indexProducer");
+    default boolean remove(final IndexExtractor indexExtractor) {
+        Objects.requireNonNull(indexExtractor, "indexExtractor");
         try {
-            return subtract(CellProducer.from(indexProducer.uniqueIndices()));
+            return subtract(CellExtractor.from(indexExtractor.uniqueIndices()));
         } catch (final IndexOutOfBoundsException e) {
             throw new IllegalArgumentException(
                     String.format("Filter only accepts values in the [0,%d) range", getShape().getNumberOfBits()));
@@ -338,7 +338,7 @@ default boolean remove(final IndexProducer indexProducer) {
 
 
     /**
-     * Adds the specified CellProducer to this Bloom filter.
+     * Adds the specified CellExtractor to this Bloom filter.
      *
      * <p>Specifically
      * all cells for the indexes identified by the {@code other} will be decremented
@@ -346,15 +346,19 @@ default boolean remove(final IndexProducer indexProducer) {
      *
      * <p>This method will return true if the filter is valid after the operation.</p>
      *
-     * @param other the CellProducer to subtract.
+     * @param other the CellExtractor to subtract.
      * @return {@code true} if the subtraction was successful and the state is valid
      * @see #isValid()
-     * @see #add(CellProducer)
+     * @see #add(CellExtractor)
      */
-    boolean subtract(CellProducer other);
+    boolean subtract(CellExtractor other);
 
+    /**
+     * The default implementation is a no-op since the counting bloom filter returns an unique IndexExtractor by default.
+     * @return this counting Bloom filter.
+     */
     @Override
-    default IndexProducer uniqueIndices() {
+    default IndexExtractor uniqueIndices() {
         return this;
     }
 }
diff --git a/src/main/java/org/apache/commons/collections4/bloomfilter/CountingLongPredicate.java b/src/main/java/org/apache/commons/collections4/bloomfilter/CountingLongPredicate.java
index 90ef5647b3..a9e5b31af4 100644
--- a/src/main/java/org/apache/commons/collections4/bloomfilter/CountingLongPredicate.java
+++ b/src/main/java/org/apache/commons/collections4/bloomfilter/CountingLongPredicate.java
@@ -21,7 +21,7 @@
 /**
  * A long predicate that applies the test func to each member of the {@code ary} in sequence for each call to {@code test()}.
  * if the {@code ary} is exhausted, the subsequent calls to {@code test} are executed with a zero value.
- * If the calls to {@code test} do not exhaust the {@code ary} the {@code forEachRemaining} method can be called to
+ * If the calls to {@code test} do not exhaust the {@code ary} the {@code processRemaining} method can be called to
  * execute the @{code test} with a zero value for each remaining {@code idx} value.
  * @since 4.5
  */
@@ -45,12 +45,12 @@ class CountingLongPredicate implements LongPredicate {
     /**
      * Call the long-long consuming bi-predicate for each remaining unpaired long in
      * the input array. This method should be invoked after the predicate has been
-     * passed to {@link BitMapProducer#forEachBitMap(LongPredicate)} to consume any
+     * passed to {@link BitMapExtractor#processBitMaps(LongPredicate)} to consume any
      * unpaired bitmaps. The second argument to the bi-predicate will be zero.
      *
-     * @return true if all calls the predicate were successful
+     * @return true if all calls to the predicate were successful
      */
-    boolean forEachRemaining() {
+    boolean processRemaining() {
         // uses local references for optimization benefit.
         int i = idx;
         final long[] a = ary;
diff --git a/src/main/java/org/apache/commons/collections4/bloomfilter/CountingPredicate.java b/src/main/java/org/apache/commons/collections4/bloomfilter/CountingPredicate.java
index 05a3543627..ba8049da7a 100644
--- a/src/main/java/org/apache/commons/collections4/bloomfilter/CountingPredicate.java
+++ b/src/main/java/org/apache/commons/collections4/bloomfilter/CountingPredicate.java
@@ -24,7 +24,7 @@
  * sequence for each call to {@code test()}. if the {@code ary} is exhausted,
  * the subsequent calls to {@code test} are executed with a {@code null} value.
  * If the calls to {@code test} do not exhaust the {@code ary} the {@code
- * forEachRemaining} method can be called to execute the @{code test} with a
+ * processRemaining} method can be called to execute the @{code test} with a
  * {@code null} value for each remaining {@code idx} value.
  *
  * @param <T> the type of object being compared.
@@ -52,12 +52,12 @@ class CountingPredicate<T> implements Predicate<T> {
     /**
      * Call {@code BiPredicate<T, T>} for each remaining unpaired {@code <T>} in the
      * input array. This method should be invoked after the predicate has been
-     * passed to a {@code Producer.forEach<T>(BiPredicate<T, T>)} to consume any
+     * passed to a {@code Extractor.forEach<T>(BiPredicate<T, T>)} to consume any
      * unpaired {@code <T>}s. The second argument to the BiPredicate will be {@code null}.
      *
-     * @return true if all calls the predicate were successful
+     * @return true if all calls to the predicate were successful
      */
-    boolean forEachRemaining() {
+    boolean processRemaining() {
         // uses local references for optimization benefit.
         int i = idx;
         final T[] a = ary;
diff --git a/src/main/java/org/apache/commons/collections4/bloomfilter/EnhancedDoubleHasher.java b/src/main/java/org/apache/commons/collections4/bloomfilter/EnhancedDoubleHasher.java
index 12115e5ce8..761803e49f 100644
--- a/src/main/java/org/apache/commons/collections4/bloomfilter/EnhancedDoubleHasher.java
+++ b/src/main/java/org/apache/commons/collections4/bloomfilter/EnhancedDoubleHasher.java
@@ -130,10 +130,10 @@ long getInitial() {
     }
 
     @Override
-    public IndexProducer indices(final Shape shape) {
+    public IndexExtractor indices(final Shape shape) {
         Objects.requireNonNull(shape, "shape");
 
-        return new IndexProducer() {
+        return new IndexExtractor() {
 
             @Override
             public int[] asIndexArray() {
@@ -142,7 +142,7 @@ public int[] asIndexArray() {
 
                 // This method needs to return duplicate indices
 
-                forEachIndex(i -> {
+                processIndices(i -> {
                     result[idx[0]++] = i;
                     return true;
                 });
@@ -150,7 +150,7 @@ public int[] asIndexArray() {
             }
 
             @Override
-            public boolean forEachIndex(final IntPredicate consumer) {
+            public boolean processIndices(final IntPredicate consumer) {
                 Objects.requireNonNull(consumer, "consumer");
                 final int bits = shape.getNumberOfBits();
                 // Enhanced double hashing:
@@ -166,8 +166,8 @@ public boolean forEachIndex(final IntPredicate consumer) {
                 // The final hash is:
                 // hash[i] = ( h1(x) - i*h2(x) - (i*i*i - i)/6 ) wrapped in [0, bits)
 
-                int index = BitMap.mod(initial, bits);
-                int inc = BitMap.mod(increment, bits);
+                int index = BitMaps.mod(initial, bits);
+                int inc = BitMaps.mod(increment, bits);
 
                 final int k = shape.getNumberOfHashFunctions();
                 if (k > bits) {
diff --git a/src/main/java/org/apache/commons/collections4/bloomfilter/Hasher.java b/src/main/java/org/apache/commons/collections4/bloomfilter/Hasher.java
index e2c30d5d28..dcc13c7115 100644
--- a/src/main/java/org/apache/commons/collections4/bloomfilter/Hasher.java
+++ b/src/main/java/org/apache/commons/collections4/bloomfilter/Hasher.java
@@ -17,7 +17,7 @@
 package org.apache.commons.collections4.bloomfilter;
 
 /**
- * A Hasher creates IndexProducer based on the hash implementation and the
+ * A Hasher creates IndexExtractor based on the hash implementation and the
  * provided Shape.
  *
  * @since 4.5
@@ -25,14 +25,14 @@
 public interface Hasher {
 
     /**
-     * Creates an IndexProducer for this hasher based on the Shape.
+     * Creates an IndexExtractor for this hasher based on the Shape.
      *
-     * <p>The {@code IndexProducer} will create indices within the range defined by the number of bits in
+     * <p>The {@code IndexExtractor} will create indices within the range defined by the number of bits in
      * the shape. The total number of indices will respect the number of hash functions per item
      * defined by the shape. However the count of indices may not be a multiple of the number of
      * hash functions if the implementation has removed duplicates.</p>
      *
-     * <p>This IndexProducer must be deterministic in that it must return the same indices for the
+     * <p>This IndexExtractor must be deterministic in that it must return the same indices for the
      * same Shape.</p>
      *
      * <p>No guarantee is made as to order of indices.</p>
@@ -41,5 +41,5 @@ public interface Hasher {
      * @param shape the shape of the desired Bloom filter.
      * @return the iterator of integers
      */
-    IndexProducer indices(Shape shape);
+    IndexExtractor indices(Shape shape);
 }
diff --git a/src/main/java/org/apache/commons/collections4/bloomfilter/IndexProducer.java b/src/main/java/org/apache/commons/collections4/bloomfilter/IndexExtractor.java
similarity index 77%
rename from src/main/java/org/apache/commons/collections4/bloomfilter/IndexProducer.java
rename to src/main/java/org/apache/commons/collections4/bloomfilter/IndexExtractor.java
index 7923288765..d6a33537e9 100644
--- a/src/main/java/org/apache/commons/collections4/bloomfilter/IndexProducer.java
+++ b/src/main/java/org/apache/commons/collections4/bloomfilter/IndexExtractor.java
@@ -31,15 +31,15 @@
  * @since 4.5
  */
 @FunctionalInterface
-public interface IndexProducer {
+public interface IndexExtractor {
 
     /**
-     * Creates an IndexProducer from a {@code BitMapProducer}.
-     * @param producer the {@code BitMapProducer}
-     * @return a new {@code IndexProducer}.
+     * Creates an IndexExtractor from a {@code BitMapExtractor}.
+     * @param bitMapExtractor the {@code BitMapExtractor}
+     * @return a new {@code IndexExtractor}.
      */
-    static IndexProducer fromBitMapProducer(final BitMapProducer producer) {
-        Objects.requireNonNull(producer, "producer");
+    static IndexExtractor fromBitMapExtractor(final BitMapExtractor bitMapExtractor) {
+        Objects.requireNonNull(bitMapExtractor, "bitMapExtractor");
         return consumer -> {
             final LongPredicate longPredicate = new LongPredicate() {
                 int wordIdx;
@@ -58,17 +58,17 @@ public boolean test(long word) {
                     return true;
                 }
             };
-            return producer.forEachBitMap(longPredicate::test);
+            return bitMapExtractor.processBitMaps(longPredicate::test);
         };
     }
 
     /**
-     * Creates an IndexProducer from an array of integers.
+     * Creates an IndexExtractor from an array of integers.
      * @param values the index values
-     * @return an IndexProducer that uses the values.
+     * @return an IndexExtractor that uses the values.
      */
-    static IndexProducer fromIndexArray(final int... values) {
-        return new IndexProducer() {
+    static IndexExtractor fromIndexArray(final int... values) {
+        return new IndexExtractor() {
 
             @Override
             public int[] asIndexArray() {
@@ -76,7 +76,7 @@ public int[] asIndexArray() {
             }
 
             @Override
-            public boolean forEachIndex(final IntPredicate predicate) {
+            public boolean processIndices(final IntPredicate predicate) {
                 for (final int value : values) {
                     if (!predicate.test(value)) {
                         return false;
@@ -88,7 +88,7 @@ public boolean forEachIndex(final IntPredicate predicate) {
     }
 
     /**
-     * Return a copy of the IndexProducer data as an int array.
+     * Return a copy of the IndexExtractor data as an int array.
      *
      * <p>Indices ordering and uniqueness is not guaranteed.</p>
      *
@@ -117,7 +117,7 @@ int[] toArray() {
             }
         }
         final Indices indices = new Indices();
-        forEachIndex(indices::add);
+        processIndices(indices::add);
         return indices.toArray();
     }
 
@@ -134,31 +134,31 @@ int[] toArray() {
      * @return {@code true} if all indexes return true from consumer, {@code false} otherwise.
      * @throws NullPointerException if the specified action is null
      */
-    boolean forEachIndex(IntPredicate predicate);
+    boolean processIndices(IntPredicate predicate);
 
     /**
-     * Creates an IndexProducer comprising the unique indices for this producer.
+     * Creates an IndexExtractor comprising the unique indices for this extractor.
      *
-     * <p>By default creates a new producer with some overhead to remove
-     * duplicates.  IndexProducers that return unique indices by default
+     * <p>By default creates a new extractor with some overhead to remove
+     * duplicates.  IndexExtractors that return unique indices by default
      * should override this to return {@code this}.</p>
      *
      * <p>The default implementation will filter the indices from this instance
      * and return them in ascending order.</p>
      *
-     * @return the IndexProducer of unique values.
+     * @return the IndexExtractor of unique values.
      * @throws IndexOutOfBoundsException if any index is less than zero.
      */
-    default IndexProducer uniqueIndices() {
+    default IndexExtractor uniqueIndices() {
         final BitSet bitSet = new BitSet();
-        forEachIndex(i -> {
+        processIndices(i -> {
             bitSet.set(i);
             return true;
         });
 
-        return new IndexProducer() {
+        return new IndexExtractor() {
             @Override
-            public boolean forEachIndex(final IntPredicate predicate) {
+            public boolean processIndices(final IntPredicate predicate) {
                 for (int idx = bitSet.nextSetBit(0); idx >= 0; idx = bitSet.nextSetBit(idx + 1)) {
                     if (!predicate.test(idx)) {
                         return false;
@@ -168,7 +168,7 @@ public boolean forEachIndex(final IntPredicate predicate) {
             }
 
             @Override
-            public IndexProducer uniqueIndices() {
+            public IndexExtractor uniqueIndices() {
                 return this;
             }
         };
diff --git a/src/main/java/org/apache/commons/collections4/bloomfilter/IndexFilter.java b/src/main/java/org/apache/commons/collections4/bloomfilter/IndexFilter.java
index 4fc4bab5e6..070a49fdaa 100644
--- a/src/main/java/org/apache/commons/collections4/bloomfilter/IndexFilter.java
+++ b/src/main/java/org/apache/commons/collections4/bloomfilter/IndexFilter.java
@@ -71,13 +71,13 @@ static class BitMapTracker implements IntPredicate {
          * @param shape The shape that is being generated.
          */
         BitMapTracker(final Shape shape) {
-            bits = new long[BitMap.numberOfBitMaps(shape.getNumberOfBits())];
+            bits = new long[BitMaps.numberOfBitMaps(shape.getNumberOfBits())];
         }
 
         @Override
         public boolean test(final int number) {
-            final boolean retval = !BitMap.contains(bits, number);
-            BitMap.set(bits, number);
+            final boolean retval = !BitMaps.contains(bits, number);
+            BitMaps.set(bits, number);
             return retval;
         }
     }
@@ -105,7 +105,7 @@ public static IntPredicate create(final Shape shape, final IntPredicate consumer
     private IndexFilter(final Shape shape, final IntPredicate consumer) {
         this.size = shape.getNumberOfBits();
         this.consumer = consumer;
-        if (BitMap.numberOfBitMaps(shape.getNumberOfBits()) * Long.BYTES < (long) shape.getNumberOfHashFunctions()
+        if (BitMaps.numberOfBitMaps(shape.getNumberOfBits()) * Long.BYTES < (long) shape.getNumberOfHashFunctions()
                 * Integer.BYTES) {
             this.tracker = new BitMapTracker(shape);
         } else {
diff --git a/src/main/java/org/apache/commons/collections4/bloomfilter/IndexUtils.java b/src/main/java/org/apache/commons/collections4/bloomfilter/IndexUtils.java
index 3c835ea570..fdf3b8fb19 100644
--- a/src/main/java/org/apache/commons/collections4/bloomfilter/IndexUtils.java
+++ b/src/main/java/org/apache/commons/collections4/bloomfilter/IndexUtils.java
@@ -19,8 +19,8 @@
 import java.util.Arrays;
 
 /**
- * Provides functions to assist in IndexProducer creation and manipulation.
- * @see IndexProducer
+ * Provides functions to assist in IndexExtractor creation and manipulation.
+ * @see IndexExtractor
  */
 final class IndexUtils {
 
diff --git a/src/main/java/org/apache/commons/collections4/bloomfilter/LayerManager.java b/src/main/java/org/apache/commons/collections4/bloomfilter/LayerManager.java
index f5500f747c..011822e82d 100644
--- a/src/main/java/org/apache/commons/collections4/bloomfilter/LayerManager.java
+++ b/src/main/java/org/apache/commons/collections4/bloomfilter/LayerManager.java
@@ -51,7 +51,7 @@
  *
  * @since 4.5
  */
-public class LayerManager<T extends BloomFilter> implements BloomFilterProducer {
+public class LayerManager<T extends BloomFilter> implements BloomFilterExtractor {
 
     /**
      * Builder to create Layer Manager
@@ -358,7 +358,7 @@ public final T first() {
      *         {@code true} if all filters pass the test.
      */
     @Override
-    public boolean forEachBloomFilter(final Predicate<BloomFilter> bloomFilterPredicate) {
+    public boolean processBloomFilters(final Predicate<BloomFilter> bloomFilterPredicate) {
         for (final BloomFilter bf : filters) {
             if (!bloomFilterPredicate.test(bf)) {
                 return false;
diff --git a/src/main/java/org/apache/commons/collections4/bloomfilter/LayeredBloomFilter.java b/src/main/java/org/apache/commons/collections4/bloomfilter/LayeredBloomFilter.java
index 058fe4aeec..ee39bae65a 100644
--- a/src/main/java/org/apache/commons/collections4/bloomfilter/LayeredBloomFilter.java
+++ b/src/main/java/org/apache/commons/collections4/bloomfilter/LayeredBloomFilter.java
@@ -62,7 +62,7 @@
  * @param <T> The type of Bloom Filter that is used for the layers.
  * @since 4.5
  */
-public class LayeredBloomFilter<T extends BloomFilter> implements BloomFilter, BloomFilterProducer {
+public class LayeredBloomFilter<T extends BloomFilter> implements BloomFilter, BloomFilterExtractor {
     /**
      * A class used to locate matching filters across all the layers.
      */
@@ -131,15 +131,15 @@ public final void clear() {
     }
 
     @Override
-    public boolean contains(final BitMapProducer bitMapProducer) {
-        return contains(createFilter(bitMapProducer));
+    public boolean contains(final BitMapExtractor bitMapExtractor) {
+        return contains(createFilter(bitMapExtractor));
     }
 
     /**
      * Returns {@code true} if this any layer contained by this filter contains the
      * specified filter.
      * <p>
-     * If the {@code other} is a BloomFilterProducer each filter within the
+     * If the {@code other} is a BloomFilterExtractor each filter within the
      * {@code other} is checked to see if it exits within this filter.
      * </p>
      *
@@ -148,23 +148,23 @@ public boolean contains(final BitMapProducer bitMapProducer) {
      */
     @Override
     public boolean contains(final BloomFilter other) {
-        return other instanceof BloomFilterProducer ? contains((BloomFilterProducer) other)
-                : !forEachBloomFilter(x -> !x.contains(other));
+        return other instanceof BloomFilterExtractor ? contains((BloomFilterExtractor) other)
+                : !processBloomFilters(x -> !x.contains(other));
     }
 
     /**
-     * Returns {@code true} if each filter within the {@code producer} exits within
+     * Returns {@code true} if each filter within the {@code bloomFilterExtractor} exits within
      * this filter.
      *
-     * @param producer the BloomFilterProducer that provides the filters to check
+     * @param bloomFilterExtractor the BloomFilterExtractor that provides the filters to check
      *                 for.
      * @return {@code true} if this filter contains all of the filters contained in
-     *         the {@code producer}.
+     *         the {@code bloomFilterExtractor}.
      */
-    public boolean contains(final BloomFilterProducer producer) {
+    public boolean contains(final BloomFilterExtractor bloomFilterExtractor) {
         final boolean[] result = { true };
         // return false when we have found a match to short circuit checks
-        return producer.forEachBloomFilter(x -> {
+        return bloomFilterExtractor.processBloomFilters(x -> {
             result[0] &= contains(x);
             return result[0];
         });
@@ -176,8 +176,8 @@ public boolean contains(final Hasher hasher) {
     }
 
     @Override
-    public boolean contains(final IndexProducer indexProducer) {
-        return contains(createFilter(indexProducer));
+    public boolean contains(final IndexExtractor indexExtractor) {
+        return contains(createFilter(indexExtractor));
     }
 
     @Override
@@ -186,14 +186,14 @@ public LayeredBloomFilter<T> copy() {
     }
 
     /**
-     * Creates a Bloom filter from a BitMapProducer.
+     * Creates a Bloom filter from a BitMapExtractor.
      *
-     * @param bitMapProducer the BitMapProducer to create the filter from.
+     * @param bitMapExtractor the BitMapExtractor to create the filter from.
      * @return the BloomFilter.
      */
-    private BloomFilter createFilter(final BitMapProducer bitMapProducer) {
+    private BloomFilter createFilter(final BitMapExtractor bitMapExtractor) {
         final SimpleBloomFilter bf = new SimpleBloomFilter(shape);
-        bf.merge(bitMapProducer);
+        bf.merge(bitMapExtractor);
         return bf;
     }
 
@@ -210,14 +210,14 @@ private BloomFilter createFilter(final Hasher hasher) {
     }
 
     /**
-     * Creates a Bloom filter from an IndexProducer.
+     * Creates a Bloom filter from an IndexExtractor.
      *
-     * @param indexProducer the IndexProducer to create the filter from.
+     * @param indexExtractor the IndexExtractor to create the filter from.
      * @return the BloomFilter.
      */
-    private BloomFilter createFilter(final IndexProducer indexProducer) {
+    private BloomFilter createFilter(final IndexExtractor indexExtractor) {
         final SimpleBloomFilter bf = new SimpleBloomFilter(shape);
-        bf.merge(indexProducer);
+        bf.merge(indexExtractor);
         return bf;
     }
 
@@ -235,14 +235,14 @@ public int estimateUnion(final BloomFilter other) {
     }
 
     /**
-     * Finds the layers in which the BitMapProducer is found.
+     * Finds the layers in which the BitMapExtractor is found.
      *
-     * @param bitMapProducer the BitMapProducer to search for.
+     * @param bitMapExtractor the BitMapExtractor to search for.
      * @return an array of layer indices in which the Bloom filter is found.
      */
-    public int[] find(final BitMapProducer bitMapProducer) {
+    public int[] find(final BitMapExtractor bitMapExtractor) {
         final SimpleBloomFilter bf = new SimpleBloomFilter(shape);
-        bf.merge(bitMapProducer);
+        bf.merge(bitMapExtractor);
         return find(bf);
     }
 
@@ -254,7 +254,7 @@ public int[] find(final BitMapProducer bitMapProducer) {
      */
     public int[] find(final BloomFilter bf) {
         final Finder finder = new Finder(bf);
-        forEachBloomFilter(finder);
+        processBloomFilters(finder);
         return finder.getResult();
     }
 
@@ -271,14 +271,14 @@ public int[] find(final Hasher hasher) {
     }
 
     /**
-     * Finds the layers in which the IndexProducer is found.
+     * Finds the layers in which the IndexExtractor is found.
      *
-     * @param indexProducer the Index producer to search for.
+     * @param indexExtractor the Index extractor to search for.
      * @return an array of layer indices in which the Bloom filter is found.
      */
-    public int[] find(final IndexProducer indexProducer) {
+    public int[] find(final IndexExtractor indexExtractor) {
         final SimpleBloomFilter bf = new SimpleBloomFilter(shape);
-        bf.merge(indexProducer);
+        bf.merge(indexExtractor);
         return find(bf);
     }
 
@@ -291,13 +291,13 @@ public int[] find(final IndexProducer indexProducer) {
     @Override
     public BloomFilter flatten() {
         final BloomFilter bf = new SimpleBloomFilter(shape);
-        forEachBloomFilter(bf::merge);
+        processBloomFilters(bf::merge);
         return bf;
     }
 
     @Override
-    public boolean forEachBitMap(final LongPredicate predicate) {
-        return flatten().forEachBitMap(predicate);
+    public boolean processBitMaps(final LongPredicate predicate) {
+        return flatten().processBitMaps(predicate);
     }
 
     /**
@@ -310,13 +310,13 @@ public boolean forEachBitMap(final LongPredicate predicate) {
      *         otherwise.
      */
     @Override
-    public final boolean forEachBloomFilter(final Predicate<BloomFilter> bloomFilterPredicate) {
-        return layerManager.forEachBloomFilter(bloomFilterPredicate);
+    public final boolean processBloomFilters(final Predicate<BloomFilter> bloomFilterPredicate) {
+        return layerManager.processBloomFilters(bloomFilterPredicate);
     }
 
     @Override
-    public boolean forEachIndex(final IntPredicate predicate) {
-        return forEachBloomFilter(bf -> bf.forEachIndex(predicate));
+    public boolean processIndices(final IntPredicate predicate) {
+        return processBloomFilters(bf -> bf.processIndices(predicate));
     }
 
     /**
@@ -347,12 +347,12 @@ public final Shape getShape() {
 
     @Override
     public boolean isEmpty() {
-        return forEachBloomFilter(BloomFilter::isEmpty);
+        return processBloomFilters(BloomFilter::isEmpty);
     }
 
     @Override
-    public boolean merge(final BitMapProducer bitMapProducer) {
-        return layerManager.getTarget().merge(bitMapProducer);
+    public boolean merge(final BitMapExtractor bitMapExtractor) {
+        return layerManager.getTarget().merge(bitMapExtractor);
     }
 
     @Override
@@ -361,8 +361,8 @@ public boolean merge(final BloomFilter bf) {
     }
 
     @Override
-    public boolean merge(final IndexProducer indexProducer) {
-        return layerManager.getTarget().merge(indexProducer);
+    public boolean merge(final IndexExtractor indexExtractor) {
+        return layerManager.getTarget().merge(indexExtractor);
     }
 
     /**
@@ -376,4 +376,5 @@ public boolean merge(final IndexProducer indexProducer) {
     public void next() {
         layerManager.next();
     }
+
 }
diff --git a/src/main/java/org/apache/commons/collections4/bloomfilter/SetOperations.java b/src/main/java/org/apache/commons/collections4/bloomfilter/SetOperations.java
index 1cb57262df..54f4598fdc 100644
--- a/src/main/java/org/apache/commons/collections4/bloomfilter/SetOperations.java
+++ b/src/main/java/org/apache/commons/collections4/bloomfilter/SetOperations.java
@@ -19,7 +19,7 @@
 import java.util.function.LongBinaryOperator;
 
 /**
- * Implementations of set operations on BitMapProducers.
+ * Implementations of set operations on BitMapExtractors.
  *
  * @since 4.5
  */
@@ -27,23 +27,23 @@ public final class SetOperations {
 
     /**
      * Calculates the cardinality of the logical {@code AND} of the bit maps for the two filters.
-     * @param first the first BitMapProducer.
-     * @param second the second BitMapProducer
+     * @param first the first BitMapExtractor.
+     * @param second the second BitMapExtractor
      * @return the cardinality of the {@code AND} of the filters.
      */
-    public static int andCardinality(final BitMapProducer first, final BitMapProducer second) {
+    public static int andCardinality(final BitMapExtractor first, final BitMapExtractor second) {
         return cardinality(first, second, (x, y) -> x & y);
     }
 
     /**
-     * Calculates the cardinality of a BitMapProducer. By necessity this method will visit each bit map
-     * created by the producer.
-     * @param producer the Producer to calculate the cardinality for.
-     * @return the cardinality of the bit maps produced by the producer.
+     * Calculates the cardinality of a BitMapExtractor. By necessity this method will visit each bit map
+     * created by the bitMapExtractor.
+     * @param bitMapExtractor the extractor to calculate the cardinality for.
+     * @return the cardinality of the bit maps produced by the bitMapExtractor.
      */
-    public static int cardinality(final BitMapProducer producer) {
+    public static int cardinality(final BitMapExtractor bitMapExtractor) {
         final int[] cardinality = new int[1];
-        producer.forEachBitMap(l -> {
+        bitMapExtractor.processBitMaps(l -> {
             cardinality[0] += Long.bitCount(l);
             return true;
         });
@@ -52,16 +52,16 @@ public static int cardinality(final BitMapProducer producer) {
 
     /**
      * Calculates the cardinality of the result of a LongBinaryOperator using the
-     * {@code BitMapProducer.makePredicate} method.
-     * @param first the first BitMapProducer
-     * @param second the second BitMapProducer
-     * @param op a long binary operation on where x = {@code first} and y = {@code second} bitmap producers.
+     * {@code BitMapExtractor.makePredicate} method.
+     * @param first the first BitMapExtractor
+     * @param second the second BitMapExtractor
+     * @param op a long binary operation on where x = {@code first} and y = {@code second} bitmap extractors.
      * @return the calculated cardinality.
      */
-    private static int cardinality(final BitMapProducer first, final BitMapProducer second, final LongBinaryOperator op) {
+    private static int cardinality(final BitMapExtractor first, final BitMapExtractor second, final LongBinaryOperator op) {
         final int[] cardinality = new int[1];
 
-        first.forEachBitMapPair(second, (x, y) -> {
+        first.processBitMapPairs(second, (x, y) -> {
             cardinality[0] += Long.bitCount(op.applyAsLong(x, y));
             return true;
         });
@@ -69,30 +69,30 @@ private static int cardinality(final BitMapProducer first, final BitMapProducer
     }
 
     /**
-     * Calculates the Cosine distance between two BitMapProducer.
+     * Calculates the Cosine distance between two BitMapExtractor.
      *
      * <p>Cosine distance is defined as {@code 1 - Cosine similarity}</p>
      *
-     * @param first the first BitMapProducer.
-     * @param second the second BitMapProducer.
+     * @param first the first BitMapExtractor.
+     * @param second the second BitMapExtractor.
      * @return the jaccard distance.
      */
-    public static double cosineDistance(final BitMapProducer first, final BitMapProducer second) {
+    public static double cosineDistance(final BitMapExtractor first, final BitMapExtractor second) {
         return 1.0 - cosineSimilarity(first, second);
     }
 
     /**
-     * Calculates the Cosine similarity between two BitMapProducers.
+     * Calculates the Cosine similarity between two BitMapExtractors.
      * <p> Also known as Orchini similarity and the Tucker coefficient of congruence or
      * Ochiai similarity.</p>
      *
-     * <p>If either producer is empty the result is 0 (zero)</p>
+     * <p>If either extractor is empty the result is 0 (zero)</p>
      *
-     * @param first the first BitMapProducer.
-     * @param second the second BitMapProducer.
+     * @param first the first BitMapExtractor.
+     * @param second the second BitMapExtractor.
      * @return the Cosine similarity.
      */
-    public static double cosineSimilarity(final BitMapProducer first, final BitMapProducer second) {
+    public static double cosineSimilarity(final BitMapExtractor first, final BitMapExtractor second) {
         final int numerator = andCardinality(first, second);
         // Given that the cardinality is an int then the product as a double will not
         // overflow, we can use one sqrt:
@@ -120,41 +120,41 @@ public static double cosineSimilarity(final BloomFilter first, final BloomFilter
     }
 
     /**
-     * Calculates the Hamming distance between two BitMapProducers.
+     * Calculates the Hamming distance between two BitMapExtractors.
      *
-     * @param first the first BitMapProducer.
-     * @param second the second BitMapProducer.
+     * @param first the first BitMapExtractor.
+     * @param second the second BitMapExtractor.
      * @return the Hamming distance.
      */
-    public static int hammingDistance(final BitMapProducer first, final BitMapProducer second) {
+    public static int hammingDistance(final BitMapExtractor first, final BitMapExtractor second) {
         return xorCardinality(first, second);
     }
 
     /**
-     * Calculates the Jaccard distance between two BitMapProducer.
+     * Calculates the Jaccard distance between two BitMapExtractor.
      *
      * <p>Jaccard distance is defined as {@code 1 - Jaccard similarity}</p>
      *
-     * @param first the first BitMapProducer.
-     * @param second the second BitMapProducer.
+     * @param first the first BitMapExtractor.
+     * @param second the second BitMapExtractor.
      * @return the Jaccard distance.
      */
-    public static double jaccardDistance(final BitMapProducer first, final BitMapProducer second) {
+    public static double jaccardDistance(final BitMapExtractor first, final BitMapExtractor second) {
         return 1.0 - jaccardSimilarity(first, second);
     }
 
     /**
-     * Calculates the Jaccard similarity between two BitMapProducer.
+     * Calculates the Jaccard similarity between two BitMapExtractor.
      *
      * <p>Also known as Jaccard index, Intersection over Union, and Jaccard similarity coefficient</p>
      *
-     * @param first the first BitMapProducer.
-     * @param second the second BitMapProducer.
+     * @param first the first BitMapExtractor.
+     * @param second the second BitMapExtractor.
      * @return the Jaccard similarity.
      */
-    public static double jaccardSimilarity(final BitMapProducer first, final BitMapProducer second) {
+    public static double jaccardSimilarity(final BitMapExtractor first, final BitMapExtractor second) {
         final int[] cardinality = new int[2];
-        first.forEachBitMapPair(second, (x, y) -> {
+        first.processBitMapPairs(second, (x, y) -> {
             cardinality[0] += Long.bitCount(x & y);
             cardinality[1] += Long.bitCount(x | y);
             return true;
@@ -165,21 +165,21 @@ public static double jaccardSimilarity(final BitMapProducer first, final BitMapP
 
     /**
      * Calculates the cardinality of the logical {@code OR} of the bit maps for the two filters.
-     * @param first the first BitMapProducer.
-     * @param second the second BitMapProducer
+     * @param first the first BitMapExtractor.
+     * @param second the second BitMapExtractor
      * @return the cardinality of the {@code OR} of the filters.
      */
-    public static int orCardinality(final BitMapProducer first, final BitMapProducer second) {
+    public static int orCardinality(final BitMapExtractor first, final BitMapExtractor second) {
         return cardinality(first, second, (x, y) -> x | y);
     }
 
     /**
      * Calculates the cardinality of the logical {@code XOR} of the bit maps for the two filters.
-     * @param first the first BitMapProducer.
-     * @param second the second BitMapProducer
+     * @param first the first BitMapExtractor.
+     * @param second the second BitMapExtractor
      * @return the cardinality of the {@code XOR} of the filters.
      */
-    public static int xorCardinality(final BitMapProducer first, final BitMapProducer second) {
+    public static int xorCardinality(final BitMapExtractor first, final BitMapExtractor second) {
         return cardinality(first, second, (x, y) -> x ^ y);
     }
 
diff --git a/src/main/java/org/apache/commons/collections4/bloomfilter/Shape.java b/src/main/java/org/apache/commons/collections4/bloomfilter/Shape.java
index 8a184e7da9..2be155d8db 100644
--- a/src/main/java/org/apache/commons/collections4/bloomfilter/Shape.java
+++ b/src/main/java/org/apache/commons/collections4/bloomfilter/Shape.java
@@ -483,7 +483,7 @@ public boolean isSparse(final int cardinality) {
          * (number of indexes) is less than or equal to 2*number of bit maps the
          * cardinality is sparse within the shape.
          */
-        return cardinality <= BitMap.numberOfBitMaps(getNumberOfBits()) * 2;
+        return cardinality <= BitMaps.numberOfBitMaps(getNumberOfBits()) * 2;
     }
 
     @Override
diff --git a/src/main/java/org/apache/commons/collections4/bloomfilter/SimpleBloomFilter.java b/src/main/java/org/apache/commons/collections4/bloomfilter/SimpleBloomFilter.java
index 4cf672394a..c5f55405e4 100644
--- a/src/main/java/org/apache/commons/collections4/bloomfilter/SimpleBloomFilter.java
+++ b/src/main/java/org/apache/commons/collections4/bloomfilter/SimpleBloomFilter.java
@@ -51,7 +51,7 @@ public final class SimpleBloomFilter implements BloomFilter {
     public SimpleBloomFilter(final Shape shape) {
         Objects.requireNonNull(shape, "shape");
         this.shape = shape;
-        this.bitMap = new long[BitMap.numberOfBitMaps(shape.getNumberOfBits())];
+        this.bitMap = new long[BitMaps.numberOfBitMaps(shape.getNumberOfBits())];
         this.cardinality = 0;
     }
 
@@ -92,8 +92,8 @@ public void clear() {
     }
 
     @Override
-    public boolean contains(final IndexProducer indexProducer) {
-        return indexProducer.forEachIndex(idx -> BitMap.contains(bitMap, idx));
+    public boolean contains(final IndexExtractor indexExtractor) {
+        return indexExtractor.processIndices(idx -> BitMaps.contains(bitMap, idx));
     }
 
     @Override
@@ -102,7 +102,7 @@ public SimpleBloomFilter copy() {
     }
 
     @Override
-    public boolean forEachBitMap(final LongPredicate consumer) {
+    public boolean processBitMaps(final LongPredicate consumer) {
         Objects.requireNonNull(consumer, "consumer");
         for (final long l : bitMap) {
             if (!consumer.test(l)) {
@@ -113,15 +113,15 @@ public boolean forEachBitMap(final LongPredicate consumer) {
     }
 
     @Override
-    public boolean forEachBitMapPair(final BitMapProducer other, final LongBiPredicate func) {
+    public boolean processBitMapPairs(final BitMapExtractor other, final LongBiPredicate func) {
         final CountingLongPredicate p = new CountingLongPredicate(bitMap, func);
-        return other.forEachBitMap(p) && p.forEachRemaining();
+        return other.processBitMaps(p) && p.processRemaining();
     }
 
     @Override
-    public boolean forEachIndex(final IntPredicate consumer) {
+    public boolean processIndices(final IntPredicate consumer) {
         Objects.requireNonNull(consumer, "consumer");
-        return IndexProducer.fromBitMapProducer(this).forEachIndex(consumer);
+        return IndexExtractor.fromBitMapExtractor(this).processIndices(consumer);
     }
 
     @Override
@@ -131,33 +131,33 @@ public Shape getShape() {
 
     @Override
     public boolean isEmpty() {
-        return cardinality == 0 || forEachBitMap(y -> y == 0);
+        return cardinality == 0 || processBitMaps(y -> y == 0);
     }
 
     @Override
-    public boolean merge(final BitMapProducer bitMapProducer) {
-        Objects.requireNonNull(bitMapProducer, "bitMapProducer");
+    public boolean merge(final BitMapExtractor bitMapExtractor) {
+        Objects.requireNonNull(bitMapExtractor, "bitMapExtractor");
         try {
             final int[] idx = new int[1];
-            bitMapProducer.forEachBitMap(value -> {
+            bitMapExtractor.processBitMaps(value -> {
                 bitMap[idx[0]++] |= value;
                 return true;
             });
             // idx[0] will be limit+1 so decrement it
             idx[0]--;
-            final int idxLimit = BitMap.getLongIndex(shape.getNumberOfBits());
+            final int idxLimit = BitMaps.getLongIndex(shape.getNumberOfBits());
             if (idxLimit == idx[0]) {
                 final long excess = bitMap[idxLimit] >> shape.getNumberOfBits();
                 if (excess != 0) {
                     throw new IllegalArgumentException(
-                            String.format("BitMapProducer set a bit higher than the limit for the shape: %s",
+                            String.format("BitMapExtractor set a bit higher than the limit for the shape: %s",
                                     shape.getNumberOfBits()));
                 }
             }
             cardinality = -1;
         } catch (final IndexOutOfBoundsException e) {
             throw new IllegalArgumentException(
-                    String.format("BitMapProducer should send at most %s maps", bitMap.length), e);
+                    String.format("BitMapExtractor should send at most %s maps", bitMap.length), e);
         }
         return true;
     }
@@ -166,9 +166,9 @@ public boolean merge(final BitMapProducer bitMapProducer) {
     public boolean merge(final BloomFilter other) {
         Objects.requireNonNull(other, "other");
         if ((other.characteristics() & SPARSE) != 0) {
-            merge((IndexProducer) other);
+            merge((IndexExtractor) other);
         } else {
-            merge((BitMapProducer) other);
+            merge((BitMapExtractor) other);
         }
         return true;
     }
@@ -180,14 +180,14 @@ public boolean merge(final Hasher hasher) {
     }
 
     @Override
-    public boolean merge(final IndexProducer indexProducer) {
-        Objects.requireNonNull(indexProducer, "indexProducer");
-        indexProducer.forEachIndex(idx -> {
+    public boolean merge(final IndexExtractor indexExtractor) {
+        Objects.requireNonNull(indexExtractor, "indexExtractor");
+        indexExtractor.processIndices(idx -> {
             if (idx < 0 || idx >= shape.getNumberOfBits()) {
                 throw new IllegalArgumentException(String.format(
-                        "IndexProducer should only send values in the range[0,%s)", shape.getNumberOfBits()));
+                        "IndexExtractor should only send values in the range[0,%s)", shape.getNumberOfBits()));
             }
-            BitMap.set(bitMap, idx);
+            BitMaps.set(bitMap, idx);
             return true;
         });
         cardinality = -1;
diff --git a/src/main/java/org/apache/commons/collections4/bloomfilter/SparseBloomFilter.java b/src/main/java/org/apache/commons/collections4/bloomfilter/SparseBloomFilter.java
index 736a0412d2..6c0a3d1472 100644
--- a/src/main/java/org/apache/commons/collections4/bloomfilter/SparseBloomFilter.java
+++ b/src/main/java/org/apache/commons/collections4/bloomfilter/SparseBloomFilter.java
@@ -66,9 +66,9 @@ private boolean add(final int idx) {
 
     @Override
     public long[] asBitMapArray() {
-        final long[] result = new long[BitMap.numberOfBitMaps(shape.getNumberOfBits())];
+        final long[] result = new long[BitMaps.numberOfBitMaps(shape.getNumberOfBits())];
         for (final int i : indices) {
-            BitMap.set(result, i);
+            BitMaps.set(result, i);
         }
         return result;
     }
@@ -89,13 +89,13 @@ public void clear() {
     }
 
     @Override
-    public boolean contains(final BitMapProducer bitMapProducer) {
-        return contains(IndexProducer.fromBitMapProducer(bitMapProducer));
+    public boolean contains(final BitMapExtractor bitMapExtractor) {
+        return contains(IndexExtractor.fromBitMapExtractor(bitMapExtractor));
     }
 
     @Override
-    public boolean contains(final IndexProducer indexProducer) {
-        return indexProducer.forEachIndex(indices::contains);
+    public boolean contains(final IndexExtractor indexExtractor) {
+        return indexExtractor.processIndices(indices::contains);
     }
 
     @Override
@@ -104,9 +104,9 @@ public SparseBloomFilter copy() {
     }
 
     @Override
-    public boolean forEachBitMap(final LongPredicate consumer) {
+    public boolean processBitMaps(final LongPredicate consumer) {
         Objects.requireNonNull(consumer, "consumer");
-        final int limit = BitMap.numberOfBitMaps(shape.getNumberOfBits());
+        final int limit = BitMaps.numberOfBitMaps(shape.getNumberOfBits());
         /*
          * because our indices are always in order we can shorten the time necessary to
          * create the longs for the consumer
@@ -116,14 +116,14 @@ public boolean forEachBitMap(final LongPredicate consumer) {
         // the bitmap we are working on
         int idx = 0;
         for (final int i : indices) {
-            while (BitMap.getLongIndex(i) != idx) {
+            while (BitMaps.getLongIndex(i) != idx) {
                 if (!consumer.test(bitMap)) {
                     return false;
                 }
                 bitMap = 0;
                 idx++;
             }
-            bitMap |= BitMap.getLongBit(i);
+            bitMap |= BitMaps.getLongBit(i);
         }
         // we fall through with data in the bitMap
         if (!consumer.test(bitMap)) {
@@ -142,7 +142,7 @@ public boolean forEachBitMap(final LongPredicate consumer) {
     }
 
     @Override
-    public boolean forEachIndex(final IntPredicate consumer) {
+    public boolean processIndices(final IntPredicate consumer) {
         Objects.requireNonNull(consumer, "consumer");
         for (final int value : indices) {
             if (!consumer.test(value)) {
@@ -163,16 +163,16 @@ public boolean isEmpty() {
     }
 
     @Override
-    public boolean merge(final BitMapProducer bitMapProducer) {
-        Objects.requireNonNull(bitMapProducer, "bitMapProducer");
-        return this.merge(IndexProducer.fromBitMapProducer(bitMapProducer));
+    public boolean merge(final BitMapExtractor bitMapExtractor) {
+        Objects.requireNonNull(bitMapExtractor, "bitMapExtractor");
+        return this.merge(IndexExtractor.fromBitMapExtractor(bitMapExtractor));
     }
 
     @Override
     public boolean merge(final BloomFilter other) {
         Objects.requireNonNull(other, "other");
-        final IndexProducer producer = (other.characteristics() & SPARSE) != 0 ? (IndexProducer) other : IndexProducer.fromBitMapProducer(other);
-        merge(producer);
+        final IndexExtractor indexExtractor = (other.characteristics() & SPARSE) != 0 ? (IndexExtractor) other : IndexExtractor.fromBitMapExtractor(other);
+        merge(indexExtractor);
         return true;
     }
 
@@ -184,9 +184,9 @@ public boolean merge(final Hasher hasher) {
     }
 
     @Override
-    public boolean merge(final IndexProducer indexProducer) {
-        Objects.requireNonNull(indexProducer, "indexProducer");
-        indexProducer.forEachIndex(this::add);
+    public boolean merge(final IndexExtractor indexExtractor) {
+        Objects.requireNonNull(indexExtractor, "indexExtractor");
+        indexExtractor.processIndices(this::add);
         if (!this.indices.isEmpty()) {
             if (this.indices.last() >= shape.getNumberOfBits()) {
                 throw new IllegalArgumentException(String.format("Value in list %s is greater than maximum value (%s)",
diff --git a/src/main/java/org/apache/commons/collections4/bloomfilter/WrappedBloomFilter.java b/src/main/java/org/apache/commons/collections4/bloomfilter/WrappedBloomFilter.java
index 2a59fcf018..4e259d2a58 100644
--- a/src/main/java/org/apache/commons/collections4/bloomfilter/WrappedBloomFilter.java
+++ b/src/main/java/org/apache/commons/collections4/bloomfilter/WrappedBloomFilter.java
@@ -62,8 +62,8 @@ public void clear() {
     }
 
     @Override
-    public boolean contains(final BitMapProducer bitMapProducer) {
-        return wrapped.contains(bitMapProducer);
+    public boolean contains(final BitMapExtractor bitMapExtractor) {
+        return wrapped.contains(bitMapExtractor);
     }
 
     @Override
@@ -77,8 +77,8 @@ public boolean contains(final Hasher hasher) {
     }
 
     @Override
-    public boolean contains(final IndexProducer indexProducer) {
-        return wrapped.contains(indexProducer);
+    public boolean contains(final IndexExtractor indexExtractor) {
+        return wrapped.contains(indexExtractor);
     }
 
     @Override
@@ -97,18 +97,18 @@ public int estimateUnion(final BloomFilter other) {
     }
 
     @Override
-    public boolean forEachBitMap(final LongPredicate predicate) {
-        return wrapped.forEachBitMap(predicate);
+    public boolean processBitMaps(final LongPredicate predicate) {
+        return wrapped.processBitMaps(predicate);
     }
 
     @Override
-    public boolean forEachBitMapPair(final BitMapProducer other, final LongBiPredicate func) {
-        return wrapped.forEachBitMapPair(other, func);
+    public boolean processBitMapPairs(final BitMapExtractor other, final LongBiPredicate func) {
+        return wrapped.processBitMapPairs(other, func);
     }
 
     @Override
-    public boolean forEachIndex(final IntPredicate predicate) {
-        return wrapped.forEachIndex(predicate);
+    public boolean processIndices(final IntPredicate predicate) {
+        return wrapped.processIndices(predicate);
     }
 
     @Override
@@ -126,8 +126,8 @@ public boolean isFull() {
     }
 
     @Override
-    public boolean merge(final BitMapProducer bitMapProducer) {
-        return wrapped.merge(bitMapProducer);
+    public boolean merge(final BitMapExtractor bitMapExtractor) {
+        return wrapped.merge(bitMapExtractor);
     }
 
     @Override
@@ -141,7 +141,7 @@ public boolean merge(final Hasher hasher) {
     }
 
     @Override
-    public boolean merge(final IndexProducer indexProducer) {
-        return wrapped.merge(indexProducer);
+    public boolean merge(final IndexExtractor indexExtractor) {
+        return wrapped.merge(indexExtractor);
     }
 }
diff --git a/src/main/java/org/apache/commons/collections4/bloomfilter/package-info.java b/src/main/java/org/apache/commons/collections4/bloomfilter/package-info.java
index d2c4355930..ce3657ac39 100644
--- a/src/main/java/org/apache/commons/collections4/bloomfilter/package-info.java
+++ b/src/main/java/org/apache/commons/collections4/bloomfilter/package-info.java
@@ -21,7 +21,7 @@
  * <h2>Background:</h2>
  *
  * <p>The Bloom filter is a probabilistic data structure that indicates where things are not. Conceptually it is a bit
- * vector. You create a Bloom filter by creating hashes and converting those to enabled bits in the vector. Multiple
+ * vector or BitMap. You create a Bloom filter by creating hashes and converting those to enabled bits in the map. Multiple
  * Bloom filters may be merged together into one Bloom filter. It is possible to test if a filter {@code B} has merged
  * into another filter {@code A} by verifying that {@code (A & B) == B}.</p>
  *
@@ -41,12 +41,43 @@
  * {@code add}, and {@code subtract} may throw exceptions. Once an exception is thrown the state of the Bloom filter is unknown.
  * The choice to use not use atomic transactions was made to achieve maximum performance under correct usage.</p>
  *
- * <p>In addition the architecture is designed so that the implementation of the storage of bits is abstracted.
- * Programs that utilize the Bloom filters may use the {@code BitMapProducer} or {@code IndexProducer} to retrieve a
- * representation of the internal structure. Additional methods are available in the {@code BitMap} to assist in
- * manipulation of the representations.</p>
+ * <h4>Nomenclature</h4>
  *
- * <p>The Bloom filter code is an interface that requires implementation of 9 methods:</p>
+ * <ul>
+ *     <li>BitMap - In the bloomfilter package a BitMap is not a structure but a logical construct.  It is conceptualized
+ *     as an ordered collection of {@code long} values each of which is interpreted as the enabled true/false state of 64 continuous indices.  The mapping of
+ *     bits into the {@code long} values is described in the {@code BitMaps} javadoc.</li>
+ *
+ *     <li>Index - In the bloomfilter package an Index is a logical collection of {@code int}s specifying the enabled
+ *     bits in the BitMap.</li>
+ *
+ *     <li>Cell - Some Bloom filters (e.g. CountingBloomFilter) use counters rather than bits.  In the bloomfilter package
+ *     Cells are pairs of ints representing an index and a value.  They are not {@code Pair} objects.  </li>
+ *
+ *     <li>Extractor - The Extractors are {@code FunctionalInterfaces} that are conceptually iterators on a {@code BitMap}, an {@code Index}, or a
+ *     collection of {@code Cell}s, with an early termination switch.  Extractors have
+ *     names like {@code BitMapExtractor} or {@code IndexExtractor} and have a {@code processXs} methods that take a
+ *     {@code Predicate<X>} argument (e.g. {@code processBitMaps(LongPredicate)} or {@code processIndicies(IntPredicate)}).
+ *     That predicate is expected to process each of the Xs in turn and return {@code true} if the processing should continue
+ *     or {@code false} to stop it. </li>
+ * </ul>
+ *
+ * <p>There is an obvious association between the BitMap and the Index, as defined above, in that if bit 5 is enabled in the
+ * BitMap than the Index must contain the value 5.</p>
+ *
+ *
+ * <h4>Implementation Notes</h4>
+ *
+ * <p>The architecture is designed so that the implementation of the storage of bits is abstracted. Rather than specifying a
+ * specific state representation we require that all Bloom filters implement the BitMapExtractor and IndexExtractor interfaces,
+ * Counting-based Bloom filters implement {@code CellExtractor} as well.  There are static
+ * methods in the various Extractor interfaces to convert from one type to another.</p>
+ *
+ * <p>Programs that utilize the Bloom filters may use the {@code BitMapExtractor} or {@code IndexExtractor} to retrieve
+ * or process a representation of the internal structure.
+ * Additional methods are available in the {@code BitMaps} class to assist in manipulation of BitMap representations.</p>
+ *
+ * <p>The Bloom filter is an interface that requires implementation of 9 methods:</p>
  * <ul>
  * <li>{@link BloomFilter#cardinality()} returns the number of bits enabled in the Bloom filter.</li>
  *
@@ -54,17 +85,17 @@
  *
  * <li>{@link BloomFilter#clear()} which resets the Bloomfilter to its initial empty state.</li>
  *
- * <li>{@link BloomFilter#contains(IndexProducer)} which returns true if the bits specified by the indices generated by
- * IndexProducer are enabled in the Bloom filter.</li>
+ * <li>{@link BloomFilter#contains(IndexExtractor)} which returns true if the bits specified by the indices generated by
+ * IndexExtractor are enabled in the Bloom filter.</li>
  *
  * <li>{@link BloomFilter#copy()} which returns a fresh copy of the bitmap.</li>
  *
  * <li>{@link BloomFilter#getShape()} which returns the shape the Bloom filter was created with.</li>
  *
- * <li>{@link BloomFilter#merge(BitMapProducer)} which merges the BitMaps from the BitMapProducer into the internal
+ * <li>{@link BloomFilter#merge(BitMapExtractor)} which merges the BitMaps from the BitMapExtractor into the internal
  * representation of the Bloom filter.</li>
  *
- * <li>{@link BloomFilter#merge(IndexProducer)} which merges the indices from the IndexProducer into the internal
+ * <li>{@link BloomFilter#merge(IndexExtractor)} which merges the indices from the IndexExtractor into the internal
  * representation of the Bloom filter.</li>
  * </ul>
  *
@@ -83,7 +114,8 @@
  *
  * <h3>Shape</h3>
  *
- * <p>The Shape describes the Bloom filter using the number of bits and the number of hash functions</p>
+ * <p>The Shape describes the Bloom filter using the number of bits and the number of hash functions.  It can be specified
+ * by the number of expected items and desired false positive rate.</p>
  *
  * <h3>Hasher</h3>
  *
