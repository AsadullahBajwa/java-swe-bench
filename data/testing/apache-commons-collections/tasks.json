[ {
  "instance_id" : "apache-commons-collections-PR-665",
  "repo" : "apache/commons-collections",
  "base_commit" : "a60ee0c714939816cbb44833b11ea263a1defa23",
  "patch" : "diff --git a/src/main/java/org/apache/commons/collections4/MultiMapUtils.java b/src/main/java/org/apache/commons/collections4/MultiMapUtils.java\nindex ef7fc8c96c..c698a38e50 100644\n--- a/src/main/java/org/apache/commons/collections4/MultiMapUtils.java\n+++ b/src/main/java/org/apache/commons/collections4/MultiMapUtils.java\n@@ -20,6 +20,7 @@\n import java.util.Collection;\n import java.util.HashSet;\n import java.util.List;\n+import java.util.Map;\n import java.util.Set;\n \n import org.apache.commons.collections4.bag.HashBag;\n@@ -170,6 +171,27 @@ public static boolean isEmpty(final MultiValuedMap<?, ?> map) {\n         return map == null || map.isEmpty();\n     }\n \n+    /**\n+     * A utility method to invert the mappings from an input MultiValuedMap\n+     * and add them to an output MultiValuedMap. Use this method to have complete\n+     * control of the output MultiValuedMap or when merging several inverse mappings.\n+     * In simple cases, consider just using the {@link MultiValuedMap#inverted()} method.\n+     *\n+     * @param input take key-to-value mappings from here\n+     * @param output add value-to-key mappings here\n+     * @param <K> the output MultiValuedMap key type\n+     * @param <V> the output MultiValuedMap value type\n+     * @param <M> the output MultiValuedMap with key and value types reversed compared with input\n+     * @return the updated output MultiValuedMap\n+     */\n+    public static <K, V, M extends MultiValuedMap<K, V>>\n+    M invert(MultiValuedMap<? extends V, ? extends K> input, M output) {\n+        for (Map.Entry<? extends V, ? extends K> e : input.entries()) {\n+            output.put(e.getValue(), e.getKey());\n+        }\n+        return output;\n+    }\n+\n     /**\n      * Creates a {@link ListValuedMap} with an {@link java.util.ArrayList ArrayList} as\n      * collection class to store the values mapped to a key.\ndiff --git a/src/main/java/org/apache/commons/collections4/MultiValuedMap.java b/src/main/java/org/apache/commons/collections4/MultiValuedMap.java\nindex 96d2f6b086..350e74e7e1 100644\n--- a/src/main/java/org/apache/commons/collections4/MultiValuedMap.java\n+++ b/src/main/java/org/apache/commons/collections4/MultiValuedMap.java\n@@ -140,6 +140,17 @@ public interface MultiValuedMap<K, V> {\n      */\n     Collection<V> get(K key);\n \n+    /**\n+     * Returns a new MultiValuedMap with inverted mappings.\n+     * The new multimap will have a value-to-key mapping\n+     * for each key-to-value mapping in the original.\n+     *\n+     * @return a new MultiValuedMap with inverted mappings\n+     */\n+    default MultiValuedMap<V, K> inverted() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n     /**\n      * Returns {@code true} if this map contains no key-value mappings.\n      *\ndiff --git a/src/main/java/org/apache/commons/collections4/multimap/ArrayListValuedHashMap.java b/src/main/java/org/apache/commons/collections4/multimap/ArrayListValuedHashMap.java\nindex a9d2a11537..47586dc631 100644\n--- a/src/main/java/org/apache/commons/collections4/multimap/ArrayListValuedHashMap.java\n+++ b/src/main/java/org/apache/commons/collections4/multimap/ArrayListValuedHashMap.java\n@@ -25,6 +25,7 @@\n import java.util.HashMap;\n import java.util.Map;\n \n+import org.apache.commons.collections4.MultiMapUtils;\n import org.apache.commons.collections4.MultiValuedMap;\n \n /**\n@@ -118,6 +119,11 @@ protected ArrayList<V> createCollection() {\n         return new ArrayList<>(initialListCapacity);\n     }\n \n+    @Override\n+    public ArrayListValuedHashMap<V, K> inverted() {\n+        return MultiMapUtils.invert(this, new ArrayListValuedHashMap<V, K>());\n+    }\n+\n     /**\n      * Deserializes an instance from an ObjectInputStream.\n      *\ndiff --git a/src/main/java/org/apache/commons/collections4/multimap/ArrayListValuedLinkedHashMap.java b/src/main/java/org/apache/commons/collections4/multimap/ArrayListValuedLinkedHashMap.java\nindex f1b797b532..2556ab3f74 100644\n--- a/src/main/java/org/apache/commons/collections4/multimap/ArrayListValuedLinkedHashMap.java\n+++ b/src/main/java/org/apache/commons/collections4/multimap/ArrayListValuedLinkedHashMap.java\n@@ -25,6 +25,7 @@\n import java.util.LinkedHashMap;\n import java.util.Map;\n \n+import org.apache.commons.collections4.MultiMapUtils;\n import org.apache.commons.collections4.MultiValuedMap;\n \n /**\n@@ -118,6 +119,11 @@ protected ArrayList<V> createCollection() {\n         return new ArrayList<>(initialListCapacity);\n     }\n \n+    @Override\n+    public ArrayListValuedLinkedHashMap<V, K> inverted() {\n+        return MultiMapUtils.invert(this, new ArrayListValuedLinkedHashMap<>());\n+    }\n+\n     /**\n      * Deserializes an instance from an ObjectInputStream.\n      *\ndiff --git a/src/main/java/org/apache/commons/collections4/multimap/HashSetValuedHashMap.java b/src/main/java/org/apache/commons/collections4/multimap/HashSetValuedHashMap.java\nindex b122e2c410..184730cbfb 100644\n--- a/src/main/java/org/apache/commons/collections4/multimap/HashSetValuedHashMap.java\n+++ b/src/main/java/org/apache/commons/collections4/multimap/HashSetValuedHashMap.java\n@@ -24,6 +24,7 @@\n import java.util.HashSet;\n import java.util.Map;\n \n+import org.apache.commons.collections4.MultiMapUtils;\n import org.apache.commons.collections4.MultiValuedMap;\n \n /**\n@@ -117,6 +118,11 @@ protected HashSet<V> createCollection() {\n         return new HashSet<>(initialSetCapacity);\n     }\n \n+    @Override\n+    public HashSetValuedHashMap<V, K> inverted() {\n+        return MultiMapUtils.invert(this, new HashSetValuedHashMap<V, K>());\n+    }\n+\n     /**\n      * Deserializes an instance from an ObjectInputStream.\n      *\ndiff --git a/src/main/java/org/apache/commons/collections4/multimap/LinkedHashSetValuedLinkedHashMap.java b/src/main/java/org/apache/commons/collections4/multimap/LinkedHashSetValuedLinkedHashMap.java\nindex c8be8751dc..c381893b6a 100644\n--- a/src/main/java/org/apache/commons/collections4/multimap/LinkedHashSetValuedLinkedHashMap.java\n+++ b/src/main/java/org/apache/commons/collections4/multimap/LinkedHashSetValuedLinkedHashMap.java\n@@ -24,6 +24,7 @@\n import java.util.LinkedHashSet;\n import java.util.Map;\n \n+import org.apache.commons.collections4.MultiMapUtils;\n import org.apache.commons.collections4.MultiValuedMap;\n \n /**\n@@ -117,6 +118,11 @@ protected LinkedHashSet<V> createCollection() {\n         return new LinkedHashSet<>(initialSetCapacity);\n     }\n \n+    @Override\n+    public LinkedHashSetValuedLinkedHashMap<V, K> inverted() {\n+        return MultiMapUtils.invert(this, new LinkedHashSetValuedLinkedHashMap<V, K>());\n+    }\n+\n     /**\n      * Deserializes an instance from an ObjectInputStream.\n      *\n",
  "test_patch" : "diff --git a/src/test/java/org/apache/commons/collections4/MultiMapUtilsTest.java b/src/test/java/org/apache/commons/collections4/MultiMapUtilsTest.java\nindex 14f177f2b4..7ff98ba078 100644\n--- a/src/test/java/org/apache/commons/collections4/MultiMapUtilsTest.java\n+++ b/src/test/java/org/apache/commons/collections4/MultiMapUtilsTest.java\n@@ -29,6 +29,8 @@\n import java.util.Set;\n \n import org.apache.commons.collections4.multimap.ArrayListValuedHashMap;\n+import org.apache.commons.collections4.multimap.HashSetValuedHashMap;\n+import org.apache.commons.collections4.multimap.LinkedHashSetValuedLinkedHashMap;\n import org.junit.jupiter.api.Test;\n \n /**\n@@ -116,6 +118,30 @@ void testGetValuesAsSet() {\n         assertEquals(new HashSet<>(Arrays.asList(values)), set);\n     }\n \n+    @Test\n+    void testInvert() {\n+        final HashSetValuedHashMap<String, String> usages = new HashSetValuedHashMap<>();\n+\n+        final LinkedHashSetValuedLinkedHashMap<String, String> deps = new LinkedHashSetValuedLinkedHashMap<>();\n+        deps.put(\"commons-configuration2\", \"commons-logging\");\n+        deps.put(\"commons-configuration2\", \"commons-lang3\");\n+        deps.put(\"commons-configuration2\", \"commons-text\");\n+        deps.put(\"commons-beanutils\", \"commons-collections\");\n+        deps.put(\"commons-beanutils\", \"commons-logging\");\n+        MultiMapUtils.invert(deps, usages);\n+        final Set<String> loggingUsagesCompile = usages.get(\"commons-logging\");\n+        assertEquals(\"[commons-configuration2, commons-beanutils]\", loggingUsagesCompile.toString());\n+        final Set<String> codecUsagesCompile = usages.get(\"commons-codec\");\n+        assertEquals(\"[]\", codecUsagesCompile.toString());\n+\n+        final LinkedHashSetValuedLinkedHashMap<String, String> optionalDeps = new LinkedHashSetValuedLinkedHashMap<>();\n+        optionalDeps.put(\"commons-configuration2\", \"commons-codec\");\n+        optionalDeps.put(\"commons-collections\", \"commons-codec\");\n+        MultiMapUtils.invert(optionalDeps, usages);\n+        final Set<String> codecUsagesAll = usages.get(\"commons-codec\");\n+        assertEquals(\"[commons-collections, commons-configuration2]\", codecUsagesAll.toString());\n+    }\n+\n     @Test\n     void testIsEmptyWithEmptyMap() {\n         assertTrue(MultiMapUtils.isEmpty(new ArrayListValuedHashMap<>()));\ndiff --git a/src/test/java/org/apache/commons/collections4/multimap/ArrayListValuedHashMapTest.java b/src/test/java/org/apache/commons/collections4/multimap/ArrayListValuedHashMapTest.java\nindex 47e9a63e60..f65ee297c0 100644\n--- a/src/test/java/org/apache/commons/collections4/multimap/ArrayListValuedHashMapTest.java\n+++ b/src/test/java/org/apache/commons/collections4/multimap/ArrayListValuedHashMapTest.java\n@@ -93,6 +93,19 @@ void testEqualsHashCodeContract() {\n         assertNotSame(map1.hashCode(), map2.hashCode());\n     }\n \n+    @Test\n+    void testInverted() {\n+        final ArrayListValuedHashMap<String, String> shopping = new ArrayListValuedHashMap<>(4);\n+        shopping.put(\"Alice\", \"Bread\");\n+        shopping.put(\"Alice\", \"Milk\");\n+        shopping.put(\"Alice\", \"Milk\");\n+        shopping.put(\"Bob\", \"Pizza\");\n+        shopping.put(\"Bob\", \"Bread\");\n+        shopping.put(\"Bob\", \"Bread\");\n+        assertEquals(\"{Pizza=[Bob], Bread=[Bob, Bob, Alice], Milk=[Alice, Alice]}\",\n+                shopping.inverted().toString());\n+    }\n+\n     @Test\n     @SuppressWarnings(\"unchecked\")\n     void testListValuedMapAdd() {\ndiff --git a/src/test/java/org/apache/commons/collections4/multimap/ArrayListValuedLinkedHashMapTest.java b/src/test/java/org/apache/commons/collections4/multimap/ArrayListValuedLinkedHashMapTest.java\nindex 74353b50ab..550a192409 100644\n--- a/src/test/java/org/apache/commons/collections4/multimap/ArrayListValuedLinkedHashMapTest.java\n+++ b/src/test/java/org/apache/commons/collections4/multimap/ArrayListValuedLinkedHashMapTest.java\n@@ -99,6 +99,19 @@ void testEqualsHashCodeContract() {\n         assertNotSame(map1.hashCode(), map2.hashCode());\n     }\n \n+    @Test\n+    void testInverted() {\n+        final ArrayListValuedLinkedHashMap<String, String> shopping = new ArrayListValuedLinkedHashMap<>(4);\n+        shopping.put(\"Alice\", \"Bread\");\n+        shopping.put(\"Alice\", \"Milk\");\n+        shopping.put(\"Alice\", \"Milk\");\n+        shopping.put(\"Bob\", \"Pizza\");\n+        shopping.put(\"Bob\", \"Bread\");\n+        shopping.put(\"Bob\", \"Bread\");\n+        assertEquals(\"{Bread=[Alice, Bob, Bob], Milk=[Alice, Alice], Pizza=[Bob]}\",\n+                shopping.inverted().toString());\n+    }\n+\n     @Test\n     @SuppressWarnings(\"unchecked\")\n     void testListValuedMapAdd() {\ndiff --git a/src/test/java/org/apache/commons/collections4/multimap/HashSetValuedHashMapTest.java b/src/test/java/org/apache/commons/collections4/multimap/HashSetValuedHashMapTest.java\nindex 7b50d6cd13..419ae3814f 100644\n--- a/src/test/java/org/apache/commons/collections4/multimap/HashSetValuedHashMapTest.java\n+++ b/src/test/java/org/apache/commons/collections4/multimap/HashSetValuedHashMapTest.java\n@@ -110,6 +110,19 @@ void testHashSetValueHashMap_1() {\n         assertEquals(\"{}\", map3.toString());\n     }\n \n+    @Test\n+    void testInverted() {\n+        final HashSetValuedHashMap<String, String> dependencies = new HashSetValuedHashMap<>();\n+        dependencies.put(\"commons-configuration2\", \"commons-logging\");\n+        dependencies.put(\"commons-configuration2\", \"commons-lang3\");\n+        dependencies.put(\"commons-configuration2\", \"commons-text\");\n+        dependencies.put(\"commons-beanutils\", \"commons-collections\");\n+        dependencies.put(\"commons-beanutils\", \"commons-logging\");\n+        final Set<String> loggingUsages = dependencies.inverted().get(\"commons-logging\");\n+        assertEquals(\"[commons-beanutils, commons-configuration2]\",\n+                loggingUsages.toString());\n+    }\n+\n     @Test\n     @SuppressWarnings(\"unchecked\")\n     void testSetValuedMapAdd() {\ndiff --git a/src/test/java/org/apache/commons/collections4/multimap/LinkedHashSetValuedLinkedHashMapTest.java b/src/test/java/org/apache/commons/collections4/multimap/LinkedHashSetValuedLinkedHashMapTest.java\nindex 2b37cb76d2..561432363b 100644\n--- a/src/test/java/org/apache/commons/collections4/multimap/LinkedHashSetValuedLinkedHashMapTest.java\n+++ b/src/test/java/org/apache/commons/collections4/multimap/LinkedHashSetValuedLinkedHashMapTest.java\n@@ -96,6 +96,19 @@ void testHashSetValueHashMap_1() {\n         assertEquals(\"{}\", map3.toString());\n     }\n \n+    @Test\n+    void testInverted() {\n+        final LinkedHashSetValuedLinkedHashMap<String, String> citiesLived = new LinkedHashSetValuedLinkedHashMap<>(4);\n+        citiesLived.put(\"Alice\", \"N.Y.\");\n+        citiesLived.put(\"Alice\", \"L.A.\");\n+        citiesLived.put(\"Alice\", \"Chicago\");\n+        citiesLived.put(\"Bob\", \"N.Y.\");\n+        citiesLived.put(\"Cara\", \"L.A.\");\n+        citiesLived.put(\"Cara\", \"Chicago\");\n+        assertEquals(\"{N.Y.=[Alice, Bob], L.A.=[Alice, Cara], Chicago=[Alice, Cara]}\",\n+                citiesLived.inverted().toString());\n+    }\n+\n     @Test\n     void testLinkedHashSetValuedLinkedHashMap_2() {\n         final Map<K, V> map = new HashMap<>();\ndiff --git a/src/test/java/org/apache/commons/collections4/multimap/TransformedMultiValuedMapTest.java b/src/test/java/org/apache/commons/collections4/multimap/TransformedMultiValuedMapTest.java\nindex 37ef87d8f0..d83b47108a 100644\n--- a/src/test/java/org/apache/commons/collections4/multimap/TransformedMultiValuedMapTest.java\n+++ b/src/test/java/org/apache/commons/collections4/multimap/TransformedMultiValuedMapTest.java\n@@ -19,6 +19,7 @@\n import static org.junit.jupiter.api.Assertions.assertEquals;\n import static org.junit.jupiter.api.Assertions.assertFalse;\n import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n import static org.junit.jupiter.api.Assertions.assertTrue;\n \n import java.util.Collection;\n@@ -99,6 +100,11 @@ void testFactory_decorateTransform() {\n         assertTrue(transMap.get((K) \"D\").contains(Integer.valueOf(4)));\n     }\n \n+    @Test\n+    void testInvertedIsUnsupportedByDefault() {\n+        assertThrows(UnsupportedOperationException.class, () -> makeObject().inverted());\n+    }\n+\n     @Test\n     @SuppressWarnings(\"unchecked\")\n     void testKeyTransformedMap() {\n",
  "problem_statement" : "Add MultiValuedMap.inverted()\n\nThis PR adds an inverse method into the following multimap implementations:\r\n\r\n`ArrayListValuedHashMap`\r\n`ArrayListValuedLinkedHashMap`\r\n`HashSetValuedHashMap`\r\n`HashSetValuedLinkedHashMap`\r\n\r\nThere is also an `inverseInto` method added to `MultiMapUtils` to handle the case of a heterogenous collector.\r\n\r\nAs well as a test case to the relevant source files. Decorated multimaps throw `UnsupportedOperationException` by default. ",
  "hints_text" : null,
  "created_at" : "Fri Dec 12 12:29:15 CET 2025",
  "version" : null,
  "FAIL_TO_PASS" : [ "ArrayListValuedLinkedHashMapTest", "LinkedHashSetValuedLinkedHashMapTest", "HashSetValuedHashMapTest", "ArrayListValuedHashMapTest", "TransformedMultiValuedMapTest", "MultiMapUtilsTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=ArrayListValuedLinkedHashMapTest,LinkedHashSetValuedLinkedHashMapTest,HashSetValuedHashMapTest,ArrayListValuedHashMapTest,TransformedMultiValuedMapTest,MultiMapUtilsTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 665,
  "metadata" : null
}, {
  "instance_id" : "apache-commons-collections-PR-633",
  "repo" : "apache/commons-collections",
  "base_commit" : "d8c59cdbc79d41b1309720d745a39735b334ae86",
  "patch" : "diff --git a/src/changes/changes.xml b/src/changes/changes.xml\nindex 1f59bf07eb..e90b8015ed 100644\n--- a/src/changes/changes.xml\n+++ b/src/changes/changes.xml\n@@ -32,6 +32,7 @@\n     <action type=\"fix\" dev=\"ggregory\" due-to=\"Sebastian Götz, Gary Gregory\" issue=\"COLLECTIONS-874\">MapUtils.getLongValue(Map, K, Function) returns a byte instead of a long.</action>\n     <action type=\"fix\" dev=\"ggregory\" due-to=\"Gary Gregory\">Fix exception message in org.apache.commons.collections4.functors.FunctorUtils.validate(Consumer...)</action>\n     <action type=\"fix\" dev=\"ggregory\" due-to=\"Gary Gregory\">Fix exception message in org.apache.commons.collections4.iterators.UnmodifiableIterator.remove() to match java.util.Iterator.remove().</action>\n+    <action type=\"fix\" dev=\"pkarwasz\" due-to=\"Piotr P. Karwasz, Joerg Budischewski\" issue=\"COLLECTIONS-838\">Calling SetUtils.union on multiple instances of SetView causes JVM to hang</action>\n     <!-- ADD -->\n     <action type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory\">Add generics to UnmodifiableIterator for the wrapped type.</action>\n     <!-- UPDATE -->\ndiff --git a/src/main/java/org/apache/commons/collections4/iterators/IteratorChain.java b/src/main/java/org/apache/commons/collections4/iterators/IteratorChain.java\nindex 7c69f3f749..97373b13cd 100644\n--- a/src/main/java/org/apache/commons/collections4/iterators/IteratorChain.java\n+++ b/src/main/java/org/apache/commons/collections4/iterators/IteratorChain.java\n@@ -63,7 +63,7 @@ public class IteratorChain<E> implements Iterator<E> {\n     private Iterator<? extends E> currentIterator;\n \n     /**\n-     * The \"last used\" Iterator is the Iterator upon which next() or hasNext()\n+     * The \"last used\" Iterator is the Iterator upon which next()\n      * was most recently called used for the remove() operation only\n      */\n     private Iterator<? extends E> lastUsedIterator;\n@@ -74,6 +74,11 @@ public class IteratorChain<E> implements Iterator<E> {\n      */\n     private boolean isLocked;\n \n+    /**\n+     * Contains the result of the last hasNext() call until next() is invoked\n+     */\n+    private Boolean cachedHasNextValue;\n+\n     /**\n      * Constructs an IteratorChain with no Iterators.\n      * <p>\n@@ -183,9 +188,10 @@ private void checkLocked() {\n     @Override\n     public boolean hasNext() {\n         lockChain();\n-        updateCurrentIterator();\n-        lastUsedIterator = currentIterator;\n-        return currentIterator.hasNext();\n+        if (cachedHasNextValue == null) {\n+            updateCurrentIterator();\n+        }\n+        return cachedHasNextValue;\n     }\n \n     /**\n@@ -219,9 +225,11 @@ private void lockChain() {\n     @Override\n     public E next() {\n         lockChain();\n-        updateCurrentIterator();\n+        if (cachedHasNextValue == null) {\n+            updateCurrentIterator();\n+        }\n         lastUsedIterator = currentIterator;\n-\n+        cachedHasNextValue = null;\n         return currentIterator.next();\n     }\n \n@@ -241,10 +249,11 @@ public E next() {\n     @Override\n     public void remove() {\n         lockChain();\n-        if (currentIterator == null) {\n-            updateCurrentIterator();\n+        if (lastUsedIterator == null)  {\n+            throw new IllegalStateException(\"remove() has been invoked without next()\");\n         }\n         lastUsedIterator.remove();\n+        lastUsedIterator = null;  // must never be used twice without next() being invoked\n     }\n \n     /**\n@@ -267,13 +276,16 @@ protected void updateCurrentIterator() {\n             } else {\n                 currentIterator = iteratorQueue.remove();\n             }\n-            // set last used iterator here, in case the user calls remove\n-            // before calling hasNext() or next() (although they shouldn't)\n-            lastUsedIterator = currentIterator;\n         }\n-        while (!currentIterator.hasNext() && !iteratorQueue.isEmpty()) {\n+        while (true) {\n+            cachedHasNextValue = currentIterator.hasNext();\n+            if (cachedHasNextValue) {\n+                break;\n+            }\n+            if (iteratorQueue.isEmpty()) {\n+                break;\n+            }\n             currentIterator = iteratorQueue.remove();\n         }\n     }\n-\n }\n",
  "test_patch" : "diff --git a/src/test/java/org/apache/commons/collections4/SetUtilsTest.java b/src/test/java/org/apache/commons/collections4/SetUtilsTest.java\nindex ffb7bc3a18..27a0965f78 100644\n--- a/src/test/java/org/apache/commons/collections4/SetUtilsTest.java\n+++ b/src/test/java/org/apache/commons/collections4/SetUtilsTest.java\n@@ -23,17 +23,22 @@\n import static org.junit.jupiter.api.Assertions.assertNull;\n import static org.junit.jupiter.api.Assertions.assertSame;\n import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTimeoutPreemptively;\n import static org.junit.jupiter.api.Assertions.assertTrue;\n \n+import java.time.Duration;\n import java.util.Arrays;\n import java.util.Collection;\n import java.util.HashSet;\n+import java.util.Iterator;\n import java.util.Set;\n \n import org.apache.commons.collections4.SetUtils.SetView;\n import org.apache.commons.collections4.set.PredicatedSet;\n import org.junit.jupiter.api.BeforeEach;\n import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n \n /**\n  * Tests for SetUtils.\n@@ -218,6 +223,31 @@ void testUnion() {\n         assertThrows(NullPointerException.class, () -> SetUtils.union(null, setA));\n     }\n \n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    void testReverseNestedUnionPerfomWell(final boolean mergeLeft) {\n+        Set<Integer> set = SetUtils.union(setA, setB);\n+        for (int i = 0; i < 128; i++) {\n+            if (mergeLeft) {\n+                set = SetUtils.union(setB, set);\n+            } else {\n+                set = SetUtils.union(set, setB);\n+            }\n+        }\n+        final Set<Integer> combinedSet = set;\n+        assertTimeoutPreemptively(Duration.ofSeconds(1), () -> {\n+                assertEquals(7, combinedSet.size());\n+                assertTrue(combinedSet.containsAll(setA));\n+                assertTrue(combinedSet.containsAll(setB));\n+\n+                final Iterator<Integer> iterator = combinedSet.iterator();\n+                while (iterator.hasNext()) { // without the IteratorChain hasNext() caching, this would run hours\n+                    iterator.next();\n+                }\n+                assertFalse(iterator.hasNext());\n+            });\n+    }\n+\n     @Test\n     void testUnmodifiableSet() {\n         final Set<?> set1 = SetUtils.unmodifiableSet();\ndiff --git a/src/test/java/org/apache/commons/collections4/iterators/IteratorChainTest.java b/src/test/java/org/apache/commons/collections4/iterators/IteratorChainTest.java\nindex a452118533..f1cff577f2 100644\n--- a/src/test/java/org/apache/commons/collections4/iterators/IteratorChainTest.java\n+++ b/src/test/java/org/apache/commons/collections4/iterators/IteratorChainTest.java\n@@ -19,9 +19,12 @@\n import static org.junit.jupiter.api.Assertions.assertEquals;\n import static org.junit.jupiter.api.Assertions.assertFalse;\n import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTimeoutPreemptively;\n import static org.junit.jupiter.api.Assertions.assertTrue;\n \n+import java.time.Duration;\n import java.util.ArrayList;\n+import java.util.Arrays;\n import java.util.Iterator;\n import java.util.List;\n import java.util.NoSuchElementException;\n@@ -126,8 +129,10 @@ void testFirstIteratorIsEmptyBug() {\n         assertTrue(chain.hasNext(), \"should have next\");\n         assertEquals(\"B\", chain.next());\n         assertTrue(chain.hasNext(), \"should have next\");\n+        assertTrue(chain.hasNext(), \"should not change\");\n         assertEquals(\"C\", chain.next());\n         assertFalse(chain.hasNext(), \"should not have next\");\n+        assertFalse(chain.hasNext(), \"should not change\");\n     }\n \n     @Test\n@@ -146,6 +151,9 @@ void testIterator() {\n     public void testRemove() {\n         final Iterator<String> iter = makeObject();\n         assertThrows(IllegalStateException.class, () -> iter.remove(), \"Calling remove before the first call to next() should throw an exception\");\n+        assertTrue(iter.hasNext(), \"initial has next should be true\");\n+        assertThrows(IllegalStateException.class, () -> iter.remove(), \"Calling remove before the first call to next() should throw an exception\");\n+\n         for (final String testValue : testArray) {\n             final String iterValue = iter.next();\n             assertEquals(testValue, iterValue, \"Iteration value is correct\");\n@@ -158,6 +166,78 @@ public void testRemove() {\n         assertTrue(list3.isEmpty(), \"List is empty\");\n     }\n \n+    @Test\n+    public void testRemoveDoubleCallShouldFail() {\n+        final Iterator<String> iter = makeObject();\n+        assertEquals(iter.next(), \"One\");\n+        iter.remove();\n+        assertThrows(IllegalStateException.class, () -> iter.remove());\n+    }\n+\n+    @Test\n+    public void testHasNextIsInvokedOnEdgeBeforeRemove() {\n+        final Iterator<String> iter = makeObject();\n+        assertEquals(iter.next(), \"One\");\n+        assertEquals(iter.next(), \"Two\");\n+        assertEquals(iter.next(), \"Three\");\n+        assertTrue(iter.hasNext(), \"next elements exists\");\n+        iter.remove();  // though hasNext() on next iterator has been invoked, removing an element on old iterator must still work\n+        assertTrue(iter.hasNext(), \"next elements exists\");\n+        assertEquals(iter.next(), \"Four\");\n+\n+        assertEquals(list1, Arrays.asList(\"One\", \"Two\")); // Three must be gone\n+        assertEquals(list2, Arrays.asList(\"Four\")); // Four still be there\n+        assertEquals(list3, Arrays.asList(\"Five\", \"Six\")); // Five+Six anyway\n+    }\n+\n+    @Test\n+    public void testChainingPerformsWell() {\n+        Iterator<String> iter = makeObject();\n+        for (int i = 0; i < 150; i++) {\n+            final IteratorChain<String> chain = new IteratorChain<>();\n+            chain.addIterator(iter);\n+            iter = chain;\n+        }\n+        final Iterator<String> iterFinal = iter;\n+        assertTimeoutPreemptively(Duration.ofSeconds(1), () -> {\n+                for (final String testValue : testArray) {\n+                    final String iterValue = iterFinal.next();\n+                    assertEquals(testValue, iterValue, \"Iteration value is correct\");\n+                    if (!iterValue.equals(\"Four\")) {\n+                        iterFinal.remove();\n+                    }\n+                }\n+                assertFalse(iterFinal.hasNext(), \"all values got iterated\");\n+                assertTrue(list1.isEmpty(), \"List is empty\");\n+                assertEquals(1, list2.size(), \"List is empty\");\n+                assertTrue(list3.isEmpty(), \"List is empty\");\n+            });\n+    }\n+\n+    @Test\n+    public void testChaining() {\n+        IteratorChain<String> chain = new IteratorChain<>();\n+        chain.addIterator(list1.iterator());\n+        chain = new IteratorChain<>(chain);\n+        chain.addIterator(list2.iterator());\n+        chain = new IteratorChain<>(chain);\n+        chain.addIterator(list3.iterator());\n+\n+        for (final String testValue : testArray) {\n+            assertTrue(chain.hasNext(), \"chain contains values\");\n+            assertTrue(chain.hasNext(), \"hasNext doesn't change on 2nd invocation\");\n+            final String iterValue = chain.next();\n+            assertEquals(testValue, iterValue, \"Iteration value is correct\");\n+            if (!iterValue.equals(\"Four\")) {\n+                chain.remove();\n+            }\n+        }\n+        assertFalse(chain.hasNext(), \"all values got iterated\");\n+        assertTrue(list1.isEmpty(), \"List is empty\");\n+        assertEquals(1, list2.size(), \"List is empty\");\n+        assertTrue(list3.isEmpty(), \"List is empty\");\n+    }\n+\n     @Test\n     void testRemoveFromFilteredIterator() {\n \n",
  "problem_statement" : "[collections-838] hasNext() value is now cached till next() or remove…\n\n…() get invoked, thus reducing call load on hasNext() drastically  in nested chained iterator scenarios.\r\n\r\nBefore this change, the call-load on hasNext() grew exponentially with the number of nested IteratorChains.\r\n@ppkarwasz: I think, the fix is indeed this easy, please check. It raises the question, if the fix for collections-722 is even needed anymore ... (the discussion in parallel on  PR 628). \r\n\r\n<!--\r\n  Licensed to the Apache Software Foundation (ASF) under one\r\n  or more contributor license agreements.  See the NOTICE file\r\n  distributed with this work for additional information\r\n  regarding copyright ownership.  The ASF licenses this file\r\n  to you under the Apache License, Version 2.0 (the\r\n  \"License\"); you may not use this file except in compliance\r\n  with the License.  You may obtain a copy of the License at\r\n\r\n    https://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing,\r\n  software distributed under the License is distributed on an\r\n  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n  KIND, either express or implied.  See the License for the\r\n  specific language governing permissions and limitations\r\n  under the License.\r\n-->\r\n\r\nThanks for your contribution to [Apache Commons](https://commons.apache.org/)! Your help is appreciated!\r\n\r\nBefore you push a pull request, review this list:\r\n\r\n- [x] Read the [contribution guidelines](CONTRIBUTING.md) for this project.\r\n- [-] Read the [ASF Generative Tooling Guidance](https://www.apache.org/legal/generative-tooling.html) if you use Artificial Intelligence (AI).\r\n- [-] I used AI to create any part of, or all of, this pull request.\r\n- [x] Run a successful build using the default [Maven](https://maven.apache.org/) goal with `mvn`; that's `mvn` on the command line by itself.\r\n- [x] Write unit tests that match behavioral changes, where the tests fail if the changes to the runtime are not applied. This may not always be possible, but it is a best-practice.\r\n- [x] Write a pull request description that is detailed enough to understand what the pull request does, how, and why.\r\n- [x] Each commit in the pull request should have a meaningful subject line and body. Note that a maintainer may squash commits during the merge process.\r\n",
  "hints_text" : null,
  "created_at" : "Sun Aug 10 01:31:56 CEST 2025",
  "version" : null,
  "FAIL_TO_PASS" : [ "SetUtilsTest", "IteratorChainTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=SetUtilsTest,IteratorChainTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 633,
  "metadata" : null
}, {
  "instance_id" : "apache-commons-collections-PR-628",
  "repo" : "apache/commons-collections",
  "base_commit" : "ec38f6fa7f867000eed81791c3078b327a451d89",
  "patch" : "diff --git a/src/changes/changes.xml b/src/changes/changes.xml\nindex 70ef6bb2e8..42830e30ac 100644\n--- a/src/changes/changes.xml\n+++ b/src/changes/changes.xml\n@@ -33,6 +33,7 @@\n     <action type=\"fix\" dev=\"ggregory\" due-to=\"Gary Gregory\">Fix exception message in org.apache.commons.collections4.functors.FunctorUtils.validate(Consumer...)</action>\n     <action type=\"fix\" dev=\"ggregory\" due-to=\"Gary Gregory\">Fix exception message in org.apache.commons.collections4.iterators.UnmodifiableIterator.remove() to match java.util.Iterator.remove().</action>\n     <action type=\"fix\" dev=\"pkarwasz\" due-to=\"Piotr P. Karwasz, Joerg Budischewski\" issue=\"COLLECTIONS-838\">Calling SetUtils.union on multiple instances of SetView causes JVM to hang</action>\n+    <action type=\"fix\" dev=\"pkarwasz\" due-to=\"Piotr P. Karwasz, Joerg Budischewski\" issue=\"COLLECTIONS-722\">Improve IteratorUtils.chainedIterator() performance.</action>\n     <!-- ADD -->\n     <action type=\"add\" dev=\"ggregory\" due-to=\"Gary Gregory\">Add generics to UnmodifiableIterator for the wrapped type.</action>\n     <!-- UPDATE -->\ndiff --git a/src/main/java/org/apache/commons/collections4/iterators/IteratorChain.java b/src/main/java/org/apache/commons/collections4/iterators/IteratorChain.java\nindex 97373b13cd..433f60d46b 100644\n--- a/src/main/java/org/apache/commons/collections4/iterators/IteratorChain.java\n+++ b/src/main/java/org/apache/commons/collections4/iterators/IteratorChain.java\n@@ -168,7 +168,29 @@ public IteratorChain(final Iterator<? extends E> first, final Iterator<? extends\n      */\n     public void addIterator(final Iterator<? extends E> iterator) {\n         checkLocked();\n-        iteratorQueue.add(Objects.requireNonNull(iterator, \"iterator\"));\n+        Objects.requireNonNull(iterator, \"iterator\");\n+        if (iterator instanceof UnmodifiableIterator) {\n+            final Iterator<? extends E> underlyingIterator = ((UnmodifiableIterator) iterator).unwrap();\n+            if (underlyingIterator instanceof IteratorChain) {\n+                // in case it is an IteratorChain, wrap every underlying iterators as unmodifiable\n+                // multiple rechainings would otherwise lead to exponential growing number of function calls\n+                // when the iteratorChain gets used.\n+                for (Iterator<? extends E> nestedIterator : ((IteratorChain<? extends E>) underlyingIterator).iteratorQueue) {\n+                    iteratorQueue.add(UnmodifiableIterator.unmodifiableIterator(nestedIterator));\n+                }\n+            } else {\n+                // we don't know anything about the underlying iterator, simply add it here\n+                iteratorQueue.add(iterator);\n+            }\n+        } else if (iterator instanceof IteratorChain) {\n+            // add the wrapped iterators directly instead of reusing the given instance\n+            // multiple rechainings would otherwise lead to exponential growing number of function calls\n+            // when the iteratorChain gets used.\n+            iteratorQueue.addAll(((IteratorChain) iterator).iteratorQueue);\n+        } else {\n+            // arbitrary other iterator\n+            iteratorQueue.add(iterator);\n+        }\n     }\n \n     /**\ndiff --git a/src/main/java/org/apache/commons/collections4/iterators/UnmodifiableIterator.java b/src/main/java/org/apache/commons/collections4/iterators/UnmodifiableIterator.java\nindex 42b11b41ad..1fb56b5ccc 100644\n--- a/src/main/java/org/apache/commons/collections4/iterators/UnmodifiableIterator.java\n+++ b/src/main/java/org/apache/commons/collections4/iterators/UnmodifiableIterator.java\n@@ -91,5 +91,4 @@ public void remove() {\n     T unwrap() {\n         return iterator;\n     }\n-\n }\n",
  "test_patch" : "diff --git a/src/test/java/org/apache/commons/collections4/iterators/IteratorChainTest.java b/src/test/java/org/apache/commons/collections4/iterators/IteratorChainTest.java\nindex be17dac084..8d642e774b 100644\n--- a/src/test/java/org/apache/commons/collections4/iterators/IteratorChainTest.java\n+++ b/src/test/java/org/apache/commons/collections4/iterators/IteratorChainTest.java\n@@ -25,9 +25,13 @@\n import java.time.Duration;\n import java.util.ArrayList;\n import java.util.Arrays;\n+import java.util.HashMap;\n import java.util.Iterator;\n import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n import java.util.NoSuchElementException;\n+import java.util.Set;\n \n import org.apache.commons.collections4.IteratorUtils;\n import org.apache.commons.collections4.Predicate;\n@@ -42,10 +46,14 @@ public class IteratorChainTest extends AbstractIteratorTest<String> {\n     protected String[] testArray = {\n         \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\"\n     };\n+    protected String[] testArray1234 = {\n+        \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\"\n+    };\n \n     protected List<String> list1;\n     protected List<String> list2;\n     protected List<String> list3;\n+    protected List<String> list4;\n \n     public List<String> getList1() {\n         return list1;\n@@ -89,6 +97,9 @@ public void setUp() {\n         list3 = new ArrayList<>();\n         list3.add(\"Five\");\n         list3.add(\"Six\");\n+        list4 = new ArrayList<>();\n+        list4.add(\"Seven\");\n+        list4.add(\"Eight\");\n     }\n \n     @Test\n@@ -149,9 +160,14 @@ void testConstructList() {\n         expected.addAll(list2);\n         expected.addAll(list3);\n         final IteratorChain<String> iter = new IteratorChain<>(list);\n+        assertEquals(iter.size(), list.size());\n+        assertFalse(iter.isLocked());\n         final List<String> actual = new ArrayList<>();\n         iter.forEachRemaining(actual::add);\n         assertEquals(actual, expected);\n+        assertTrue(iter.isLocked());\n+        assertThrows(UnsupportedOperationException.class, () -> iter.addIterator(list1.iterator()),\n+                     \"adding iterators after iteratorChain has been traversed must fail\");\n     }\n \n     @Test\n@@ -263,4 +279,69 @@ void testRemoveFromFilteredIterator() {\n         assertEquals(1, list2.size());\n     }\n \n+    @Test\n+    public void testChainOfChains() {\n+        final Iterator<String> iteratorChain1 = new IteratorChain<>(list1.iterator(), list2.iterator());\n+        final Iterator<String> iteratorChain2 = new IteratorChain<>(list3.iterator(), list4.iterator());\n+        final Iterator<String> iteratorChainOfChains = new IteratorChain<>(iteratorChain1, iteratorChain2);\n+\n+        for (final String testValue : testArray1234) {\n+            final String iterValue = (String) iteratorChainOfChains.next();\n+            assertEquals(testValue, iterValue, \"Iteration value is correct\");\n+        }\n+\n+        assertFalse(iteratorChainOfChains.hasNext(), \"Iterator should now be empty\");\n+        assertThrows(NoSuchElementException.class, iteratorChainOfChains::next, \"NoSuchElementException must be thrown\");\n+    }\n+\n+    @Test\n+    public void testChainOfUnmodifiableChains() {\n+        final Iterator<String> iteratorChain1 = new IteratorChain<>(list1.iterator(), list2.iterator());\n+        final Iterator<String> unmodifiableChain1 = IteratorUtils.unmodifiableIterator(iteratorChain1);\n+        final Iterator<String> iteratorChain2 = new IteratorChain<>(list3.iterator(), list4.iterator());\n+        final Iterator<String> unmodifiableChain2 = IteratorUtils.unmodifiableIterator(iteratorChain2);\n+        final Iterator<String> iteratorChainOfChains = new IteratorChain<>(unmodifiableChain1, unmodifiableChain2);\n+\n+        for (final String testValue : testArray1234) {\n+            final String iterValue = (String) iteratorChainOfChains.next();\n+            assertEquals(testValue, iterValue, \"Iteration value is correct\");\n+        }\n+\n+        assertFalse(iteratorChainOfChains.hasNext(), \"Iterator should now be empty\");\n+        assertThrows(NoSuchElementException.class, iteratorChainOfChains::next, \"NoSuchElementException must be thrown\");\n+    }\n+\n+    @Test\n+    public void testChainOfUnmodifiableChainsRetainsUnmodifiableBehaviourOfNestedIterator() {\n+        final Iterator<String> iteratorChain1 = new IteratorChain<>(list1.iterator(), list2.iterator());\n+        final Iterator<String> unmodifiableChain1 = IteratorUtils.unmodifiableIterator(iteratorChain1);\n+        final Iterator<String> iteratorChain2 = new IteratorChain<>(list3.iterator(), list4.iterator());\n+        final Iterator<String> unmodifiableChain2 = IteratorUtils.unmodifiableIterator(iteratorChain2);\n+        final Iterator<String> iteratorChainOfChains = new IteratorChain<>(unmodifiableChain1, unmodifiableChain2);\n+\n+        iteratorChainOfChains.next();\n+        assertThrows(UnsupportedOperationException.class, iteratorChainOfChains::remove,\n+                     \"Calling remove must fail when nested iterator is unmodifiable\");\n+    }\n+\n+    @Test\n+    public void testMultipleChainedIteratorPerformWellCollections722() {\n+        final Map<Integer, List<Integer>> source = new HashMap<>();\n+        for (int i = 0; i < 50; i++) {\n+            source.put(i, Arrays.asList(1, 2, 3));\n+        }\n+\n+        Iterator<Integer> iterator = IteratorUtils.emptyIterator();\n+        final Set<Entry<Integer, List<Integer>>> entries = source.entrySet();\n+        for (final Entry<Integer, List<Integer>> entry : entries) {\n+            final Iterator<Integer> next = entry.getValue().iterator();\n+            iterator = IteratorUtils.chainedIterator(iterator, next);\n+        }\n+        final Iterator<Integer> lastIterator = iterator;\n+        assertTimeoutPreemptively(Duration.ofSeconds(2), () -> {\n+                      while (lastIterator.hasNext()) {\n+                          lastIterator.next().toString();\n+                      }\n+            });\n+    }\n }\n",
  "problem_statement" : "[collections-722] deeply nested chainedIterator performance problems fixed\n\nbasically 'renovated' stale PR https://github.com/apache/commons-collections/pull/308 from collections-770, ensures that rechaining chainedIterators multiple times now result in a single IteratorChain instance with all picked up underlying iterators, thus avoiding deeply nested imperformant IteratorChain instances. Additionally the UnmodifiableIterator gets a special treatment, so that SetUtils.SetView.iterator() also benefits from this solution. Raised test coverage.\r\n\r\nNote: From the comments in PR 308  (collections-770), I think, the PR stalled because it did not directly address the issue in that ticket, however there might be other reasons I am not aware of. \r\nBut as far as I can see, it fits perfectly for Collections-722. Cudos to original author [stevebosman-oc](https://github.com/stevebosman-oc).\r\n\r\n<!--\r\n  Licensed to the Apache Software Foundation (ASF) under one\r\n  or more contributor license agreements.  See the NOTICE file\r\n  distributed with this work for additional information\r\n  regarding copyright ownership.  The ASF licenses this file\r\n  to you under the Apache License, Version 2.0 (the\r\n  \"License\"); you may not use this file except in compliance\r\n  with the License.  You may obtain a copy of the License at\r\n\r\n    https://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing,\r\n  software distributed under the License is distributed on an\r\n  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n  KIND, either express or implied.  See the License for the\r\n  specific language governing permissions and limitations\r\n  under the License.\r\n-->\r\n\r\nThanks for your contribution to [Apache Commons](https://commons.apache.org/)! Your help is appreciated!\r\n\r\nBefore you push a pull request, review this list:\r\n\r\n- [x] Read the [contribution guidelines](CONTRIBUTING.md) for this project.\r\n- [-] Read the [ASF Generative Tooling Guidance](https://www.apache.org/legal/generative-tooling.html) if you use Artificial Intelligence (AI).\r\n- [-] I used AI to create any part of, or all of, this pull request.\r\n- [x] Run a successful build using the default [Maven](https://maven.apache.org/) goal with `mvn`; that's `mvn` on the command line by itself.\r\n- [x] Write unit tests that match behavioral changes, where the tests fail if the changes to the runtime are not applied. This may not always be possible, but it is a best-practice.\r\n- [x] Write a pull request description that is detailed enough to understand what the pull request does, how, and why.\r\n- [x] Each commit in the pull request should have a meaningful subject line and body. Note that a maintainer may squash commits during the merge process.\r\n",
  "hints_text" : null,
  "created_at" : "Mon Jul 28 23:56:49 CEST 2025",
  "version" : null,
  "FAIL_TO_PASS" : [ "IteratorChainTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=IteratorChainTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 628,
  "metadata" : null
}, {
  "instance_id" : "apache-commons-collections-PR-565",
  "repo" : "apache/commons-collections",
  "base_commit" : "96763c2612a022266f102f4daca055370e22a47d",
  "patch" : "diff --git a/src/main/java/org/apache/commons/collections4/multimap/LinkedHashSetValuedLinkedHashMap.java b/src/main/java/org/apache/commons/collections4/multimap/LinkedHashSetValuedLinkedHashMap.java\nnew file mode 100644\nindex 0000000000..4cf55f358d\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/multimap/LinkedHashSetValuedLinkedHashMap.java\n@@ -0,0 +1,144 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.multimap;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n+import java.util.Map;\n+\n+import org.apache.commons.collections4.MultiValuedMap;\n+\n+/**\n+ * Implements a {@code SetValuedMap}, using a {@link LinkedHashMap} to provide data\n+ * storage and {@link LinkedHashSet}s as value collections. This is the standard\n+ * implementation of a SetValuedMap.\n+ * <p>\n+ * <strong>Note that LinkedHashSetValuedLinkedHashMap is not synchronized and is not\n+ * thread-safe.</strong> If you wish to use this map from multiple threads\n+ * concurrently, you must use appropriate synchronization. This class may throw\n+ * exceptions when accessed by concurrent threads without synchronization.\n+ * </p>\n+ *\n+ * @param <K> the type of the keys in this map\n+ * @param <V> the type of the values in this map\n+ * @since 4.5.0-M3\n+ */\n+public class LinkedHashSetValuedLinkedHashMap<K, V> extends AbstractSetValuedMap<K, V>\n+    implements Serializable {\n+\n+    /** Serialization Version */\n+    private static final long serialVersionUID = 20241020L;\n+\n+    /**\n+     * The initial map capacity used when none specified in constructor.\n+     */\n+    private static final int DEFAULT_INITIAL_MAP_CAPACITY = 16;\n+\n+    /**\n+     * The initial set capacity when using none specified in constructor.\n+     */\n+    private static final int DEFAULT_INITIAL_SET_CAPACITY = 3;\n+\n+    /**\n+     * The initial list capacity when creating a new value collection.\n+     */\n+    private final int initialSetCapacity;\n+\n+    /**\n+     * Creates an empty LinkedHashSetValuedHashMap with the default initial\n+     * map capacity (16) and the default initial set capacity (3).\n+     */\n+    public LinkedHashSetValuedLinkedHashMap() {\n+        this(DEFAULT_INITIAL_MAP_CAPACITY, DEFAULT_INITIAL_SET_CAPACITY);\n+    }\n+\n+    /**\n+     * Creates an empty LinkedHashSetValuedHashMap with the default initial\n+     * map capacity (16) and the specified initial set capacity.\n+     *\n+     * @param initialSetCapacity  the initial capacity used for value collections\n+     */\n+    public LinkedHashSetValuedLinkedHashMap(final int initialSetCapacity) {\n+        this(DEFAULT_INITIAL_MAP_CAPACITY, initialSetCapacity);\n+    }\n+\n+    /**\n+     * Creates an empty LinkedHashSetValuedHashMap with the specified initial\n+     * map and list capacities.\n+     *\n+     * @param initialMapCapacity  the initial hashmap capacity\n+     * @param initialSetCapacity  the initial capacity used for value collections\n+     */\n+    public LinkedHashSetValuedLinkedHashMap(final int initialMapCapacity, final int initialSetCapacity) {\n+        super(new LinkedHashMap<>(initialMapCapacity));\n+        this.initialSetCapacity = initialSetCapacity;\n+    }\n+\n+    /**\n+     * Creates an LinkedHashSetValuedHashMap copying all the mappings of the given map.\n+     *\n+     * @param map a {@code Map} to copy into this map\n+     */\n+    public LinkedHashSetValuedLinkedHashMap(final Map<? extends K, ? extends V> map) {\n+        this(map.size(), DEFAULT_INITIAL_SET_CAPACITY);\n+        super.putAll(map);\n+    }\n+\n+    /**\n+     * Creates an LinkedHashSetValuedHashMap copying all the mappings of the given map.\n+     *\n+     * @param map a {@code MultiValuedMap} to copy into this map\n+     */\n+    public LinkedHashSetValuedLinkedHashMap(final MultiValuedMap<? extends K, ? extends V> map) {\n+        this(map.size(), DEFAULT_INITIAL_SET_CAPACITY);\n+        super.putAll(map);\n+    }\n+\n+    @Override\n+    protected LinkedHashSet<V> createCollection() {\n+        return new LinkedHashSet<>(initialSetCapacity);\n+    }\n+\n+    /**\n+     * Deserializes an instance from an ObjectInputStream.\n+     *\n+     * @param in The source ObjectInputStream.\n+     * @throws IOException            Any of the usual Input/Output related exceptions.\n+     * @throws ClassNotFoundException A class of a serialized object cannot be found.\n+     */\n+    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        setMap(new LinkedHashMap<>());\n+        doReadObject(in);\n+    }\n+\n+    /**\n+     * Serializes this object to an ObjectOutputStream.\n+     *\n+     * @param out the target ObjectOutputStream.\n+     * @throws IOException thrown when an I/O errors occur writing to the target stream.\n+     */\n+    private void writeObject(final ObjectOutputStream out) throws IOException {\n+        out.defaultWriteObject();\n+        doWriteObject(out);\n+    }\n+\n+}\ndiff --git a/src/test/resources/org/apache/commons/collections4/data/test/LinkedHashSetValuedLinkedHashMap.emptyCollection.version4.5.obj b/src/test/resources/org/apache/commons/collections4/data/test/LinkedHashSetValuedLinkedHashMap.emptyCollection.version4.5.obj\nnew file mode 100644\nindex 0000000000..4f3c57195d\nBinary files /dev/null and b/src/test/resources/org/apache/commons/collections4/data/test/LinkedHashSetValuedLinkedHashMap.emptyCollection.version4.5.obj differ\ndiff --git a/src/test/resources/org/apache/commons/collections4/data/test/LinkedHashSetValuedLinkedHashMap.fullCollection.version4.5.obj b/src/test/resources/org/apache/commons/collections4/data/test/LinkedHashSetValuedLinkedHashMap.fullCollection.version4.5.obj\nnew file mode 100644\nindex 0000000000..c4b9fb801d\nBinary files /dev/null and b/src/test/resources/org/apache/commons/collections4/data/test/LinkedHashSetValuedLinkedHashMap.fullCollection.version4.5.obj differ\n",
  "test_patch" : "diff --git a/src/test/java/org/apache/commons/collections4/multimap/HashSetValuedHashMapTest.java b/src/test/java/org/apache/commons/collections4/multimap/HashSetValuedHashMapTest.java\nindex b36f4ed01e..5ec19ed0cd 100644\n--- a/src/test/java/org/apache/commons/collections4/multimap/HashSetValuedHashMapTest.java\n+++ b/src/test/java/org/apache/commons/collections4/multimap/HashSetValuedHashMapTest.java\n@@ -193,9 +193,9 @@ public void testSetValuedMapRemoveViaIterator() {\n \n //    public void testCreate() throws Exception {\n //        writeExternalFormToDisk((java.io.Serializable) makeObject(),\n-//                \"src/test/resources/data/test/HashSetValuedHashMap.emptyCollection.version4.1.obj\");\n+//                \"src/test/resources/org/apache/commons/collections4/data/test/HashSetValuedHashMap.emptyCollection.version4.1.obj\");\n //        writeExternalFormToDisk((java.io.Serializable) makeFullMap(),\n-//                \"src/test/resources/data/test/HashSetValuedHashMap.fullCollection.version4.1.obj\");\n+//                \"src/test/resources/org/apache/commons/collections4/data/test/HashSetValuedHashMap.fullCollection.version4.1.obj\");\n //    }\n \n }\ndiff --git a/src/test/java/org/apache/commons/collections4/multimap/LinkedHashSetValuedLinkedHashMapTest.java b/src/test/java/org/apache/commons/collections4/multimap/LinkedHashSetValuedLinkedHashMapTest.java\nnew file mode 100644\nindex 0000000000..15f1d367f0\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/multimap/LinkedHashSetValuedLinkedHashMapTest.java\n@@ -0,0 +1,206 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.multimap;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotSame;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.commons.collections4.MultiValuedMap;\n+import org.apache.commons.collections4.SetValuedMap;\n+import org.apache.commons.collections4.collection.AbstractCollectionTest;\n+import org.junit.jupiter.api.Test;\n+\n+/**\n+ * Tests {@link LinkedHashSetValuedLinkedHashMap}.\n+ */\n+public class LinkedHashSetValuedLinkedHashMapTest<K, V> extends AbstractMultiValuedMapTest<K, V> {\n+\n+    public LinkedHashSetValuedLinkedHashMapTest() {\n+        super(LinkedHashSetValuedLinkedHashMapTest.class.getSimpleName());\n+    }\n+\n+    @Override\n+    protected int getIterationBehaviour() {\n+        return AbstractCollectionTest.UNORDERED;\n+    }\n+\n+    @Override\n+    public boolean isHashSetValue() {\n+        return true;\n+    }\n+\n+    @Override\n+    public MultiValuedMap<K, V> makeConfirmedMap() {\n+        return new LinkedHashSetValuedLinkedHashMap<>();\n+    }\n+\n+    @Override\n+    public SetValuedMap<K, V> makeObject() {\n+        return new LinkedHashSetValuedLinkedHashMap<>();\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"4.5\"; // LinkedHashSetValuedLinkedHashMap was added in version 4.5\n+    }\n+\n+    @Test\n+    public void testLinkedHashSetValuedLinkedHashMap_2() {\n+        final Map<K, V> map = new HashMap<>();\n+        final SetValuedMap<K, V> map1;\n+        final SetValuedMap<K, V> map2;\n+\n+        map.put((K) \"A\", (V) \"W\");\n+        map.put((K) \"B\", (V) \"X\");\n+        map.put((K) \"C\", (V) \"F\");\n+        map1 = new LinkedHashSetValuedLinkedHashMap<>(map);\n+        assertEquals(1, map1.get((K) \"A\").size());\n+\n+        map.remove(\"A\");\n+        map.remove(\"B\");\n+        map.remove(\"C\");\n+        map2 = new LinkedHashSetValuedLinkedHashMap<>(map);\n+        assertEquals(\"{}\", map2.toString());\n+    }\n+\n+    @Test\n+    public void testHashSetValueHashMap() {\n+        final SetValuedMap<K, V> setMap = new LinkedHashSetValuedLinkedHashMap<>(4);\n+        assertEquals(0, setMap.get((K) \"whatever\").size());\n+\n+        final Set<V> set = setMap.get((K) \"A\");\n+        set.add((V) \"W\");\n+        set.add((V) \"X\");\n+        set.add((V) \"F\");\n+        assertEquals(3, setMap.get((K) \"A\").size());\n+    }\n+\n+    @Test\n+    public void testHashSetValueHashMap_1() {\n+        final MultiValuedMap<K, V> map = new ArrayListValuedHashMap<>();\n+        final SetValuedMap<K, V> map1;\n+        final SetValuedMap<K, V> map2 = makeObject();\n+        final SetValuedMap<K, V> map3;\n+\n+        map.put((K) \"A\", (V) \"W\");\n+        map.put((K) \"A\", (V) \"X\");\n+        map.put((K) \"A\", (V) \"F\");\n+        map1 = new LinkedHashSetValuedLinkedHashMap<>(map);\n+        assertEquals(3, map1.get((K) \"A\").size());\n+        map2.put((K) \"A\", (V) \"X\");\n+        map2.put((K) \"A\", (V) \"F\");\n+        map2.put((K) \"A\", (V) \"W\");\n+        assertEquals(map1, map2);\n+        assertEquals(map1.hashCode(), map2.hashCode());\n+\n+        map.remove(\"A\");\n+        map3 = new LinkedHashSetValuedLinkedHashMap<>(map);\n+        assertEquals(\"{}\", map3.toString());\n+    }\n+\n+    @Test\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSetValuedMapAdd() {\n+        final SetValuedMap<K, V> setMap = makeObject();\n+        assertTrue(setMap.get((K) \"whatever\") instanceof Set);\n+\n+        final Set<V> set = setMap.get((K) \"A\");\n+        assertTrue(set.add((V) \"a1\"));\n+        assertTrue(set.add((V) \"a2\"));\n+        assertFalse(set.add((V) \"a1\"));\n+        assertEquals(2, setMap.size());\n+        assertTrue(setMap.containsKey(\"A\"));\n+    }\n+\n+    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n+    @Test\n+    public void testSetValuedMapEqualsHashCodeContract() {\n+        final SetValuedMap map1 = makeObject();\n+        final SetValuedMap map2 = makeObject();\n+\n+        map1.put(\"a\", \"a1\");\n+        map1.put(\"a\", \"a2\");\n+        map2.put(\"a\", \"a2\");\n+        map2.put(\"a\", \"a1\");\n+        assertEquals(map1, map2);\n+        assertEquals(map1.hashCode(), map2.hashCode());\n+\n+        map2.put(\"a\", \"a2\");\n+        assertEquals(map1, map2);\n+        assertEquals(map1.hashCode(), map2.hashCode());\n+\n+        map2.put(\"a\", \"a3\");\n+        assertNotSame(map1, map2);\n+        assertNotSame(map1.hashCode(), map2.hashCode());\n+    }\n+\n+    @Test\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSetValuedMapRemove() {\n+        final SetValuedMap<K, V> setMap = makeObject();\n+        assertTrue(setMap.get((K) \"whatever\") instanceof Set);\n+\n+        final Set<V> set = setMap.get((K) \"A\");\n+        assertTrue(set.add((V) \"a1\"));\n+        assertTrue(set.add((V) \"a2\"));\n+        assertFalse(set.add((V) \"a1\"));\n+        assertEquals(2, setMap.size());\n+        assertTrue(setMap.containsKey(\"A\"));\n+\n+        assertTrue(set.remove(\"a1\"));\n+        assertTrue(set.remove(\"a2\"));\n+        assertFalse(set.remove(\"a1\"));\n+\n+        assertEquals(0, setMap.size());\n+        assertFalse(setMap.containsKey(\"A\"));\n+    }\n+\n+    @Test\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSetValuedMapRemoveViaIterator() {\n+        final SetValuedMap<K, V> setMap = makeObject();\n+        assertTrue(setMap.get((K) \"whatever\") instanceof Set);\n+\n+        final Set<V> set = setMap.get((K) \"A\");\n+        set.add((V) \"a1\");\n+        set.add((V) \"a2\");\n+        set.add((V) \"a1\");\n+\n+        final Iterator<V> it = set.iterator();\n+        while (it.hasNext()) {\n+            it.next();\n+            it.remove();\n+        }\n+        assertEquals(0, setMap.size());\n+        assertFalse(setMap.containsKey(\"A\"));\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        writeExternalFormToDisk((java.io.Serializable) makeObject(),\n+//                \"src/test/resources/org/apache/commons/collections4/data/test/LinkedHashSetValuedLinkedHashMap.emptyCollection.version4.5.obj\");\n+//        writeExternalFormToDisk((java.io.Serializable) makeFullMap(),\n+//                \"src/test/resources/org/apache/commons/collections4/data/test/LinkedHashSetValuedLinkedHashMap.fullCollection.version4.5.obj\");\n+//    }\n+\n+}\n",
  "problem_statement" : "COLLECTIONS-871 Added LinkedHashSetValuedLinkedHashMap",
  "hints_text" : null,
  "created_at" : "Sun Oct 20 20:50:07 CEST 2024",
  "version" : null,
  "FAIL_TO_PASS" : [ "LinkedHashSetValuedLinkedHashMapTest", "HashSetValuedHashMapTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=LinkedHashSetValuedLinkedHashMapTest,HashSetValuedHashMapTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 565,
  "metadata" : null
}, {
  "instance_id" : "apache-commons-collections-PR-564",
  "repo" : "apache/commons-collections",
  "base_commit" : "63d30d55bfbc7203621c0443086a59b874611c0b",
  "patch" : "diff --git a/src/main/java/org/apache/commons/collections4/iterators/ExtendedIterator.java b/src/main/java/org/apache/commons/collections4/iterators/ExtendedIterator.java\nnew file mode 100644\nindex 0000000000..7b67335431\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/iterators/ExtendedIterator.java\n@@ -0,0 +1,196 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.iterators;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.stream.Stream;\n+\n+\n+/**\n+ * Extends Iterator functionality to include operations commonly found on streams (e.g. filtering, concatenating, mapping).\n+ * It also provides convenience methods for common operations.\n+ * @param <T> The type of object returned from the iterator.\n+ * @since 4.5.0-M3\n+ */\n+public final class ExtendedIterator<T> implements Iterator<T> {\n+    /**\n+     * Set to <code>true</code> if this wrapping doesn't permit the use of\n+     * {@link #remove()}, otherwise removal is delegated to the base iterator.\n+     */\n+    private final boolean throwOnRemove;\n+\n+    /**\n+     * Creates an ExtendedIterator wrapped round <code>it</code>,\n+     * which does not permit <code>.remove()</code>\n+     * even if <code>it</code> does.\n+     * @param it The Iterator to wrap.\n+     * @return an Extended iterator on {@code it}\n+     * @throws UnsupportedOperationException if remove() is called on the resulting iterator.\n+     */\n+    public static <T> ExtendedIterator<T> createNoRemove(final Iterator<T> it) {\n+        return new ExtendedIterator<>(it, true);\n+    }\n+\n+    /**\n+     * Creates an ExtendedIterator wrapped round a {@link Stream}.\n+     * The extended iterator does not permit <code>.remove()</code>.\n+     * <p>\n+     * The stream should not be used directly. The effect of doing so is\n+     * undefined.\n+     * </p>\n+     * @param stream the Stream to create an iterator from.\n+     * @return an Extended iterator on the {@code stream} iterator.\n+     */\n+    public static <T> ExtendedIterator<T> create(final Stream<T> stream) {\n+        return new ExtendedIterator<T>(stream.iterator(), true);\n+    }\n+\n+    /**\n+     * Flattens an iterator of iterators into an Iterator over the next level values.\n+     * Similar to list splicing in lisp.\n+     * @param iterators An iterator of iterators.\n+     * @return An iterator over the logical concatenation of the inner iterators.\n+     */\n+    public static <T> ExtendedIterator<T> flatten(final Iterator<Iterator<T>> iterators) {\n+        return create(new LazyIteratorChain<T>() {\n+\n+            @Override\n+            protected Iterator<? extends T> nextIterator(final int count) {\n+                return iterators.hasNext() ? iterators.next() : null;\n+            }\n+\n+        });\n+    }\n+\n+    /**\n+     * Creates an empty Extended iterator.\n+     * @return An empty Extended iterator.\n+     */\n+    public static ExtendedIterator<?> emptyIterator() {\n+        return new ExtendedIterator<>(Collections.emptyIterator(), false);\n+    }\n+\n+    /**\n+     * Create an ExtendedIterator returning the elements of <code>it</code>.\n+     * If <code>it</code> is itself an ExtendedIterator, return that;\n+     * otherwise wrap <code>it</code>.\n+     * @param it The iterator to wrap.\n+     * @return An Extended iterator wrapping {@code it}\n+     */\n+    public static <T> ExtendedIterator<T> create(final Iterator<T> it) {\n+        return it instanceof ExtendedIterator<?>\n+                ? (ExtendedIterator<T>) it\n+                : new ExtendedIterator<>(it, false);\n+    }\n+\n+    /** the base iterator that we wrap */\n+    private final Iterator<? extends T> base;\n+\n+    /**\n+     * Initialise this wrapping with the given base iterator and remove-control.\n+     * @param base the base iterator that this iterator wraps\n+     * @param throwOnRemove true if .remove() must throw an exception\n+     */\n+    private ExtendedIterator(final Iterator<? extends T> base, final boolean throwOnRemove) {\n+        this.base = base;\n+        this.throwOnRemove = throwOnRemove;\n+    }\n+\n+    @Override\n+    public boolean hasNext() {\n+        return base.hasNext();\n+    }\n+\n+    @Override\n+    public T next() {\n+        return base.next();\n+    }\n+\n+    @Override\n+    public void forEachRemaining(final Consumer<? super T> action) {\n+        base.forEachRemaining(action);\n+    }\n+\n+    @Override\n+    public void remove() {\n+        if (throwOnRemove) {\n+            throw new UnsupportedOperationException();\n+        }\n+        base.remove();\n+    }\n+\n+    /**\n+     * Returns the next item and removes it from the iterator.\n+     * @return the next item from the iterator.\n+     */\n+    public T removeNext() {\n+        T result = next();\n+        remove();\n+        return result;\n+    }\n+\n+    /**\n+     * Chains the {@code other} iterator to the end of this one.\n+     * @param other the other iterator to extend this iterator with.\n+     * @return A new iterator returning the contents of {@code this} iterator followed by the contents of {@code other} iterator.\n+     * @param <X> The type of object returned from the other iterator.\n+     */\n+    public <X extends T> ExtendedIterator<T> andThen(final Iterator<X> other) {\n+        if (base instanceof IteratorChain) {\n+            ((IteratorChain<T>) base).addIterator(other);\n+            return this;\n+        }\n+        return new ExtendedIterator<T>(new IteratorChain<T>(this.base, other), this.throwOnRemove);\n+    }\n+\n+    /**\n+     * Filter this iterator using a predicate.  Only items for which the predicate returns {@code true} will\n+     * be included in the result.\n+     * @param predicate The predicate to filter the items with.\n+     * @return An iterator filtered by the predicate.\n+     */\n+    public ExtendedIterator<T> filter(final Predicate<T> predicate) {\n+        return new ExtendedIterator<T>(new FilterIterator<>(this, predicate::test), this.throwOnRemove);\n+    }\n+\n+    /**\n+     * Map the elements of the iterator to a now type.\n+     * @param function The function to map elements of {@code <T>} to type {@code <U>}.\n+     * @return An Extended iterator that returns a {@code <U>} for very {@code <T>} in the original iterator.\n+     * @param <U> The object type to return.\n+     */\n+    public <U> ExtendedIterator<U> map(final Function<T, U> function) {\n+        return new ExtendedIterator<U>(new TransformIterator<>(this, function::apply), false);\n+    }\n+\n+    /**\n+     * A method to add the remaining elements in the iterator an arbitrary collection.\n+     * This method consumes the iterator.\n+     * @param collection THe collection to add elements to.\n+     * @return the {@code collection} with the elements added.\n+     * @param <U> A collection of objects of type {@code <T>}.\n+     */\n+    public <U extends Collection<T>> U addTo(final U collection) {\n+        this.forEachRemaining(collection::add);\n+        return collection;\n+    }\n+}\n",
  "test_patch" : "diff --git a/src/test/java/org/apache/commons/collections4/iterators/ExtendedIteratorTest.java b/src/test/java/org/apache/commons/collections4/iterators/ExtendedIteratorTest.java\nnew file mode 100644\nindex 0000000000..9362905111\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/iterators/ExtendedIteratorTest.java\n@@ -0,0 +1,150 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.collections4.iterators;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+public class ExtendedIteratorTest {\n+    /**\n+     * Collection of {@link Integer}s\n+     */\n+    private List<Integer> collectionA;\n+\n+    @BeforeEach\n+    public void setUp() {\n+        collectionA = new ArrayList<>();\n+        collectionA.add(1);\n+        collectionA.add(2);\n+        collectionA.add(3);\n+        collectionA.add(4);\n+        collectionA.add(5);\n+        collectionA.add(6);\n+    }\n+\n+    @Test\n+    public void testCreateNoRemove() {\n+        Iterator<Integer> iter = ExtendedIterator.createNoRemove(collectionA.iterator());\n+        assertThrows(UnsupportedOperationException.class, iter::remove);\n+    }\n+\n+    @Test\n+    public void testCreateWithStream() {\n+        Iterator<Integer> iter = ExtendedIterator.create(collectionA.stream());\n+        assertThrows(UnsupportedOperationException.class, iter::remove);\n+        List<Integer> actual = new ArrayList<>();\n+        iter.forEachRemaining(actual::add);\n+        assertEquals(collectionA, actual);\n+    }\n+\n+    @Test\n+    public void testFlatten() {\n+        Iterator<Iterator<Integer>> iteratorIterator = Arrays.asList(\n+                Arrays.asList(1, 2, 3).iterator(),\n+                Arrays.asList(4, 5, 6).iterator()\n+        ).iterator();\n+        Iterator<Integer>  iter = ExtendedIterator.flatten(iteratorIterator);\n+        List<Integer> actual = new ArrayList<>();\n+        iter.forEachRemaining(actual::add);\n+        assertEquals(collectionA, actual);\n+    }\n+\n+    @Test\n+    public void testEmptyIterator() {\n+        assertFalse(ExtendedIterator.emptyIterator().hasNext());\n+    }\n+\n+    @Test\n+    public void testCreate() {\n+        Iterator<Integer> iter = ExtendedIterator.create(collectionA.iterator());\n+        List<Integer> actual = new ArrayList<>();\n+        iter.forEachRemaining(actual::add);\n+        assertEquals(collectionA, actual);\n+    }\n+\n+    @Test\n+    public void testRemove() {\n+        Iterator<Integer> iter = ExtendedIterator.create(collectionA.iterator());\n+        Integer i = iter.next();\n+        iter.remove();\n+        assertFalse(collectionA.contains(i));\n+        List<Integer> actual = new ArrayList<>();\n+        iter.forEachRemaining(actual::add);\n+        assertEquals(collectionA, actual);\n+    }\n+\n+    @Test\n+    public void testRemoveNext() {\n+        ExtendedIterator<Integer> iter = ExtendedIterator.create(collectionA.iterator());\n+        Integer i = iter.removeNext();\n+        assertFalse(collectionA.contains(i));\n+        List<Integer> actual = new ArrayList<>();\n+        iter.forEachRemaining(actual::add);\n+        assertEquals(collectionA, actual);\n+    }\n+\n+    @Test\n+    public void testAndThen() {\n+        Iterator<Integer> iter1 = Arrays.asList(1, 2, 3).iterator();\n+        Iterator<Integer> iter2 = Arrays.asList(4, 5, 6).iterator();\n+\n+        ExtendedIterator<Integer> underTest = ExtendedIterator.create(iter1).andThen(iter2);\n+        List<Integer> actual = new ArrayList<>();\n+        underTest.forEachRemaining(actual::add);\n+        assertEquals(collectionA, actual);\n+    }\n+\n+    @Test\n+    public void testFilter() {\n+        List<Integer> expected = Arrays.asList(2, 4, 6);\n+        Predicate<Integer> predicate = i -> i % 2 == 0;\n+        ExtendedIterator<Integer> underTest = ExtendedIterator.create(collectionA.iterator()).filter(predicate);\n+        List<Integer> actual = new ArrayList<>();\n+        underTest.forEachRemaining(actual::add);\n+        assertEquals(expected, actual);\n+    }\n+\n+    @Test\n+    public void testMap() {\n+        List<Double> expected = Arrays.asList(0.5, 1., 1.5, 2.0, 2.5, 3.0);\n+        Function<Integer, Double> function = i -> i / 2.0;\n+        ExtendedIterator<Double> underTest = ExtendedIterator.create(collectionA.iterator()).map(function);\n+        List<Double> actual = new ArrayList<>();\n+        underTest.forEachRemaining(actual::add);\n+        assertEquals(expected, actual);\n+    }\n+\n+    @Test\n+    public void testAddTo() {\n+        List<Integer> expected = new ArrayList<>(collectionA);\n+        expected.addAll(collectionA);\n+        List<Integer> actual = ExtendedIterator.create(collectionA.iterator()).addTo(new ArrayList<>(collectionA));\n+        assertEquals(expected, actual);\n+    }\n+}\n",
  "problem_statement" : "COLLECTIONS-870: Added ExtendedIterator and tests\n\nImplement COLLECTIONS-870\r\n\r\nAdds an ExtendedIterator as defined in COLLECTIONS-870 as well as in the discussion on the mailing list.\r\n\r\nmailing list discussion: https://lists.apache.org/thread/rpcsoz3jwz7x9sp3cgzf315ls7pcd90w\r\n\r\n ",
  "hints_text" : null,
  "created_at" : "Sun Oct 20 11:26:18 CEST 2024",
  "version" : null,
  "FAIL_TO_PASS" : [ "ExtendedIteratorTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=ExtendedIteratorTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 564,
  "metadata" : null
}, {
  "instance_id" : "apache-commons-collections-PR-560",
  "repo" : "apache/commons-collections",
  "base_commit" : "45603c08d9c4561b34990440b2ca5631d5d90ec3",
  "patch" : "diff --git a/src/main/java/org/apache/commons/collections4/multimap/ArrayListValuedLinkedHashMap.java b/src/main/java/org/apache/commons/collections4/multimap/ArrayListValuedLinkedHashMap.java\nnew file mode 100644\nindex 0000000000..3c238156f7\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/multimap/ArrayListValuedLinkedHashMap.java\n@@ -0,0 +1,155 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.multimap;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+import org.apache.commons.collections4.MultiValuedMap;\n+\n+/**\n+ * Implements a {@code ListValuedMap}, using a {@link LinkedHashMap} to provide data\n+ * storage and {@link ArrayList}s as value collections. This is the standard\n+ * implementation of a ListValuedMap.\n+ * <p>\n+ * <strong>Note that ArrayListValuedLinkedHashMap is not synchronized and is not\n+ * thread-safe.</strong> If you wish to use this map from multiple threads\n+ * concurrently, you must use appropriate synchronization. This class may throw\n+ * exceptions when accessed by concurrent threads without synchronization.\n+ * </p>\n+ *\n+ * @param <K> the type of the keys in this map\n+ * @param <V> the type of the values in this map\n+ * @since 4.5\n+ */\n+public class ArrayListValuedLinkedHashMap<K, V> extends AbstractListValuedMap<K, V>\n+    implements Serializable {\n+\n+    /** Serialization Version */\n+    private static final long serialVersionUID = 20241014L;\n+\n+    /**\n+     * The initial map capacity used when none specified in constructor.\n+     */\n+    private static final int DEFAULT_INITIAL_MAP_CAPACITY = 16;\n+\n+    /**\n+     * The initial list capacity when using none specified in constructor.\n+     */\n+    private static final int DEFAULT_INITIAL_LIST_CAPACITY = 3;\n+\n+    /**\n+     * The initial list capacity when creating a new value collection.\n+     */\n+    private final int initialListCapacity;\n+\n+    /**\n+     * Creates an empty ArrayListValuedHashMap with the default initial\n+     * map capacity (16) and the default initial list capacity (3).\n+     */\n+    public ArrayListValuedLinkedHashMap() {\n+        this(DEFAULT_INITIAL_MAP_CAPACITY, DEFAULT_INITIAL_LIST_CAPACITY);\n+    }\n+\n+    /**\n+     * Creates an empty ArrayListValuedHashMap with the default initial\n+     * map capacity (16) and the specified initial list capacity.\n+     *\n+     * @param initialListCapacity  the initial capacity used for value collections\n+     */\n+    public ArrayListValuedLinkedHashMap(final int initialListCapacity) {\n+        this(DEFAULT_INITIAL_MAP_CAPACITY, initialListCapacity);\n+    }\n+\n+    /**\n+     * Creates an empty ArrayListValuedHashMap with the specified initial\n+     * map and list capacities.\n+     *\n+     * @param initialMapCapacity  the initial hashmap capacity\n+     * @param initialListCapacity  the initial capacity used for value collections\n+     */\n+    public ArrayListValuedLinkedHashMap(final int initialMapCapacity, final int initialListCapacity) {\n+        super(new LinkedHashMap<>(initialMapCapacity));\n+        this.initialListCapacity = initialListCapacity;\n+    }\n+\n+    /**\n+     * Creates an ArrayListValuedHashMap copying all the mappings of the given map.\n+     *\n+     * @param map a {@code Map} to copy into this map\n+     */\n+    public ArrayListValuedLinkedHashMap(final Map<? extends K, ? extends V> map) {\n+        this(map.size(), DEFAULT_INITIAL_LIST_CAPACITY);\n+        super.putAll(map);\n+    }\n+\n+    /**\n+     * Creates an ArrayListValuedHashMap copying all the mappings of the given map.\n+     *\n+     * @param map a {@code MultiValuedMap} to copy into this map\n+     */\n+    public ArrayListValuedLinkedHashMap(final MultiValuedMap<? extends K, ? extends V> map) {\n+        this(map.size(), DEFAULT_INITIAL_LIST_CAPACITY);\n+        super.putAll(map);\n+    }\n+\n+    @Override\n+    protected ArrayList<V> createCollection() {\n+        return new ArrayList<>(initialListCapacity);\n+    }\n+\n+    /**\n+     * Deserializes an instance from an ObjectInputStream.\n+     *\n+     * @param in The source ObjectInputStream.\n+     * @throws IOException            Any of the usual Input/Output related exceptions.\n+     * @throws ClassNotFoundException A class of a serialized object cannot be found.\n+     */\n+    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        setMap(new LinkedHashMap<>());\n+        doReadObject(in);\n+    }\n+\n+    /**\n+     * Trims the capacity of all value collections to their current size.\n+     */\n+    public void trimToSize() {\n+        for (final Collection<V> coll : getMap().values()) {\n+            final ArrayList<V> list = (ArrayList<V>) coll;\n+            list.trimToSize();\n+        }\n+    }\n+\n+    /**\n+     * Serializes this object to an ObjectOutputStream.\n+     *\n+     * @param out the target ObjectOutputStream.\n+     * @throws IOException thrown when an I/O errors occur writing to the target stream.\n+     */\n+    private void writeObject(final ObjectOutputStream out) throws IOException {\n+        out.defaultWriteObject();\n+        doWriteObject(out);\n+    }\n+\n+}\ndiff --git a/src/test/resources/org/apache/commons/collections4/data/test/ArrayListValuedLinkedHashMap.emptyCollection.version4.5.obj b/src/test/resources/org/apache/commons/collections4/data/test/ArrayListValuedLinkedHashMap.emptyCollection.version4.5.obj\nnew file mode 100644\nindex 0000000000..1b2bd01f83\nBinary files /dev/null and b/src/test/resources/org/apache/commons/collections4/data/test/ArrayListValuedLinkedHashMap.emptyCollection.version4.5.obj differ\ndiff --git a/src/test/resources/org/apache/commons/collections4/data/test/ArrayListValuedLinkedHashMap.fullCollection.version4.5.obj b/src/test/resources/org/apache/commons/collections4/data/test/ArrayListValuedLinkedHashMap.fullCollection.version4.5.obj\nnew file mode 100644\nindex 0000000000..7499484e03\nBinary files /dev/null and b/src/test/resources/org/apache/commons/collections4/data/test/ArrayListValuedLinkedHashMap.fullCollection.version4.5.obj differ\n",
  "test_patch" : "diff --git a/src/test/java/org/apache/commons/collections4/multimap/ArrayListValuedHashMapTest.java b/src/test/java/org/apache/commons/collections4/multimap/ArrayListValuedHashMapTest.java\nindex 89830a9d08..aed4b14144 100644\n--- a/src/test/java/org/apache/commons/collections4/multimap/ArrayListValuedHashMapTest.java\n+++ b/src/test/java/org/apache/commons/collections4/multimap/ArrayListValuedHashMapTest.java\n@@ -254,11 +254,19 @@ public void testWrappedListAddAll() {\n         assertEquals(\"Q\", list3.get(2));\n     }\n \n+    @Test\n+    public void testCopyConstructorWithMultiValuedMap() {\n+        final ListValuedMap<K, V> map = makeObject();\n+        map.put((K) \"key\", (V) \"sleutel\");\n+        final ListValuedMap<K, V> copy = new ArrayListValuedHashMap<>(map);\n+        assertEquals(map, copy);\n+    }\n+\n //    public void testCreate() throws Exception {\n //        writeExternalFormToDisk((java.io.Serializable) makeObject(),\n-//                \"src/test/resources/data/test/ArrayListValuedHashMap.emptyCollection.version4.1.obj\");\n+//                \"src/test/resources/org/apache/commons/collections4/data/test/ArrayListValuedHashMap.emptyCollection.version4.1.obj\");\n //        writeExternalFormToDisk((java.io.Serializable) makeFullMap(),\n-//                \"src/test/resources/data/test/ArrayListValuedHashMap.fullCollection.version4.1.obj\");\n+//                \"src/test/resources/org/apache/commons/collections4/data/test/ArrayListValuedHashMap.fullCollection.version4.1.obj\");\n //    }\n \n }\ndiff --git a/src/test/java/org/apache/commons/collections4/multimap/ArrayListValuedLinkedHashMapTest.java b/src/test/java/org/apache/commons/collections4/multimap/ArrayListValuedLinkedHashMapTest.java\nnew file mode 100644\nindex 0000000000..a05758f63d\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/multimap/ArrayListValuedLinkedHashMapTest.java\n@@ -0,0 +1,295 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.multimap;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotSame;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.Map;\n+\n+import org.apache.commons.collections4.ListValuedMap;\n+import org.apache.commons.collections4.MapIterator;\n+import org.apache.commons.collections4.MultiValuedMap;\n+import org.apache.commons.collections4.collection.AbstractCollectionTest;\n+import org.junit.jupiter.api.Test;\n+\n+/**\n+ * Tests {@link ArrayListValuedLinkedHashMap}.\n+ */\n+public class ArrayListValuedLinkedHashMapTest<K, V> extends AbstractMultiValuedMapTest<K, V> {\n+\n+    public ArrayListValuedLinkedHashMapTest() {\n+        super(ArrayListValuedLinkedHashMapTest.class.getSimpleName());\n+    }\n+\n+    @Override\n+    protected int getIterationBehaviour() {\n+        return AbstractCollectionTest.UNORDERED;\n+    }\n+\n+    @Override\n+    public ListValuedMap<K, V> makeObject() {\n+        return new ArrayListValuedLinkedHashMap<>();\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"4.5\"; // ArrayListValuedLinkedHashMap has been added in version 4.5\n+    }\n+\n+    @Test\n+    public void testArrayListValuedLinkedHashMap() {\n+        final ListValuedMap<K, V> listMap;\n+        final ListValuedMap<K, V> listMap1;\n+        final Map<K, V> map = new HashMap<>();\n+        final Map<K, V> map1 = new HashMap<>();\n+        map.put((K) \"A\", (V) \"W\");\n+        map.put((K) \"B\", (V) \"X\");\n+        map.put((K) \"C\", (V) \"F\");\n+\n+        listMap = new ArrayListValuedLinkedHashMap<>(map);\n+        assertEquals(1, listMap.get((K) \"A\").size());\n+        assertEquals(1, listMap.get((K) \"B\").size());\n+        assertEquals(1, listMap.get((K) \"C\").size());\n+\n+        listMap1 = new ArrayListValuedLinkedHashMap<>(map1);\n+        assertEquals(\"{}\", listMap1.toString());\n+    }\n+\n+    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n+    @Test\n+    public void testEqualsHashCodeContract() {\n+        final MultiValuedMap map1 = makeObject();\n+        final MultiValuedMap map2 = makeObject();\n+\n+        map1.put(\"a\", \"a1\");\n+        map1.put(\"a\", \"a2\");\n+        map2.put(\"a\", \"a1\");\n+        map2.put(\"a\", \"a2\");\n+        assertEquals(map1, map2);\n+        assertEquals(map1.hashCode(), map2.hashCode());\n+\n+        map2.put(\"a\", \"a2\");\n+        assertNotSame(map1, map2);\n+        assertNotSame(map1.hashCode(), map2.hashCode());\n+    }\n+\n+    @Test\n+    @SuppressWarnings(\"unchecked\")\n+    public void testListValuedMapAdd() {\n+        final ListValuedMap<K, V> listMap = makeObject();\n+        assertTrue(listMap.get((K) \"whatever\") instanceof List);\n+        final List<V> list = listMap.get((K) \"A\");\n+        list.add((V) \"a1\");\n+        assertEquals(1, listMap.size());\n+        assertTrue(listMap.containsKey(\"A\"));\n+    }\n+\n+    @Test\n+    @SuppressWarnings(\"unchecked\")\n+    public void testListValuedMapAddViaListIterator() {\n+        final ListValuedMap<K, V> listMap = makeObject();\n+        final ListIterator<V> listIt = listMap.get((K) \"B\").listIterator();\n+        assertFalse(listIt.hasNext());\n+        listIt.add((V) \"b1\");\n+        listIt.add((V) \"b2\");\n+        listIt.add((V) \"b3\");\n+        assertEquals(3, listMap.size());\n+        assertTrue(listMap.containsKey(\"B\"));\n+        // As ListIterator always adds before the current cursor\n+        assertFalse(listIt.hasNext());\n+    }\n+\n+    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n+    @Test\n+    public void testListValuedMapEqualsHashCodeContract() {\n+        final ListValuedMap map1 = makeObject();\n+        final ListValuedMap map2 = makeObject();\n+\n+        map1.put(\"a\", \"a1\");\n+        map1.put(\"a\", \"a2\");\n+        map2.put(\"a\", \"a1\");\n+        map2.put(\"a\", \"a2\");\n+        assertEquals(map1, map2);\n+        assertEquals(map1.hashCode(), map2.hashCode());\n+\n+        map1.put(\"b\", \"b1\");\n+        map1.put(\"b\", \"b2\");\n+        map2.put(\"b\", \"b2\");\n+        map2.put(\"b\", \"b1\");\n+        assertNotSame(map1, map2);\n+        assertNotSame(map1.hashCode(), map2.hashCode());\n+    }\n+\n+    @Test\n+    @SuppressWarnings(\"unchecked\")\n+    public void testListValuedMapRemove() {\n+        final ListValuedMap<K, V> listMap = makeObject();\n+        final List<V> list = listMap.get((K) \"A\");\n+        list.add((V) \"a1\");\n+        list.add((V) \"a2\");\n+        list.add((V) \"a3\");\n+        assertEquals(3, listMap.size());\n+        assertEquals(\"a1\", list.remove(0));\n+        assertEquals(2, listMap.size());\n+        assertEquals(\"a2\", list.remove(0));\n+        assertEquals(1, listMap.size());\n+        assertEquals(\"a3\", list.remove(0));\n+        assertEquals(0, listMap.size());\n+        assertFalse(listMap.containsKey(\"A\"));\n+    }\n+\n+    @Test\n+    @SuppressWarnings(\"unchecked\")\n+    public void testListValuedMapRemoveViaListIterator() {\n+        final ListValuedMap<K, V> listMap = makeObject();\n+        ListIterator<V> listIt = listMap.get((K) \"B\").listIterator();\n+        listIt.add((V) \"b1\");\n+        listIt.add((V) \"b2\");\n+        assertEquals(2, listMap.size());\n+        assertTrue(listMap.containsKey(\"B\"));\n+        listIt = listMap.get((K) \"B\").listIterator();\n+        while (listIt.hasNext()) {\n+            listIt.next();\n+            listIt.remove();\n+        }\n+        assertFalse(listMap.containsKey(\"B\"));\n+        listIt.add((V) \"b1\");\n+        listIt.add((V) \"b2\");\n+        assertTrue(listMap.containsKey(\"B\"));\n+        assertEquals(2, listMap.get((K) \"B\").size());\n+    }\n+\n+    @Test\n+    public void testTrimToSize() {\n+        final ArrayListValuedLinkedHashMap<K, V> listMap = new ArrayListValuedLinkedHashMap<>(4);\n+\n+        assertEquals(\"{}\", listMap.toString());\n+        listMap.put((K) \"A\", (V) \"W\");\n+        listMap.put((K) \"A\", (V) \"X\");\n+        listMap.put((K) \"B\", (V) \"F\");\n+        assertEquals(2, listMap.get((K) \"A\").size());\n+        assertEquals(1, listMap.get((K) \"B\").size());\n+\n+        listMap.trimToSize();\n+        assertEquals(2, listMap.get((K) \"A\").size());\n+        assertEquals(1, listMap.get((K) \"B\").size());\n+    }\n+\n+    @Test\n+    public void testValuesListIteratorMethods() {\n+        final ListValuedMap<K, V> listMap = makeObject();\n+        final List<V> listA = listMap.get((K) \"A\");\n+        final List<V> list = Arrays.asList((V) \"W\", (V) \"X\", (V) \"F\", (V) \"Q\", (V) \"Q\", (V) \"F\");\n+        listA.addAll(0, list);\n+        final ListIterator<V> it = listMap.get((K) \"A\").listIterator(1);\n+        assertTrue(it.hasNext());\n+        assertEquals(\"X\", it.next());\n+        assertEquals(\"F\", it.next());\n+        assertTrue(it.hasPrevious());\n+        assertEquals(\"F\", it.previous());\n+        assertEquals(2, it.nextIndex());\n+        assertEquals(1, it.previousIndex());\n+        it.set((V) \"Z\");\n+        assertEquals(\"Z\", it.next());\n+        assertEquals(\"Q\", it.next());\n+    }\n+\n+    @Test\n+    public void testWrappedListAdd() {\n+        final ListValuedMap<K, V> listMap = makeObject();\n+        final List<V> listA = listMap.get((K) \"A\");\n+        listA.add(0, (V) \"W\");\n+        listA.add(1, (V) \"X\");\n+        listA.add(2, (V) \"F\");\n+        assertEquals(\"{A=[W, X, F]}\", listMap.toString());\n+        listMap.get((K) \"A\").set(1, (V) \"Q\");\n+        assertEquals(\"{A=[W, Q, F]}\", listMap.toString());\n+    }\n+\n+    @Test\n+    public void testWrappedListAddAll() {\n+        final ListValuedMap<K, V> listMap = makeObject();\n+        final List<V> listA = listMap.get((K) \"A\");\n+        final List<V> list = Arrays.asList((V) \"W\", (V) \"X\", (V) \"F\");\n+        listA.addAll(0, list);\n+        assertEquals(\"{A=[W, X, F]}\", listMap.toString());\n+\n+        final List<V> list1 = Arrays.asList((V) \"Q\", (V) \"Q\", (V) \"L\");\n+        listA.addAll(3, list1);\n+        assertEquals(\"{A=[W, X, F, Q, Q, L]}\", listMap.toString());\n+        assertEquals(\"W\", listMap.get((K) \"A\").get(0));\n+        assertEquals(\"X\", listMap.get((K) \"A\").get(1));\n+        assertEquals(\"F\", listMap.get((K) \"A\").get(2));\n+        assertEquals(\"Q\", listMap.get((K) \"A\").get(3));\n+        assertEquals(\"Q\", listMap.get((K) \"A\").get(4));\n+        assertEquals(\"L\", listMap.get((K) \"A\").get(5));\n+        assertEquals(0, listMap.get((K) \"A\").indexOf(\"W\"));\n+        assertEquals(2, listMap.get((K) \"A\").indexOf(\"F\"));\n+        assertEquals(-1, listMap.get((K) \"A\").indexOf(\"C\"));\n+        assertEquals(3, listMap.get((K) \"A\").indexOf(\"Q\"));\n+        assertEquals(4, listMap.get((K) \"A\").lastIndexOf(\"Q\"));\n+        assertEquals(-1, listMap.get((K) \"A\").lastIndexOf(\"A\"));\n+\n+        final List<V> list2 = new ArrayList<>();\n+        listMap.get((K) \"B\").addAll(0, list2);\n+        assertEquals(\"{A=[W, X, F, Q, Q, L]}\", listMap.toString());\n+        final List<V> list3 = listMap.get((K) \"A\").subList(1, 4);\n+        assertEquals(3, list3.size());\n+        assertEquals(\"Q\", list3.get(2));\n+    }\n+\n+    @Test\n+    public void testPreservesKeyInsertionOrder() {\n+        final ListValuedMap<K, V> map = makeObject();\n+        map.put((K) Integer.valueOf(5), (V) \"five\");\n+        map.put((K) Integer.valueOf(1), (V) \"one\");\n+        map.put((K) Integer.valueOf(5), (V) \"vijf\"); // \"vijf\" = \"five\" in Dutch\n+        MapIterator<K, V> mapIterator = map.mapIterator();\n+        assertEquals(5, mapIterator.next());\n+        assertEquals(\"five\", mapIterator.getValue());\n+        assertEquals(5, mapIterator.next());\n+        assertEquals(\"vijf\", mapIterator.getValue());\n+        assertEquals(1, mapIterator.next());\n+        assertEquals(\"one\", mapIterator.getValue());\n+        assertFalse(mapIterator.hasNext());\n+    }\n+\n+    @Test\n+    public void testCopyConstructorWithMultiValuedMap() {\n+        final ListValuedMap<K, V> map = makeObject();\n+        map.put((K) \"key\", (V) \"sleutel\");\n+        final ListValuedMap<K, V> copy = new ArrayListValuedLinkedHashMap<>(map);\n+        assertEquals(map, copy);\n+    }\n+\n+//    @Test\n+//    public void testCreate() throws Exception {\n+//        writeExternalFormToDisk((java.io.Serializable) makeObject(),\n+//                \"src/test/resources/org/apache/commons/collections4/data/test/ArrayListValuedLinkedHashMap.emptyCollection.version4.5.obj\");\n+//        writeExternalFormToDisk((java.io.Serializable) makeFullMap(),\n+//                \"src/test/resources/org/apache/commons/collections4/data/test/ArrayListValuedLinkedHashMap.fullCollection.version4.5.obj\");\n+//    }\n+\n+}\n",
  "problem_statement" : "[COLLECTIONS-533] Add ArrayListValuedLinkedHashMap\n\n- Main and test code inspired by (largely copied from) `ArrayListValuedHashMap`.\r\n- Unit tests cover the product code for 100%.\r\n- Bumped coverage for `ArrayListValuedHashMap` also to 100%, coming from 88% previously due to an uncovered copy constructor.",
  "hints_text" : null,
  "created_at" : "Mon Oct 14 21:37:44 CEST 2024",
  "version" : null,
  "FAIL_TO_PASS" : [ "ArrayListValuedLinkedHashMapTest", "ArrayListValuedHashMapTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=ArrayListValuedLinkedHashMapTest,ArrayListValuedHashMapTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 560,
  "metadata" : null
}, {
  "instance_id" : "apache-commons-collections-PR-501",
  "repo" : "apache/commons-collections",
  "base_commit" : "f59075822be96094129521ff831271b23ae67b64",
  "patch" : "diff --git a/src/main/java/org/apache/commons/collections4/bloomfilter/EnhancedDoubleHasher.java b/src/main/java/org/apache/commons/collections4/bloomfilter/EnhancedDoubleHasher.java\nindex 761803e49f..d82e10f57b 100644\n--- a/src/main/java/org/apache/commons/collections4/bloomfilter/EnhancedDoubleHasher.java\n+++ b/src/main/java/org/apache/commons/collections4/bloomfilter/EnhancedDoubleHasher.java\n@@ -167,42 +167,48 @@ public boolean processIndices(final IntPredicate consumer) {\n                 // hash[i] = ( h1(x) - i*h2(x) - (i*i*i - i)/6 ) wrapped in [0, bits)\n \n                 int index = BitMaps.mod(initial, bits);\n+                if (!consumer.test(index)) {\n+                    return false;\n+                }\n                 int inc = BitMaps.mod(increment, bits);\n \n                 final int k = shape.getNumberOfHashFunctions();\n-                if (k > bits) {\n-                    for (int j = k; j > 0;) {\n-                        // handle k > bits\n-                        final int block = Math.min(j, bits);\n-                        j -= block;\n-                        for (int i = 0; i < block; i++) {\n-                            if (!consumer.test(index)) {\n-                                return false;\n-                            }\n-                            // Update index and handle wrapping\n-                            index -= inc;\n-                            index = index < 0 ? index + bits : index;\n-\n-                            // Incorporate the counter into the increment to create a\n-                            // tetrahedral number additional term, and handle wrapping.\n-                            inc -= i;\n-                            inc = inc < 0 ? inc + bits : inc;\n-                        }\n-                    }\n-                } else {\n-                    for (int i = 0; i < k; i++) {\n+\n+                if (k >= bits) {\n+                    // the tetraheadral incrementer.  We need to ensure that this\n+                    // number does not exceed bits-1 or we may end up with an index > bits.\n+                    int tet = 1;\n+                    for (int i = 1; i < k; i++) {\n+                        // Update index and handle wrapping\n+                        index -= inc;\n+                        index = index < 0 ? index + bits : index;\n                         if (!consumer.test(index)) {\n                             return false;\n                         }\n+\n+                        // Incorporate the counter into the increment to create a\n+                        // tetrahedral number additional term, and handle wrapping.\n+                        inc -= tet;\n+                        inc = inc < 0 ? inc + bits : inc;\n+                        if (++tet == bits) {\n+                            tet = 0;\n+                        }\n+                    }\n+                } else {\n+                    for (int i = 1; i < k; i++) {\n                         // Update index and handle wrapping\n                         index -= inc;\n                         index = index < 0 ? index + bits : index;\n+                        if (!consumer.test(index)) {\n+                            return false;\n+                        }\n \n                         // Incorporate the counter into the increment to create a\n                         // tetrahedral number additional term, and handle wrapping.\n                         inc -= i;\n                         inc = inc < 0 ? inc + bits : inc;\n                     }\n+\n                 }\n                 return true;\n             }\n",
  "test_patch" : "diff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/EnhancedDoubleHasherTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/EnhancedDoubleHasherTest.java\nindex 8f14538316..73d2ee9c0c 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/EnhancedDoubleHasherTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/EnhancedDoubleHasherTest.java\n@@ -25,7 +25,7 @@\n  * Tests the {@link EnhancedDoubleHasher}.\n  */\n public class EnhancedDoubleHasherTest extends AbstractHasherTest {\n-    int[] expected = {1, 0, 71, 71, 1, 6, 15, 29, 49, 4, 39, 11, 65, 58, 63, 9, 41};\n+    int[] expected = {1, 0, 0, 2, 7, 16, 30, 50, 5, 40, 12, 66, 59, 64, 10, 42, 17};\n \n     @Override\n     protected Hasher createEmptyHasher() {\n",
  "problem_statement" : "[COLLECTIONS-855] Fixed hashing calculation as per report\n\nFix for [COLLECTIONS-855](https://issues.apache.org/jira/browse/COLLECTIONS-855)\r\n\r\nModified the loop counters as recommended in bug report.\r\nAdjusted test data accordingly.",
  "hints_text" : null,
  "created_at" : "Fri Jun 07 16:19:52 CEST 2024",
  "version" : null,
  "FAIL_TO_PASS" : [ "EnhancedDoubleHasherTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=EnhancedDoubleHasherTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 501,
  "metadata" : null
}, {
  "instance_id" : "apache-commons-collections-PR-492",
  "repo" : "apache/commons-collections",
  "base_commit" : "94c4c7c6678e8540e277166c65759b6d16a514cc",
  "patch" : "diff --git a/src/main/java/org/apache/commons/collections4/bloomfilter/ArrayCountingBloomFilter.java b/src/main/java/org/apache/commons/collections4/bloomfilter/ArrayCountingBloomFilter.java\nindex 746c5bf6eb..aac95f77e9 100644\n--- a/src/main/java/org/apache/commons/collections4/bloomfilter/ArrayCountingBloomFilter.java\n+++ b/src/main/java/org/apache/commons/collections4/bloomfilter/ArrayCountingBloomFilter.java\n@@ -46,7 +46,7 @@\n  * consumption of approximately 8 GB.\n  *\n  * @see Shape\n- * @see CellProducer\n+ * @see CellExtractor\n  * @since 4.5\n  */\n public final class ArrayCountingBloomFilter implements CountingBloomFilter {\n@@ -105,9 +105,9 @@ public ArrayCountingBloomFilter(final Shape shape) {\n     }\n \n     @Override\n-    public boolean add(final CellProducer other) {\n+    public boolean add(final CellExtractor other) {\n         Objects.requireNonNull(other, \"other\");\n-        other.forEachCell(this::add);\n+        other.processCells(this::add);\n         return isValid();\n     }\n \n@@ -151,13 +151,13 @@ public void clear() {\n     }\n \n     @Override\n-    public boolean contains(final BitMapProducer bitMapProducer) {\n-        return contains(IndexProducer.fromBitMapProducer(bitMapProducer));\n+    public boolean contains(final BitMapExtractor bitMapExtractor) {\n+        return contains(IndexExtractor.fromBitMapExtractor(bitMapExtractor));\n     }\n \n     @Override\n-    public boolean contains(final IndexProducer indexProducer) {\n-        return indexProducer.forEachIndex(idx -> this.cells[idx] != 0);\n+    public boolean contains(final IndexExtractor indexExtractor) {\n+        return indexExtractor.processIndices(idx -> this.cells[idx] != 0);\n     }\n \n     @Override\n@@ -166,9 +166,9 @@ public ArrayCountingBloomFilter copy() {\n     }\n \n     @Override\n-    public boolean forEachBitMap(final LongPredicate consumer) {\n+    public boolean processBitMaps(final LongPredicate consumer) {\n         Objects.requireNonNull(consumer, \"consumer\");\n-        final int blocksm1 = BitMap.numberOfBitMaps(cells.length) - 1;\n+        final int blocksm1 = BitMaps.numberOfBitMaps(cells.length) - 1;\n         int i = 0;\n         long value;\n         // must break final block separate as the number of bits may not fall on the long boundary\n@@ -176,7 +176,7 @@ public boolean forEachBitMap(final LongPredicate consumer) {\n             value = 0;\n             for (int k = 0; k < Long.SIZE; k++) {\n                 if (cells[i++] != 0) {\n-                    value |= BitMap.getLongBit(k);\n+                    value |= BitMaps.getLongBit(k);\n                 }\n             }\n             if (!consumer.test(value)) {\n@@ -187,14 +187,14 @@ public boolean forEachBitMap(final LongPredicate consumer) {\n         value = 0;\n         for (int k = 0; i < cells.length; k++) {\n             if (cells[i++] != 0) {\n-                value |= BitMap.getLongBit(k);\n+                value |= BitMaps.getLongBit(k);\n             }\n         }\n         return consumer.test(value);\n     }\n \n     @Override\n-    public boolean forEachCell(final CellProducer.CellConsumer consumer) {\n+    public boolean processCells(final CellPredicate consumer) {\n         Objects.requireNonNull(consumer, \"consumer\");\n         for (int i = 0; i < cells.length; i++) {\n             if (cells[i] != 0 && !consumer.test(i, cells[i])) {\n@@ -205,7 +205,7 @@ public boolean forEachCell(final CellProducer.CellConsumer consumer) {\n     }\n \n     @Override\n-    public boolean forEachIndex(final IntPredicate consumer) {\n+    public boolean processIndices(final IntPredicate consumer) {\n         Objects.requireNonNull(consumer, \"consumer\");\n         for (int i = 0; i < cells.length; i++) {\n             if (cells[i] != 0 && !consumer.test(i)) {\n@@ -221,9 +221,9 @@ public int getMaxCell() {\n     }\n \n     @Override\n-    public int getMaxInsert(final CellProducer cellProducer) {\n+    public int getMaxInsert(final CellExtractor cellExtractor) {\n         final int[] max = {Integer.MAX_VALUE};\n-        cellProducer.forEachCell( (x, y) -> {\n+        cellExtractor.processCells( (x, y) -> {\n             final int count = cells[x] / y;\n             if (count < max[0]) {\n                 max[0] = count;\n@@ -250,7 +250,7 @@ public Shape getShape() {\n      * generated invalid cells can be reversed by using the complement of the\n      * original operation with the same Bloom filter. This will restore the cells\n      * to the state prior to the invalid operation. Cells can then be extracted\n-     * using {@link #forEachCell(CellConsumer)}.</p>\n+     * using {@link #processCells(CellPredicate)}.</p>\n      */\n     @Override\n     public boolean isValid() {\n@@ -258,9 +258,9 @@ public boolean isValid() {\n     }\n \n     @Override\n-    public boolean subtract(final CellProducer other) {\n+    public boolean subtract(final CellExtractor other) {\n         Objects.requireNonNull(other, \"other\");\n-        other.forEachCell(this::subtract);\n+        other.processCells(this::subtract);\n         return isValid();\n     }\n \ndiff --git a/src/main/java/org/apache/commons/collections4/bloomfilter/BitMapProducer.java b/src/main/java/org/apache/commons/collections4/bloomfilter/BitMapExtractor.java\nsimilarity index 70%\nrename from src/main/java/org/apache/commons/collections4/bloomfilter/BitMapProducer.java\nrename to src/main/java/org/apache/commons/collections4/bloomfilter/BitMapExtractor.java\nindex 6ef8c5ecea..84659fc1dd 100644\n--- a/src/main/java/org/apache/commons/collections4/bloomfilter/BitMapProducer.java\n+++ b/src/main/java/org/apache/commons/collections4/bloomfilter/BitMapExtractor.java\n@@ -36,22 +36,22 @@\n  * @since 4.5\n  */\n @FunctionalInterface\n-public interface BitMapProducer {\n+public interface BitMapExtractor {\n \n     /**\n-     * Creates a BitMapProducer from an array of Long.\n+     * Creates a BitMapExtractor from an array of Long.\n      * @param bitMaps the bit maps to return.\n-     * @return a BitMapProducer.\n+     * @return a BitMapExtractor.\n      */\n-    static BitMapProducer fromBitMapArray(final long... bitMaps) {\n-        return new BitMapProducer() {\n+    static BitMapExtractor fromBitMapArray(final long... bitMaps) {\n+        return new BitMapExtractor() {\n             @Override\n             public long[] asBitMapArray() {\n                 return Arrays.copyOf(bitMaps, bitMaps.length);\n             }\n \n             @Override\n-            public boolean forEachBitMap(final LongPredicate predicate) {\n+            public boolean processBitMaps(final LongPredicate predicate) {\n                 for (final long word : bitMaps) {\n                     if (!predicate.test(word)) {\n                         return false;\n@@ -61,33 +61,32 @@ public boolean forEachBitMap(final LongPredicate predicate) {\n             }\n \n             @Override\n-            public boolean forEachBitMapPair(final BitMapProducer other, final LongBiPredicate func) {\n+            public boolean processBitMapPairs(final BitMapExtractor other, final LongBiPredicate func) {\n                 final CountingLongPredicate p = new CountingLongPredicate(bitMaps, func);\n-                return other.forEachBitMap(p) && p.forEachRemaining();\n+                return other.processBitMaps(p) && p.processRemaining();\n             }\n         };\n     }\n \n     /**\n-     * Creates a BitMapProducer from an IndexProducer.\n-     * @param producer the IndexProducer that specifies the indexes of the bits to enable.\n+     * Creates a BitMapExtractor from an IndexExtractor.\n+     * @param extractor the IndexExtractor that specifies the indexes of the bits to enable.\n      * @param numberOfBits the number of bits in the Bloom filter.\n-     * @return A BitMapProducer that produces the bit maps equivalent of the Indices from the producer.\n+     * @return A BitMapExtractor that produces the bit maps equivalent of the Indices from the extractor.\n      */\n-    static BitMapProducer fromIndexProducer(final IndexProducer producer, final int numberOfBits) {\n-        Objects.requireNonNull(producer, \"producer\");\n-        Objects.requireNonNull(numberOfBits, \"numberOfBits\");\n+    static BitMapExtractor fromIndexExtractor(final IndexExtractor extractor, final int numberOfBits) {\n+        Objects.requireNonNull(extractor, \"extractor\");\n \n-        final long[] result = new long[BitMap.numberOfBitMaps(numberOfBits)];\n-        producer.forEachIndex(i -> {\n-            BitMap.set(result, i);\n+        final long[] result = new long[BitMaps.numberOfBitMaps(numberOfBits)];\n+        extractor.processIndices(i -> {\n+            BitMaps.set(result, i);\n             return true;\n         });\n         return fromBitMapArray(result);\n     }\n \n     /**\n-     * Return a copy of the BitMapProducer data as a bit map array.\n+     * Return a copy of the BitMapExtractor data as a bit map array.\n      * <p>\n      * The default implementation of this method is slow. It is recommended\n      * that implementing classes reimplement this method.\n@@ -95,7 +94,7 @@ static BitMapProducer fromIndexProducer(final IndexProducer producer, final int\n      * @return An array of bit map data.\n      */\n     default long[] asBitMapArray() {\n-        class Bits {\n+        final class Bits {\n             private long[] data = new long[16];\n             private int size;\n \n@@ -117,7 +116,7 @@ long[] toArray() {\n             }\n         }\n         final Bits bits = new Bits();\n-        forEachBitMap(bits::add);\n+        processBitMaps(bits::add);\n         return bits.toArray();\n     }\n \n@@ -126,7 +125,7 @@ long[] toArray() {\n      * bit map value, if the predicate returns {@code false} the execution is stopped, {@code false}\n      * is returned, and no further bit maps are processed.\n      *\n-     * <p>If the producer is empty this method will return true.</p>\n+     * <p>If the extractor is empty this method will return true.</p>\n      *\n      * <p>Any exceptions thrown by the action are relayed to the caller.</p>\n      *\n@@ -134,22 +133,22 @@ long[] toArray() {\n      * @return {@code true} if all bit maps returned {@code true}, {@code false} otherwise.\n      * @throws NullPointerException if the specified consumer is null\n      */\n-    boolean forEachBitMap(LongPredicate predicate);\n+    boolean processBitMaps(LongPredicate predicate);\n \n     /**\n      * Applies the {@code func} to each bit map pair in order. Will apply all of the bit maps from the other\n-     * BitMapProducer to this producer. If this producer does not have as many bit maps it will provide 0 (zero)\n+     * BitMapExtractor to this extractor. If this extractor does not have as many bit maps it will provide 0 (zero)\n      * for all excess calls to the LongBiPredicate.\n      * <p>\n      * <em>The default implementation of this method uses {@code asBitMapArray()}. It is recommended that implementations\n-     * of BitMapProducer that have local arrays reimplement this method.</em></p>\n+     * of BitMapExtractor that have local arrays reimplement this method.</em></p>\n      *\n-     * @param other The other BitMapProducer that provides the y values in the (x,y) pair.\n+     * @param other The other BitMapExtractor that provides the y values in the (x,y) pair.\n      * @param func The function to apply.\n-     * @return A LongPredicate that tests this BitMapProducers bitmap values in order.\n+     * @return A LongPredicate that tests this BitMapExtractor's bitmap values in order.\n      */\n-    default boolean forEachBitMapPair(final BitMapProducer other, final LongBiPredicate func) {\n+    default boolean processBitMapPairs(final BitMapExtractor other, final LongBiPredicate func) {\n         final CountingLongPredicate p = new CountingLongPredicate(asBitMapArray(), func);\n-        return other.forEachBitMap(p) && p.forEachRemaining();\n+        return other.processBitMaps(p) && p.processRemaining();\n     }\n }\ndiff --git a/src/main/java/org/apache/commons/collections4/bloomfilter/BitMap.java b/src/main/java/org/apache/commons/collections4/bloomfilter/BitMaps.java\nsimilarity index 98%\nrename from src/main/java/org/apache/commons/collections4/bloomfilter/BitMap.java\nrename to src/main/java/org/apache/commons/collections4/bloomfilter/BitMaps.java\nindex 99fd96fd80..f08d3ad191 100644\n--- a/src/main/java/org/apache/commons/collections4/bloomfilter/BitMap.java\n+++ b/src/main/java/org/apache/commons/collections4/bloomfilter/BitMaps.java\n@@ -20,11 +20,11 @@\n  * Contains functions to convert {@code int} indices into Bloom filter bit positions and visa versa.\n  *\n  * <p>The functions view an array of longs as a collection of bit maps each containing 64 bits. The bits are arranged\n- * in memory as a little-endian long value. This matches the requirements of the BitMapProducer interface.</p>\n+ * in memory as a little-endian long value. This matches the requirements of the BitMapExtractor interface.</p>\n  *\n  * @since 4.5\n  */\n-public class BitMap {\n+public class BitMaps {\n     /** A bit shift to apply to an integer to divided by 64 (2^6). */\n     private static final int DIVIDE_BY_64 = 6;\n \n@@ -136,6 +136,6 @@ public static void set(final long[] bitMaps, final int bitIndex) {\n     }\n \n     /** Do not instantiate. */\n-    private BitMap() {\n+    private BitMaps() {\n     }\n }\ndiff --git a/src/main/java/org/apache/commons/collections4/bloomfilter/BloomFilter.java b/src/main/java/org/apache/commons/collections4/bloomfilter/BloomFilter.java\nindex 41ec91058b..3fcdf6c94e 100644\n--- a/src/main/java/org/apache/commons/collections4/bloomfilter/BloomFilter.java\n+++ b/src/main/java/org/apache/commons/collections4/bloomfilter/BloomFilter.java\n@@ -21,13 +21,13 @@\n /**\n  * The interface that describes a Bloom filter.\n  * <p>\n- * <em>See implementation notes for BitMapProducer and IndexProducer.</em>\n+ * <em>See implementation notes for BitMapExtractor and IndexExtractor.</em>\n  * </p>\n- * @see BitMapProducer\n- * @see IndexProducer\n+ * @see BitMapExtractor\n+ * @see IndexExtractor\n  * @since 4.5\n  */\n-public interface BloomFilter extends IndexProducer, BitMapProducer {\n+public interface BloomFilter extends IndexExtractor, BitMapExtractor {\n \n     /**\n      * The sparse characteristic used to determine the best method for matching.\n@@ -64,13 +64,13 @@ public interface BloomFilter extends IndexProducer, BitMapProducer {\n \n     /**\n      * Returns {@code true} if this filter contains the bits specified in the bit maps produced by the\n-     * bitMapProducer.\n+     * bitMapExtractor.\n      *\n-     * @param bitMapProducer the {@code BitMapProducer} to provide the bit maps.\n+     * @param bitMapExtractor the {@code BitMapExtractor} to provide the bit maps.\n      * @return {@code true} if this filter is enabled for all bits specified by the bit maps\n      */\n-    default boolean contains(final BitMapProducer bitMapProducer) {\n-        return forEachBitMapPair(bitMapProducer, (x, y) -> (x & y) == y);\n+    default boolean contains(final BitMapExtractor bitMapExtractor) {\n+        return processBitMapPairs(bitMapExtractor, (x, y) -> (x & y) == y);\n     }\n \n     /**\n@@ -86,7 +86,7 @@ default boolean contains(final BitMapProducer bitMapProducer) {\n      */\n     default boolean contains(final BloomFilter other) {\n         Objects.requireNonNull(other, \"other\");\n-        return (characteristics() & SPARSE) != 0 ? contains((IndexProducer) other) : contains((BitMapProducer) other);\n+        return (characteristics() & SPARSE) != 0 ? contains((IndexExtractor) other) : contains((BitMapExtractor) other);\n     }\n \n     /**\n@@ -106,15 +106,15 @@ default boolean contains(final Hasher hasher) {\n     }\n \n     /**\n-     * Returns {@code true} if this filter contains the indices specified IndexProducer.\n+     * Returns {@code true} if this filter contains the indices specified IndexExtractor.\n      *\n      * <p>Specifically this returns {@code true} if this filter is enabled for all bit indexes\n-     * identified by the {@code IndexProducer}.</p>\n+     * identified by the {@code IndexExtractor}.</p>\n      *\n-     * @param indexProducer the IndexProducer to provide the indexes\n-     * @return {@code true} if this filter is enabled for all bits specified by the IndexProducer\n+     * @param indexExtractor the IndexExtractor to provide the indexes\n+     * @return {@code true} if this filter is enabled for all bits specified by the IndexExtractor\n      */\n-    boolean contains(IndexProducer indexProducer);\n+    boolean contains(IndexExtractor indexExtractor);\n \n     /**\n      * Creates a new instance of the BloomFilter with the same properties as the current one.\n@@ -245,7 +245,7 @@ default int estimateUnion(final BloomFilter other) {\n      * @return {@code true} if no bits are enabled, {@code false} otherwise.\n      */\n     default boolean isEmpty() {\n-        return forEachBitMap(y -> y == 0);\n+        return processBitMaps(y -> y == 0);\n     }\n \n     /**\n@@ -261,18 +261,18 @@ default boolean isFull() {\n \n     /**\n      * Merges the specified hasher into this Bloom filter. Specifically all\n-     * bit indexes that are identified by the {@code producer} will be enabled in this filter.\n+     * bit indexes that are identified by the {@code bitMapExtractor} will be enabled in this filter.\n      *\n      * <p><em>Note: This method should return {@code true} even if no additional bit indexes were\n      * enabled. A {@code false} result indicates that this filter may or may not contain all the indexes\n-     * enabled in the {@code producer}.</em>  This state may occur in complex Bloom filter implementations like\n+     * enabled in the {@code bitMapExtractor}.</em>  This state may occur in complex Bloom filter implementations like\n      * counting Bloom filters.</p>\n      *\n-     * @param bitMapProducer The producer to merge.\n+     * @param bitMapExtractor The BitMapExtractor to merge.\n      * @return true if the merge was successful\n-     * @throws IllegalArgumentException if producer sends illegal value.\n+     * @throws IllegalArgumentException if bitMapExtractor sends illegal value.\n      */\n-    boolean merge(BitMapProducer bitMapProducer);\n+    boolean merge(BitMapExtractor bitMapExtractor);\n \n     /**\n      * Merges the specified Bloom filter into this Bloom filter.\n@@ -289,7 +289,7 @@ default boolean isFull() {\n      * @return true if the merge was successful\n      */\n     default boolean merge(final BloomFilter other) {\n-        return (characteristics() & SPARSE) != 0 ? merge((IndexProducer) other) : merge((BitMapProducer) other);\n+        return (characteristics() & SPARSE) != 0 ? merge((IndexExtractor) other) : merge((BitMapExtractor) other);\n     }\n \n     /**\n@@ -311,25 +311,25 @@ default boolean merge(final Hasher hasher) {\n     }\n \n     /**\n-     * Merges the specified IndexProducer into this Bloom filter. Specifically all\n-     * bit indexes that are identified by the {@code producer} will be enabled in this filter.\n+     * Merges the specified IndexExtractor into this Bloom filter. Specifically all\n+     * bit indexes that are identified by the {@code indexExtractor} will be enabled in this filter.\n      *\n      * <p><em>Note: This method should return {@code true} even if no additional bit indexes were\n      * enabled. A {@code false} result indicates that this filter may or may not contain all the indexes of\n-     * the {@code producer}.</em>  This state may occur in complex Bloom filter implementations like\n+     * the {@code indexExtractor}.</em>  This state may occur in complex Bloom filter implementations like\n      * counting Bloom filters.</p>\n      *\n-     * @param indexProducer The IndexProducer to merge.\n+     * @param indexExtractor The IndexExtractor to merge.\n      * @return true if the merge was successful\n-     * @throws IllegalArgumentException if producer sends illegal value.\n+     * @throws IllegalArgumentException if indexExtractor sends illegal value.\n      */\n-    boolean merge(IndexProducer indexProducer);\n+    boolean merge(IndexExtractor indexExtractor);\n \n     /**\n-     * Most Bloom filters create unique IndexProducers.\n+     * Most Bloom filters create unique IndexExtractors.\n      */\n     @Override\n-    default IndexProducer uniqueIndices() {\n+    default IndexExtractor uniqueIndices() {\n         return this;\n     }\n }\ndiff --git a/src/main/java/org/apache/commons/collections4/bloomfilter/BloomFilterProducer.java b/src/main/java/org/apache/commons/collections4/bloomfilter/BloomFilterExtractor.java\nsimilarity index 76%\nrename from src/main/java/org/apache/commons/collections4/bloomfilter/BloomFilterProducer.java\nrename to src/main/java/org/apache/commons/collections4/bloomfilter/BloomFilterExtractor.java\nindex 280813ff72..7ad82713e6 100644\n--- a/src/main/java/org/apache/commons/collections4/bloomfilter/BloomFilterProducer.java\n+++ b/src/main/java/org/apache/commons/collections4/bloomfilter/BloomFilterExtractor.java\n@@ -27,10 +27,11 @@\n  *\n  * @since 4.5\n  */\n-public interface BloomFilterProducer {\n+@FunctionalInterface\n+public interface BloomFilterExtractor {\n \n     /**\n-     * Creates a BloomFilterProducer from an array of Bloom filters.\n+     * Creates a BloomFilterExtractor from an array of Bloom filters.\n      *\n      * <ul>\n      * <li>The asBloomFilterArray() method returns a copy of the original array\n@@ -39,12 +40,12 @@ public interface BloomFilterProducer {\n      * </ul>\n      * <p><em>All modifications to the Bloom filters are reflected in the original filters</em></p>\n      *\n-     * @param filters The filters to be returned by the producer.\n-     * @return THe BloomFilterProducer containing the filters.\n+     * @param filters The filters to be returned by the extractor.\n+     * @return THe BloomFilterExtractor containing the filters.\n      */\n-    static BloomFilterProducer fromBloomFilterArray(final BloomFilter... filters) {\n+    static BloomFilterExtractor fromBloomFilterArray(final BloomFilter... filters) {\n         Objects.requireNonNull(filters, \"filters\");\n-        return new BloomFilterProducer() {\n+        return new BloomFilterExtractor() {\n             /**\n              * This implementation returns a copy the original array, the contained Bloom filters\n              * are references to the originals, any modifications to them are reflected in the original\n@@ -56,7 +57,7 @@ public BloomFilter[] asBloomFilterArray() {\n             }\n \n             @Override\n-            public boolean forEachBloomFilter(final Predicate<BloomFilter> predicate) {\n+            public boolean processBloomFilters(final Predicate<BloomFilter> predicate) {\n                 for (final BloomFilter filter : filters) {\n                     if (!predicate.test(filter)) {\n                         return false;\n@@ -70,10 +71,10 @@ public boolean forEachBloomFilter(final Predicate<BloomFilter> predicate) {\n              * filters are reflected in the originals.\n              */\n             @Override\n-            public boolean forEachBloomFilterPair(final BloomFilterProducer other,\n-                    final BiPredicate<BloomFilter, BloomFilter> func) {\n+            public boolean processBloomFilterPair(final BloomFilterExtractor other,\n+                                                  final BiPredicate<BloomFilter, BloomFilter> func) {\n                 final CountingPredicate<BloomFilter> p = new CountingPredicate<>(filters, func);\n-                return other.forEachBloomFilter(p) && p.forEachRemaining();\n+                return other.processBloomFilters(p) && p.processRemaining();\n             }\n         };\n     }\n@@ -88,7 +89,7 @@ public boolean forEachBloomFilterPair(final BloomFilterProducer other,\n      */\n     default BloomFilter[] asBloomFilterArray() {\n         final List<BloomFilter> filters = new ArrayList<>();\n-        forEachBloomFilter(f -> filters.add(f.copy()));\n+        processBloomFilters(f -> filters.add(f.copy()));\n         return filters.toArray(new BloomFilter[0]);\n     }\n \n@@ -100,7 +101,7 @@ default BloomFilter[] asBloomFilterArray() {\n      */\n     default BloomFilter flatten() {\n         final BloomFilter[] bf = {null};\n-        forEachBloomFilter( x -> {\n+        processBloomFilters(x -> {\n             if (bf[0] == null) {\n                 bf[0] = new SimpleBloomFilter( x.getShape());\n             }\n@@ -117,27 +118,27 @@ default BloomFilter flatten() {\n      * @return {@code false} when the first filter fails the predicate test. Returns\n      *         {@code true} if all filters pass the test.\n      */\n-    boolean forEachBloomFilter(Predicate<BloomFilter> bloomFilterPredicate);\n+    boolean processBloomFilters(Predicate<BloomFilter> bloomFilterPredicate);\n \n     /**\n      * Applies the {@code func} to each Bloom filter pair in order. Will apply all\n-     * of the Bloom filters from the other BloomFilterProducer to this producer. If\n-     * either {@code this} producer or {@code other} producer has fewer BloomFilters\n+     * of the Bloom filters from the other BloomFilterExtractor to this extractor. If\n+     * either {@code this} extractor or {@code other} extractor has fewer BloomFilters\n      * ths method will provide {@code null} for all excess calls to the {@code func}.\n      *\n      * <p><em>This implementation returns references to the Bloom filter.  Other implementations\n      * should specify if the array contains deep copies, immutable instances,\n      * or references to the filters in the collection.</em></p>\n      *\n-     * @param other The other BloomFilterProducer that provides the y values in the\n+     * @param other The other BloomFilterExtractor that provides the y values in the\n      *              (x,y) pair.\n      * @param func  The function to apply.\n      * @return {@code true} if the {@code func} returned {@code true} for every pair,\n      *         {@code false} otherwise.\n      */\n-    default boolean forEachBloomFilterPair(final BloomFilterProducer other,\n-            final BiPredicate<BloomFilter, BloomFilter> func) {\n+    default boolean processBloomFilterPair(final BloomFilterExtractor other,\n+                                           final BiPredicate<BloomFilter, BloomFilter> func) {\n         final CountingPredicate<BloomFilter> p = new CountingPredicate<>(asBloomFilterArray(), func);\n-        return other.forEachBloomFilter(p) && p.forEachRemaining();\n+        return other.processBloomFilters(p) && p.processRemaining();\n     }\n }\ndiff --git a/src/main/java/org/apache/commons/collections4/bloomfilter/CellProducer.java b/src/main/java/org/apache/commons/collections4/bloomfilter/CellExtractor.java\nsimilarity index 74%\nrename from src/main/java/org/apache/commons/collections4/bloomfilter/CellProducer.java\nrename to src/main/java/org/apache/commons/collections4/bloomfilter/CellExtractor.java\nindex 928f1d4e66..6ff79374ec 100644\n--- a/src/main/java/org/apache/commons/collections4/bloomfilter/CellProducer.java\n+++ b/src/main/java/org/apache/commons/collections4/bloomfilter/CellExtractor.java\n@@ -22,26 +22,26 @@\n \n /**\n  * Some Bloom filter implementations use a count rather than a bit flag. The term {@code Cell} is used to\n- * refer to these counts and their associated index.  This class is the equivalent of the index producer except\n+ * refer to these counts and their associated index.  This class is the equivalent of the index extractor except\n  * that it produces cells.\n  *\n- * <p>Note that a CellProducer must not return duplicate indices and must be ordered.</p>\n+ * <p>Note that a CellExtractor must not return duplicate indices and must be ordered.</p>\n  *\n  * <p>Implementations must guarantee that:</p>\n  *\n  * <ul>\n- * <li>The IndexProducer implementation returns unique ordered indices.</li>\n- * <li>The cells are produced in IndexProducer order.</li>\n- * <li>For every value produced by the IndexProducer there will be only one matching\n- * cell produced by the CellProducer.</li>\n- * <li>The CellProducer will not generate cells with indices that are not output by the IndexProducer.</li>\n- * <li>The IndexProducer will not generate indices that have a zero count for the cell.</li>\n+ * <li>The IndexExtractor implementation returns unique ordered indices.</li>\n+ * <li>The cells are produced in IndexExtractor order.</li>\n+ * <li>For every value produced by the IndexExtractor there will be only one matching\n+ * cell produced by the CellExtractor.</li>\n+ * <li>The CellExtractor will not generate cells with indices that are not output by the IndexExtractor.</li>\n+ * <li>The IndexExtractor will not generate indices that have a zero count for the cell.</li>\n  * </ul>\n  *\n  * @since 4.5\n  */\n @FunctionalInterface\n-public interface CellProducer extends IndexProducer {\n+public interface CellExtractor extends IndexExtractor {\n \n     /**\n      * Represents an operation that accepts an {@code <index, count>} pair.\n@@ -51,7 +51,7 @@ public interface CellProducer extends IndexProducer {\n      * {@link java.util.function.BiPredicate} for {@code int}.</p>\n      */\n     @FunctionalInterface\n-    interface CellConsumer {\n+    interface CellPredicate {\n         /**\n          * Performs an operation on the given {@code <index, count>} pair.\n          *\n@@ -63,15 +63,15 @@ interface CellConsumer {\n     }\n \n     /**\n-     * Creates a CellProducer from an IndexProducer.\n+     * Creates a CellExtractor from an IndexExtractor.\n      *\n      * <p>Note the following properties:\n      * <ul>\n-     * <li>Each index returned from the IndexProducer is assumed to have a cell value of 1.</li>\n-     * <li>The CellProducer aggregates duplicate indices from the IndexProducer.</li>\n+     * <li>Each index returned from the IndexExtractor is assumed to have a cell value of 1.</li>\n+     * <li>The CellExtractor aggregates duplicate indices from the IndexExtractor.</li>\n      * </ul>\n      *\n-     * <p>A CellProducer that outputs the mapping [(1,2),(2,3),(3,1)] can be created from many combinations\n+     * <p>A CellExtractor that outputs the mapping [(1,2),(2,3),(3,1)] can be created from many combinations\n      * of indices including:\n      * <pre>\n      * [1, 1, 2, 2, 2, 3]\n@@ -80,11 +80,11 @@ interface CellConsumer {\n      * ...\n      * </pre>\n      *\n-     * @param producer An index producer.\n-     * @return A CellProducer with the same indices as the IndexProducer.\n+     * @param indexExtractor An index indexExtractor.\n+     * @return A CellExtractor with the same indices as the IndexExtractor.\n      */\n-    static CellProducer from(final IndexProducer producer) {\n-        return new CellProducer() {\n+    static CellExtractor from(final IndexExtractor indexExtractor) {\n+        return new CellExtractor() {\n             /**\n              * Class to track cell values in the TreeMap.\n              */\n@@ -112,7 +112,7 @@ public int[] asIndexArray() {\n             }\n \n             @Override\n-            public boolean forEachCell(final CellConsumer consumer) {\n+            public boolean processCells(final CellPredicate consumer) {\n                 populate();\n                 for (final CounterCell cell : counterCells.values()) {\n                     if (!consumer.test(cell.idx, cell.count)) {\n@@ -124,7 +124,7 @@ public boolean forEachCell(final CellConsumer consumer) {\n \n             private void populate() {\n                 if (counterCells.isEmpty()) {\n-                    producer.forEachIndex( idx -> {\n+                    indexExtractor.processIndices(idx -> {\n                         final CounterCell cell = new CounterCell(idx, 1);\n                         final CounterCell counter = counterCells.get(cell);\n                         if (counter == null) {\n@@ -153,18 +153,18 @@ private void populate() {\n      * @return {@code true} if all cells return true from consumer, {@code false} otherwise.\n      * @throws NullPointerException if the specified consumer is null\n      */\n-    boolean forEachCell(CellConsumer consumer);\n+    boolean processCells(CellPredicate consumer);\n \n     /**\n      * The default implementation returns distinct and ordered indices for all cells with a non-zero count.\n      */\n     @Override\n-    default boolean forEachIndex(final IntPredicate predicate) {\n-        return forEachCell((i, v) -> predicate.test(i));\n+    default boolean processIndices(final IntPredicate predicate) {\n+        return processCells((i, v) -> predicate.test(i));\n     }\n \n     @Override\n-    default IndexProducer uniqueIndices() {\n+    default IndexExtractor uniqueIndices() {\n         return this;\n     }\n }\ndiff --git a/src/main/java/org/apache/commons/collections4/bloomfilter/CountingBloomFilter.java b/src/main/java/org/apache/commons/collections4/bloomfilter/CountingBloomFilter.java\nindex 503bde72d1..af1ef43287 100644\n--- a/src/main/java/org/apache/commons/collections4/bloomfilter/CountingBloomFilter.java\n+++ b/src/main/java/org/apache/commons/collections4/bloomfilter/CountingBloomFilter.java\n@@ -51,15 +51,15 @@\n  * of the filter after such an operation. For example are the cells not updated,\n  * partially updated or updated entirely before the exception is raised.</p>\n  *\n- * @see CellProducer\n+ * @see CellExtractor\n  * @since 4.5\n  */\n-public interface CountingBloomFilter extends BloomFilter, CellProducer {\n+public interface CountingBloomFilter extends BloomFilter, CellExtractor {\n \n     // Query Operations\n \n     /**\n-     * Adds the specified CellProducer to this Bloom filter.\n+     * Adds the specified CellExtractor to this Bloom filter.\n      *\n      * <p>Specifically\n      * all cells for the indexes identified by the {@code other} will be incremented\n@@ -67,12 +67,12 @@ public interface CountingBloomFilter extends BloomFilter, CellProducer {\n      *\n      * <p>This method will return {@code true} if the filter is valid after the operation.</p>\n      *\n-     * @param other the CellProducer to add.\n+     * @param other the CellExtractor to add.\n      * @return {@code true} if the addition was successful and the state is valid\n      * @see #isValid()\n-     * @see #subtract(CellProducer)\n+     * @see #subtract(CellExtractor)\n      */\n-    boolean add(CellProducer other);\n+    boolean add(CellExtractor other);\n \n     /**\n      * Creates a new instance of the CountingBloomFilter with the same properties as the current one.\n@@ -88,19 +88,19 @@ public interface CountingBloomFilter extends BloomFilter, CellProducer {\n     int getMaxCell();\n \n     /**\n-     * Determines the maximum number of times the BitMapProducer could have been merged into this\n+     * Determines the maximum number of times the BitMapExtractor could have been merged into this\n      * counting filter.\n-     * @param bitMapProducer the BitMapProducer to provide the indices.\n-     * @return the maximum number of times the BitMapProducer could have been inserted.\n+     * @param bitMapExtractor the BitMapExtractor to provide the indices.\n+     * @return the maximum number of times the BitMapExtractor could have been inserted.\n      */\n-    default int getMaxInsert(final BitMapProducer bitMapProducer) {\n-        if (!contains(bitMapProducer)) {\n+    default int getMaxInsert(final BitMapExtractor bitMapExtractor) {\n+        if (!contains(bitMapExtractor)) {\n             return 0;\n         }\n-        final long[] bitMaps = bitMapProducer.asBitMapArray();\n+        final long[] bitMaps = bitMapExtractor.asBitMapArray();\n         final int[] max = { Integer.MAX_VALUE };\n-        forEachCell((x, y) -> {\n-            if ((bitMaps[BitMap.getLongIndex(x)] & BitMap.getLongBit(x)) != 0) {\n+        processCells((x, y) -> {\n+            if ((bitMaps[BitMaps.getLongIndex(x)] & BitMaps.getLongBit(x)) != 0) {\n                 max[0] = max[0] <= y ? max[0] : y;\n             }\n             return true;\n@@ -115,15 +115,15 @@ default int getMaxInsert(final BitMapProducer bitMapProducer) {\n      * @return the maximum number of times the Bloom filter could have been inserted.\n      */\n     default int getMaxInsert(final BloomFilter bloomFilter) {\n-        return getMaxInsert((BitMapProducer) bloomFilter);\n+        return getMaxInsert((BitMapExtractor) bloomFilter);\n     }\n \n     /**\n-     * Determines the maximum number of times the Cell Producer could have been add.\n-     * @param cellProducer the producer of cells.\n-     * @return the maximum number of times the CellProducer could have been inserted.\n+     * Determines the maximum number of times the Cell Extractor could have been added.\n+     * @param cellExtractor the extractor of cells.\n+     * @return the maximum number of times the CellExtractor could have been inserted.\n      */\n-    int getMaxInsert(CellProducer cellProducer);\n+    int getMaxInsert(CellExtractor cellExtractor);\n \n     /**\n      * Determines the maximum number of times the Hasher could have been merged into this\n@@ -138,16 +138,16 @@ default int getMaxInsert(final Hasher hasher) {\n     // Modification Operations\n \n     /**\n-     * Determines the maximum number of times the IndexProducer could have been merged\n+     * Determines the maximum number of times the IndexExtractor could have been merged\n      * into this counting filter.\n-     * <p>To determine how many times an indxProducer could have been added create a CellProducer\n-     * from the indexProducer and check that</p>\n-     * @param idxProducer the producer to drive the count check.\n-     * @return the maximum number of times the IndexProducer could have been inserted.\n-     * @see #getMaxInsert(CellProducer)\n+     * <p>To determine how many times an indexExtractor could have been added create a CellExtractor\n+     * from the indexExtractor and check that</p>\n+     * @param indexExtractor the extractor to drive the count check.\n+     * @return the maximum number of times the IndexExtractor could have been inserted.\n+     * @see #getMaxInsert(CellExtractor)\n      */\n-    default int getMaxInsert(final IndexProducer idxProducer) {\n-        return getMaxInsert(CellProducer.from(idxProducer.uniqueIndices()) );\n+    default int getMaxInsert(final IndexExtractor indexExtractor) {\n+        return getMaxInsert(CellExtractor.from(indexExtractor.uniqueIndices()) );\n     }\n \n     /**\n@@ -172,21 +172,20 @@ default int getMaxInsert(final IndexProducer idxProducer) {\n     boolean isValid();\n \n     /**\n-     * Merges the specified BitMap producer into this Bloom filter.\n+     * Merges the specified BitMap extractor into this Bloom filter.\n      *\n-     * <p>Specifically: all cells for the indexes identified by the {@code bitMapProducer} will be incremented by 1.</p>\n+     * <p>Specifically: all cells for the indexes identified by the {@code bitMapExtractor} will be incremented by 1.</p>\n      *\n      * <p>This method will return {@code true} if the filter is valid after the operation.</p>\n      *\n-     * @param bitMapProducer the BitMapProducer\n+     * @param bitMapExtractor the BitMapExtractor\n      * @return {@code true} if the removal was successful and the state is valid\n      * @see #isValid()\n-     * @see #add(CellProducer)\n+     * @see #add(CellExtractor)\n      */\n     @Override\n-    default boolean merge(final BitMapProducer bitMapProducer) {\n-        Objects.requireNonNull(bitMapProducer, \"bitMapProducer\");\n-        return merge(IndexProducer.fromBitMapProducer(bitMapProducer));\n+    default boolean merge(final BitMapExtractor bitMapExtractor) {\n+        return merge(IndexExtractor.fromBitMapExtractor(bitMapExtractor));\n     }\n \n     /**\n@@ -195,19 +194,19 @@ default boolean merge(final BitMapProducer bitMapProducer) {\n      * <p>Specifically: all cells for the indexes identified by the {@code other} filter will be incremented by 1.</p>\n      *\n      * <p>Note: If the other filter is a counting Bloom filter the other filter's cells are ignored and it is treated as an\n-     * IndexProducer.</p>\n+     * IndexExtractor.</p>\n      *\n      * <p>This method will return {@code true} if the filter is valid after the operation.</p>\n      *\n      * @param other the other Bloom filter\n      * @return {@code true} if the removal was successful and the state is valid\n      * @see #isValid()\n-     * @see #add(CellProducer)\n+     * @see #add(CellExtractor)\n      */\n     @Override\n     default boolean merge(final BloomFilter other) {\n         Objects.requireNonNull(other, \"other\");\n-        return merge((IndexProducer) other);\n+        return merge((IndexExtractor) other);\n     }\n \n     /**\n@@ -220,7 +219,7 @@ default boolean merge(final BloomFilter other) {\n      * @param hasher the hasher\n      * @return {@code true} if the removal was successful and the state is valid\n      * @see #isValid()\n-     * @see #add(CellProducer)\n+     * @see #add(CellExtractor)\n      */\n     @Override\n     default boolean merge(final Hasher hasher) {\n@@ -229,25 +228,28 @@ default boolean merge(final Hasher hasher) {\n     }\n \n     /**\n-     * Merges the specified index producer into this Bloom filter.\n+     * Merges the specified index extractor into this Bloom filter.\n      *\n-     * <p>Specifically: all unique cells for the indices identified by the {@code indexProducer} will be incremented by 1.</p>\n+     * <p>Specifically: all unique cells for the indices identified by the {@code indexExtractor} will be incremented by 1.</p>\n      *\n      * <p>This method will return {@code true} if the filter is valid after the operation.</p>\n      *\n-     * <p>Note: If indices that are returned multiple times should be incremented multiple times convert the IndexProducer\n-     * to a CellProducer and add that.</p>\n-     *\n-     * @param indexProducer the IndexProducer\n+     * <p>Notes:</p>\n+     * <ul>\n+     * <li>If indices that are returned multiple times should be incremented multiple times convert the IndexExtractor\n+     * to a CellExtractor and add that.</li>\n+     * <li>Implementations should throw {@code IllegalArgumentException} and no other exception on bad input.</li>\n+     * </ul>\n+     * @param indexExtractor the IndexExtractor\n      * @return {@code true} if the removal was successful and the state is valid\n      * @see #isValid()\n-     * @see #add(CellProducer)\n+     * @see #add(CellExtractor)\n      */\n     @Override\n-    default boolean merge(final IndexProducer indexProducer) {\n-        Objects.requireNonNull(indexProducer, \"indexProducer\");\n+    default boolean merge(final IndexExtractor indexExtractor) {\n+        Objects.requireNonNull(indexExtractor, \"indexExtractor\");\n         try {\n-            return add(CellProducer.from(indexProducer.uniqueIndices()));\n+            return add(CellExtractor.from(indexExtractor.uniqueIndices()));\n         } catch (final IndexOutOfBoundsException e) {\n             throw new IllegalArgumentException(\n                     String.format(\"Filter only accepts values in the [0,%d) range\", getShape().getNumberOfBits()), e);\n@@ -255,21 +257,20 @@ default boolean merge(final IndexProducer indexProducer) {\n     }\n \n     /**\n-     * Removes the specified BitMapProducer from this Bloom filter.\n+     * Removes the specified BitMapExtractor from this Bloom filter.\n      *\n-     * <p>Specifically all cells for the indices produced by the {@code bitMapProducer} will be\n+     * <p>Specifically all cells for the indices produced by the {@code bitMapExtractor} will be\n      * decremented by 1.</p>\n      *\n      * <p>This method will return {@code true} if the filter is valid after the operation.</p>\n      *\n-     * @param bitMapProducer the BitMapProducer to provide the indexes\n+     * @param bitMapExtractor the BitMapExtractor to provide the indexes\n      * @return {@code true} if the removal was successful and the state is valid\n      * @see #isValid()\n-     * @see #subtract(CellProducer)\n+     * @see #subtract(CellExtractor)\n      */\n-    default boolean remove(final BitMapProducer bitMapProducer) {\n-        Objects.requireNonNull(bitMapProducer, \"bitMapProducer\");\n-        return remove(IndexProducer.fromBitMapProducer(bitMapProducer));\n+    default boolean remove(final BitMapExtractor bitMapExtractor) {\n+        return remove(IndexExtractor.fromBitMapExtractor(bitMapExtractor));\n     }\n \n     /**\n@@ -278,18 +279,17 @@ default boolean remove(final BitMapProducer bitMapProducer) {\n      * <p>Specifically: all cells for the indexes identified by the {@code other} filter will be decremented by 1.</p>\n      *\n      * <p>Note: If the other filter is a counting Bloom filter the other filter's cells are ignored and it is treated as an\n-     * IndexProducer.</p>\n+     * IndexExtractor.</p>\n      *\n      * <p>This method will return {@code true} if the filter is valid after the operation.</p>\n      *\n      * @param other the other Bloom filter\n      * @return {@code true} if the removal was successful and the state is valid\n      * @see #isValid()\n-     * @see #subtract(CellProducer)\n+     * @see #subtract(CellExtractor)\n      */\n     default boolean remove(final BloomFilter other) {\n-        Objects.requireNonNull(other, \"other\");\n-        return remove((IndexProducer) other);\n+        return remove((IndexExtractor) other);\n     }\n \n     /**\n@@ -303,7 +303,7 @@ default boolean remove(final BloomFilter other) {\n      * @param hasher the hasher to provide the indexes\n      * @return {@code true} if the removal was successful and the state is valid\n      * @see #isValid()\n-     * @see #subtract(CellProducer)\n+     * @see #subtract(CellExtractor)\n      */\n     default boolean remove(final Hasher hasher) {\n         Objects.requireNonNull(hasher, \"hasher\");\n@@ -311,25 +311,25 @@ default boolean remove(final Hasher hasher) {\n     }\n \n     /**\n-     * Removes the values from the specified IndexProducer from the Bloom filter from this Bloom filter.\n+     * Removes the values from the specified IndexExtractor from the Bloom filter from this Bloom filter.\n      *\n      * <p>Specifically all cells for the unique indices produced by the {@code hasher} will be\n      * decremented by 1.</p>\n      *\n      * <p>This method will return {@code true} if the filter is valid after the operation.</p>\n      *\n-     * <p>Note: If indices that are returned multiple times should be decremented multiple times convert the IndexProducer\n-     * to a CellProducer and subtract that.</p>\n+     * <p>Note: If indices that are returned multiple times should be decremented multiple times convert the IndexExtractor\n+     * to a CellExtractor and subtract that.</p>\n      *\n-     * @param indexProducer the IndexProducer to provide the indexes\n+     * @param indexExtractor the IndexExtractor to provide the indexes\n      * @return {@code true} if the removal was successful and the state is valid\n      * @see #isValid()\n-     * @see #subtract(CellProducer)\n+     * @see #subtract(CellExtractor)\n      */\n-    default boolean remove(final IndexProducer indexProducer) {\n-        Objects.requireNonNull(indexProducer, \"indexProducer\");\n+    default boolean remove(final IndexExtractor indexExtractor) {\n+        Objects.requireNonNull(indexExtractor, \"indexExtractor\");\n         try {\n-            return subtract(CellProducer.from(indexProducer.uniqueIndices()));\n+            return subtract(CellExtractor.from(indexExtractor.uniqueIndices()));\n         } catch (final IndexOutOfBoundsException e) {\n             throw new IllegalArgumentException(\n                     String.format(\"Filter only accepts values in the [0,%d) range\", getShape().getNumberOfBits()));\n@@ -338,7 +338,7 @@ default boolean remove(final IndexProducer indexProducer) {\n \n \n     /**\n-     * Adds the specified CellProducer to this Bloom filter.\n+     * Adds the specified CellExtractor to this Bloom filter.\n      *\n      * <p>Specifically\n      * all cells for the indexes identified by the {@code other} will be decremented\n@@ -346,15 +346,19 @@ default boolean remove(final IndexProducer indexProducer) {\n      *\n      * <p>This method will return true if the filter is valid after the operation.</p>\n      *\n-     * @param other the CellProducer to subtract.\n+     * @param other the CellExtractor to subtract.\n      * @return {@code true} if the subtraction was successful and the state is valid\n      * @see #isValid()\n-     * @see #add(CellProducer)\n+     * @see #add(CellExtractor)\n      */\n-    boolean subtract(CellProducer other);\n+    boolean subtract(CellExtractor other);\n \n+    /**\n+     * The default implementation is a no-op since the counting bloom filter returns an unique IndexExtractor by default.\n+     * @return this counting Bloom filter.\n+     */\n     @Override\n-    default IndexProducer uniqueIndices() {\n+    default IndexExtractor uniqueIndices() {\n         return this;\n     }\n }\ndiff --git a/src/main/java/org/apache/commons/collections4/bloomfilter/CountingLongPredicate.java b/src/main/java/org/apache/commons/collections4/bloomfilter/CountingLongPredicate.java\nindex 90ef5647b3..a9e5b31af4 100644\n--- a/src/main/java/org/apache/commons/collections4/bloomfilter/CountingLongPredicate.java\n+++ b/src/main/java/org/apache/commons/collections4/bloomfilter/CountingLongPredicate.java\n@@ -21,7 +21,7 @@\n /**\n  * A long predicate that applies the test func to each member of the {@code ary} in sequence for each call to {@code test()}.\n  * if the {@code ary} is exhausted, the subsequent calls to {@code test} are executed with a zero value.\n- * If the calls to {@code test} do not exhaust the {@code ary} the {@code forEachRemaining} method can be called to\n+ * If the calls to {@code test} do not exhaust the {@code ary} the {@code processRemaining} method can be called to\n  * execute the @{code test} with a zero value for each remaining {@code idx} value.\n  * @since 4.5\n  */\n@@ -45,12 +45,12 @@ class CountingLongPredicate implements LongPredicate {\n     /**\n      * Call the long-long consuming bi-predicate for each remaining unpaired long in\n      * the input array. This method should be invoked after the predicate has been\n-     * passed to {@link BitMapProducer#forEachBitMap(LongPredicate)} to consume any\n+     * passed to {@link BitMapExtractor#processBitMaps(LongPredicate)} to consume any\n      * unpaired bitmaps. The second argument to the bi-predicate will be zero.\n      *\n-     * @return true if all calls the predicate were successful\n+     * @return true if all calls to the predicate were successful\n      */\n-    boolean forEachRemaining() {\n+    boolean processRemaining() {\n         // uses local references for optimization benefit.\n         int i = idx;\n         final long[] a = ary;\ndiff --git a/src/main/java/org/apache/commons/collections4/bloomfilter/CountingPredicate.java b/src/main/java/org/apache/commons/collections4/bloomfilter/CountingPredicate.java\nindex 05a3543627..ba8049da7a 100644\n--- a/src/main/java/org/apache/commons/collections4/bloomfilter/CountingPredicate.java\n+++ b/src/main/java/org/apache/commons/collections4/bloomfilter/CountingPredicate.java\n@@ -24,7 +24,7 @@\n  * sequence for each call to {@code test()}. if the {@code ary} is exhausted,\n  * the subsequent calls to {@code test} are executed with a {@code null} value.\n  * If the calls to {@code test} do not exhaust the {@code ary} the {@code\n- * forEachRemaining} method can be called to execute the @{code test} with a\n+ * processRemaining} method can be called to execute the @{code test} with a\n  * {@code null} value for each remaining {@code idx} value.\n  *\n  * @param <T> the type of object being compared.\n@@ -52,12 +52,12 @@ class CountingPredicate<T> implements Predicate<T> {\n     /**\n      * Call {@code BiPredicate<T, T>} for each remaining unpaired {@code <T>} in the\n      * input array. This method should be invoked after the predicate has been\n-     * passed to a {@code Producer.forEach<T>(BiPredicate<T, T>)} to consume any\n+     * passed to a {@code Extractor.forEach<T>(BiPredicate<T, T>)} to consume any\n      * unpaired {@code <T>}s. The second argument to the BiPredicate will be {@code null}.\n      *\n-     * @return true if all calls the predicate were successful\n+     * @return true if all calls to the predicate were successful\n      */\n-    boolean forEachRemaining() {\n+    boolean processRemaining() {\n         // uses local references for optimization benefit.\n         int i = idx;\n         final T[] a = ary;\ndiff --git a/src/main/java/org/apache/commons/collections4/bloomfilter/EnhancedDoubleHasher.java b/src/main/java/org/apache/commons/collections4/bloomfilter/EnhancedDoubleHasher.java\nindex 12115e5ce8..761803e49f 100644\n--- a/src/main/java/org/apache/commons/collections4/bloomfilter/EnhancedDoubleHasher.java\n+++ b/src/main/java/org/apache/commons/collections4/bloomfilter/EnhancedDoubleHasher.java\n@@ -130,10 +130,10 @@ long getInitial() {\n     }\n \n     @Override\n-    public IndexProducer indices(final Shape shape) {\n+    public IndexExtractor indices(final Shape shape) {\n         Objects.requireNonNull(shape, \"shape\");\n \n-        return new IndexProducer() {\n+        return new IndexExtractor() {\n \n             @Override\n             public int[] asIndexArray() {\n@@ -142,7 +142,7 @@ public int[] asIndexArray() {\n \n                 // This method needs to return duplicate indices\n \n-                forEachIndex(i -> {\n+                processIndices(i -> {\n                     result[idx[0]++] = i;\n                     return true;\n                 });\n@@ -150,7 +150,7 @@ public int[] asIndexArray() {\n             }\n \n             @Override\n-            public boolean forEachIndex(final IntPredicate consumer) {\n+            public boolean processIndices(final IntPredicate consumer) {\n                 Objects.requireNonNull(consumer, \"consumer\");\n                 final int bits = shape.getNumberOfBits();\n                 // Enhanced double hashing:\n@@ -166,8 +166,8 @@ public boolean forEachIndex(final IntPredicate consumer) {\n                 // The final hash is:\n                 // hash[i] = ( h1(x) - i*h2(x) - (i*i*i - i)/6 ) wrapped in [0, bits)\n \n-                int index = BitMap.mod(initial, bits);\n-                int inc = BitMap.mod(increment, bits);\n+                int index = BitMaps.mod(initial, bits);\n+                int inc = BitMaps.mod(increment, bits);\n \n                 final int k = shape.getNumberOfHashFunctions();\n                 if (k > bits) {\ndiff --git a/src/main/java/org/apache/commons/collections4/bloomfilter/Hasher.java b/src/main/java/org/apache/commons/collections4/bloomfilter/Hasher.java\nindex e2c30d5d28..dcc13c7115 100644\n--- a/src/main/java/org/apache/commons/collections4/bloomfilter/Hasher.java\n+++ b/src/main/java/org/apache/commons/collections4/bloomfilter/Hasher.java\n@@ -17,7 +17,7 @@\n package org.apache.commons.collections4.bloomfilter;\n \n /**\n- * A Hasher creates IndexProducer based on the hash implementation and the\n+ * A Hasher creates IndexExtractor based on the hash implementation and the\n  * provided Shape.\n  *\n  * @since 4.5\n@@ -25,14 +25,14 @@\n public interface Hasher {\n \n     /**\n-     * Creates an IndexProducer for this hasher based on the Shape.\n+     * Creates an IndexExtractor for this hasher based on the Shape.\n      *\n-     * <p>The {@code IndexProducer} will create indices within the range defined by the number of bits in\n+     * <p>The {@code IndexExtractor} will create indices within the range defined by the number of bits in\n      * the shape. The total number of indices will respect the number of hash functions per item\n      * defined by the shape. However the count of indices may not be a multiple of the number of\n      * hash functions if the implementation has removed duplicates.</p>\n      *\n-     * <p>This IndexProducer must be deterministic in that it must return the same indices for the\n+     * <p>This IndexExtractor must be deterministic in that it must return the same indices for the\n      * same Shape.</p>\n      *\n      * <p>No guarantee is made as to order of indices.</p>\n@@ -41,5 +41,5 @@ public interface Hasher {\n      * @param shape the shape of the desired Bloom filter.\n      * @return the iterator of integers\n      */\n-    IndexProducer indices(Shape shape);\n+    IndexExtractor indices(Shape shape);\n }\ndiff --git a/src/main/java/org/apache/commons/collections4/bloomfilter/IndexProducer.java b/src/main/java/org/apache/commons/collections4/bloomfilter/IndexExtractor.java\nsimilarity index 77%\nrename from src/main/java/org/apache/commons/collections4/bloomfilter/IndexProducer.java\nrename to src/main/java/org/apache/commons/collections4/bloomfilter/IndexExtractor.java\nindex 7923288765..d6a33537e9 100644\n--- a/src/main/java/org/apache/commons/collections4/bloomfilter/IndexProducer.java\n+++ b/src/main/java/org/apache/commons/collections4/bloomfilter/IndexExtractor.java\n@@ -31,15 +31,15 @@\n  * @since 4.5\n  */\n @FunctionalInterface\n-public interface IndexProducer {\n+public interface IndexExtractor {\n \n     /**\n-     * Creates an IndexProducer from a {@code BitMapProducer}.\n-     * @param producer the {@code BitMapProducer}\n-     * @return a new {@code IndexProducer}.\n+     * Creates an IndexExtractor from a {@code BitMapExtractor}.\n+     * @param bitMapExtractor the {@code BitMapExtractor}\n+     * @return a new {@code IndexExtractor}.\n      */\n-    static IndexProducer fromBitMapProducer(final BitMapProducer producer) {\n-        Objects.requireNonNull(producer, \"producer\");\n+    static IndexExtractor fromBitMapExtractor(final BitMapExtractor bitMapExtractor) {\n+        Objects.requireNonNull(bitMapExtractor, \"bitMapExtractor\");\n         return consumer -> {\n             final LongPredicate longPredicate = new LongPredicate() {\n                 int wordIdx;\n@@ -58,17 +58,17 @@ public boolean test(long word) {\n                     return true;\n                 }\n             };\n-            return producer.forEachBitMap(longPredicate::test);\n+            return bitMapExtractor.processBitMaps(longPredicate::test);\n         };\n     }\n \n     /**\n-     * Creates an IndexProducer from an array of integers.\n+     * Creates an IndexExtractor from an array of integers.\n      * @param values the index values\n-     * @return an IndexProducer that uses the values.\n+     * @return an IndexExtractor that uses the values.\n      */\n-    static IndexProducer fromIndexArray(final int... values) {\n-        return new IndexProducer() {\n+    static IndexExtractor fromIndexArray(final int... values) {\n+        return new IndexExtractor() {\n \n             @Override\n             public int[] asIndexArray() {\n@@ -76,7 +76,7 @@ public int[] asIndexArray() {\n             }\n \n             @Override\n-            public boolean forEachIndex(final IntPredicate predicate) {\n+            public boolean processIndices(final IntPredicate predicate) {\n                 for (final int value : values) {\n                     if (!predicate.test(value)) {\n                         return false;\n@@ -88,7 +88,7 @@ public boolean forEachIndex(final IntPredicate predicate) {\n     }\n \n     /**\n-     * Return a copy of the IndexProducer data as an int array.\n+     * Return a copy of the IndexExtractor data as an int array.\n      *\n      * <p>Indices ordering and uniqueness is not guaranteed.</p>\n      *\n@@ -117,7 +117,7 @@ int[] toArray() {\n             }\n         }\n         final Indices indices = new Indices();\n-        forEachIndex(indices::add);\n+        processIndices(indices::add);\n         return indices.toArray();\n     }\n \n@@ -134,31 +134,31 @@ int[] toArray() {\n      * @return {@code true} if all indexes return true from consumer, {@code false} otherwise.\n      * @throws NullPointerException if the specified action is null\n      */\n-    boolean forEachIndex(IntPredicate predicate);\n+    boolean processIndices(IntPredicate predicate);\n \n     /**\n-     * Creates an IndexProducer comprising the unique indices for this producer.\n+     * Creates an IndexExtractor comprising the unique indices for this extractor.\n      *\n-     * <p>By default creates a new producer with some overhead to remove\n-     * duplicates.  IndexProducers that return unique indices by default\n+     * <p>By default creates a new extractor with some overhead to remove\n+     * duplicates.  IndexExtractors that return unique indices by default\n      * should override this to return {@code this}.</p>\n      *\n      * <p>The default implementation will filter the indices from this instance\n      * and return them in ascending order.</p>\n      *\n-     * @return the IndexProducer of unique values.\n+     * @return the IndexExtractor of unique values.\n      * @throws IndexOutOfBoundsException if any index is less than zero.\n      */\n-    default IndexProducer uniqueIndices() {\n+    default IndexExtractor uniqueIndices() {\n         final BitSet bitSet = new BitSet();\n-        forEachIndex(i -> {\n+        processIndices(i -> {\n             bitSet.set(i);\n             return true;\n         });\n \n-        return new IndexProducer() {\n+        return new IndexExtractor() {\n             @Override\n-            public boolean forEachIndex(final IntPredicate predicate) {\n+            public boolean processIndices(final IntPredicate predicate) {\n                 for (int idx = bitSet.nextSetBit(0); idx >= 0; idx = bitSet.nextSetBit(idx + 1)) {\n                     if (!predicate.test(idx)) {\n                         return false;\n@@ -168,7 +168,7 @@ public boolean forEachIndex(final IntPredicate predicate) {\n             }\n \n             @Override\n-            public IndexProducer uniqueIndices() {\n+            public IndexExtractor uniqueIndices() {\n                 return this;\n             }\n         };\ndiff --git a/src/main/java/org/apache/commons/collections4/bloomfilter/IndexFilter.java b/src/main/java/org/apache/commons/collections4/bloomfilter/IndexFilter.java\nindex 4fc4bab5e6..070a49fdaa 100644\n--- a/src/main/java/org/apache/commons/collections4/bloomfilter/IndexFilter.java\n+++ b/src/main/java/org/apache/commons/collections4/bloomfilter/IndexFilter.java\n@@ -71,13 +71,13 @@ static class BitMapTracker implements IntPredicate {\n          * @param shape The shape that is being generated.\n          */\n         BitMapTracker(final Shape shape) {\n-            bits = new long[BitMap.numberOfBitMaps(shape.getNumberOfBits())];\n+            bits = new long[BitMaps.numberOfBitMaps(shape.getNumberOfBits())];\n         }\n \n         @Override\n         public boolean test(final int number) {\n-            final boolean retval = !BitMap.contains(bits, number);\n-            BitMap.set(bits, number);\n+            final boolean retval = !BitMaps.contains(bits, number);\n+            BitMaps.set(bits, number);\n             return retval;\n         }\n     }\n@@ -105,7 +105,7 @@ public static IntPredicate create(final Shape shape, final IntPredicate consumer\n     private IndexFilter(final Shape shape, final IntPredicate consumer) {\n         this.size = shape.getNumberOfBits();\n         this.consumer = consumer;\n-        if (BitMap.numberOfBitMaps(shape.getNumberOfBits()) * Long.BYTES < (long) shape.getNumberOfHashFunctions()\n+        if (BitMaps.numberOfBitMaps(shape.getNumberOfBits()) * Long.BYTES < (long) shape.getNumberOfHashFunctions()\n                 * Integer.BYTES) {\n             this.tracker = new BitMapTracker(shape);\n         } else {\ndiff --git a/src/main/java/org/apache/commons/collections4/bloomfilter/IndexUtils.java b/src/main/java/org/apache/commons/collections4/bloomfilter/IndexUtils.java\nindex 3c835ea570..fdf3b8fb19 100644\n--- a/src/main/java/org/apache/commons/collections4/bloomfilter/IndexUtils.java\n+++ b/src/main/java/org/apache/commons/collections4/bloomfilter/IndexUtils.java\n@@ -19,8 +19,8 @@\n import java.util.Arrays;\n \n /**\n- * Provides functions to assist in IndexProducer creation and manipulation.\n- * @see IndexProducer\n+ * Provides functions to assist in IndexExtractor creation and manipulation.\n+ * @see IndexExtractor\n  */\n final class IndexUtils {\n \ndiff --git a/src/main/java/org/apache/commons/collections4/bloomfilter/LayerManager.java b/src/main/java/org/apache/commons/collections4/bloomfilter/LayerManager.java\nindex f5500f747c..011822e82d 100644\n--- a/src/main/java/org/apache/commons/collections4/bloomfilter/LayerManager.java\n+++ b/src/main/java/org/apache/commons/collections4/bloomfilter/LayerManager.java\n@@ -51,7 +51,7 @@\n  *\n  * @since 4.5\n  */\n-public class LayerManager<T extends BloomFilter> implements BloomFilterProducer {\n+public class LayerManager<T extends BloomFilter> implements BloomFilterExtractor {\n \n     /**\n      * Builder to create Layer Manager\n@@ -358,7 +358,7 @@ public final T first() {\n      *         {@code true} if all filters pass the test.\n      */\n     @Override\n-    public boolean forEachBloomFilter(final Predicate<BloomFilter> bloomFilterPredicate) {\n+    public boolean processBloomFilters(final Predicate<BloomFilter> bloomFilterPredicate) {\n         for (final BloomFilter bf : filters) {\n             if (!bloomFilterPredicate.test(bf)) {\n                 return false;\ndiff --git a/src/main/java/org/apache/commons/collections4/bloomfilter/LayeredBloomFilter.java b/src/main/java/org/apache/commons/collections4/bloomfilter/LayeredBloomFilter.java\nindex 058fe4aeec..ee39bae65a 100644\n--- a/src/main/java/org/apache/commons/collections4/bloomfilter/LayeredBloomFilter.java\n+++ b/src/main/java/org/apache/commons/collections4/bloomfilter/LayeredBloomFilter.java\n@@ -62,7 +62,7 @@\n  * @param <T> The type of Bloom Filter that is used for the layers.\n  * @since 4.5\n  */\n-public class LayeredBloomFilter<T extends BloomFilter> implements BloomFilter, BloomFilterProducer {\n+public class LayeredBloomFilter<T extends BloomFilter> implements BloomFilter, BloomFilterExtractor {\n     /**\n      * A class used to locate matching filters across all the layers.\n      */\n@@ -131,15 +131,15 @@ public final void clear() {\n     }\n \n     @Override\n-    public boolean contains(final BitMapProducer bitMapProducer) {\n-        return contains(createFilter(bitMapProducer));\n+    public boolean contains(final BitMapExtractor bitMapExtractor) {\n+        return contains(createFilter(bitMapExtractor));\n     }\n \n     /**\n      * Returns {@code true} if this any layer contained by this filter contains the\n      * specified filter.\n      * <p>\n-     * If the {@code other} is a BloomFilterProducer each filter within the\n+     * If the {@code other} is a BloomFilterExtractor each filter within the\n      * {@code other} is checked to see if it exits within this filter.\n      * </p>\n      *\n@@ -148,23 +148,23 @@ public boolean contains(final BitMapProducer bitMapProducer) {\n      */\n     @Override\n     public boolean contains(final BloomFilter other) {\n-        return other instanceof BloomFilterProducer ? contains((BloomFilterProducer) other)\n-                : !forEachBloomFilter(x -> !x.contains(other));\n+        return other instanceof BloomFilterExtractor ? contains((BloomFilterExtractor) other)\n+                : !processBloomFilters(x -> !x.contains(other));\n     }\n \n     /**\n-     * Returns {@code true} if each filter within the {@code producer} exits within\n+     * Returns {@code true} if each filter within the {@code bloomFilterExtractor} exits within\n      * this filter.\n      *\n-     * @param producer the BloomFilterProducer that provides the filters to check\n+     * @param bloomFilterExtractor the BloomFilterExtractor that provides the filters to check\n      *                 for.\n      * @return {@code true} if this filter contains all of the filters contained in\n-     *         the {@code producer}.\n+     *         the {@code bloomFilterExtractor}.\n      */\n-    public boolean contains(final BloomFilterProducer producer) {\n+    public boolean contains(final BloomFilterExtractor bloomFilterExtractor) {\n         final boolean[] result = { true };\n         // return false when we have found a match to short circuit checks\n-        return producer.forEachBloomFilter(x -> {\n+        return bloomFilterExtractor.processBloomFilters(x -> {\n             result[0] &= contains(x);\n             return result[0];\n         });\n@@ -176,8 +176,8 @@ public boolean contains(final Hasher hasher) {\n     }\n \n     @Override\n-    public boolean contains(final IndexProducer indexProducer) {\n-        return contains(createFilter(indexProducer));\n+    public boolean contains(final IndexExtractor indexExtractor) {\n+        return contains(createFilter(indexExtractor));\n     }\n \n     @Override\n@@ -186,14 +186,14 @@ public LayeredBloomFilter<T> copy() {\n     }\n \n     /**\n-     * Creates a Bloom filter from a BitMapProducer.\n+     * Creates a Bloom filter from a BitMapExtractor.\n      *\n-     * @param bitMapProducer the BitMapProducer to create the filter from.\n+     * @param bitMapExtractor the BitMapExtractor to create the filter from.\n      * @return the BloomFilter.\n      */\n-    private BloomFilter createFilter(final BitMapProducer bitMapProducer) {\n+    private BloomFilter createFilter(final BitMapExtractor bitMapExtractor) {\n         final SimpleBloomFilter bf = new SimpleBloomFilter(shape);\n-        bf.merge(bitMapProducer);\n+        bf.merge(bitMapExtractor);\n         return bf;\n     }\n \n@@ -210,14 +210,14 @@ private BloomFilter createFilter(final Hasher hasher) {\n     }\n \n     /**\n-     * Creates a Bloom filter from an IndexProducer.\n+     * Creates a Bloom filter from an IndexExtractor.\n      *\n-     * @param indexProducer the IndexProducer to create the filter from.\n+     * @param indexExtractor the IndexExtractor to create the filter from.\n      * @return the BloomFilter.\n      */\n-    private BloomFilter createFilter(final IndexProducer indexProducer) {\n+    private BloomFilter createFilter(final IndexExtractor indexExtractor) {\n         final SimpleBloomFilter bf = new SimpleBloomFilter(shape);\n-        bf.merge(indexProducer);\n+        bf.merge(indexExtractor);\n         return bf;\n     }\n \n@@ -235,14 +235,14 @@ public int estimateUnion(final BloomFilter other) {\n     }\n \n     /**\n-     * Finds the layers in which the BitMapProducer is found.\n+     * Finds the layers in which the BitMapExtractor is found.\n      *\n-     * @param bitMapProducer the BitMapProducer to search for.\n+     * @param bitMapExtractor the BitMapExtractor to search for.\n      * @return an array of layer indices in which the Bloom filter is found.\n      */\n-    public int[] find(final BitMapProducer bitMapProducer) {\n+    public int[] find(final BitMapExtractor bitMapExtractor) {\n         final SimpleBloomFilter bf = new SimpleBloomFilter(shape);\n-        bf.merge(bitMapProducer);\n+        bf.merge(bitMapExtractor);\n         return find(bf);\n     }\n \n@@ -254,7 +254,7 @@ public int[] find(final BitMapProducer bitMapProducer) {\n      */\n     public int[] find(final BloomFilter bf) {\n         final Finder finder = new Finder(bf);\n-        forEachBloomFilter(finder);\n+        processBloomFilters(finder);\n         return finder.getResult();\n     }\n \n@@ -271,14 +271,14 @@ public int[] find(final Hasher hasher) {\n     }\n \n     /**\n-     * Finds the layers in which the IndexProducer is found.\n+     * Finds the layers in which the IndexExtractor is found.\n      *\n-     * @param indexProducer the Index producer to search for.\n+     * @param indexExtractor the Index extractor to search for.\n      * @return an array of layer indices in which the Bloom filter is found.\n      */\n-    public int[] find(final IndexProducer indexProducer) {\n+    public int[] find(final IndexExtractor indexExtractor) {\n         final SimpleBloomFilter bf = new SimpleBloomFilter(shape);\n-        bf.merge(indexProducer);\n+        bf.merge(indexExtractor);\n         return find(bf);\n     }\n \n@@ -291,13 +291,13 @@ public int[] find(final IndexProducer indexProducer) {\n     @Override\n     public BloomFilter flatten() {\n         final BloomFilter bf = new SimpleBloomFilter(shape);\n-        forEachBloomFilter(bf::merge);\n+        processBloomFilters(bf::merge);\n         return bf;\n     }\n \n     @Override\n-    public boolean forEachBitMap(final LongPredicate predicate) {\n-        return flatten().forEachBitMap(predicate);\n+    public boolean processBitMaps(final LongPredicate predicate) {\n+        return flatten().processBitMaps(predicate);\n     }\n \n     /**\n@@ -310,13 +310,13 @@ public boolean forEachBitMap(final LongPredicate predicate) {\n      *         otherwise.\n      */\n     @Override\n-    public final boolean forEachBloomFilter(final Predicate<BloomFilter> bloomFilterPredicate) {\n-        return layerManager.forEachBloomFilter(bloomFilterPredicate);\n+    public final boolean processBloomFilters(final Predicate<BloomFilter> bloomFilterPredicate) {\n+        return layerManager.processBloomFilters(bloomFilterPredicate);\n     }\n \n     @Override\n-    public boolean forEachIndex(final IntPredicate predicate) {\n-        return forEachBloomFilter(bf -> bf.forEachIndex(predicate));\n+    public boolean processIndices(final IntPredicate predicate) {\n+        return processBloomFilters(bf -> bf.processIndices(predicate));\n     }\n \n     /**\n@@ -347,12 +347,12 @@ public final Shape getShape() {\n \n     @Override\n     public boolean isEmpty() {\n-        return forEachBloomFilter(BloomFilter::isEmpty);\n+        return processBloomFilters(BloomFilter::isEmpty);\n     }\n \n     @Override\n-    public boolean merge(final BitMapProducer bitMapProducer) {\n-        return layerManager.getTarget().merge(bitMapProducer);\n+    public boolean merge(final BitMapExtractor bitMapExtractor) {\n+        return layerManager.getTarget().merge(bitMapExtractor);\n     }\n \n     @Override\n@@ -361,8 +361,8 @@ public boolean merge(final BloomFilter bf) {\n     }\n \n     @Override\n-    public boolean merge(final IndexProducer indexProducer) {\n-        return layerManager.getTarget().merge(indexProducer);\n+    public boolean merge(final IndexExtractor indexExtractor) {\n+        return layerManager.getTarget().merge(indexExtractor);\n     }\n \n     /**\n@@ -376,4 +376,5 @@ public boolean merge(final IndexProducer indexProducer) {\n     public void next() {\n         layerManager.next();\n     }\n+\n }\ndiff --git a/src/main/java/org/apache/commons/collections4/bloomfilter/SetOperations.java b/src/main/java/org/apache/commons/collections4/bloomfilter/SetOperations.java\nindex 1cb57262df..54f4598fdc 100644\n--- a/src/main/java/org/apache/commons/collections4/bloomfilter/SetOperations.java\n+++ b/src/main/java/org/apache/commons/collections4/bloomfilter/SetOperations.java\n@@ -19,7 +19,7 @@\n import java.util.function.LongBinaryOperator;\n \n /**\n- * Implementations of set operations on BitMapProducers.\n+ * Implementations of set operations on BitMapExtractors.\n  *\n  * @since 4.5\n  */\n@@ -27,23 +27,23 @@ public final class SetOperations {\n \n     /**\n      * Calculates the cardinality of the logical {@code AND} of the bit maps for the two filters.\n-     * @param first the first BitMapProducer.\n-     * @param second the second BitMapProducer\n+     * @param first the first BitMapExtractor.\n+     * @param second the second BitMapExtractor\n      * @return the cardinality of the {@code AND} of the filters.\n      */\n-    public static int andCardinality(final BitMapProducer first, final BitMapProducer second) {\n+    public static int andCardinality(final BitMapExtractor first, final BitMapExtractor second) {\n         return cardinality(first, second, (x, y) -> x & y);\n     }\n \n     /**\n-     * Calculates the cardinality of a BitMapProducer. By necessity this method will visit each bit map\n-     * created by the producer.\n-     * @param producer the Producer to calculate the cardinality for.\n-     * @return the cardinality of the bit maps produced by the producer.\n+     * Calculates the cardinality of a BitMapExtractor. By necessity this method will visit each bit map\n+     * created by the bitMapExtractor.\n+     * @param bitMapExtractor the extractor to calculate the cardinality for.\n+     * @return the cardinality of the bit maps produced by the bitMapExtractor.\n      */\n-    public static int cardinality(final BitMapProducer producer) {\n+    public static int cardinality(final BitMapExtractor bitMapExtractor) {\n         final int[] cardinality = new int[1];\n-        producer.forEachBitMap(l -> {\n+        bitMapExtractor.processBitMaps(l -> {\n             cardinality[0] += Long.bitCount(l);\n             return true;\n         });\n@@ -52,16 +52,16 @@ public static int cardinality(final BitMapProducer producer) {\n \n     /**\n      * Calculates the cardinality of the result of a LongBinaryOperator using the\n-     * {@code BitMapProducer.makePredicate} method.\n-     * @param first the first BitMapProducer\n-     * @param second the second BitMapProducer\n-     * @param op a long binary operation on where x = {@code first} and y = {@code second} bitmap producers.\n+     * {@code BitMapExtractor.makePredicate} method.\n+     * @param first the first BitMapExtractor\n+     * @param second the second BitMapExtractor\n+     * @param op a long binary operation on where x = {@code first} and y = {@code second} bitmap extractors.\n      * @return the calculated cardinality.\n      */\n-    private static int cardinality(final BitMapProducer first, final BitMapProducer second, final LongBinaryOperator op) {\n+    private static int cardinality(final BitMapExtractor first, final BitMapExtractor second, final LongBinaryOperator op) {\n         final int[] cardinality = new int[1];\n \n-        first.forEachBitMapPair(second, (x, y) -> {\n+        first.processBitMapPairs(second, (x, y) -> {\n             cardinality[0] += Long.bitCount(op.applyAsLong(x, y));\n             return true;\n         });\n@@ -69,30 +69,30 @@ private static int cardinality(final BitMapProducer first, final BitMapProducer\n     }\n \n     /**\n-     * Calculates the Cosine distance between two BitMapProducer.\n+     * Calculates the Cosine distance between two BitMapExtractor.\n      *\n      * <p>Cosine distance is defined as {@code 1 - Cosine similarity}</p>\n      *\n-     * @param first the first BitMapProducer.\n-     * @param second the second BitMapProducer.\n+     * @param first the first BitMapExtractor.\n+     * @param second the second BitMapExtractor.\n      * @return the jaccard distance.\n      */\n-    public static double cosineDistance(final BitMapProducer first, final BitMapProducer second) {\n+    public static double cosineDistance(final BitMapExtractor first, final BitMapExtractor second) {\n         return 1.0 - cosineSimilarity(first, second);\n     }\n \n     /**\n-     * Calculates the Cosine similarity between two BitMapProducers.\n+     * Calculates the Cosine similarity between two BitMapExtractors.\n      * <p> Also known as Orchini similarity and the Tucker coefficient of congruence or\n      * Ochiai similarity.</p>\n      *\n-     * <p>If either producer is empty the result is 0 (zero)</p>\n+     * <p>If either extractor is empty the result is 0 (zero)</p>\n      *\n-     * @param first the first BitMapProducer.\n-     * @param second the second BitMapProducer.\n+     * @param first the first BitMapExtractor.\n+     * @param second the second BitMapExtractor.\n      * @return the Cosine similarity.\n      */\n-    public static double cosineSimilarity(final BitMapProducer first, final BitMapProducer second) {\n+    public static double cosineSimilarity(final BitMapExtractor first, final BitMapExtractor second) {\n         final int numerator = andCardinality(first, second);\n         // Given that the cardinality is an int then the product as a double will not\n         // overflow, we can use one sqrt:\n@@ -120,41 +120,41 @@ public static double cosineSimilarity(final BloomFilter first, final BloomFilter\n     }\n \n     /**\n-     * Calculates the Hamming distance between two BitMapProducers.\n+     * Calculates the Hamming distance between two BitMapExtractors.\n      *\n-     * @param first the first BitMapProducer.\n-     * @param second the second BitMapProducer.\n+     * @param first the first BitMapExtractor.\n+     * @param second the second BitMapExtractor.\n      * @return the Hamming distance.\n      */\n-    public static int hammingDistance(final BitMapProducer first, final BitMapProducer second) {\n+    public static int hammingDistance(final BitMapExtractor first, final BitMapExtractor second) {\n         return xorCardinality(first, second);\n     }\n \n     /**\n-     * Calculates the Jaccard distance between two BitMapProducer.\n+     * Calculates the Jaccard distance between two BitMapExtractor.\n      *\n      * <p>Jaccard distance is defined as {@code 1 - Jaccard similarity}</p>\n      *\n-     * @param first the first BitMapProducer.\n-     * @param second the second BitMapProducer.\n+     * @param first the first BitMapExtractor.\n+     * @param second the second BitMapExtractor.\n      * @return the Jaccard distance.\n      */\n-    public static double jaccardDistance(final BitMapProducer first, final BitMapProducer second) {\n+    public static double jaccardDistance(final BitMapExtractor first, final BitMapExtractor second) {\n         return 1.0 - jaccardSimilarity(first, second);\n     }\n \n     /**\n-     * Calculates the Jaccard similarity between two BitMapProducer.\n+     * Calculates the Jaccard similarity between two BitMapExtractor.\n      *\n      * <p>Also known as Jaccard index, Intersection over Union, and Jaccard similarity coefficient</p>\n      *\n-     * @param first the first BitMapProducer.\n-     * @param second the second BitMapProducer.\n+     * @param first the first BitMapExtractor.\n+     * @param second the second BitMapExtractor.\n      * @return the Jaccard similarity.\n      */\n-    public static double jaccardSimilarity(final BitMapProducer first, final BitMapProducer second) {\n+    public static double jaccardSimilarity(final BitMapExtractor first, final BitMapExtractor second) {\n         final int[] cardinality = new int[2];\n-        first.forEachBitMapPair(second, (x, y) -> {\n+        first.processBitMapPairs(second, (x, y) -> {\n             cardinality[0] += Long.bitCount(x & y);\n             cardinality[1] += Long.bitCount(x | y);\n             return true;\n@@ -165,21 +165,21 @@ public static double jaccardSimilarity(final BitMapProducer first, final BitMapP\n \n     /**\n      * Calculates the cardinality of the logical {@code OR} of the bit maps for the two filters.\n-     * @param first the first BitMapProducer.\n-     * @param second the second BitMapProducer\n+     * @param first the first BitMapExtractor.\n+     * @param second the second BitMapExtractor\n      * @return the cardinality of the {@code OR} of the filters.\n      */\n-    public static int orCardinality(final BitMapProducer first, final BitMapProducer second) {\n+    public static int orCardinality(final BitMapExtractor first, final BitMapExtractor second) {\n         return cardinality(first, second, (x, y) -> x | y);\n     }\n \n     /**\n      * Calculates the cardinality of the logical {@code XOR} of the bit maps for the two filters.\n-     * @param first the first BitMapProducer.\n-     * @param second the second BitMapProducer\n+     * @param first the first BitMapExtractor.\n+     * @param second the second BitMapExtractor\n      * @return the cardinality of the {@code XOR} of the filters.\n      */\n-    public static int xorCardinality(final BitMapProducer first, final BitMapProducer second) {\n+    public static int xorCardinality(final BitMapExtractor first, final BitMapExtractor second) {\n         return cardinality(first, second, (x, y) -> x ^ y);\n     }\n \ndiff --git a/src/main/java/org/apache/commons/collections4/bloomfilter/Shape.java b/src/main/java/org/apache/commons/collections4/bloomfilter/Shape.java\nindex 8a184e7da9..2be155d8db 100644\n--- a/src/main/java/org/apache/commons/collections4/bloomfilter/Shape.java\n+++ b/src/main/java/org/apache/commons/collections4/bloomfilter/Shape.java\n@@ -483,7 +483,7 @@ public boolean isSparse(final int cardinality) {\n          * (number of indexes) is less than or equal to 2*number of bit maps the\n          * cardinality is sparse within the shape.\n          */\n-        return cardinality <= BitMap.numberOfBitMaps(getNumberOfBits()) * 2;\n+        return cardinality <= BitMaps.numberOfBitMaps(getNumberOfBits()) * 2;\n     }\n \n     @Override\ndiff --git a/src/main/java/org/apache/commons/collections4/bloomfilter/SimpleBloomFilter.java b/src/main/java/org/apache/commons/collections4/bloomfilter/SimpleBloomFilter.java\nindex 4cf672394a..c5f55405e4 100644\n--- a/src/main/java/org/apache/commons/collections4/bloomfilter/SimpleBloomFilter.java\n+++ b/src/main/java/org/apache/commons/collections4/bloomfilter/SimpleBloomFilter.java\n@@ -51,7 +51,7 @@ public final class SimpleBloomFilter implements BloomFilter {\n     public SimpleBloomFilter(final Shape shape) {\n         Objects.requireNonNull(shape, \"shape\");\n         this.shape = shape;\n-        this.bitMap = new long[BitMap.numberOfBitMaps(shape.getNumberOfBits())];\n+        this.bitMap = new long[BitMaps.numberOfBitMaps(shape.getNumberOfBits())];\n         this.cardinality = 0;\n     }\n \n@@ -92,8 +92,8 @@ public void clear() {\n     }\n \n     @Override\n-    public boolean contains(final IndexProducer indexProducer) {\n-        return indexProducer.forEachIndex(idx -> BitMap.contains(bitMap, idx));\n+    public boolean contains(final IndexExtractor indexExtractor) {\n+        return indexExtractor.processIndices(idx -> BitMaps.contains(bitMap, idx));\n     }\n \n     @Override\n@@ -102,7 +102,7 @@ public SimpleBloomFilter copy() {\n     }\n \n     @Override\n-    public boolean forEachBitMap(final LongPredicate consumer) {\n+    public boolean processBitMaps(final LongPredicate consumer) {\n         Objects.requireNonNull(consumer, \"consumer\");\n         for (final long l : bitMap) {\n             if (!consumer.test(l)) {\n@@ -113,15 +113,15 @@ public boolean forEachBitMap(final LongPredicate consumer) {\n     }\n \n     @Override\n-    public boolean forEachBitMapPair(final BitMapProducer other, final LongBiPredicate func) {\n+    public boolean processBitMapPairs(final BitMapExtractor other, final LongBiPredicate func) {\n         final CountingLongPredicate p = new CountingLongPredicate(bitMap, func);\n-        return other.forEachBitMap(p) && p.forEachRemaining();\n+        return other.processBitMaps(p) && p.processRemaining();\n     }\n \n     @Override\n-    public boolean forEachIndex(final IntPredicate consumer) {\n+    public boolean processIndices(final IntPredicate consumer) {\n         Objects.requireNonNull(consumer, \"consumer\");\n-        return IndexProducer.fromBitMapProducer(this).forEachIndex(consumer);\n+        return IndexExtractor.fromBitMapExtractor(this).processIndices(consumer);\n     }\n \n     @Override\n@@ -131,33 +131,33 @@ public Shape getShape() {\n \n     @Override\n     public boolean isEmpty() {\n-        return cardinality == 0 || forEachBitMap(y -> y == 0);\n+        return cardinality == 0 || processBitMaps(y -> y == 0);\n     }\n \n     @Override\n-    public boolean merge(final BitMapProducer bitMapProducer) {\n-        Objects.requireNonNull(bitMapProducer, \"bitMapProducer\");\n+    public boolean merge(final BitMapExtractor bitMapExtractor) {\n+        Objects.requireNonNull(bitMapExtractor, \"bitMapExtractor\");\n         try {\n             final int[] idx = new int[1];\n-            bitMapProducer.forEachBitMap(value -> {\n+            bitMapExtractor.processBitMaps(value -> {\n                 bitMap[idx[0]++] |= value;\n                 return true;\n             });\n             // idx[0] will be limit+1 so decrement it\n             idx[0]--;\n-            final int idxLimit = BitMap.getLongIndex(shape.getNumberOfBits());\n+            final int idxLimit = BitMaps.getLongIndex(shape.getNumberOfBits());\n             if (idxLimit == idx[0]) {\n                 final long excess = bitMap[idxLimit] >> shape.getNumberOfBits();\n                 if (excess != 0) {\n                     throw new IllegalArgumentException(\n-                            String.format(\"BitMapProducer set a bit higher than the limit for the shape: %s\",\n+                            String.format(\"BitMapExtractor set a bit higher than the limit for the shape: %s\",\n                                     shape.getNumberOfBits()));\n                 }\n             }\n             cardinality = -1;\n         } catch (final IndexOutOfBoundsException e) {\n             throw new IllegalArgumentException(\n-                    String.format(\"BitMapProducer should send at most %s maps\", bitMap.length), e);\n+                    String.format(\"BitMapExtractor should send at most %s maps\", bitMap.length), e);\n         }\n         return true;\n     }\n@@ -166,9 +166,9 @@ public boolean merge(final BitMapProducer bitMapProducer) {\n     public boolean merge(final BloomFilter other) {\n         Objects.requireNonNull(other, \"other\");\n         if ((other.characteristics() & SPARSE) != 0) {\n-            merge((IndexProducer) other);\n+            merge((IndexExtractor) other);\n         } else {\n-            merge((BitMapProducer) other);\n+            merge((BitMapExtractor) other);\n         }\n         return true;\n     }\n@@ -180,14 +180,14 @@ public boolean merge(final Hasher hasher) {\n     }\n \n     @Override\n-    public boolean merge(final IndexProducer indexProducer) {\n-        Objects.requireNonNull(indexProducer, \"indexProducer\");\n-        indexProducer.forEachIndex(idx -> {\n+    public boolean merge(final IndexExtractor indexExtractor) {\n+        Objects.requireNonNull(indexExtractor, \"indexExtractor\");\n+        indexExtractor.processIndices(idx -> {\n             if (idx < 0 || idx >= shape.getNumberOfBits()) {\n                 throw new IllegalArgumentException(String.format(\n-                        \"IndexProducer should only send values in the range[0,%s)\", shape.getNumberOfBits()));\n+                        \"IndexExtractor should only send values in the range[0,%s)\", shape.getNumberOfBits()));\n             }\n-            BitMap.set(bitMap, idx);\n+            BitMaps.set(bitMap, idx);\n             return true;\n         });\n         cardinality = -1;\ndiff --git a/src/main/java/org/apache/commons/collections4/bloomfilter/SparseBloomFilter.java b/src/main/java/org/apache/commons/collections4/bloomfilter/SparseBloomFilter.java\nindex 736a0412d2..6c0a3d1472 100644\n--- a/src/main/java/org/apache/commons/collections4/bloomfilter/SparseBloomFilter.java\n+++ b/src/main/java/org/apache/commons/collections4/bloomfilter/SparseBloomFilter.java\n@@ -66,9 +66,9 @@ private boolean add(final int idx) {\n \n     @Override\n     public long[] asBitMapArray() {\n-        final long[] result = new long[BitMap.numberOfBitMaps(shape.getNumberOfBits())];\n+        final long[] result = new long[BitMaps.numberOfBitMaps(shape.getNumberOfBits())];\n         for (final int i : indices) {\n-            BitMap.set(result, i);\n+            BitMaps.set(result, i);\n         }\n         return result;\n     }\n@@ -89,13 +89,13 @@ public void clear() {\n     }\n \n     @Override\n-    public boolean contains(final BitMapProducer bitMapProducer) {\n-        return contains(IndexProducer.fromBitMapProducer(bitMapProducer));\n+    public boolean contains(final BitMapExtractor bitMapExtractor) {\n+        return contains(IndexExtractor.fromBitMapExtractor(bitMapExtractor));\n     }\n \n     @Override\n-    public boolean contains(final IndexProducer indexProducer) {\n-        return indexProducer.forEachIndex(indices::contains);\n+    public boolean contains(final IndexExtractor indexExtractor) {\n+        return indexExtractor.processIndices(indices::contains);\n     }\n \n     @Override\n@@ -104,9 +104,9 @@ public SparseBloomFilter copy() {\n     }\n \n     @Override\n-    public boolean forEachBitMap(final LongPredicate consumer) {\n+    public boolean processBitMaps(final LongPredicate consumer) {\n         Objects.requireNonNull(consumer, \"consumer\");\n-        final int limit = BitMap.numberOfBitMaps(shape.getNumberOfBits());\n+        final int limit = BitMaps.numberOfBitMaps(shape.getNumberOfBits());\n         /*\n          * because our indices are always in order we can shorten the time necessary to\n          * create the longs for the consumer\n@@ -116,14 +116,14 @@ public boolean forEachBitMap(final LongPredicate consumer) {\n         // the bitmap we are working on\n         int idx = 0;\n         for (final int i : indices) {\n-            while (BitMap.getLongIndex(i) != idx) {\n+            while (BitMaps.getLongIndex(i) != idx) {\n                 if (!consumer.test(bitMap)) {\n                     return false;\n                 }\n                 bitMap = 0;\n                 idx++;\n             }\n-            bitMap |= BitMap.getLongBit(i);\n+            bitMap |= BitMaps.getLongBit(i);\n         }\n         // we fall through with data in the bitMap\n         if (!consumer.test(bitMap)) {\n@@ -142,7 +142,7 @@ public boolean forEachBitMap(final LongPredicate consumer) {\n     }\n \n     @Override\n-    public boolean forEachIndex(final IntPredicate consumer) {\n+    public boolean processIndices(final IntPredicate consumer) {\n         Objects.requireNonNull(consumer, \"consumer\");\n         for (final int value : indices) {\n             if (!consumer.test(value)) {\n@@ -163,16 +163,16 @@ public boolean isEmpty() {\n     }\n \n     @Override\n-    public boolean merge(final BitMapProducer bitMapProducer) {\n-        Objects.requireNonNull(bitMapProducer, \"bitMapProducer\");\n-        return this.merge(IndexProducer.fromBitMapProducer(bitMapProducer));\n+    public boolean merge(final BitMapExtractor bitMapExtractor) {\n+        Objects.requireNonNull(bitMapExtractor, \"bitMapExtractor\");\n+        return this.merge(IndexExtractor.fromBitMapExtractor(bitMapExtractor));\n     }\n \n     @Override\n     public boolean merge(final BloomFilter other) {\n         Objects.requireNonNull(other, \"other\");\n-        final IndexProducer producer = (other.characteristics() & SPARSE) != 0 ? (IndexProducer) other : IndexProducer.fromBitMapProducer(other);\n-        merge(producer);\n+        final IndexExtractor indexExtractor = (other.characteristics() & SPARSE) != 0 ? (IndexExtractor) other : IndexExtractor.fromBitMapExtractor(other);\n+        merge(indexExtractor);\n         return true;\n     }\n \n@@ -184,9 +184,9 @@ public boolean merge(final Hasher hasher) {\n     }\n \n     @Override\n-    public boolean merge(final IndexProducer indexProducer) {\n-        Objects.requireNonNull(indexProducer, \"indexProducer\");\n-        indexProducer.forEachIndex(this::add);\n+    public boolean merge(final IndexExtractor indexExtractor) {\n+        Objects.requireNonNull(indexExtractor, \"indexExtractor\");\n+        indexExtractor.processIndices(this::add);\n         if (!this.indices.isEmpty()) {\n             if (this.indices.last() >= shape.getNumberOfBits()) {\n                 throw new IllegalArgumentException(String.format(\"Value in list %s is greater than maximum value (%s)\",\ndiff --git a/src/main/java/org/apache/commons/collections4/bloomfilter/WrappedBloomFilter.java b/src/main/java/org/apache/commons/collections4/bloomfilter/WrappedBloomFilter.java\nindex 2a59fcf018..4e259d2a58 100644\n--- a/src/main/java/org/apache/commons/collections4/bloomfilter/WrappedBloomFilter.java\n+++ b/src/main/java/org/apache/commons/collections4/bloomfilter/WrappedBloomFilter.java\n@@ -62,8 +62,8 @@ public void clear() {\n     }\n \n     @Override\n-    public boolean contains(final BitMapProducer bitMapProducer) {\n-        return wrapped.contains(bitMapProducer);\n+    public boolean contains(final BitMapExtractor bitMapExtractor) {\n+        return wrapped.contains(bitMapExtractor);\n     }\n \n     @Override\n@@ -77,8 +77,8 @@ public boolean contains(final Hasher hasher) {\n     }\n \n     @Override\n-    public boolean contains(final IndexProducer indexProducer) {\n-        return wrapped.contains(indexProducer);\n+    public boolean contains(final IndexExtractor indexExtractor) {\n+        return wrapped.contains(indexExtractor);\n     }\n \n     @Override\n@@ -97,18 +97,18 @@ public int estimateUnion(final BloomFilter other) {\n     }\n \n     @Override\n-    public boolean forEachBitMap(final LongPredicate predicate) {\n-        return wrapped.forEachBitMap(predicate);\n+    public boolean processBitMaps(final LongPredicate predicate) {\n+        return wrapped.processBitMaps(predicate);\n     }\n \n     @Override\n-    public boolean forEachBitMapPair(final BitMapProducer other, final LongBiPredicate func) {\n-        return wrapped.forEachBitMapPair(other, func);\n+    public boolean processBitMapPairs(final BitMapExtractor other, final LongBiPredicate func) {\n+        return wrapped.processBitMapPairs(other, func);\n     }\n \n     @Override\n-    public boolean forEachIndex(final IntPredicate predicate) {\n-        return wrapped.forEachIndex(predicate);\n+    public boolean processIndices(final IntPredicate predicate) {\n+        return wrapped.processIndices(predicate);\n     }\n \n     @Override\n@@ -126,8 +126,8 @@ public boolean isFull() {\n     }\n \n     @Override\n-    public boolean merge(final BitMapProducer bitMapProducer) {\n-        return wrapped.merge(bitMapProducer);\n+    public boolean merge(final BitMapExtractor bitMapExtractor) {\n+        return wrapped.merge(bitMapExtractor);\n     }\n \n     @Override\n@@ -141,7 +141,7 @@ public boolean merge(final Hasher hasher) {\n     }\n \n     @Override\n-    public boolean merge(final IndexProducer indexProducer) {\n-        return wrapped.merge(indexProducer);\n+    public boolean merge(final IndexExtractor indexExtractor) {\n+        return wrapped.merge(indexExtractor);\n     }\n }\ndiff --git a/src/main/java/org/apache/commons/collections4/bloomfilter/package-info.java b/src/main/java/org/apache/commons/collections4/bloomfilter/package-info.java\nindex d2c4355930..ce3657ac39 100644\n--- a/src/main/java/org/apache/commons/collections4/bloomfilter/package-info.java\n+++ b/src/main/java/org/apache/commons/collections4/bloomfilter/package-info.java\n@@ -21,7 +21,7 @@\n  * <h2>Background:</h2>\n  *\n  * <p>The Bloom filter is a probabilistic data structure that indicates where things are not. Conceptually it is a bit\n- * vector. You create a Bloom filter by creating hashes and converting those to enabled bits in the vector. Multiple\n+ * vector or BitMap. You create a Bloom filter by creating hashes and converting those to enabled bits in the map. Multiple\n  * Bloom filters may be merged together into one Bloom filter. It is possible to test if a filter {@code B} has merged\n  * into another filter {@code A} by verifying that {@code (A & B) == B}.</p>\n  *\n@@ -41,12 +41,43 @@\n  * {@code add}, and {@code subtract} may throw exceptions. Once an exception is thrown the state of the Bloom filter is unknown.\n  * The choice to use not use atomic transactions was made to achieve maximum performance under correct usage.</p>\n  *\n- * <p>In addition the architecture is designed so that the implementation of the storage of bits is abstracted.\n- * Programs that utilize the Bloom filters may use the {@code BitMapProducer} or {@code IndexProducer} to retrieve a\n- * representation of the internal structure. Additional methods are available in the {@code BitMap} to assist in\n- * manipulation of the representations.</p>\n+ * <h4>Nomenclature</h4>\n  *\n- * <p>The Bloom filter code is an interface that requires implementation of 9 methods:</p>\n+ * <ul>\n+ *     <li>BitMap - In the bloomfilter package a BitMap is not a structure but a logical construct.  It is conceptualized\n+ *     as an ordered collection of {@code long} values each of which is interpreted as the enabled true/false state of 64 continuous indices.  The mapping of\n+ *     bits into the {@code long} values is described in the {@code BitMaps} javadoc.</li>\n+ *\n+ *     <li>Index - In the bloomfilter package an Index is a logical collection of {@code int}s specifying the enabled\n+ *     bits in the BitMap.</li>\n+ *\n+ *     <li>Cell - Some Bloom filters (e.g. CountingBloomFilter) use counters rather than bits.  In the bloomfilter package\n+ *     Cells are pairs of ints representing an index and a value.  They are not {@code Pair} objects.  </li>\n+ *\n+ *     <li>Extractor - The Extractors are {@code FunctionalInterfaces} that are conceptually iterators on a {@code BitMap}, an {@code Index}, or a\n+ *     collection of {@code Cell}s, with an early termination switch.  Extractors have\n+ *     names like {@code BitMapExtractor} or {@code IndexExtractor} and have a {@code processXs} methods that take a\n+ *     {@code Predicate<X>} argument (e.g. {@code processBitMaps(LongPredicate)} or {@code processIndicies(IntPredicate)}).\n+ *     That predicate is expected to process each of the Xs in turn and return {@code true} if the processing should continue\n+ *     or {@code false} to stop it. </li>\n+ * </ul>\n+ *\n+ * <p>There is an obvious association between the BitMap and the Index, as defined above, in that if bit 5 is enabled in the\n+ * BitMap than the Index must contain the value 5.</p>\n+ *\n+ *\n+ * <h4>Implementation Notes</h4>\n+ *\n+ * <p>The architecture is designed so that the implementation of the storage of bits is abstracted. Rather than specifying a\n+ * specific state representation we require that all Bloom filters implement the BitMapExtractor and IndexExtractor interfaces,\n+ * Counting-based Bloom filters implement {@code CellExtractor} as well.  There are static\n+ * methods in the various Extractor interfaces to convert from one type to another.</p>\n+ *\n+ * <p>Programs that utilize the Bloom filters may use the {@code BitMapExtractor} or {@code IndexExtractor} to retrieve\n+ * or process a representation of the internal structure.\n+ * Additional methods are available in the {@code BitMaps} class to assist in manipulation of BitMap representations.</p>\n+ *\n+ * <p>The Bloom filter is an interface that requires implementation of 9 methods:</p>\n  * <ul>\n  * <li>{@link BloomFilter#cardinality()} returns the number of bits enabled in the Bloom filter.</li>\n  *\n@@ -54,17 +85,17 @@\n  *\n  * <li>{@link BloomFilter#clear()} which resets the Bloomfilter to its initial empty state.</li>\n  *\n- * <li>{@link BloomFilter#contains(IndexProducer)} which returns true if the bits specified by the indices generated by\n- * IndexProducer are enabled in the Bloom filter.</li>\n+ * <li>{@link BloomFilter#contains(IndexExtractor)} which returns true if the bits specified by the indices generated by\n+ * IndexExtractor are enabled in the Bloom filter.</li>\n  *\n  * <li>{@link BloomFilter#copy()} which returns a fresh copy of the bitmap.</li>\n  *\n  * <li>{@link BloomFilter#getShape()} which returns the shape the Bloom filter was created with.</li>\n  *\n- * <li>{@link BloomFilter#merge(BitMapProducer)} which merges the BitMaps from the BitMapProducer into the internal\n+ * <li>{@link BloomFilter#merge(BitMapExtractor)} which merges the BitMaps from the BitMapExtractor into the internal\n  * representation of the Bloom filter.</li>\n  *\n- * <li>{@link BloomFilter#merge(IndexProducer)} which merges the indices from the IndexProducer into the internal\n+ * <li>{@link BloomFilter#merge(IndexExtractor)} which merges the indices from the IndexExtractor into the internal\n  * representation of the Bloom filter.</li>\n  * </ul>\n  *\n@@ -83,7 +114,8 @@\n  *\n  * <h3>Shape</h3>\n  *\n- * <p>The Shape describes the Bloom filter using the number of bits and the number of hash functions</p>\n+ * <p>The Shape describes the Bloom filter using the number of bits and the number of hash functions.  It can be specified\n+ * by the number of expected items and desired false positive rate.</p>\n  *\n  * <h3>Hasher</h3>\n  *\n",
  "test_patch" : "diff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBitMapProducerTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBitMapExtractorTest.java\nsimilarity index 59%\nrename from src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBitMapProducerTest.java\nrename to src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBitMapExtractorTest.java\nindex ed47f1ec08..0a631158f0 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBitMapProducerTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBitMapExtractorTest.java\n@@ -25,7 +25,7 @@\n \n import org.junit.jupiter.api.Test;\n \n-public abstract class AbstractBitMapProducerTest {\n+public abstract class AbstractBitMapExtractorTest {\n \n     /**\n      * A testing consumer that always returns false.\n@@ -38,16 +38,16 @@ public abstract class AbstractBitMapProducerTest {\n     static final LongPredicate TRUE_CONSUMER = arg0 -> true;\n \n     /**\n-     * Creates an producer without data.\n-     * @return a producer that has no data.\n+     * Creates a BitMapExtractor without data.\n+     * @return a BitMap extractor that has no data.\n      */\n-    protected abstract BitMapProducer createEmptyProducer();\n+    protected abstract BitMapExtractor createEmptyExtractor();\n \n     /**\n-     * Creates a producer with some data.\n-     * @return a producer with some data\n+     * Creates a BitMapExtractor with some data.\n+     * @return a BitMap extractor with some data\n      */\n-    protected abstract BitMapProducer createProducer();\n+    protected abstract BitMapExtractor createExtractor();\n \n     protected boolean emptyIsZeroLength() {\n         return false;\n@@ -55,32 +55,32 @@ protected boolean emptyIsZeroLength() {\n \n     @Test\n     public final void testAsBitMapArray() {\n-        long[] array = createEmptyProducer().asBitMapArray();\n+        long[] array = createEmptyExtractor().asBitMapArray();\n         for (int i = 0; i < array.length; i++) {\n             assertEquals(0, array[i], \"Wrong value at \" + i);\n         }\n \n-        array = createProducer().asBitMapArray();\n+        array = createExtractor().asBitMapArray();\n         assertFalse(array.length == 0);\n     }\n \n     @Test\n     public final void testForEachBitMap() {\n-        assertFalse(createProducer().forEachBitMap(FALSE_CONSUMER), \"non-empty should be false\");\n+        assertFalse(createExtractor().processBitMaps(FALSE_CONSUMER), \"non-empty should be false\");\n         if (emptyIsZeroLength()) {\n-            assertTrue(createEmptyProducer().forEachBitMap(FALSE_CONSUMER), \"empty should be true\");\n+            assertTrue(createEmptyExtractor().processBitMaps(FALSE_CONSUMER), \"empty should be true\");\n         } else {\n-            assertFalse(createEmptyProducer().forEachBitMap(FALSE_CONSUMER), \"empty should be false\");\n+            assertFalse(createEmptyExtractor().processBitMaps(FALSE_CONSUMER), \"empty should be false\");\n         }\n \n-        assertTrue(createProducer().forEachBitMap(TRUE_CONSUMER), \"non-empty should be true\");\n-        assertTrue(createEmptyProducer().forEachBitMap(TRUE_CONSUMER), \"empty should be true\");\n+        assertTrue(createExtractor().processBitMaps(TRUE_CONSUMER), \"non-empty should be true\");\n+        assertTrue(createEmptyExtractor().processBitMaps(TRUE_CONSUMER), \"empty should be true\");\n     }\n \n     @Test\n     public void testForEachBitMapEarlyExit() {\n         final int[] passes = new int[1];\n-        assertFalse(createProducer().forEachBitMap(l -> {\n+        assertFalse(createExtractor().processBitMaps(l -> {\n             passes[0]++;\n             return false;\n         }));\n@@ -88,13 +88,13 @@ public void testForEachBitMapEarlyExit() {\n \n         passes[0] = 0;\n         if (emptyIsZeroLength()) {\n-            assertTrue(createEmptyProducer().forEachBitMap(l -> {\n+            assertTrue(createEmptyExtractor().processBitMaps(l -> {\n                 passes[0]++;\n                 return false;\n             }));\n             assertEquals(0, passes[0]);\n         } else {\n-            assertFalse(createEmptyProducer().forEachBitMap(l -> {\n+            assertFalse(createEmptyExtractor().processBitMaps(l -> {\n                 passes[0]++;\n                 return false;\n             }));\n@@ -105,12 +105,12 @@ public void testForEachBitMapEarlyExit() {\n     @Test\n     public final void testForEachBitMapPair() {\n         final LongBiPredicate func = (x, y) -> x == y;\n-        assertTrue(createEmptyProducer().forEachBitMapPair(createEmptyProducer(), func), \"empty == empty failed\");\n-        assertFalse(createEmptyProducer().forEachBitMapPair(createProducer(), func), \"empty == not_empty failed\");\n-        assertFalse(createProducer().forEachBitMapPair(createEmptyProducer(), func), \"not_empty == empty passed\");\n-        assertTrue(createProducer().forEachBitMapPair(createProducer(), func), \"not_empty == not_empty failed\");\n+        assertTrue(createEmptyExtractor().processBitMapPairs(createEmptyExtractor(), func), \"empty == empty failed\");\n+        assertFalse(createEmptyExtractor().processBitMapPairs(createExtractor(), func), \"empty == not_empty failed\");\n+        assertFalse(createExtractor().processBitMapPairs(createEmptyExtractor(), func), \"not_empty == empty passed\");\n+        assertTrue(createExtractor().processBitMapPairs(createExtractor(), func), \"not_empty == not_empty failed\");\n \n-        // test BitMapProducers of different length send 0 for missing values.\n+        // test BitMapExtractors of different length send 0 for missing values.\n         final int[] count = new int[3];\n         final LongBiPredicate lbp = (x, y) -> {\n             if (x == 0) {\n@@ -122,38 +122,38 @@ public final void testForEachBitMapPair() {\n             count[2]++;\n             return true;\n         };\n-        createEmptyProducer().forEachBitMapPair(createProducer(), lbp);\n+        createEmptyExtractor().processBitMapPairs(createExtractor(), lbp);\n         assertEquals(count[2], count[0]);\n \n         Arrays.fill(count, 0);\n-        createProducer().forEachBitMapPair(createEmptyProducer(), lbp);\n+        createExtractor().processBitMapPairs(createEmptyExtractor(), lbp);\n         assertEquals(count[2], count[1]);\n \n-        // test where the created producer does not process all records because the predicate function\n+        // test where the created extractor does not process all records because the predicate function\n         // returns false before the processing is completed.\n         final int[] limit = new int[1];\n         final LongBiPredicate shortFunc =  (x, y) -> {\n             limit[0]++;\n             return limit[0] < 2;\n         };\n-        final BitMapProducer shortProducer = l -> true;\n-        assertFalse(createProducer().forEachBitMapPair(shortProducer, shortFunc));\n+        final BitMapExtractor shortExtractor = l -> true;\n+        assertFalse(createExtractor().processBitMapPairs(shortExtractor, shortFunc));\n     }\n \n     @Test\n     public void testForEachBitMapPairEarlyExit() {\n \n-        // test BitMapProducers of different length send 0 for missing values.\n+        // test BitMapExtractir of different length send 0 for missing values.\n         final int[] count = new int[1];\n         final LongBiPredicate lbp = (x, y) -> {\n             count[0]++;\n             return false;\n         };\n-        createProducer().forEachBitMapPair(createEmptyProducer(), lbp);\n+        createExtractor().processBitMapPairs(createEmptyExtractor(), lbp);\n         assertEquals(1, count[0]);\n \n         Arrays.fill(count, 0);\n-        createEmptyProducer().forEachBitMapPair(createProducer(), lbp);\n+        createEmptyExtractor().processBitMapPairs(createExtractor(), lbp);\n         assertEquals(1, count[0]);\n     }\n }\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBloomFilterProducerTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBloomFilterExtractorTest.java\nsimilarity index 77%\nrename from src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBloomFilterProducerTest.java\nrename to src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBloomFilterExtractorTest.java\nindex 102ba9bcf4..7dd03625a2 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBloomFilterProducerTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBloomFilterExtractorTest.java\n@@ -26,7 +26,7 @@\n import org.junit.jupiter.api.BeforeEach;\n import org.junit.jupiter.api.Test;\n \n-public abstract class AbstractBloomFilterProducerTest {\n+public abstract class AbstractBloomFilterExtractorTest {\n     private final Shape shape = Shape.fromKM(17, 72);\n \n     BloomFilter one = new SimpleBloomFilter(shape);\n@@ -46,16 +46,16 @@ public abstract class AbstractBloomFilterProducerTest {\n         return true;\n     };\n \n-    private BloomFilterProducer createUnderTest() {\n+    private BloomFilterExtractor createUnderTest() {\n         return createUnderTest(one, two);\n     }\n \n     /**\n-     * Creates a BloomFilterProducer that returns the filters (or their copy) in the order presented.\n+     * Creates a BloomFilterExtractor that returns the filters (or their copy) in the order presented.\n      * @param filters The filters to return.\n-     * @return A BloomFilterProducer that returns the filters in order.\n+     * @return A BloomFilterExtractor that returns the filters in order.\n      */\n-    protected abstract BloomFilterProducer createUnderTest(BloomFilter... filters);\n+    protected abstract BloomFilterExtractor createUnderTest(BloomFilter... filters);\n \n     /**\n      * The shape of the Bloom filters for testing.\n@@ -72,9 +72,9 @@ protected Shape getTestShape() {\n     @BeforeEach\n     public void setup() {\n         one.clear();\n-        one.merge(IndexProducer.fromIndexArray(1));\n+        one.merge(IndexExtractor.fromIndexArray(1));\n         two.clear();\n-        two.merge(IndexProducer.fromIndexArray(2, 3));\n+        two.merge(IndexExtractor.fromIndexArray(2, 3));\n         nullCount[0] = 0;\n         nullCount[1] = 0;\n         equalityCount[0] = 0;\n@@ -92,13 +92,13 @@ public void testAsBloomFilterArray() {\n     public void testFlatten() {\n         final BloomFilter underTest = createUnderTest().flatten();\n         final BloomFilter expected = new SimpleBloomFilter(shape);\n-        expected.merge(IndexProducer.fromIndexArray(1, 2, 3));\n+        expected.merge(IndexExtractor.fromIndexArray(1, 2, 3));\n         assertArrayEquals(expected.asBitMapArray(), underTest.asBitMapArray());\n     }\n \n     @Test\n     public void testForEachPairArrayTooLong() {\n-        assertTrue(createUnderTest().forEachBloomFilterPair(BloomFilterProducer.fromBloomFilterArray(one, two, one),\n+        assertTrue(createUnderTest().processBloomFilterPair(BloomFilterExtractor.fromBloomFilterArray(one, two, one),\n                 counter));\n         assertEquals(1, nullCount[0]);\n         assertEquals(0, nullCount[1]);\n@@ -107,7 +107,7 @@ public void testForEachPairArrayTooLong() {\n \n     @Test\n     public void testForEachPairArrayTooShort() {\n-        assertTrue(createUnderTest().forEachBloomFilterPair(BloomFilterProducer.fromBloomFilterArray(one), counter));\n+        assertTrue(createUnderTest().processBloomFilterPair(BloomFilterExtractor.fromBloomFilterArray(one), counter));\n         assertEquals(0, nullCount[0]);\n         assertEquals(1, nullCount[1]);\n         assertEquals(1, equalityCount[0]);\n@@ -115,20 +115,20 @@ public void testForEachPairArrayTooShort() {\n \n     @Test\n     public void testForEachPairCompleteMatch() {\n-        assertTrue(createUnderTest().forEachBloomFilterPair(createUnderTest(), counter));\n+        assertTrue(createUnderTest().processBloomFilterPair(createUnderTest(), counter));\n         assertArrayEquals(new int[] { 0, 0 }, nullCount);\n         assertEquals(2, equalityCount[0]);\n     }\n \n     @Test\n     public void testForEachPairReturnFalseEarly() {\n-        assertFalse(createUnderTest().forEachBloomFilterPair(BloomFilterProducer.fromBloomFilterArray(one, two, one),\n+        assertFalse(createUnderTest().processBloomFilterPair(BloomFilterExtractor.fromBloomFilterArray(one, two, one),\n                 (x, y) -> false));\n     }\n \n     @Test\n     public void testForEachPairReturnFalseLate() {\n-        assertFalse(createUnderTest().forEachBloomFilterPair(BloomFilterProducer.fromBloomFilterArray(one, two, one),\n+        assertFalse(createUnderTest().processBloomFilterPair(BloomFilterExtractor.fromBloomFilterArray(one, two, one),\n                 counter.and((x, y) -> x != null && y != null)));\n         assertEquals(1, nullCount[0]);\n         assertEquals(0, nullCount[1]);\n@@ -137,7 +137,7 @@ public void testForEachPairReturnFalseLate() {\n \n     @Test\n     public void testForEachPairReturnFalseLateShortArray() {\n-        assertFalse(createUnderTest().forEachBloomFilterPair(BloomFilterProducer.fromBloomFilterArray(one),\n+        assertFalse(createUnderTest().processBloomFilterPair(BloomFilterExtractor.fromBloomFilterArray(one),\n                 counter.and((x, y) -> x != null && y != null)));\n         assertEquals(0, nullCount[0]);\n         assertEquals(1, nullCount[1]);\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBloomFilterTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBloomFilterTest.java\nindex a0eaa4a5c4..93646935a0 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBloomFilterTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBloomFilterTest.java\n@@ -40,28 +40,28 @@ public abstract class AbstractBloomFilterTest<T extends BloomFilter> {\n      */\n     public static class BadHasher implements Hasher {\n \n-        IndexProducer producer;\n+        IndexExtractor extractor;\n \n         public BadHasher(final int value) {\n-            this.producer = IndexProducer.fromIndexArray(value);\n+            this.extractor = IndexExtractor.fromIndexArray(value);\n         }\n \n         @Override\n-        public IndexProducer indices(final Shape shape) {\n-            return producer;\n+        public IndexExtractor indices(final Shape shape) {\n+            return extractor;\n         }\n     }\n \n-    private void assertFailedIndexProducerConstructor(final Shape shape, final int[] values) {\n-        final IndexProducer indices = IndexProducer.fromIndexArray(values);\n+    private void assertFailedIndexExtractorConstructor(final Shape shape, final int[] values) {\n+        final IndexExtractor indices = IndexExtractor.fromIndexArray(values);\n         assertThrows(IllegalArgumentException.class, () -> createFilter(shape, indices));\n     }\n \n-    private void assertIndexProducerMerge(final Shape shape, final int[] values, final int[] expected) {\n-        final IndexProducer indices = IndexProducer.fromIndexArray(values);\n+    private void assertIndexExtractorMerge(final Shape shape, final int[] values, final int[] expected) {\n+        final IndexExtractor indices = IndexExtractor.fromIndexArray(values);\n         final BloomFilter filter = createFilter(shape, indices);\n         final List<Integer> lst = new ArrayList<>();\n-        filter.forEachIndex(x -> {\n+        filter.processIndices(x -> {\n             lst.add(x);\n             return true;\n         });\n@@ -83,12 +83,12 @@ private void assertIndexProducerMerge(final Shape shape, final int[] values, fin\n      * Create the BloomFilter implementation we are testing.\n      *\n      * @param shape the shape of the filter.\n-     * @param producer A BitMap producer to build the filter with.\n+     * @param extractor A BitMap extractor to build the filter with.\n      * @return a BloomFilter implementation.\n      */\n-    protected final T createFilter(final Shape shape, final BitMapProducer producer) {\n+    protected final T createFilter(final Shape shape, final BitMapExtractor extractor) {\n         final T bf = createEmptyFilter(shape);\n-        bf.merge(producer);\n+        bf.merge(extractor);\n         return bf;\n     }\n \n@@ -109,12 +109,12 @@ protected final T createFilter(final Shape shape, final Hasher hasher) {\n      * Create the BloomFilter implementation we are testing.\n      *\n      * @param shape the shape of the filter.\n-     * @param producer An Index producer to build the filter with.\n+     * @param extractor An Index extractor to build the filter with.\n      * @return a BloomFilter implementation.\n      */\n-    protected final T createFilter(final Shape shape, final IndexProducer producer) {\n+    protected final T createFilter(final Shape shape, final IndexExtractor extractor) {\n         final T bf = createEmptyFilter(shape);\n-        bf.merge(producer);\n+        bf.merge(extractor);\n         return bf;\n     }\n \n@@ -146,20 +146,20 @@ public final void testAsBitMapArray() {\n     }\n \n     @Test\n-    public void testBitMapProducerSize() {\n+    public void testBitMapExtractorSize() {\n         final int[] idx = new int[1];\n-        createFilter(getTestShape(), TestingHashers.FROM1).forEachBitMap(i -> {\n+        createFilter(getTestShape(), TestingHashers.FROM1).processBitMaps(i -> {\n             idx[0]++;\n             return true;\n         });\n-        assertEquals(BitMap.numberOfBitMaps(getTestShape().getNumberOfBits()), idx[0]);\n+        assertEquals(BitMaps.numberOfBitMaps(getTestShape().getNumberOfBits()), idx[0]);\n \n         idx[0] = 0;\n-        createEmptyFilter(getTestShape()).forEachBitMap(i -> {\n+        createEmptyFilter(getTestShape()).processBitMaps(i -> {\n             idx[0]++;\n             return true;\n         });\n-        assertEquals(BitMap.numberOfBitMaps(getTestShape().getNumberOfBits()), idx[0]);\n+        assertEquals(BitMaps.numberOfBitMaps(getTestShape().getNumberOfBits()), idx[0]);\n     }\n \n     @Test\n@@ -169,7 +169,7 @@ public void testCardinalityAndIsEmpty() {\n \n     /**\n      * Test cardinality and isEmpty. Bloom filter must be able to accept multiple\n-     * IndexProducer merges until all the bits are populated.\n+     * IndexExtractor merges until all the bits are populated.\n      *\n      * @param bf The Bloom filter to test.\n      */\n@@ -177,7 +177,7 @@ protected void testCardinalityAndIsEmpty(final BloomFilter bf) {\n         assertTrue(bf.isEmpty());\n         assertEquals(0, bf.cardinality());\n         for (int i = 0; i < getTestShape().getNumberOfBits(); i++) {\n-            bf.merge(IndexProducer.fromIndexArray(i));\n+            bf.merge(IndexExtractor.fromIndexArray(i));\n             assertFalse(bf.isEmpty(), \"Wrong value at \" + i);\n             assertEquals(i + 1, bf.cardinality(), \"Wrong value at \" + i);\n         }\n@@ -187,7 +187,7 @@ protected void testCardinalityAndIsEmpty(final BloomFilter bf) {\n         assertEquals(0, bf.cardinality());\n         assertTrue(bf.isEmpty());\n         for (int i = 0; i < getTestShape().getNumberOfBits(); i++) {\n-            bf.merge(IndexProducer.fromIndexArray(i));\n+            bf.merge(IndexExtractor.fromIndexArray(i));\n             assertEquals(i + 1, bf.cardinality(), \"Wrong value at \" + i);\n             assertFalse(bf.isEmpty(), \"Wrong value at \" + i);\n         }\n@@ -213,16 +213,16 @@ public final void testContains() {\n         assertTrue(bf2.contains(new IncrementingHasher(1, 1)), \"BF2 Should contain this hasher\");\n         assertFalse(bf2.contains(new IncrementingHasher(1, 3)), \"BF2 Should not contain this hasher\");\n \n-        IndexProducer indexProducer = new IncrementingHasher(1, 1).indices(getTestShape());\n-        assertTrue(bf2.contains(indexProducer), \"BF2 Should contain this hasher\");\n-        indexProducer = new IncrementingHasher(1, 3).indices(getTestShape());\n-        assertFalse(bf2.contains(indexProducer), \"BF2 Should not contain this hasher\");\n+        IndexExtractor indexExtractor = new IncrementingHasher(1, 1).indices(getTestShape());\n+        assertTrue(bf2.contains(indexExtractor), \"BF2 Should contain this hasher\");\n+        indexExtractor = new IncrementingHasher(1, 3).indices(getTestShape());\n+        assertFalse(bf2.contains(indexExtractor), \"BF2 Should not contain this hasher\");\n \n-        BitMapProducer bitMapProducer = BitMapProducer.fromIndexProducer(new IncrementingHasher(1, 1).indices(getTestShape()),\n+        BitMapExtractor bitMapExtractor = BitMapExtractor.fromIndexExtractor(new IncrementingHasher(1, 1).indices(getTestShape()),\n                 getTestShape().getNumberOfBits());\n-        assertTrue(bf2.contains(bitMapProducer), \"BF2 Should contain this hasher\");\n-        bitMapProducer = BitMapProducer.fromIndexProducer(new IncrementingHasher(1, 3).indices(getTestShape()), getTestShape().getNumberOfBits());\n-        assertFalse(bf2.contains(bitMapProducer), \"BF2 Should not contain this hasher\");\n+        assertTrue(bf2.contains(bitMapExtractor), \"BF2 Should contain this hasher\");\n+        bitMapExtractor = BitMapExtractor.fromIndexExtractor(new IncrementingHasher(1, 3).indices(getTestShape()), getTestShape().getNumberOfBits());\n+        assertFalse(bf2.contains(bitMapExtractor), \"BF2 Should not contain this hasher\");\n \n         // Test different lengths\n         bf1 = createFilter(getTestShape(), TestingHashers.FROM1);\n@@ -242,7 +242,7 @@ public void testEmptyAfterMergeWithNothing() {\n         // test the case where is empty after merge\n         // in this case the internal cardinality == -1\n         final BloomFilter bf = createEmptyFilter(getTestShape());\n-        bf.merge(IndexProducer.fromIndexArray());\n+        bf.merge(IndexExtractor.fromIndexArray());\n         assertTrue(bf.isEmpty());\n     }\n \n@@ -316,18 +316,18 @@ public final void testEstimateUnion() {\n     }\n \n     @Test\n-    public void testIndexProducerMerge() {\n+    public void testIndexExtractorMerge() {\n         final Shape shape = Shape.fromKM(5, 10);\n \n-        assertIndexProducerMerge(shape, new int[] {0, 2, 4, 6, 8}, new int[] {0, 2, 4, 6, 8});\n+        assertIndexExtractorMerge(shape, new int[] {0, 2, 4, 6, 8}, new int[] {0, 2, 4, 6, 8});\n         // test duplicate values\n-        assertIndexProducerMerge(shape, new int[] {0, 2, 4, 2, 8}, new int[] {0, 2, 4, 8});\n+        assertIndexExtractorMerge(shape, new int[] {0, 2, 4, 2, 8}, new int[] {0, 2, 4, 8});\n         // test negative values\n-        assertFailedIndexProducerConstructor(shape, new int[] {0, 2, 4, -2, 8});\n+        assertFailedIndexExtractorConstructor(shape, new int[] {0, 2, 4, -2, 8});\n         // test index too large\n-        assertFailedIndexProducerConstructor(shape, new int[] {0, 2, 4, 12, 8});\n+        assertFailedIndexExtractorConstructor(shape, new int[] {0, 2, 4, 12, 8});\n         // test no indices\n-        assertIndexProducerMerge(shape, new int[0], new int[0]);\n+        assertIndexExtractorMerge(shape, new int[0], new int[0]);\n     }\n \n     /**\n@@ -412,53 +412,53 @@ public void testMergeWithBadHasher() {\n     }\n \n     @Test\n-    public void testMergeWithBitMapProducer() {\n-        final int bitMapCount = BitMap.numberOfBitMaps(getTestShape().getNumberOfBits());\n+    public void testMergeWithBitMapExtractor() {\n+        final int bitMapCount = BitMaps.numberOfBitMaps(getTestShape().getNumberOfBits());\n         for (int i = 0; i < 5; i++) {\n             final long[] values = new long[bitMapCount];\n-            for (final int idx : DefaultIndexProducerTest.generateIntArray(getTestShape().getNumberOfHashFunctions(), getTestShape().getNumberOfBits())) {\n-                BitMap.set(values, idx);\n+            for (final int idx : DefaultIndexExtractorTest.generateIntArray(getTestShape().getNumberOfHashFunctions(), getTestShape().getNumberOfBits())) {\n+                BitMaps.set(values, idx);\n             }\n-            final BloomFilter f = createFilter(getTestShape(), BitMapProducer.fromBitMapArray(values));\n+            final BloomFilter f = createFilter(getTestShape(), BitMapExtractor.fromBitMapArray(values));\n             final List<Long> lst = new ArrayList<>();\n             for (final long l : values) {\n                 lst.add(l);\n             }\n-            assertTrue(f.forEachBitMap(l -> lst.remove(Long.valueOf(l))));\n+            assertTrue(f.processBitMaps(l -> lst.remove(Long.valueOf(l))));\n             assertTrue(lst.isEmpty());\n         }\n         // values too large\n         final long[] values = new long[bitMapCount];\n         Arrays.fill(values, Long.MAX_VALUE);\n-        final BitMapProducer badProducer = BitMapProducer.fromBitMapArray(values);\n+        final BitMapExtractor badExtractor = BitMapExtractor.fromBitMapArray(values);\n         final BloomFilter bf = createEmptyFilter(getTestShape());\n-        assertThrows(IllegalArgumentException.class, () -> bf.merge(badProducer));\n+        assertThrows(IllegalArgumentException.class, () -> bf.merge(badExtractor));\n \n         // test where merged bits exceed expected bits but both bitmaps are the same length.\n-        final BitMapProducer badProducer2 = BitMapProducer.fromBitMapArray(0x80_00_00_00_00_00_00_00L);\n+        final BitMapExtractor badExtractor2 = BitMapExtractor.fromBitMapArray(0x80_00_00_00_00_00_00_00L);\n         final BloomFilter bf2 = createEmptyFilter(Shape.fromKM(3, 32));\n-        assertThrows(IllegalArgumentException.class, () -> bf2.merge(badProducer2));\n+        assertThrows(IllegalArgumentException.class, () -> bf2.merge(badExtractor2));\n     }\n \n     @Test\n     public void testMergeWithHasher() {\n         for (int i = 0; i < 5; i++) {\n             final BloomFilter f = createEmptyFilter(getTestShape());\n-            final int[] expected = DefaultIndexProducerTest.generateIntArray(getTestShape().getNumberOfHashFunctions(), getTestShape().getNumberOfBits());\n+            final int[] expected = DefaultIndexExtractorTest.generateIntArray(getTestShape().getNumberOfHashFunctions(), getTestShape().getNumberOfBits());\n             final Hasher hasher = new ArrayHasher(expected);\n             f.merge(hasher);\n             // create sorted unique array of expected values\n-            assertArrayEquals(DefaultIndexProducerTest.unique(expected), f.asIndexArray());\n+            assertArrayEquals(DefaultIndexExtractorTest.unique(expected), f.asIndexArray());\n         }\n     }\n \n     @Test\n-    public void testMergeWithIndexProducer() {\n+    public void testMergeWithIndexExtractor() {\n         for (int i = 0; i < 5; i++) {\n-            final int[] values = DefaultIndexProducerTest.generateIntArray(getTestShape().getNumberOfHashFunctions(), getTestShape().getNumberOfBits());\n-            final BloomFilter f = createFilter(getTestShape(), IndexProducer.fromIndexArray(values));\n-            final BitSet uniqueValues = DefaultIndexProducerTest.uniqueSet(values);\n-            assertTrue(f.forEachIndex(idx -> {\n+            final int[] values = DefaultIndexExtractorTest.generateIntArray(getTestShape().getNumberOfHashFunctions(), getTestShape().getNumberOfBits());\n+            final BloomFilter f = createFilter(getTestShape(), IndexExtractor.fromIndexArray(values));\n+            final BitSet uniqueValues = DefaultIndexExtractorTest.uniqueSet(values);\n+            assertTrue(f.processIndices(idx -> {\n                 final boolean result = uniqueValues.get(idx);\n                 uniqueValues.clear(idx);\n                 return result;\n@@ -468,17 +468,17 @@ public void testMergeWithIndexProducer() {\n         // value to large\n         final BloomFilter f1 = createEmptyFilter(getTestShape());\n         assertThrows(IllegalArgumentException.class,\n-                () -> f1.merge(IndexProducer.fromIndexArray(getTestShape().getNumberOfBits())));\n+                () -> f1.merge(IndexExtractor.fromIndexArray(getTestShape().getNumberOfBits())));\n         // negative value\n         final BloomFilter f2 = createEmptyFilter(getTestShape());\n         assertThrows(IllegalArgumentException.class,\n-                () -> f2.merge(IndexProducer.fromIndexArray(-1)));\n+                () -> f2.merge(IndexExtractor.fromIndexArray(-1)));\n     }\n \n     @Test\n     public final void testNegativeIntersection() {\n-        final IndexProducer p1 = IndexProducer.fromIndexArray(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 20, 26, 28, 30, 32, 34, 35, 36, 37, 39, 40, 41, 42, 43, 45, 46, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71);\n-        final IndexProducer p2 = IndexProducer.fromIndexArray(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27);\n+        final IndexExtractor p1 = IndexExtractor.fromIndexArray(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 20, 26, 28, 30, 32, 34, 35, 36, 37, 39, 40, 41, 42, 43, 45, 46, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71);\n+        final IndexExtractor p2 = IndexExtractor.fromIndexArray(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27);\n \n         final BloomFilter filter1 = createEmptyFilter(Shape.fromKM(17, 72));\n         filter1.merge(p1);\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractCellProducerTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractCellExtractorTest.java\nsimilarity index 67%\nrename from src/test/java/org/apache/commons/collections4/bloomfilter/AbstractCellProducerTest.java\nrename to src/test/java/org/apache/commons/collections4/bloomfilter/AbstractCellExtractorTest.java\nindex b48c0a8dda..02c00c6785 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractCellProducerTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractCellExtractorTest.java\n@@ -25,33 +25,33 @@\n import java.util.Arrays;\n import java.util.BitSet;\n \n-import org.apache.commons.collections4.bloomfilter.CellProducer.CellConsumer;\n+import org.apache.commons.collections4.bloomfilter.CellExtractor.CellPredicate;\n import org.junit.jupiter.api.Test;\n \n-public abstract class AbstractCellProducerTest extends AbstractIndexProducerTest {\n+public abstract class AbstractCellExtractorTest extends AbstractIndexExtractorTest {\n \n     /**\n      * A testing CellConsumer that always returns true.\n      */\n-    private static final CellConsumer TRUE_CONSUMER = (i, j) -> true;\n+    private static final CellPredicate TRUE_CONSUMER = (i, j) -> true;\n     /**\n      * A testing CellConsumer that always returns false.\n      */\n-    private static final CellConsumer FALSE_CONSUMER = (i, j) -> false;\n+    private static final CellPredicate FALSE_CONSUMER = (i, j) -> false;\n \n     /**\n-     * Creates a producer without data.\n-     * @return a producer that has no data.\n+     * Creates a CellExtractor without data.\n+     * @return a cell extractor that has no data.\n      */\n     @Override\n-    protected abstract CellProducer createEmptyProducer();\n+    protected abstract CellExtractor createEmptyExtractor();\n \n     /**\n-     * Creates a producer with some data.\n-     * @return a producer with some data\n+     * Creates a CellExtractor with some data.\n+     * @return a cell extractor with some data\n      */\n     @Override\n-    protected abstract CellProducer createProducer();\n+    protected abstract CellExtractor createExtractor();\n \n     @Override\n     protected final int getAsIndexArrayBehaviour() {\n@@ -61,19 +61,19 @@ protected final int getAsIndexArrayBehaviour() {\n     /**\n      * Creates an array of expected values that aligns with the expected indices entries.\n      * @return an array of expected values.\n-     * @see AbstractIndexProducerTest#getExpectedIndices()\n+     * @see AbstractIndexExtractorTest#getExpectedIndices()\n      */\n     protected abstract int[] getExpectedValues();\n \n     /**\n-     * Test the behavior of {@link CellProducer#forEachCell(CellConsumer)} with respect\n+     * Test the behavior of {@link CellExtractor#processCells(CellPredicate)} with respect\n      * to ordered and distinct indices. Currently the behavior is assumed to be the same as\n-     * {@link IndexProducer#forEachIndex(java.util.function.IntPredicate)}.\n+     * {@link IndexExtractor#processIndices(java.util.function.IntPredicate)}.\n      */\n     @Test\n     public final void testBehaviourForEachCell() {\n         final IntList list = new IntList();\n-        createProducer().forEachCell((i, j) -> list.add(i));\n+        createExtractor().processCells((i, j) -> list.add(i));\n         final int[] actual = list.toArray();\n         // check order\n         final int[] expected = Arrays.stream(actual).sorted().toArray();\n@@ -84,11 +84,11 @@ public final void testBehaviourForEachCell() {\n     }\n \n     @Test\n-    public final void testEmptyCellProducer() {\n-        final CellProducer empty = createEmptyProducer();\n+    public final void testEmptyCellExtractor() {\n+        final CellExtractor empty = createEmptyExtractor();\n         final int[] ary = empty.asIndexArray();\n         assertEquals(0, ary.length);\n-        assertTrue(empty.forEachCell((i, j) -> {\n+        assertTrue(empty.processCells((i, j) -> {\n             fail(\"forEachCell consumer should not be called\");\n             return false;\n         }));\n@@ -97,13 +97,13 @@ public final void testEmptyCellProducer() {\n     @Test\n     public void testForEachCellEarlyExit() {\n         final int[] passes = new int[1];\n-        assertTrue(createEmptyProducer().forEachCell((i, j) -> {\n+        assertTrue(createEmptyExtractor().processCells((i, j) -> {\n             passes[0]++;\n             return false;\n         }));\n         assertEquals(0, passes[0]);\n \n-        assertFalse(createProducer().forEachCell((i, j) -> {\n+        assertFalse(createExtractor().processCells((i, j) -> {\n             passes[0]++;\n             return false;\n         }));\n@@ -112,14 +112,14 @@ public void testForEachCellEarlyExit() {\n \n     @Test\n     public final void testForEachCellPredicates() {\n-        final CellProducer populated = createProducer();\n-        final CellProducer empty = createEmptyProducer();\n+        final CellExtractor populated = createExtractor();\n+        final CellExtractor empty = createEmptyExtractor();\n \n-        assertFalse(populated.forEachCell(FALSE_CONSUMER), \"non-empty should be false\");\n-        assertTrue(empty.forEachCell(FALSE_CONSUMER), \"empty should be true\");\n+        assertFalse(populated.processCells(FALSE_CONSUMER), \"non-empty should be false\");\n+        assertTrue(empty.processCells(FALSE_CONSUMER), \"empty should be true\");\n \n-        assertTrue(populated.forEachCell(TRUE_CONSUMER), \"non-empty should be true\");\n-        assertTrue(empty.forEachCell(TRUE_CONSUMER), \"empty should be true\");\n+        assertTrue(populated.processCells(TRUE_CONSUMER), \"non-empty should be true\");\n+        assertTrue(empty.processCells(TRUE_CONSUMER), \"empty should be true\");\n     }\n \n     @Test\n@@ -128,7 +128,7 @@ public void testForEachCellValues() {\n         final int[] expectedValue = getExpectedValues();\n         assertEquals(expectedIdx.length, expectedValue.length, \"expected index length and value length do not match\");\n         final int[] idx = {0};\n-        createProducer().forEachCell((i, j) -> {\n+        createExtractor().processCells((i, j) -> {\n             assertEquals(expectedIdx[idx[0]], i, \"bad index at \" + idx[0]);\n             assertEquals(expectedValue[idx[0]], j, \"bad value at \" + idx[0]);\n             idx[0]++;\n@@ -138,14 +138,14 @@ public void testForEachCellValues() {\n \n     @Test\n     public final void testIndexConsistency() {\n-        final CellProducer producer = createProducer();\n+        final CellExtractor extractor = createExtractor();\n         final BitSet bs1 = new BitSet();\n         final BitSet bs2 = new BitSet();\n-        producer.forEachIndex(i -> {\n+        extractor.processIndices(i -> {\n             bs1.set(i);\n             return true;\n         });\n-        producer.forEachCell((i, j) -> {\n+        extractor.processCells((i, j) -> {\n             bs2.set(i);\n             return true;\n         });\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractCountingBloomFilterTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractCountingBloomFilterTest.java\nindex d67a0c8b56..2b3dc7ad86 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractCountingBloomFilterTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractCountingBloomFilterTest.java\n@@ -48,7 +48,7 @@ public abstract class AbstractCountingBloomFilterTest<T extends CountingBloomFil\n      */\n     private static void assertCounts(final CountingBloomFilter bf, final int[] expected) {\n         final Map<Integer, Integer> m = new HashMap<>();\n-        bf.forEachCell((i, c) -> {\n+        bf.processCells((i, c) -> {\n             m.put(i, c);\n             return true;\n         });\n@@ -65,7 +65,7 @@ private static void assertCounts(final CountingBloomFilter bf, final int[] expec\n     }\n \n     private void assertCell3(final CountingBloomFilter bf, final int value) {\n-        bf.forEachCell((k, v) -> {\n+        bf.processCells((k, v) -> {\n             if (k == 3) {\n                 assertEquals(value, v, \"Mismatch at position 3\");\n             } else {\n@@ -75,7 +75,7 @@ private void assertCell3(final CountingBloomFilter bf, final int value) {\n         });\n     }\n \n-    protected final CellProducer getMaximumValueProducer(final int maxValue) {\n+    protected final CellExtractor getMaximumValueExtractor(final int maxValue) {\n         return consumer -> {\n             for (int i = 1; i < 18; i++) {\n                 if (!consumer.test(i, maxValue)) {\n@@ -91,8 +91,8 @@ public void mergeIncrementsAllCellsTest() {\n         final CountingBloomFilter f1 = createEmptyFilter(Shape.fromKM(1, 10));\n         final CountingBloomFilter f2 = f1.copy();\n         final CountingBloomFilter f3 = f1.copy();\n-        // index producer produces 3 two times.\n-        final IndexProducer ip = p -> {\n+        // index extractor produces 3 two times.\n+        final IndexExtractor ip = p -> {\n             p.test(3);\n             p.test(3);\n             return true;\n@@ -102,22 +102,22 @@ public void mergeIncrementsAllCellsTest() {\n         assertCell3(f1, 1);\n \n         // The add should increment cells 3 by 2\n-        f2.add(CellProducer.from(ip));\n+        f2.add(CellExtractor.from(ip));\n         assertCell3(f2, 2);\n     }\n \n     @Test\n     public void removeDecrementsAllCellsTest() {\n         final CountingBloomFilter f1 = createEmptyFilter(Shape.fromKM(1, 10));\n-        final CellProducer cp = p -> {\n+        final CellExtractor cp = p -> {\n             p.test(3, 3);\n             return true;\n         };\n         f1.add(cp);\n         final CountingBloomFilter f2 = f1.copy();\n         final CountingBloomFilter f3 = f1.copy();\n-        // index producer produces 3 two times.\n-        final IndexProducer ip = p -> {\n+        // index extractor produces 3 two times.\n+        final IndexExtractor ip = p -> {\n             p.test(3);\n             p.test(3);\n             return true;\n@@ -127,11 +127,11 @@ public void removeDecrementsAllCellsTest() {\n         assertCell3(f1, 2);\n \n         // The add should decrement cells 3 by 2\n-        f2.subtract(CellProducer.from(ip));\n+        f2.subtract(CellExtractor.from(ip));\n         assertCell3(f2, 1);\n \n         // This merge will decrement by 1 as the round-trip makes the indices unique\n-        f3.remove(IndexProducer.fromIndexArray(ip.asIndexArray()));\n+        f3.remove(IndexExtractor.fromIndexArray(ip.asIndexArray()));\n         assertCell3(f3, 2);\n     }\n \n@@ -150,7 +150,7 @@ public void testAdd() {\n         // test overflow\n \n         final CountingBloomFilter bf2 = createEmptyFilter(getTestShape());\n-        assertTrue(bf2.add(getMaximumValueProducer(bf2.getMaxCell())), \"Should add to empty\");\n+        assertTrue(bf2.add(getMaximumValueExtractor(bf2.getMaxCell())), \"Should add to empty\");\n         assertTrue(bf2.isValid(), \"Should be valid\");\n \n         assertFalse(bf2.add(createFilter(getTestShape(), TestingHashers.FROM1)), \"Should not add\");\n@@ -167,8 +167,8 @@ public final void testCountingBloomFilterSpecificContains() {\n         assertTrue(bf2.contains(bf2), \"BF2 Should contain itself\");\n         assertFalse(bf.contains(bf2), \"BF should not contain BF2\");\n         assertTrue(bf2.contains(bf), \"BF2 should contain BF\");\n-        final BitMapProducer producer = bf2;\n-        assertTrue(bf2.contains(producer), \"BF2 should contain BF bitMapProducer\");\n+        final BitMapExtractor extractor = bf2;\n+        assertTrue(bf2.contains(extractor), \"BF2 should contain BF bitMapExtractor\");\n     }\n \n     /**\n@@ -180,7 +180,7 @@ public final void testCountingSpecificConstructor() {\n         // verify hasher duplicates are counted.\n         // bit hasher has duplicates for 11, 12,13,14,15,16, and 17\n         final CountingBloomFilter bf = createFilter(getTestShape(), TestingHashers.FROM1);\n-        bf.add(CellProducer.from(TestingHashers.FROM11.indices(getTestShape())));\n+        bf.add(CellExtractor.from(TestingHashers.FROM11.indices(getTestShape())));\n \n         final long[] lb = bf.asBitMapArray();\n         assertEquals(2, lb.length);\n@@ -214,7 +214,7 @@ public final void testCountingSpecificMerge() {\n         // test overflow\n \n         final CountingBloomFilter bf5 = createEmptyFilter(getTestShape());\n-        assertTrue(bf5.add(getMaximumValueProducer(bf5.getMaxCell())), \"Should add to empty\");\n+        assertTrue(bf5.add(getMaximumValueExtractor(bf5.getMaxCell())), \"Should add to empty\");\n         assertTrue(bf5.isValid(), \"Should be valid\");\n \n         final CountingBloomFilter bf6 = bf5.copy();\n@@ -234,7 +234,7 @@ public void testExcludesDuplicates() {\n \n         CountingBloomFilter bf1 = createFilter(shape, hasher);\n         assertEquals(6, bf1.cardinality());\n-        bf1.forEachCell((x, y) -> {\n+        bf1.processCells((x, y) -> {\n             assertEquals(1, y, \"Hasher in constructor results in value not equal to 1\");\n             return true;\n         });\n@@ -242,7 +242,7 @@ public void testExcludesDuplicates() {\n         bf1 = createEmptyFilter(shape);\n         bf1.merge(hasher);\n         assertEquals(6, bf1.cardinality());\n-        bf1.forEachCell((x, y) -> {\n+        bf1.processCells((x, y) -> {\n             assertEquals(1, y, \"Hasher in merge results in value not equal to 1\");\n             return true;\n         });\n@@ -251,7 +251,7 @@ public void testExcludesDuplicates() {\n         bf1.merge(hasher);\n         bf1.remove(hasher);\n         assertEquals(0, bf1.cardinality());\n-        assertTrue(bf1.forEachCell((x, y) -> false), \"Hasher in removes results in value not equal to 0\");\n+        assertTrue(bf1.processCells((x, y) -> false), \"Hasher in removes results in value not equal to 0\");\n     }\n \n     @Test\n@@ -284,7 +284,7 @@ public final void testRemove() {\n         simple.merge(TestingHashers.FROM11);\n \n         final CountingBloomFilter bf1 = createFilter(getTestShape(), TestingHashers.FROM1);\n-        bf1.add(CellProducer.from(TestingHashers.FROM11.indices(getTestShape())));\n+        bf1.add(CellExtractor.from(TestingHashers.FROM11.indices(getTestShape())));\n \n         assertTrue(bf1.remove(simple), \"Remove should work\");\n         assertFalse(bf1.contains(TestingHashers.FROM11), \"Should not contain\");\n@@ -294,7 +294,7 @@ public final void testRemove() {\n \n         // with hasher\n         final CountingBloomFilter bf2 = createFilter(getTestShape(), TestingHashers.FROM1);\n-        bf2.add(CellProducer.from(TestingHashers.FROM11.indices(getTestShape())));\n+        bf2.add(CellExtractor.from(TestingHashers.FROM11.indices(getTestShape())));\n \n         assertTrue(bf2.remove(TestingHashers.FROM11), \"Remove should work\");\n         assertFalse(bf2.contains(TestingHashers.FROM11), \"Should not contain\");\n@@ -311,11 +311,11 @@ public final void testRemove() {\n \n         assertCounts(bf3, new int[] {0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1});\n \n-        // with IndexProducer\n-        final IndexProducer ip = TestingHashers.FROM11.indices(getTestShape());\n+        // with IndexExtractor\n+        final IndexExtractor ip = TestingHashers.FROM11.indices(getTestShape());\n \n         final CountingBloomFilter bf4 = createFilter(getTestShape(), TestingHashers.FROM1);\n-        bf4.add(CellProducer.from(TestingHashers.FROM11.indices(getTestShape())));\n+        bf4.add(CellExtractor.from(TestingHashers.FROM11.indices(getTestShape())));\n \n         assertTrue(bf4.remove(ip), \"Remove should work\");\n         assertFalse(bf4.contains(TestingHashers.FROM11), \"Should not contain\");\n@@ -323,10 +323,10 @@ public final void testRemove() {\n \n         assertCounts(bf4, from1Counts);\n \n-        // with BitMapProducer\n-        final BitMapProducer bmp = BitMapProducer.fromIndexProducer(ip, getTestShape().getNumberOfBits());\n+        // with BitMapExtractor\n+        final BitMapExtractor bmp = BitMapExtractor.fromIndexExtractor(ip, getTestShape().getNumberOfBits());\n         final CountingBloomFilter bf5 = createFilter(getTestShape(), TestingHashers.FROM1);\n-        bf5.add(CellProducer.from(TestingHashers.FROM11.indices(getTestShape())));\n+        bf5.add(CellExtractor.from(TestingHashers.FROM11.indices(getTestShape())));\n \n         assertTrue(bf5.remove(bmp), \"Remove should work\");\n         assertFalse(bf5.contains(TestingHashers.FROM11), \"Should not contain\");\n@@ -334,13 +334,13 @@ public final void testRemove() {\n \n         assertCounts(bf5, from1Counts);\n \n-        // test producer errors\n-        final IndexProducer ip2 = IndexProducer.fromIndexArray(1, 2, getTestShape().getNumberOfBits());\n+        // test extractor errors\n+        final IndexExtractor ip2 = IndexExtractor.fromIndexArray(1, 2, getTestShape().getNumberOfBits());\n         final CountingBloomFilter bf6 = createFilter(getTestShape(), TestingHashers.FROM1);\n         assertThrows(IllegalArgumentException.class, () -> bf6.remove(ip2));\n \n         final CountingBloomFilter bf7 = createFilter(getTestShape(), TestingHashers.FROM1);\n-        final BitMapProducer bmp2 = BitMapProducer.fromIndexProducer(ip2, getTestShape().getNumberOfBits());\n+        final BitMapExtractor bmp2 = BitMapExtractor.fromIndexExtractor(ip2, getTestShape().getNumberOfBits());\n         assertThrows(IllegalArgumentException.class, () -> bf7.remove(bmp2));\n         assertThrows(IllegalArgumentException.class, () -> bf7.remove( new BadHasher(-1)));\n         assertThrows(IllegalArgumentException.class, () -> bf7.remove( new BadHasher(getTestShape().getNumberOfBits())));\n@@ -353,7 +353,7 @@ public final void testRemove() {\n     @Test\n     public final void testSubtract() {\n         final CountingBloomFilter bf1 = createFilter(getTestShape(), TestingHashers.FROM1);\n-        bf1.add(CellProducer.from(TestingHashers.FROM11.indices(getTestShape())));\n+        bf1.add(CellExtractor.from(TestingHashers.FROM11.indices(getTestShape())));\n \n         final CountingBloomFilter bf2 = createFilter(getTestShape(), TestingHashers.FROM11);\n \n@@ -389,17 +389,17 @@ private void verifyMaxInsert(final CountingBloomFilter bf, final int from1, fina\n \n         assertEquals(0, bf.getMaxInsert(new IncrementingHasher(0, 1)));\n         assertEquals(0, bf.getMaxInsert(bfFrom0));\n-        assertEquals(0, bf.getMaxInsert((BitMapProducer) bfFrom0));\n-        assertEquals(0, bf.getMaxInsert((IndexProducer) bfFrom0));\n+        assertEquals(0, bf.getMaxInsert((BitMapExtractor) bfFrom0));\n+        assertEquals(0, bf.getMaxInsert((IndexExtractor) bfFrom0));\n \n         assertEquals(from1, bf.getMaxInsert(TestingHashers.FROM1));\n         assertEquals(from1, bf.getMaxInsert(bfFrom1));\n-        assertEquals(from1, bf.getMaxInsert((BitMapProducer) bfFrom1));\n-        assertEquals(from1, bf.getMaxInsert((IndexProducer) bfFrom1));\n+        assertEquals(from1, bf.getMaxInsert((BitMapExtractor) bfFrom1));\n+        assertEquals(from1, bf.getMaxInsert((IndexExtractor) bfFrom1));\n \n         assertEquals(from11, bf.getMaxInsert(TestingHashers.FROM11));\n         assertEquals(from11, bf.getMaxInsert(bfFrom11));\n-        assertEquals(from11, bf.getMaxInsert((BitMapProducer) bfFrom11));\n-        assertEquals(from11, bf.getMaxInsert((IndexProducer) bfFrom11));\n+        assertEquals(from11, bf.getMaxInsert((BitMapExtractor) bfFrom11));\n+        assertEquals(from11, bf.getMaxInsert((IndexExtractor) bfFrom11));\n     }\n }\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractHasherTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractHasherTest.java\nindex 782d494513..98452c50a3 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractHasherTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractHasherTest.java\n@@ -22,19 +22,19 @@\n import org.junit.jupiter.params.ParameterizedTest;\n import org.junit.jupiter.params.provider.CsvSource;\n \n-public abstract class AbstractHasherTest extends AbstractIndexProducerTest {\n+public abstract class AbstractHasherTest extends AbstractIndexExtractorTest {\n \n     protected abstract Hasher createEmptyHasher();\n \n     @Override\n-    protected IndexProducer createEmptyProducer() {\n+    protected IndexExtractor createEmptyExtractor() {\n         return createEmptyHasher().indices(getTestShape());\n     }\n \n     protected abstract Hasher createHasher();\n \n     @Override\n-    protected IndexProducer createProducer() {\n+    protected IndexExtractor createExtractor() {\n         return createHasher().indices(getTestShape());\n     }\n \n@@ -68,7 +68,7 @@ protected final Shape getTestShape() {\n     public void testHashing(final int k, final int m) {\n         final int[] count = {0};\n         final Hasher hasher = createHasher();\n-        hasher.indices(Shape.fromKM(k, m)).forEachIndex(i -> {\n+        hasher.indices(Shape.fromKM(k, m)).processIndices(i -> {\n             assertTrue(i >= 0 && i < m, () -> \"Out of range: \" + i + \", m=\" + m);\n             count[0]++;\n             return true;\n@@ -78,7 +78,7 @@ public void testHashing(final int k, final int m) {\n \n         // test early exit\n         count[0] = 0;\n-        hasher.indices(Shape.fromKM(k, m)).forEachIndex(i -> {\n+        hasher.indices(Shape.fromKM(k, m)).processIndices(i -> {\n             assertTrue(i >= 0 && i < m, () -> \"Out of range: \" + i + \", m=\" + m);\n             count[0]++;\n             return false;\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractIndexProducerTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractIndexExtractorTest.java\nsimilarity index 73%\nrename from src/test/java/org/apache/commons/collections4/bloomfilter/AbstractIndexProducerTest.java\nrename to src/test/java/org/apache/commons/collections4/bloomfilter/AbstractIndexExtractorTest.java\nindex c1a3d3aa30..455885014a 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractIndexProducerTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractIndexExtractorTest.java\n@@ -29,9 +29,9 @@\n import org.junit.jupiter.api.Test;\n \n /**\n- * Test for IndexProducer.\n+ * Test for IndexExtractor.\n  */\n-public abstract class AbstractIndexProducerTest {\n+public abstract class AbstractIndexExtractorTest {\n \n     /**\n      * An expandable list of int values.\n@@ -66,26 +66,26 @@ int[] toArray() {\n     private static final IntPredicate TRUE_PREDICATE = i -> true;\n \n     private static final IntPredicate FALSE_PREDICATE = i -> false;\n-    /** Flag to indicate the indices are ordered, e.g. from {@link IndexProducer#forEachIndex(IntPredicate)}. */\n+    /** Flag to indicate the indices are ordered, e.g. from {@link IndexExtractor#processIndices(IntPredicate)}. */\n     protected static final int ORDERED = 0x1;\n \n-    /** Flag to indicate the indices are distinct, e.g. from {@link IndexProducer#forEachIndex(IntPredicate)}. */\n+    /** Flag to indicate the indices are distinct, e.g. from {@link IndexExtractor#processIndices(IntPredicate)}. */\n     protected static final int DISTINCT = 0x2;\n \n     /**\n-     * Creates an producer without data.\n-     * @return a producer that has no data.\n+     * Creates an extractor without data.\n+     * @return an IndexExtractor that has no data.\n      */\n-    protected abstract IndexProducer createEmptyProducer();\n+    protected abstract IndexExtractor createEmptyExtractor();\n \n     /**\n-     * Creates a producer with some data.\n-     * @return a producer with some data\n+     * Creates an extractor with some data.\n+     * @return an IndexExtractor with some data\n      */\n-    protected abstract IndexProducer createProducer();\n+    protected abstract IndexExtractor createExtractor();\n \n     /**\n-     * Gets the behavior of the {@link IndexProducer#asIndexArray()} method.\n+     * Gets the behavior of the {@link IndexExtractor#asIndexArray()} method.\n      * @return the behavior.\n      * @see #ORDERED\n      * @see #DISTINCT\n@@ -94,13 +94,13 @@ int[] toArray() {\n \n     /**\n      * Creates an array of expected indices.\n-     * The expected indices are dependent upon the producer created in the {@code createProducer()} method.\n+     * The expected indices are dependent upon the extractor created in the {@code createExtractor()} method.\n      * @return an array of expected indices.\n      */\n     protected abstract int[] getExpectedIndices();\n \n     /**\n-     * Gets the behavior of the {@link IndexProducer#forEachIndex(IntPredicate)} method.\n+     * Gets the behavior of the {@link IndexExtractor#processIndices(IntPredicate)} method.\n      * By default returns the value of {@code getAsIndexArrayBehaviour()} method.\n      * @return the behavior.\n      * @see #ORDERED\n@@ -116,14 +116,14 @@ protected int getForEachIndexBehaviour() {\n     @Test\n     public final void testAsIndexArrayValues() {\n         final BitSet bs = new BitSet();\n-        Arrays.stream(createProducer().asIndexArray()).forEach(bs::set);\n+        Arrays.stream(createExtractor().asIndexArray()).forEach(bs::set);\n         for (final int i : getExpectedIndices()) {\n             assertTrue(bs.get(i), () -> \"Missing \" + i);\n         }\n     }\n \n     /**\n-     * Tests the behavior of {@code IndexProducer.asIndexArray()}.\n+     * Tests the behavior of {@code IndexExtractor.asIndexArray()}.\n      * The expected behavior is defined by the {@code getBehaviour()} method.\n      * The index array may be Ordered, Distinct or both.\n      * If the index array is not distinct then all elements returned by the {@code getExpectedIndices()}\n@@ -132,7 +132,7 @@ public final void testAsIndexArrayValues() {\n     @Test\n     public final void testBehaviourAsIndexArray() {\n         final int flags = getAsIndexArrayBehaviour();\n-        final int[] actual = createProducer().asIndexArray();\n+        final int[] actual = createExtractor().asIndexArray();\n         if ((flags & ORDERED) != 0) {\n             final int[] expected = Arrays.stream(actual).sorted().toArray();\n             assertArrayEquals(expected, actual);\n@@ -151,15 +151,15 @@ public final void testBehaviourAsIndexArray() {\n     }\n \n     /**\n-     * Tests the behavior of {@code IndexProducer.forEachIndex()}.\n+     * Tests the behavior of {@code IndexExtractor.forEachIndex()}.\n      * The expected behavior is defined by the {@code getBehaviour()} method.\n-     * The order is assumed to follow the order produced by {@code IndexProducer.asIndexArray()}.\n+     * The order is assumed to follow the order produced by {@code IndexExtractor.asIndexArray()}.\n      */\n     @Test\n     public final void testBehaviourForEachIndex() {\n         final int flags = getForEachIndexBehaviour();\n         final IntList list = new IntList();\n-        createProducer().forEachIndex(list::add);\n+        createExtractor().processIndices(list::add);\n         final int[] actual = list.toArray();\n         if ((flags & ORDERED) != 0) {\n             final int[] expected = Arrays.stream(actual).sorted().toArray();\n@@ -178,15 +178,15 @@ public final void testBehaviourForEachIndex() {\n     }\n \n     /**\n-     * Test the distinct indices output from the producer are consistent.\n+     * Test the distinct indices output from the extractor are consistent.\n      */\n     @Test\n     public final void testConsistency() {\n-        final IndexProducer producer = createProducer();\n+        final IndexExtractor extractor = createExtractor();\n         final BitSet bs1 = new BitSet();\n         final BitSet bs2 = new BitSet();\n-        Arrays.stream(producer.asIndexArray()).forEach(bs1::set);\n-        producer.forEachIndex(i -> {\n+        Arrays.stream(extractor.asIndexArray()).forEach(bs1::set);\n+        extractor.processIndices(i -> {\n             bs2.set(i);\n             return true;\n         });\n@@ -194,24 +194,24 @@ public final void testConsistency() {\n     }\n \n     @Test\n-    public final void testEmptyProducer() {\n-        final IndexProducer empty = createEmptyProducer();\n+    public final void testEmptyExtractor() {\n+        final IndexExtractor empty = createEmptyExtractor();\n         final int[] ary = empty.asIndexArray();\n         assertEquals(0, ary.length);\n-        assertTrue(empty.forEachIndex(i -> {\n-            throw new AssertionError(\"forEach predictate should not be called\");\n+        assertTrue(empty.processIndices(i -> {\n+            throw new AssertionError(\"processIndices predictate should not be called\");\n         }));\n     }\n \n     /**\n-     * Test to ensure that for each index returns each expected index at least once.\n+     * Test to ensure that processIndices returns each expected index at least once.\n      */\n     @Test\n     public final void testForEachIndex() {\n         final BitSet bs1 = new BitSet();\n         final BitSet bs2 = new BitSet();\n         Arrays.stream(getExpectedIndices()).forEach(bs1::set);\n-        createProducer().forEachIndex(i -> {\n+        createExtractor().processIndices(i -> {\n             bs2.set(i);\n             return true;\n         });\n@@ -221,14 +221,14 @@ public final void testForEachIndex() {\n     @Test\n     public void testForEachIndexEarlyExit() {\n         final int[] passes = new int[1];\n-        assertFalse(createProducer().forEachIndex(i -> {\n+        assertFalse(createExtractor().processIndices(i -> {\n             passes[0]++;\n             return false;\n         }));\n         assertEquals(1, passes[0]);\n \n         passes[0] = 0;\n-        assertTrue(createEmptyProducer().forEachIndex(i -> {\n+        assertTrue(createEmptyExtractor().processIndices(i -> {\n             passes[0]++;\n             return false;\n         }));\n@@ -237,19 +237,19 @@ public void testForEachIndexEarlyExit() {\n \n     @Test\n     public final void testForEachIndexPredicates() {\n-        final IndexProducer populated = createProducer();\n-        final IndexProducer empty = createEmptyProducer();\n+        final IndexExtractor populated = createExtractor();\n+        final IndexExtractor empty = createEmptyExtractor();\n \n-        assertFalse(populated.forEachIndex(FALSE_PREDICATE), \"non-empty should be false\");\n-        assertTrue(empty.forEachIndex(FALSE_PREDICATE), \"empty should be true\");\n+        assertFalse(populated.processIndices(FALSE_PREDICATE), \"non-empty should be false\");\n+        assertTrue(empty.processIndices(FALSE_PREDICATE), \"empty should be true\");\n \n-        assertTrue(populated.forEachIndex(TRUE_PREDICATE), \"non-empty should be true\");\n-        assertTrue(empty.forEachIndex(TRUE_PREDICATE), \"empty should be true\");\n+        assertTrue(populated.processIndices(TRUE_PREDICATE), \"non-empty should be true\");\n+        assertTrue(empty.processIndices(TRUE_PREDICATE), \"empty should be true\");\n     }\n \n     @Test\n     public void testUniqueReturnsSelf() {\n-        final IndexProducer expected = createProducer().uniqueIndices();\n+        final IndexExtractor expected = createExtractor().uniqueIndices();\n         assertSame(expected, expected.uniqueIndices());\n     }\n }\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/ArrayHasher.java b/src/test/java/org/apache/commons/collections4/bloomfilter/ArrayHasher.java\nindex 239947e7ee..f65fdadf16 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/ArrayHasher.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/ArrayHasher.java\n@@ -25,15 +25,15 @@\n  * <p>To be used for testing only.</p>\n  */\n public final class ArrayHasher implements Hasher {\n-    private final class Producer implements IndexProducer {\n+    private final class Extractor implements IndexExtractor {\n         Shape shape;\n \n-        Producer(final Shape shape) {\n+        Extractor(final Shape shape) {\n             this.shape = shape;\n         }\n \n         @Override\n-        public boolean forEachIndex(final IntPredicate consumer) {\n+        public boolean processIndices(final IntPredicate consumer) {\n             Objects.requireNonNull(consumer, \"consumer\");\n \n             int pos = 0;\n@@ -55,8 +55,8 @@ public ArrayHasher(final int... values) {\n     }\n \n     @Override\n-    public IndexProducer indices(final Shape shape) {\n+    public IndexExtractor indices(final Shape shape) {\n         Objects.requireNonNull(shape, \"shape\");\n-        return new Producer(shape);\n+        return new Extractor(shape);\n     }\n }\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/BitMapProducerFromArrayCountingBloomFilterTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/BitMapExtractorFromArrayCountingBloomFilterTest.java\nsimilarity index 85%\nrename from src/test/java/org/apache/commons/collections4/bloomfilter/BitMapProducerFromArrayCountingBloomFilterTest.java\nrename to src/test/java/org/apache/commons/collections4/bloomfilter/BitMapExtractorFromArrayCountingBloomFilterTest.java\nindex 63ec52a667..e7c341bcf7 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/BitMapProducerFromArrayCountingBloomFilterTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/BitMapExtractorFromArrayCountingBloomFilterTest.java\n@@ -16,17 +16,17 @@\n  */\n package org.apache.commons.collections4.bloomfilter;\n \n-public class BitMapProducerFromArrayCountingBloomFilterTest extends AbstractBitMapProducerTest {\n+public class BitMapExtractorFromArrayCountingBloomFilterTest extends AbstractBitMapExtractorTest {\n \n     protected Shape shape = Shape.fromKM(17, 72);\n \n     @Override\n-    protected BitMapProducer createEmptyProducer() {\n+    protected BitMapExtractor createEmptyExtractor() {\n         return new ArrayCountingBloomFilter(shape);\n     }\n \n     @Override\n-    protected BitMapProducer createProducer() {\n+    protected BitMapExtractor createExtractor() {\n         final ArrayCountingBloomFilter filter = new ArrayCountingBloomFilter(shape);\n         final Hasher hasher = new IncrementingHasher(0, 1);\n         filter.merge(hasher);\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/BitMapProducerFromIndexProducerTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/BitMapExtractorFromIndexExtractorTest.java\nsimilarity index 57%\nrename from src/test/java/org/apache/commons/collections4/bloomfilter/BitMapProducerFromIndexProducerTest.java\nrename to src/test/java/org/apache/commons/collections4/bloomfilter/BitMapExtractorFromIndexExtractorTest.java\nindex 38b336cbde..e0a91ea79d 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/BitMapProducerFromIndexProducerTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/BitMapExtractorFromIndexExtractorTest.java\n@@ -23,31 +23,31 @@\n \n import org.junit.jupiter.api.Test;\n \n-public class BitMapProducerFromIndexProducerTest extends AbstractBitMapProducerTest {\n+public class BitMapExtractorFromIndexExtractorTest extends AbstractBitMapExtractorTest {\n \n     @Override\n-    protected BitMapProducer createEmptyProducer() {\n-        final IndexProducer iProducer = consumer -> true;\n-        return BitMapProducer.fromIndexProducer(iProducer, 200);\n+    protected BitMapExtractor createEmptyExtractor() {\n+        final IndexExtractor indexExtractor = consumer -> true;\n+        return BitMapExtractor.fromIndexExtractor(indexExtractor, 200);\n     }\n \n     @Override\n-    protected BitMapProducer createProducer() {\n-        final IndexProducer iProducer = consumer -> consumer.test(0) && consumer.test(1) && consumer.test(63) && consumer.test(64)\n+    protected BitMapExtractor createExtractor() {\n+        final IndexExtractor indexExtractor = consumer -> consumer.test(0) && consumer.test(1) && consumer.test(63) && consumer.test(64)\n                 && consumer.test(127) && consumer.test(128);\n-        return BitMapProducer.fromIndexProducer(iProducer, 200);\n+        return BitMapExtractor.fromIndexExtractor(indexExtractor, 200);\n     }\n \n     @Test\n-    public final void testFromIndexProducer() {\n+    public final void testFromIndexExtractor() {\n         final List<Long> lst = new ArrayList<>();\n-        createProducer().forEachBitMap(lst::add);\n+        createExtractor().processBitMaps(lst::add);\n         final long[] buckets = lst.stream().mapToLong(Long::longValue).toArray();\n-        assertTrue(BitMap.contains(buckets, 0));\n-        assertTrue(BitMap.contains(buckets, 1));\n-        assertTrue(BitMap.contains(buckets, 63));\n-        assertTrue(BitMap.contains(buckets, 64));\n-        assertTrue(BitMap.contains(buckets, 127));\n-        assertTrue(BitMap.contains(buckets, 128));\n+        assertTrue(BitMaps.contains(buckets, 0));\n+        assertTrue(BitMaps.contains(buckets, 1));\n+        assertTrue(BitMaps.contains(buckets, 63));\n+        assertTrue(BitMaps.contains(buckets, 64));\n+        assertTrue(BitMaps.contains(buckets, 127));\n+        assertTrue(BitMaps.contains(buckets, 128));\n     }\n }\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/BitMapProducerFromLayeredBloomFilterTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/BitMapExtractorFromLayeredBloomFilterTest.java\nsimilarity index 85%\nrename from src/test/java/org/apache/commons/collections4/bloomfilter/BitMapProducerFromLayeredBloomFilterTest.java\nrename to src/test/java/org/apache/commons/collections4/bloomfilter/BitMapExtractorFromLayeredBloomFilterTest.java\nindex 246ef518cc..b191aa09a6 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/BitMapProducerFromLayeredBloomFilterTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/BitMapExtractorFromLayeredBloomFilterTest.java\n@@ -16,17 +16,17 @@\n  */\n package org.apache.commons.collections4.bloomfilter;\n \n-public class BitMapProducerFromLayeredBloomFilterTest extends AbstractBitMapProducerTest {\n+public class BitMapExtractorFromLayeredBloomFilterTest extends AbstractBitMapExtractorTest {\n \n     protected Shape shape = Shape.fromKM(17, 72);\n \n     @Override\n-    protected BitMapProducer createEmptyProducer() {\n+    protected BitMapExtractor createEmptyExtractor() {\n         return LayeredBloomFilterTest.fixed(shape, 10);\n     }\n \n     @Override\n-    protected BitMapProducer createProducer() {\n+    protected BitMapExtractor createExtractor() {\n         final Hasher hasher = new IncrementingHasher(0, 1);\n         final BloomFilter bf = LayeredBloomFilterTest.fixed(shape, 10);\n         bf.merge(hasher);\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/BitMapProducerFromLongArrayTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/BitMapExtractorFromLongArrayTest.java\nsimilarity index 77%\nrename from src/test/java/org/apache/commons/collections4/bloomfilter/BitMapProducerFromLongArrayTest.java\nrename to src/test/java/org/apache/commons/collections4/bloomfilter/BitMapExtractorFromLongArrayTest.java\nindex 165ea404c0..7a2c684613 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/BitMapProducerFromLongArrayTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/BitMapExtractorFromLongArrayTest.java\n@@ -23,12 +23,12 @@\n \n import org.junit.jupiter.api.Test;\n \n-public class BitMapProducerFromLongArrayTest extends AbstractBitMapProducerTest {\n+public class BitMapExtractorFromLongArrayTest extends AbstractBitMapExtractorTest {\n \n     @Test\n     public void constructorTest() {\n         final List<Long> lst = new ArrayList<>();\n-        createProducer().forEachBitMap(lst::add);\n+        createExtractor().processBitMaps(lst::add);\n         assertEquals(Long.valueOf(1), lst.get(0));\n         assertEquals(Long.valueOf(2), lst.get(1));\n         assertEquals(Long.valueOf(3), lst.get(2));\n@@ -37,14 +37,14 @@ public void constructorTest() {\n     }\n \n     @Override\n-    protected BitMapProducer createEmptyProducer() {\n-        return BitMapProducer.fromBitMapArray();\n+    protected BitMapExtractor createEmptyExtractor() {\n+        return BitMapExtractor.fromBitMapArray();\n     }\n \n     @Override\n-    protected BitMapProducer createProducer() {\n+    protected BitMapExtractor createExtractor() {\n         final long[] ary = {1L, 2L, 3L, 4L, 5L};\n-        return BitMapProducer.fromBitMapArray(ary);\n+        return BitMapExtractor.fromBitMapArray(ary);\n     }\n \n     @Override\n@@ -53,9 +53,9 @@ protected boolean emptyIsZeroLength() {\n     }\n \n     @Test\n-    public void testFromIndexProducer() {\n+    public void testFromIndexExtractor() {\n         final int limit = Integer.SIZE + Long.SIZE;\n-        final IndexProducer iProducer = consumer -> {\n+        final IndexExtractor indexExtractor = consumer -> {\n             for (int i = 0; i < limit; i++) {\n                 if (!consumer.test(i)) {\n                     return false;\n@@ -63,9 +63,9 @@ public void testFromIndexProducer() {\n             }\n             return true;\n         };\n-        final BitMapProducer producer = BitMapProducer.fromIndexProducer(iProducer, limit);\n+        final BitMapExtractor bitMapExtractor = BitMapExtractor.fromIndexExtractor(indexExtractor, limit);\n         final List<Long> lst = new ArrayList<>();\n-        producer.forEachBitMap(lst::add);\n+        bitMapExtractor.processBitMaps(lst::add);\n         long expected = ~0L;\n         assertEquals(expected, lst.get(0).longValue());\n         expected &= 0XFFFFFFFFL;\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/BitMapProducerFromSimpleBloomFilterTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/BitMapExtractorFromSimpleBloomFilterTest.java\nsimilarity index 85%\nrename from src/test/java/org/apache/commons/collections4/bloomfilter/BitMapProducerFromSimpleBloomFilterTest.java\nrename to src/test/java/org/apache/commons/collections4/bloomfilter/BitMapExtractorFromSimpleBloomFilterTest.java\nindex 8e1d2ca202..5ed9acdad0 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/BitMapProducerFromSimpleBloomFilterTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/BitMapExtractorFromSimpleBloomFilterTest.java\n@@ -16,17 +16,17 @@\n  */\n package org.apache.commons.collections4.bloomfilter;\n \n-public class BitMapProducerFromSimpleBloomFilterTest extends AbstractBitMapProducerTest {\n+public class BitMapExtractorFromSimpleBloomFilterTest extends AbstractBitMapExtractorTest {\n \n     protected Shape shape = Shape.fromKM(17, 72);\n \n     @Override\n-    protected BitMapProducer createEmptyProducer() {\n+    protected BitMapExtractor createEmptyExtractor() {\n         return new SimpleBloomFilter(shape);\n     }\n \n     @Override\n-    protected BitMapProducer createProducer() {\n+    protected BitMapExtractor createExtractor() {\n         final Hasher hasher = new IncrementingHasher(0, 1);\n         final BloomFilter bf = new SimpleBloomFilter(shape);\n         bf.merge(hasher);\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/BitMapProducerFromSparseBloomFilterTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/BitMapExtractorFromSparseBloomFilterTest.java\nsimilarity index 85%\nrename from src/test/java/org/apache/commons/collections4/bloomfilter/BitMapProducerFromSparseBloomFilterTest.java\nrename to src/test/java/org/apache/commons/collections4/bloomfilter/BitMapExtractorFromSparseBloomFilterTest.java\nindex 6c15eda45d..638a0350f0 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/BitMapProducerFromSparseBloomFilterTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/BitMapExtractorFromSparseBloomFilterTest.java\n@@ -16,17 +16,17 @@\n  */\n package org.apache.commons.collections4.bloomfilter;\n \n-public class BitMapProducerFromSparseBloomFilterTest extends AbstractBitMapProducerTest {\n+public class BitMapExtractorFromSparseBloomFilterTest extends AbstractBitMapExtractorTest {\n \n     protected Shape shape = Shape.fromKM(17, 72);\n \n     @Override\n-    protected BitMapProducer createEmptyProducer() {\n+    protected BitMapExtractor createEmptyExtractor() {\n         return new SparseBloomFilter(shape);\n     }\n \n     @Override\n-    protected BitMapProducer createProducer() {\n+    protected BitMapExtractor createExtractor() {\n         final Hasher hasher = new IncrementingHasher(0, 1);\n         final BloomFilter bf = new SparseBloomFilter(shape);\n         bf.merge(hasher);\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/BitMapProducerFromWrappedBloomFilterTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/BitMapExtractorFromWrappedBloomFilterTest.java\nsimilarity index 90%\nrename from src/test/java/org/apache/commons/collections4/bloomfilter/BitMapProducerFromWrappedBloomFilterTest.java\nrename to src/test/java/org/apache/commons/collections4/bloomfilter/BitMapExtractorFromWrappedBloomFilterTest.java\nindex 9716dd4082..4040efb95f 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/BitMapProducerFromWrappedBloomFilterTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/BitMapExtractorFromWrappedBloomFilterTest.java\n@@ -16,12 +16,12 @@\n  */\n package org.apache.commons.collections4.bloomfilter;\n \n-public class BitMapProducerFromWrappedBloomFilterTest extends AbstractBitMapProducerTest {\n+public class BitMapExtractorFromWrappedBloomFilterTest extends AbstractBitMapExtractorTest {\n \n     protected Shape shape = Shape.fromKM(17, 72);\n \n     @Override\n-    protected BitMapProducer createEmptyProducer() {\n+    protected BitMapExtractor createEmptyExtractor() {\n         return new WrappedBloomFilter(new DefaultBloomFilterTest.SparseDefaultBloomFilter(shape)) {\n             @Override\n             public BloomFilter copy() {\n@@ -33,7 +33,7 @@ public BloomFilter copy() {\n     }\n \n     @Override\n-    protected BitMapProducer createProducer() {\n+    protected BitMapExtractor createExtractor() {\n         final Hasher hasher = new IncrementingHasher(0, 1);\n         final BloomFilter bf = new WrappedBloomFilter(new DefaultBloomFilterTest.SparseDefaultBloomFilter(shape)) {\n             @Override\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/BitMapTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/BitMapsTest.java\nsimilarity index 64%\nrename from src/test/java/org/apache/commons/collections4/bloomfilter/BitMapTest.java\nrename to src/test/java/org/apache/commons/collections4/bloomfilter/BitMapsTest.java\nindex 2997a8683d..274614f01e 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/BitMapTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/BitMapsTest.java\n@@ -24,10 +24,10 @@\n \n import org.junit.jupiter.api.Test;\n \n-public class BitMapTest {\n+public class BitMapsTest {\n \n     /**\n-     * Assert the {@link BitMap#mod(long, int)} method functions as an unsigned modulus.\n+     * Assert the {@link BitMaps#mod(long, int)} method functions as an unsigned modulus.\n      *\n      * @param dividend the dividend\n      * @param divisor the divisor\n@@ -35,7 +35,7 @@ public class BitMapTest {\n     private void assertMod(final long dividend, final int divisor) {\n         assertTrue(divisor > 0 && divisor <= Integer.MAX_VALUE,\n             \"Incorrect usage. Divisor must be strictly positive.\");\n-        assertEquals((int) Long.remainderUnsigned(dividend, divisor), BitMap.mod(dividend, divisor),\n+        assertEquals((int) Long.remainderUnsigned(dividend, divisor), BitMaps.mod(dividend, divisor),\n             () -> String.format(\"failure with dividend=%s and divisor=%s.\", dividend, divisor));\n     }\n \n@@ -45,12 +45,12 @@ public final void testContains() {\n \n         for (int i = 0; i < 64; i++) {\n             bitMaps[0] = 0L;\n-            BitMap.set(bitMaps, i);\n+            BitMaps.set(bitMaps, i);\n             for (int j = 0; j < 64; j++) {\n                 if (j == i) {\n-                    assertTrue(BitMap.contains(bitMaps, j), String.format(\"Failed at index: %d for %d\", i, j));\n+                    assertTrue(BitMaps.contains(bitMaps, j), String.format(\"Failed at index: %d for %d\", i, j));\n                 } else {\n-                    assertFalse(BitMap.contains(bitMaps, j), String.format(\"Failed at index %d for %d\", i, j));\n+                    assertFalse(BitMaps.contains(bitMaps, j), String.format(\"Failed at index %d for %d\", i, j));\n                 }\n             }\n         }\n@@ -59,38 +59,38 @@ public final void testContains() {\n         long[] ary = new long[1];\n \n         final long[] aryT = ary;\n-        assertThrows(ArrayIndexOutOfBoundsException.class, () -> BitMap.contains(aryT, -1));\n-        assertFalse(BitMap.contains(ary, 0));\n+        assertThrows(ArrayIndexOutOfBoundsException.class, () -> BitMaps.contains(aryT, -1));\n+        assertFalse(BitMaps.contains(ary, 0));\n         ary[0] = 0x01;\n-        assertTrue(BitMap.contains(ary, 0));\n+        assertTrue(BitMaps.contains(ary, 0));\n \n-        assertFalse(BitMap.contains(ary, 63));\n+        assertFalse(BitMaps.contains(ary, 63));\n         ary[0] = 1L << 63;\n-        assertTrue(BitMap.contains(ary, 63));\n-        assertThrows(ArrayIndexOutOfBoundsException.class, () -> BitMap.contains(aryT, 64));\n+        assertTrue(BitMaps.contains(ary, 63));\n+        assertThrows(ArrayIndexOutOfBoundsException.class, () -> BitMaps.contains(aryT, 64));\n \n         ary = new long[2];\n-        assertFalse(BitMap.contains(ary, 64));\n+        assertFalse(BitMaps.contains(ary, 64));\n         ary[1] = 1;\n-        assertTrue(BitMap.contains(ary, 64));\n+        assertTrue(BitMaps.contains(ary, 64));\n     }\n \n     @Test\n     public final void testGetLongBit() {\n-        assertEquals(1, BitMap.getLongBit(0));\n-        assertEquals(0x8000000000000000L, BitMap.getLongBit(63));\n-        assertEquals(1, BitMap.getLongBit(64));\n-        assertEquals(0x8000000000000000L, BitMap.getLongBit(127));\n-        assertEquals(1, BitMap.getLongBit(128));\n+        assertEquals(1, BitMaps.getLongBit(0));\n+        assertEquals(0x8000000000000000L, BitMaps.getLongBit(63));\n+        assertEquals(1, BitMaps.getLongBit(64));\n+        assertEquals(0x8000000000000000L, BitMaps.getLongBit(127));\n+        assertEquals(1, BitMaps.getLongBit(128));\n     }\n \n     @Test\n     public final void testGetLongIndex() {\n-        assertEquals(0, BitMap.getLongIndex(0));\n-        assertEquals(0, BitMap.getLongIndex(63));\n-        assertEquals(1, BitMap.getLongIndex(64));\n-        assertEquals(1, BitMap.getLongIndex(127));\n-        assertEquals(2, BitMap.getLongIndex(128));\n+        assertEquals(0, BitMaps.getLongIndex(0));\n+        assertEquals(0, BitMaps.getLongIndex(63));\n+        assertEquals(1, BitMaps.getLongIndex(64));\n+        assertEquals(1, BitMaps.getLongIndex(127));\n+        assertEquals(2, BitMaps.getLongIndex(128));\n     }\n \n     @Test\n@@ -106,29 +106,29 @@ public void testMod() {\n     @Test\n     public void testModEdgeCases() {\n         for (final long dividend : new long[] {0, -1, 1, Long.MAX_VALUE}) {\n-            assertThrows(ArithmeticException.class, () -> BitMap.mod(dividend, 0));\n+            assertThrows(ArithmeticException.class, () -> BitMaps.mod(dividend, 0));\n         }\n-        assertNotEquals(Math.floorMod(5, -1), BitMap.mod(5, -1));\n+        assertNotEquals(Math.floorMod(5, -1), BitMaps.mod(5, -1));\n     }\n \n     @Test\n     public final void testNumberOfBitMaps() {\n-        assertEquals(0, BitMap.numberOfBitMaps(0), \"Number of bits 0\");\n+        assertEquals(0, BitMaps.numberOfBitMaps(0), \"Number of bits 0\");\n         for (int i = 1; i < 65; i++) {\n-            assertEquals(1, BitMap.numberOfBitMaps(i), String.format(\"Number of bits %d\", i));\n+            assertEquals(1, BitMaps.numberOfBitMaps(i), String.format(\"Number of bits %d\", i));\n         }\n         for (int i = 65; i < 129; i++) {\n-            assertEquals(2, BitMap.numberOfBitMaps(i), String.format(\"Number of bits %d\", i));\n+            assertEquals(2, BitMaps.numberOfBitMaps(i), String.format(\"Number of bits %d\", i));\n         }\n-        assertEquals(3, BitMap.numberOfBitMaps(129), \"Number of bits 129\");\n+        assertEquals(3, BitMaps.numberOfBitMaps(129), \"Number of bits 129\");\n     }\n \n     @Test\n     public final void testSet() {\n-        final long[] bitMaps = new long[BitMap.numberOfBitMaps(129)];\n+        final long[] bitMaps = new long[BitMaps.numberOfBitMaps(129)];\n         for (int i = 0; i < 129; i++) {\n-            BitMap.set(bitMaps, i);\n-            assertTrue(BitMap.contains(bitMaps, i), String.format(\"Failed at index: %d\", i));\n+            BitMaps.set(bitMaps, i);\n+            assertTrue(BitMaps.contains(bitMaps, i), String.format(\"Failed at index: %d\", i));\n         }\n         assertEquals(0xFFFFFFFFFFFFFFFFL, bitMaps[0]);\n         assertEquals(0xFFFFFFFFFFFFFFFFL, bitMaps[1]);\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/BloomFilterProducerFromLayeredBloomFilterTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/BloomFilteExtractorFromLayeredBloomFilterTest.java\nsimilarity index 88%\nrename from src/test/java/org/apache/commons/collections4/bloomfilter/BloomFilterProducerFromLayeredBloomFilterTest.java\nrename to src/test/java/org/apache/commons/collections4/bloomfilter/BloomFilteExtractorFromLayeredBloomFilterTest.java\nindex 1c298f80ee..f66522d29d 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/BloomFilterProducerFromLayeredBloomFilterTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/BloomFilteExtractorFromLayeredBloomFilterTest.java\n@@ -16,10 +16,10 @@\n  */\n package org.apache.commons.collections4.bloomfilter;\n \n-public class BloomFilterProducerFromLayeredBloomFilterTest extends AbstractBloomFilterProducerTest {\n+public class BloomFilteExtractorFromLayeredBloomFilterTest extends AbstractBloomFilterExtractorTest {\n \n     @Override\n-    protected BloomFilterProducer createUnderTest(final BloomFilter... filters) {\n+    protected BloomFilterExtractor createUnderTest(final BloomFilter... filters) {\n         final Shape shape = filters[0].getShape();\n         final LayerManager layerManager = LayerManager.builder().setSupplier(() -> new SimpleBloomFilter(shape))\n                 .setExtendCheck(LayerManager.ExtendCheck.advanceOnPopulated()).setCleanup(LayerManager.Cleanup.noCleanup()).build();\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/BloomFilterProducerFromBloomFilterArrayTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/BloomFilterExtractorFromBloomFilterArrayTest.java\nsimilarity index 77%\nrename from src/test/java/org/apache/commons/collections4/bloomfilter/BloomFilterProducerFromBloomFilterArrayTest.java\nrename to src/test/java/org/apache/commons/collections4/bloomfilter/BloomFilterExtractorFromBloomFilterArrayTest.java\nindex f18025e5b3..c3419335d5 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/BloomFilterProducerFromBloomFilterArrayTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/BloomFilterExtractorFromBloomFilterArrayTest.java\n@@ -16,10 +16,10 @@\n  */\n package org.apache.commons.collections4.bloomfilter;\n \n-public class BloomFilterProducerFromBloomFilterArrayTest extends AbstractBloomFilterProducerTest {\n+public class BloomFilterExtractorFromBloomFilterArrayTest extends AbstractBloomFilterExtractorTest {\n \n     @Override\n-    protected BloomFilterProducer createUnderTest(final BloomFilter... filters) {\n-        return BloomFilterProducer.fromBloomFilterArray(filters);\n+    protected BloomFilterExtractor createUnderTest(final BloomFilter... filters) {\n+        return BloomFilterExtractor.fromBloomFilterArray(filters);\n     }\n }\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/CellProducerFromArrayCountingBloomFilterTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/CellExtractorFromArrayCountingBloomFilterTest.java\nsimilarity index 88%\nrename from src/test/java/org/apache/commons/collections4/bloomfilter/CellProducerFromArrayCountingBloomFilterTest.java\nrename to src/test/java/org/apache/commons/collections4/bloomfilter/CellExtractorFromArrayCountingBloomFilterTest.java\nindex 7f054fcc60..43571a17f0 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/CellProducerFromArrayCountingBloomFilterTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/CellExtractorFromArrayCountingBloomFilterTest.java\n@@ -16,17 +16,17 @@\n  */\n package org.apache.commons.collections4.bloomfilter;\n \n-public class CellProducerFromArrayCountingBloomFilterTest extends AbstractCellProducerTest {\n+public class CellExtractorFromArrayCountingBloomFilterTest extends AbstractCellExtractorTest {\n \n     protected Shape shape = Shape.fromKM(17, 72);\n \n     @Override\n-    protected CellProducer createEmptyProducer() {\n+    protected CellExtractor createEmptyExtractor() {\n         return new ArrayCountingBloomFilter(shape);\n     }\n \n     @Override\n-    protected CellProducer createProducer() {\n+    protected CellExtractor createExtractor() {\n         final ArrayCountingBloomFilter filter = new ArrayCountingBloomFilter(shape);\n         filter.merge(new IncrementingHasher(0, 1));\n         filter.merge(new IncrementingHasher(5, 1));\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/CellProducerFromDefaultIndexProducerTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/CellExtractorFromDefaultIndexExtractorTest.java\nsimilarity index 78%\nrename from src/test/java/org/apache/commons/collections4/bloomfilter/CellProducerFromDefaultIndexProducerTest.java\nrename to src/test/java/org/apache/commons/collections4/bloomfilter/CellExtractorFromDefaultIndexExtractorTest.java\nindex c8a819c55f..3543fb39ab 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/CellProducerFromDefaultIndexProducerTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/CellExtractorFromDefaultIndexExtractorTest.java\n@@ -16,20 +16,20 @@\n  */\n package org.apache.commons.collections4.bloomfilter;\n \n-public class CellProducerFromDefaultIndexProducerTest extends AbstractCellProducerTest {\n+public class CellExtractorFromDefaultIndexExtractorTest extends AbstractCellExtractorTest {\n \n     int[] data = {0, 63, 1, 64, 128, 1, 127};\n     int[] indices = {0, 1, 63, 64, 127, 128};\n     int[] values = {1, 2, 1, 1, 1, 1 };\n \n     @Override\n-    protected CellProducer createEmptyProducer() {\n-        return CellProducer.from(IndexProducer.fromIndexArray());\n+    protected CellExtractor createEmptyExtractor() {\n+        return CellExtractor.from(IndexExtractor.fromIndexArray());\n     }\n \n     @Override\n-    protected CellProducer createProducer() {\n-        return CellProducer.from(IndexProducer.fromIndexArray(data));\n+    protected CellExtractor createExtractor() {\n+        return CellExtractor.from(IndexExtractor.fromIndexArray(data));\n     }\n \n     @Override\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/CellProducerFromLayeredBloomFilterTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/CellExtractorFromLayeredBloomFilterTest.java\nsimilarity index 82%\nrename from src/test/java/org/apache/commons/collections4/bloomfilter/CellProducerFromLayeredBloomFilterTest.java\nrename to src/test/java/org/apache/commons/collections4/bloomfilter/CellExtractorFromLayeredBloomFilterTest.java\nindex ad3fa8c1c0..7b0b001458 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/CellProducerFromLayeredBloomFilterTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/CellExtractorFromLayeredBloomFilterTest.java\n@@ -16,21 +16,21 @@\n  */\n package org.apache.commons.collections4.bloomfilter;\n \n-public class CellProducerFromLayeredBloomFilterTest extends AbstractCellProducerTest {\n+public class CellExtractorFromLayeredBloomFilterTest extends AbstractCellExtractorTest {\n \n     protected Shape shape = Shape.fromKM(17, 72);\n \n     @Override\n-    protected CellProducer createEmptyProducer() {\n-        return CellProducer.from(LayeredBloomFilterTest.fixed(shape, 10));\n+    protected CellExtractor createEmptyExtractor() {\n+        return CellExtractor.from(LayeredBloomFilterTest.fixed(shape, 10));\n     }\n \n     @Override\n-    protected CellProducer createProducer() {\n+    protected CellExtractor createExtractor() {\n         final Hasher hasher = new IncrementingHasher(3, 2);\n         final BloomFilter bf = LayeredBloomFilterTest.fixed(shape, 10);\n         bf.merge(hasher);\n-        return CellProducer.from(bf);\n+        return CellExtractor.from(bf);\n     }\n \n     @Override\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/CountingPredicateTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/CountingPredicateTest.java\nindex 2e925db0a4..59ba2bfc65 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/CountingPredicateTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/CountingPredicateTest.java\n@@ -55,17 +55,17 @@ public void testPredicateLonger() {\n         assertTrue(cp.test(Integer.valueOf(3)));\n         assertEquals(expected, result);\n         expected.add(Pair.of(2, null));\n-        assertTrue(cp.forEachRemaining());\n+        assertTrue(cp.processRemaining());\n         assertEquals(expected, result);\n \n         // if the other array is zero length then cp.test() will not be called so\n-        // we can just call cp.forEachRemaining() here.\n+        // we can just call cp.processRemaining() here.\n         expected.clear();\n         expected.add(Pair.of(1, null));\n         expected.add(Pair.of(2, null));\n         result.clear();\n         cp = new CountingPredicate<>(ary, makeFunc((x, y) -> x != null, result));\n-        assertTrue(cp.forEachRemaining());\n+        assertTrue(cp.processRemaining());\n         assertEquals(expected, result);\n \n         // If a test fails then the result should be false and the rest of the list should\n@@ -74,7 +74,7 @@ public void testPredicateLonger() {\n         expected.add(Pair.of(1, null));\n         result.clear();\n         cp = new CountingPredicate<>(ary, makeFunc((x, y) -> x == Integer.valueOf(1), result));\n-        assertFalse(cp.forEachRemaining());\n+        assertFalse(cp.processRemaining());\n         assertEquals(expected, result);\n     }\n \n@@ -92,7 +92,7 @@ public void testPredicateSameLength() {\n         assertTrue(cp.test(3));\n         assertTrue(cp.test(3));\n         assertEquals(expected, result);\n-        assertTrue(cp.forEachRemaining());\n+        assertTrue(cp.processRemaining());\n         assertEquals(expected, result);\n     }\n \n@@ -112,7 +112,7 @@ public void testPredicateShorter() {\n             assertTrue(cp.test(i));\n         }\n         assertEquals(expected, result);\n-        assertTrue(cp.forEachRemaining());\n+        assertTrue(cp.processRemaining());\n         assertEquals(expected, result);\n     }\n }\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/DefaultBitMapProducerTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/DefaultBitMapExtractorTest.java\nsimilarity index 68%\nrename from src/test/java/org/apache/commons/collections4/bloomfilter/DefaultBitMapProducerTest.java\nrename to src/test/java/org/apache/commons/collections4/bloomfilter/DefaultBitMapExtractorTest.java\nindex 3f45b81456..d0a5e20c9a 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/DefaultBitMapProducerTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/DefaultBitMapExtractorTest.java\n@@ -24,17 +24,17 @@\n \n import org.junit.jupiter.api.Test;\n \n-public class DefaultBitMapProducerTest extends AbstractBitMapProducerTest {\n+public class DefaultBitMapExtractorTest extends AbstractBitMapExtractorTest {\n \n-    class DefaultBitMapProducer implements BitMapProducer {\n+    class DefaultBitMapExtractor implements BitMapExtractor {\n         long[] bitMaps;\n \n-        DefaultBitMapProducer(final long[] bitMaps) {\n+        DefaultBitMapExtractor(final long[] bitMaps) {\n             this.bitMaps = bitMaps;\n         }\n \n         @Override\n-        public boolean forEachBitMap(final LongPredicate predicate) {\n+        public boolean processBitMaps(final LongPredicate predicate) {\n             for (final long bitmap : bitMaps) {\n                 if (!predicate.test(bitmap)) {\n                     return false;\n@@ -56,13 +56,13 @@ static long[] generateLongArray(final int size) {\n     long[] values = generateLongArray(5);\n \n     @Override\n-    protected BitMapProducer createEmptyProducer() {\n-        return new DefaultBitMapProducer(new long[0]);\n+    protected BitMapExtractor createEmptyExtractor() {\n+        return new DefaultBitMapExtractor(new long[0]);\n     }\n \n     @Override\n-    protected BitMapProducer createProducer() {\n-        return new DefaultBitMapProducer(values);\n+    protected BitMapExtractor createExtractor() {\n+        return new DefaultBitMapExtractor(values);\n     }\n \n     @Override\n@@ -73,7 +73,7 @@ protected boolean emptyIsZeroLength() {\n     @Test\n     public void testAsBitMapArrayLargeArray() {\n         final long[] expected = generateLongArray(32);\n-        final BitMapProducer producer = predicate -> {\n+        final BitMapExtractor bitMapExtractor = predicate -> {\n             for (final long l : expected) {\n                 if (!predicate.test(l)) {\n                     return false;\n@@ -81,25 +81,25 @@ public void testAsBitMapArrayLargeArray() {\n             }\n             return true;\n         };\n-        final long[] ary = producer.asBitMapArray();\n+        final long[] ary = bitMapExtractor.asBitMapArray();\n         assertArrayEquals(expected, ary);\n     }\n \n     @Test\n     public void testFromBitMapArray() {\n-        final int nOfBitMaps = BitMap.numberOfBitMaps(256);\n+        final int nOfBitMaps = BitMaps.numberOfBitMaps(256);\n         final long[] expected = generateLongArray(nOfBitMaps);\n-        final long[] ary = BitMapProducer.fromBitMapArray(expected).asBitMapArray();\n+        final long[] ary = BitMapExtractor.fromBitMapArray(expected).asBitMapArray();\n         assertArrayEquals(expected, ary);\n     }\n \n     @Test\n-    public void testFromIndexProducer() {\n-        final int[] expected = DefaultIndexProducerTest.generateIntArray(10, 256);\n-        final IndexProducer ip = IndexProducer.fromIndexArray(expected);\n-        final long[] ary = BitMapProducer.fromIndexProducer(ip, 256).asBitMapArray();\n+    public void testFromIndexExtractor() {\n+        final int[] expected = DefaultIndexExtractorTest.generateIntArray(10, 256);\n+        final IndexExtractor indexExtractor = IndexExtractor.fromIndexArray(expected);\n+        final long[] ary = BitMapExtractor.fromIndexExtractor(indexExtractor, 256).asBitMapArray();\n         for (final int idx : expected) {\n-            assertTrue(BitMap.contains(ary, idx));\n+            assertTrue(BitMaps.contains(ary, idx));\n         }\n     }\n }\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/DefaultBloomFilterProducerTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/DefaultBloomFilterExtractorTest.java\nsimilarity index 86%\nrename from src/test/java/org/apache/commons/collections4/bloomfilter/DefaultBloomFilterProducerTest.java\nrename to src/test/java/org/apache/commons/collections4/bloomfilter/DefaultBloomFilterExtractorTest.java\nindex d588fafade..4de666477a 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/DefaultBloomFilterProducerTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/DefaultBloomFilterExtractorTest.java\n@@ -16,10 +16,10 @@\n  */\n package org.apache.commons.collections4.bloomfilter;\n \n-public class DefaultBloomFilterProducerTest extends AbstractBloomFilterProducerTest {\n+public class DefaultBloomFilterExtractorTest extends AbstractBloomFilterExtractorTest {\n \n     @Override\n-    protected BloomFilterProducer createUnderTest(final BloomFilter... filters) {\n+    protected BloomFilterExtractor createUnderTest(final BloomFilter... filters) {\n         return bloomFilterPredicate -> {\n             for (final BloomFilter bf : filters) {\n                 if (!bloomFilterPredicate.test(bf)) {\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/DefaultBloomFilterTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/DefaultBloomFilterTest.java\nindex 480bb89e39..e67201043d 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/DefaultBloomFilterTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/DefaultBloomFilterTest.java\n@@ -64,22 +64,22 @@ public void clear() {\n         }\n \n         @Override\n-        public boolean contains(final BitMapProducer bitMapProducer) {\n-            return contains(IndexProducer.fromBitMapProducer(bitMapProducer));\n+        public boolean contains(final BitMapExtractor bitMapExtractor) {\n+            return contains(IndexExtractor.fromBitMapExtractor(bitMapExtractor));\n         }\n \n         @Override\n-        public boolean contains(final IndexProducer indexProducer) {\n-            return indexProducer.forEachIndex(indices::contains);\n+        public boolean contains(final IndexExtractor indexExtractor) {\n+            return indexExtractor.processIndices(indices::contains);\n         }\n \n         @Override\n-        public boolean forEachBitMap(final LongPredicate consumer) {\n-            return BitMapProducer.fromIndexProducer(this, shape.getNumberOfBits()).forEachBitMap(consumer);\n+        public boolean processBitMaps(final LongPredicate consumer) {\n+            return BitMapExtractor.fromIndexExtractor(this, shape.getNumberOfBits()).processBitMaps(consumer);\n         }\n \n         @Override\n-        public boolean forEachIndex(final IntPredicate consumer) {\n+        public boolean processIndices(final IntPredicate consumer) {\n             for (final Integer i : indices) {\n                 if (!consumer.test(i)) {\n                     return false;\n@@ -94,13 +94,13 @@ public Shape getShape() {\n         }\n \n         @Override\n-        public boolean merge(final BitMapProducer bitMapProducer) {\n-            return merge(IndexProducer.fromBitMapProducer(bitMapProducer));\n+        public boolean merge(final BitMapExtractor bitMapExtractor) {\n+            return merge(IndexExtractor.fromBitMapExtractor(bitMapExtractor));\n         }\n \n         @Override\n-        public boolean merge(final IndexProducer indexProducer) {\n-            final boolean result = indexProducer.forEachIndex(x -> {\n+        public boolean merge(final IndexExtractor indexExtractor) {\n+            final boolean result = indexExtractor.processIndices(x -> {\n                 indices.add(x);\n                 return true;\n             });\n@@ -193,7 +193,7 @@ public void testEstimateLargeN() {\n         final Shape s = Shape.fromKM(1, Integer.MAX_VALUE);\n         // create a very large filter with Integer.MAX_VALUE-1 bits set.\n         final BloomFilter bf1 = new SimpleBloomFilter(s);\n-        bf1.merge((BitMapProducer) predicate -> {\n+        bf1.merge((BitMapExtractor) predicate -> {\n             int limit = Integer.MAX_VALUE - 1;\n             while (limit > 64) {\n                 predicate.test(0xFFFFFFFFFFFFFFFFL);\n@@ -201,7 +201,7 @@ public void testEstimateLargeN() {\n             }\n             long last = 0L;\n             for (int i = 0; i < limit; i++) {\n-                last |= BitMap.getLongBit(i);\n+                last |= BitMaps.getLongBit(i);\n             }\n             predicate.test(last);\n             return true;\n@@ -224,13 +224,13 @@ public void testHasherBasedMergeWithDifferingSparseness() {\n \n         BloomFilter bf1 = new NonSparseDefaultBloomFilter(getTestShape());\n         bf1.merge(hasher);\n-        assertTrue(BitMapProducer.fromIndexProducer(hasher.indices(getTestShape()), getTestShape().getNumberOfBits())\n-                .forEachBitMapPair(bf1, (x, y) -> x == y));\n+        assertTrue(BitMapExtractor.fromIndexExtractor(hasher.indices(getTestShape()), getTestShape().getNumberOfBits())\n+                .processBitMapPairs(bf1, (x, y) -> x == y));\n \n         bf1 = new SparseDefaultBloomFilter(getTestShape());\n         bf1.merge(hasher);\n-        assertTrue(BitMapProducer.fromIndexProducer(hasher.indices(getTestShape()), getTestShape().getNumberOfBits())\n-                .forEachBitMapPair(bf1, (x, y) -> x == y));\n+        assertTrue(BitMapExtractor.fromIndexExtractor(hasher.indices(getTestShape()), getTestShape().getNumberOfBits())\n+                .processBitMapPairs(bf1, (x, y) -> x == y));\n     }\n \n     @Test\n@@ -238,7 +238,7 @@ public void testIntersectionLimit() {\n         final Shape s = Shape.fromKM(1, Integer.MAX_VALUE);\n         // create a very large filter with Integer.MAX_VALUE-1 bit set.\n         final BloomFilter bf1 = new SimpleBloomFilter(s);\n-        bf1.merge((BitMapProducer) predicate -> {\n+        bf1.merge((BitMapExtractor) predicate -> {\n             int limit = Integer.MAX_VALUE - 1;\n             while (limit > 64) {\n                 predicate.test(0xFFFFFFFFFFFFFFFFL);\n@@ -246,7 +246,7 @@ public void testIntersectionLimit() {\n             }\n             long last = 0L;\n             for (int i = 0; i < limit; i++) {\n-                last |= BitMap.getLongBit(i);\n+                last |= BitMaps.getLongBit(i);\n             }\n             predicate.test(last);\n             return true;\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/DefaultCellProducerTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/DefaultCellExtractorTest.java\nsimilarity index 90%\nrename from src/test/java/org/apache/commons/collections4/bloomfilter/DefaultCellProducerTest.java\nrename to src/test/java/org/apache/commons/collections4/bloomfilter/DefaultCellExtractorTest.java\nindex eb6c18417f..5711360cea 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/DefaultCellProducerTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/DefaultCellExtractorTest.java\n@@ -16,19 +16,19 @@\n  */\n package org.apache.commons.collections4.bloomfilter;\n \n-public class DefaultCellProducerTest extends AbstractCellProducerTest {\n+public class DefaultCellExtractorTest extends AbstractCellExtractorTest {\n \n     /** Make forEachIndex unordered and contain duplicates. */\n     private final int[] indices = {1, 2, 3, 5};\n     private final int[] values = {1, 4, 9, 25};\n \n     @Override\n-    protected CellProducer createEmptyProducer() {\n+    protected CellExtractor createEmptyExtractor() {\n         return consumer -> true;\n     }\n \n     @Override\n-    protected CellProducer createProducer() {\n+    protected CellExtractor createExtractor() {\n         return consumer -> {\n             for (int i = 0; i < indices.length; i++) {\n                 if (!consumer.test(indices[i], values[i] )) {\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/DefaultIndexProducerTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/DefaultIndexExtractorTest.java\nsimilarity index 85%\nrename from src/test/java/org/apache/commons/collections4/bloomfilter/DefaultIndexProducerTest.java\nrename to src/test/java/org/apache/commons/collections4/bloomfilter/DefaultIndexExtractorTest.java\nindex 8fa0a3db9f..0d58fbcda1 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/DefaultIndexProducerTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/DefaultIndexExtractorTest.java\n@@ -28,7 +28,7 @@\n import org.junit.jupiter.params.ParameterizedTest;\n import org.junit.jupiter.params.provider.ValueSource;\n \n-public class DefaultIndexProducerTest extends AbstractIndexProducerTest {\n+public class DefaultIndexExtractorTest extends AbstractIndexExtractorTest {\n \n     /**\n      * Generates an array of integers.\n@@ -64,7 +64,7 @@ public static BitSet uniqueSet(final int[] ary) {\n     private final int[] values = {10, 1, 10, 1};\n \n     @Override\n-    protected IndexProducer createEmptyProducer() {\n+    protected IndexExtractor createEmptyExtractor() {\n         return predicate -> {\n             Objects.requireNonNull(predicate);\n             return true;\n@@ -72,7 +72,7 @@ protected IndexProducer createEmptyProducer() {\n     }\n \n     @Override\n-    protected IndexProducer createProducer() {\n+    protected IndexExtractor createExtractor() {\n         return predicate -> {\n             Objects.requireNonNull(predicate);\n             for (final int i : values) {\n@@ -104,7 +104,7 @@ protected int getForEachIndexBehaviour() {\n     @ValueSource(ints = {32, 33})\n     public void testEntries(final int size) {\n         final int[] values = IntStream.range(0, size).toArray();\n-        final IndexProducer producer =  predicate -> {\n+        final IndexExtractor indexExtractor = predicate -> {\n             Objects.requireNonNull(predicate);\n             for (final int i : values) {\n                 if (!predicate.test(i)) {\n@@ -113,19 +113,19 @@ public void testEntries(final int size) {\n             }\n             return true;\n         };\n-        final int[] other = producer.asIndexArray();\n+        final int[] other = indexExtractor.asIndexArray();\n         assertArrayEquals(values, other);\n     }\n \n     @Test\n-    public void testFromBitMapProducer() {\n+    public void testFromBitMapExtractor() {\n         for (int i = 0; i < 5; i++) {\n             final int[] expected = generateIntArray(7, 256);\n-            final long[] bits = new long[BitMap.numberOfBitMaps(256)];\n+            final long[] bits = new long[BitMaps.numberOfBitMaps(256)];\n             for (final int bitIndex : expected) {\n-                BitMap.set(bits, bitIndex);\n+                BitMaps.set(bits, bitIndex);\n             }\n-            final IndexProducer ip = IndexProducer.fromBitMapProducer(BitMapProducer.fromBitMapArray(bits));\n+            final IndexExtractor ip = IndexExtractor.fromBitMapExtractor(BitMapExtractor.fromBitMapArray(bits));\n             assertArrayEquals(unique(expected), ip.asIndexArray());\n         }\n     }\n@@ -134,7 +134,7 @@ public void testFromBitMapProducer() {\n     public void testFromIndexArray() {\n         for (int i = 0; i < 5; i++) {\n             final int[] expected = generateIntArray(10, 256);\n-            final IndexProducer ip = IndexProducer.fromIndexArray(expected);\n+            final IndexExtractor ip = IndexExtractor.fromIndexArray(expected);\n             assertArrayEquals(expected, ip.asIndexArray());\n         }\n     }\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/IncrementingHasher.java b/src/test/java/org/apache/commons/collections4/bloomfilter/IncrementingHasher.java\nindex b7f9b62717..778a9d541d 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/IncrementingHasher.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/IncrementingHasher.java\n@@ -52,10 +52,10 @@ public IncrementingHasher(final long initial, final long increment) {\n     }\n \n     @Override\n-    public IndexProducer indices(final Shape shape) {\n+    public IndexExtractor indices(final Shape shape) {\n         Objects.requireNonNull(shape, \"shape\");\n \n-        return new IndexProducer() {\n+        return new IndexExtractor() {\n             @Override\n             public int[] asIndexArray() {\n                 final int[] result = new int[shape.getNumberOfHashFunctions()];\n@@ -63,7 +63,7 @@ public int[] asIndexArray() {\n \n                 // This method needs to return duplicate indices\n \n-                forEachIndex(i -> {\n+                processIndices(i -> {\n                     result[idx[0]++] = i;\n                     return true;\n                 });\n@@ -71,7 +71,7 @@ public int[] asIndexArray() {\n             }\n \n             @Override\n-            public boolean forEachIndex(final IntPredicate consumer) {\n+            public boolean processIndices(final IntPredicate consumer) {\n                 Objects.requireNonNull(consumer, \"consumer\");\n                 final int bits = shape.getNumberOfBits();\n \n@@ -80,8 +80,8 @@ public boolean forEachIndex(final IntPredicate consumer) {\n                 // This avoids any modulus operation inside the while loop. It uses a long index\n                 // to avoid overflow.\n \n-                long index = BitMap.mod(initial, bits);\n-                final int inc = BitMap.mod(increment, bits);\n+                long index = BitMaps.mod(initial, bits);\n+                final int inc = BitMaps.mod(increment, bits);\n \n                 for (int functionalCount = 0; functionalCount < shape.getNumberOfHashFunctions(); functionalCount++) {\n                     if (!consumer.test((int) index)) {\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromArrayCountingBloomFilterTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/IndexExtractorFromArrayCountingBloomFilterTest.java\nsimilarity index 88%\nrename from src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromArrayCountingBloomFilterTest.java\nrename to src/test/java/org/apache/commons/collections4/bloomfilter/IndexExtractorFromArrayCountingBloomFilterTest.java\nindex 857c1f51e3..118a2ec46a 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromArrayCountingBloomFilterTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/IndexExtractorFromArrayCountingBloomFilterTest.java\n@@ -16,17 +16,17 @@\n  */\n package org.apache.commons.collections4.bloomfilter;\n \n-public class IndexProducerFromArrayCountingBloomFilterTest extends AbstractIndexProducerTest {\n+public class IndexExtractorFromArrayCountingBloomFilterTest extends AbstractIndexExtractorTest {\n \n     protected Shape shape = Shape.fromKM(17, 72);\n \n     @Override\n-    protected IndexProducer createEmptyProducer() {\n+    protected IndexExtractor createEmptyExtractor() {\n         return new ArrayCountingBloomFilter(shape);\n     }\n \n     @Override\n-    protected IndexProducer createProducer() {\n+    protected IndexExtractor createExtractor() {\n         final ArrayCountingBloomFilter filter = new ArrayCountingBloomFilter(shape);\n         filter.merge(new IncrementingHasher(0, 1));\n         filter.merge(new IncrementingHasher(5, 1));\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromBitmapProducerTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/IndexExtractorFromBitmapExtractorTest.java\nsimilarity index 67%\nrename from src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromBitmapProducerTest.java\nrename to src/test/java/org/apache/commons/collections4/bloomfilter/IndexExtractorFromBitmapExtractorTest.java\nindex 3de474b9a3..0c8cd27c71 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromBitmapProducerTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/IndexExtractorFromBitmapExtractorTest.java\n@@ -24,17 +24,17 @@\n \n import org.junit.jupiter.api.Test;\n \n-public class IndexProducerFromBitmapProducerTest extends AbstractIndexProducerTest {\n+public class IndexExtractorFromBitmapExtractorTest extends AbstractIndexExtractorTest {\n \n-    private static final class TestingBitMapProducer implements BitMapProducer {\n+    private static final class TestingBitMapExtractor implements BitMapExtractor {\n         long[] values;\n \n-        TestingBitMapProducer(final long[] values) {\n+        TestingBitMapExtractor(final long[] values) {\n             this.values = values;\n         }\n \n         @Override\n-        public boolean forEachBitMap(final LongPredicate consumer) {\n+        public boolean processBitMaps(final LongPredicate consumer) {\n             for (final long l : values) {\n                 if (!consumer.test(l)) {\n                     return false;\n@@ -45,14 +45,14 @@ public boolean forEachBitMap(final LongPredicate consumer) {\n     }\n \n     @Override\n-    protected IndexProducer createEmptyProducer() {\n-        final TestingBitMapProducer producer = new TestingBitMapProducer(new long[0]);\n-        return IndexProducer.fromBitMapProducer(producer);\n+    protected IndexExtractor createEmptyExtractor() {\n+        final TestingBitMapExtractor testingBitMapExtractor = new TestingBitMapExtractor(new long[0]);\n+        return IndexExtractor.fromBitMapExtractor(testingBitMapExtractor);\n     }\n \n     @Override\n-    protected IndexProducer createProducer() {\n-        /* Creates an index producer that produces the values:\n+    protected IndexExtractor createExtractor() {\n+        /* Creates an index testingBitMapExtractor that produces the values:\n          * 0, 65, 128, and 129\n          @formatter:off\n                 Index2    Index1     Index0\n@@ -63,8 +63,8 @@ protected IndexProducer createProducer() {\n          3L => ...0011\n          @formatter:on\n          */\n-        final TestingBitMapProducer producer = new TestingBitMapProducer(new long[] {1L, 2L, 3L});\n-        return IndexProducer.fromBitMapProducer(producer);\n+        final TestingBitMapExtractor testingBitMapExtractor = new TestingBitMapExtractor(new long[] {1L, 2L, 3L});\n+        return IndexExtractor.fromBitMapExtractor(testingBitMapExtractor);\n     }\n \n     @Override\n@@ -79,22 +79,22 @@ protected int[] getExpectedIndices() {\n     }\n \n     @Test\n-    public final void testFromBitMapProducerTest() {\n-        IndexProducer underTest = createProducer();\n+    public final void testFromBitMapExtractor() {\n+        IndexExtractor underTest = createExtractor();\n         List<Integer> lst = new ArrayList<>();\n \n-        underTest.forEachIndex(lst::add);\n+        underTest.processIndices(lst::add);\n         assertEquals(4, lst.size());\n         assertEquals(Integer.valueOf(0), lst.get(0));\n         assertEquals(Integer.valueOf(1 + 64), lst.get(1));\n         assertEquals(Integer.valueOf(0 + 128), lst.get(2));\n         assertEquals(Integer.valueOf(1 + 128), lst.get(3));\n \n-        final BitMapProducer producer = new TestingBitMapProducer(new long[] {0xFFFFFFFFFFFFFFFFL});\n-        underTest = IndexProducer.fromBitMapProducer(producer);\n+        final BitMapExtractor bitMapExtractor = new TestingBitMapExtractor(new long[] {0xFFFFFFFFFFFFFFFFL});\n+        underTest = IndexExtractor.fromBitMapExtractor(bitMapExtractor);\n         lst = new ArrayList<>();\n \n-        underTest.forEachIndex(lst::add);\n+        underTest.processIndices(lst::add);\n \n         assertEquals(64, lst.size());\n         for (int i = 0; i < 64; i++) {\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromHasherTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/IndexExtractorFromHasherTest.java\nsimilarity index 87%\nrename from src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromHasherTest.java\nrename to src/test/java/org/apache/commons/collections4/bloomfilter/IndexExtractorFromHasherTest.java\nindex c617146b6e..c647e80845 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromHasherTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/IndexExtractorFromHasherTest.java\n@@ -16,15 +16,15 @@\n  */\n package org.apache.commons.collections4.bloomfilter;\n \n-public class IndexProducerFromHasherTest extends AbstractIndexProducerTest {\n+public class IndexExtractorFromHasherTest extends AbstractIndexExtractorTest {\n \n     @Override\n-    protected IndexProducer createEmptyProducer() {\n+    protected IndexExtractor createEmptyExtractor() {\n         return NullHasher.INSTANCE.indices(Shape.fromKM(17, 72));\n     }\n \n     @Override\n-    protected IndexProducer createProducer() {\n+    protected IndexExtractor createExtractor() {\n         // hasher has collisions and wraps\n         return new IncrementingHasher(4, 8).indices(Shape.fromKM(17, 72));\n     }\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromIntArrayTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/IndexExtractorFromIntArrayTest.java\nsimilarity index 79%\nrename from src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromIntArrayTest.java\nrename to src/test/java/org/apache/commons/collections4/bloomfilter/IndexExtractorFromIntArrayTest.java\nindex b813a0caf4..1bab6146a4 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromIntArrayTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/IndexExtractorFromIntArrayTest.java\n@@ -16,18 +16,18 @@\n  */\n package org.apache.commons.collections4.bloomfilter;\n \n-public class IndexProducerFromIntArrayTest extends AbstractIndexProducerTest {\n+public class IndexExtractorFromIntArrayTest extends AbstractIndexExtractorTest {\n \n     int[] data = {6, 8, 1, 2, 4, 4, 5};\n \n     @Override\n-    protected IndexProducer createEmptyProducer() {\n-        return IndexProducer.fromIndexArray();\n+    protected IndexExtractor createEmptyExtractor() {\n+        return IndexExtractor.fromIndexArray();\n     }\n \n     @Override\n-    protected IndexProducer createProducer() {\n-        return IndexProducer.fromIndexArray(data);\n+    protected IndexExtractor createExtractor() {\n+        return IndexExtractor.fromIndexArray(data);\n     }\n \n     @Override\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromSimpleBloomFilterTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/IndexExtractorFromSimpleBloomFilterTest.java\nsimilarity index 88%\nrename from src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromSimpleBloomFilterTest.java\nrename to src/test/java/org/apache/commons/collections4/bloomfilter/IndexExtractorFromSimpleBloomFilterTest.java\nindex 75e14a7beb..aa13658ac0 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromSimpleBloomFilterTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/IndexExtractorFromSimpleBloomFilterTest.java\n@@ -16,17 +16,17 @@\n  */\n package org.apache.commons.collections4.bloomfilter;\n \n-public class IndexProducerFromSimpleBloomFilterTest extends AbstractIndexProducerTest {\n+public class IndexExtractorFromSimpleBloomFilterTest extends AbstractIndexExtractorTest {\n \n     protected Shape shape = Shape.fromKM(17, 72);\n \n     @Override\n-    protected IndexProducer createEmptyProducer() {\n+    protected IndexExtractor createEmptyExtractor() {\n         return new SimpleBloomFilter(shape);\n     }\n \n     @Override\n-    protected IndexProducer createProducer() {\n+    protected IndexExtractor createExtractor() {\n         final Hasher hasher = new IncrementingHasher(3, 2);\n         final BloomFilter bf = new SimpleBloomFilter(shape);\n         bf.merge(hasher);\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromSparseBloomFilterTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/IndexExtractorFromSparseBloomFilterTest.java\nsimilarity index 88%\nrename from src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromSparseBloomFilterTest.java\nrename to src/test/java/org/apache/commons/collections4/bloomfilter/IndexExtractorFromSparseBloomFilterTest.java\nindex 6ad25e4400..e7febe1aae 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromSparseBloomFilterTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/IndexExtractorFromSparseBloomFilterTest.java\n@@ -16,17 +16,17 @@\n  */\n package org.apache.commons.collections4.bloomfilter;\n \n-public class IndexProducerFromSparseBloomFilterTest extends AbstractIndexProducerTest {\n+public class IndexExtractorFromSparseBloomFilterTest extends AbstractIndexExtractorTest {\n \n     protected Shape shape = Shape.fromKM(17, 72);\n \n     @Override\n-    protected IndexProducer createEmptyProducer() {\n+    protected IndexExtractor createEmptyExtractor() {\n         return new SparseBloomFilter(shape);\n     }\n \n     @Override\n-    protected IndexProducer createProducer() {\n+    protected IndexExtractor createExtractor() {\n         final Hasher hasher = new IncrementingHasher(4, 7);\n         final BloomFilter bf = new SparseBloomFilter(shape);\n         bf.merge(hasher);\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromUniqueHasherTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/IndexExtractorFromUniqueHasherTest.java\nsimilarity index 87%\nrename from src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromUniqueHasherTest.java\nrename to src/test/java/org/apache/commons/collections4/bloomfilter/IndexExtractorFromUniqueHasherTest.java\nindex ccddd9d4b1..f1a8ff3f62 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromUniqueHasherTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/IndexExtractorFromUniqueHasherTest.java\n@@ -16,15 +16,15 @@\n  */\n package org.apache.commons.collections4.bloomfilter;\n \n-public class IndexProducerFromUniqueHasherTest extends AbstractIndexProducerTest {\n+public class IndexExtractorFromUniqueHasherTest extends AbstractIndexExtractorTest {\n \n     @Override\n-    protected IndexProducer createEmptyProducer() {\n+    protected IndexExtractor createEmptyExtractor() {\n         return NullHasher.INSTANCE.indices(Shape.fromKM(17, 72));\n     }\n \n     @Override\n-    protected IndexProducer createProducer() {\n+    protected IndexExtractor createExtractor() {\n         // hasher has collisions and wraps\n         return new IncrementingHasher(4, 8).indices(Shape.fromKM(17, 72)).uniqueIndices();\n     }\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/IndexExtractorTest.java\nsimilarity index 74%\nrename from src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerTest.java\nrename to src/test/java/org/apache/commons/collections4/bloomfilter/IndexExtractorTest.java\nindex a8343d94db..82010ca490 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/IndexExtractorTest.java\n@@ -27,17 +27,17 @@\n import org.junit.jupiter.params.ParameterizedTest;\n import org.junit.jupiter.params.provider.ValueSource;\n \n-public class IndexProducerTest {\n+public class IndexExtractorTest {\n \n-    private static final class TestingBitMapProducer implements BitMapProducer {\n+    private static final class TestingBitMapExtractor implements BitMapExtractor {\n         long[] values;\n \n-        TestingBitMapProducer(final long[] values) {\n+        TestingBitMapExtractor(final long[] values) {\n             this.values = values;\n         }\n \n         @Override\n-        public boolean forEachBitMap(final LongPredicate consumer) {\n+        public boolean processBitMaps(final LongPredicate consumer) {\n             for (final long l : values) {\n                 if (!consumer.test(l)) {\n                     return false;\n@@ -48,23 +48,23 @@ public boolean forEachBitMap(final LongPredicate consumer) {\n     }\n \n     @Test\n-    public void fromBitMapProducerTest() {\n-        TestingBitMapProducer producer = new TestingBitMapProducer(new long[] {1L, 2L, 3L});\n-        IndexProducer underTest = IndexProducer.fromBitMapProducer(producer);\n+    public void testFromBitMapExtractor() {\n+        TestingBitMapExtractor testingBitMapExtractor = new TestingBitMapExtractor(new long[] {1L, 2L, 3L});\n+        IndexExtractor underTest = IndexExtractor.fromBitMapExtractor(testingBitMapExtractor);\n         List<Integer> lst = new ArrayList<>();\n \n-        underTest.forEachIndex(lst::add);\n+        underTest.processIndices(lst::add);\n         assertEquals(4, lst.size());\n         assertEquals(Integer.valueOf(0), lst.get(0));\n         assertEquals(Integer.valueOf(1 + 64), lst.get(1));\n         assertEquals(Integer.valueOf(0 + 128), lst.get(2));\n         assertEquals(Integer.valueOf(1 + 128), lst.get(3));\n \n-        producer = new TestingBitMapProducer(new long[] {0xFFFFFFFFFFFFFFFFL});\n-        underTest = IndexProducer.fromBitMapProducer(producer);\n+        testingBitMapExtractor = new TestingBitMapExtractor(new long[] {0xFFFFFFFFFFFFFFFFL});\n+        underTest = IndexExtractor.fromBitMapExtractor(testingBitMapExtractor);\n         lst = new ArrayList<>();\n \n-        underTest.forEachIndex(lst::add);\n+        underTest.processIndices(lst::add);\n \n         assertEquals(64, lst.size());\n         for (int i = 0; i < 64; i++) {\n@@ -75,7 +75,7 @@ public void fromBitMapProducerTest() {\n     @ParameterizedTest\n     @ValueSource(ints = {32, 33})\n     void testAsIndexArray(final int n) {\n-        final IndexProducer ip = i -> {\n+        final IndexExtractor ip = i -> {\n             for (int j = 0; j < n; j++) {\n                 // Always test index zero\n                 i.test(0);\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/LayerManagerTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/LayerManagerTest.java\nindex 09ffac2e74..ca90f0d0d6 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/LayerManagerTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/LayerManagerTest.java\n@@ -134,7 +134,7 @@ public void testCopy() {\n \n         assertEquals(underTest.getDepth(), copy.getDepth());\n         assertTrue(\n-                underTest.forEachBloomFilterPair(copy, (x, y) -> Arrays.equals(x.asBitMapArray(), y.asBitMapArray())));\n+                underTest.processBloomFilterPair(copy, (x, y) -> Arrays.equals(x.asBitMapArray(), y.asBitMapArray())));\n     }\n \n     @Test\n@@ -150,7 +150,7 @@ public void testForEachBloomFilter() {\n             underTest.getTarget().merge(bf);\n         }\n         final List<BloomFilter> lst2 = new ArrayList<>();\n-        underTest.forEachBloomFilter(lst2::add);\n+        underTest.processBloomFilters(lst2::add);\n         assertEquals(10, lst.size());\n         assertEquals(10, lst2.size());\n         for (int i = 0; i < lst.size(); i++) {\n@@ -242,7 +242,7 @@ public void testRemoveEmptyTarget() {\n         assertTrue(list.isEmpty());\n \n         // does not remove a populated filter.\n-        bf.merge(IndexProducer.fromIndexArray(1));\n+        bf.merge(IndexExtractor.fromIndexArray(1));\n         list.add(bf);\n         assertEquals(bf, list.get(0));\n         underTest.accept(list);\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/LayeredBloomFilterTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/LayeredBloomFilterTest.java\nindex 32a47c17c7..24a143b85a 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/LayeredBloomFilterTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/LayeredBloomFilterTest.java\n@@ -201,14 +201,14 @@ protected BloomFilter makeFilter(final Hasher h) {\n         return bf;\n     }\n \n-    protected BloomFilter makeFilter(final IndexProducer p) {\n+    protected BloomFilter makeFilter(final IndexExtractor p) {\n         final BloomFilter bf = new SparseBloomFilter(getTestShape());\n         bf.merge(p);\n         return bf;\n     }\n \n     protected BloomFilter makeFilter(final int... values) {\n-        return makeFilter(IndexProducer.fromIndexArray(values));\n+        return makeFilter(IndexExtractor.fromIndexArray(values));\n     }\n \n     private LayeredBloomFilter<BloomFilter> setupFindTest() {\n@@ -291,7 +291,7 @@ public void testExpiration() throws InterruptedException {\n         for (int i = 0; i < 10; i++) {\n             underTest.merge(TestingHashers.randomHasher());\n         }\n-        underTest.forEachBloomFilter(dbg.and(x -> lst.add(((TimestampedBloomFilter) x).timestamp)));\n+        underTest.processBloomFilters(dbg.and(x -> lst.add(((TimestampedBloomFilter) x).timestamp)));\n         assertTrue(underTest.getDepth() > 1);\n \n         Thread.sleep(300);\n@@ -299,38 +299,38 @@ public void testExpiration() throws InterruptedException {\n             underTest.merge(TestingHashers.randomHasher());\n         }\n         dbgInstrument.add(\"=== AFTER 300 milliseconds ====\\n\");\n-        underTest.forEachBloomFilter(dbg);\n+        underTest.processBloomFilters(dbg);\n \n         Thread.sleep(150);\n         for (int i = 0; i < 10; i++) {\n             underTest.merge(TestingHashers.randomHasher());\n         }\n         dbgInstrument.add(\"=== AFTER 450 milliseconds ====\\n\");\n-        underTest.forEachBloomFilter(dbg);\n+        underTest.processBloomFilters(dbg);\n \n         // sleep 200 milliseconds to ensure we cross the 600 millisecond boundary\n         Thread.sleep(200);\n         underTest.merge(TestingHashers.randomHasher());\n         dbgInstrument.add(\"=== AFTER 600 milliseconds ====\\n\");\n-        assertTrue(underTest.forEachBloomFilter(dbg.and(x -> !lst.contains(((TimestampedBloomFilter) x).timestamp))),\n+        assertTrue(underTest.processBloomFilters(dbg.and(x -> !lst.contains(((TimestampedBloomFilter) x).timestamp))),\n                 \"Found filter that should have been deleted: \" + dbgInstrument.get(dbgInstrument.size() - 1));\n     }\n \n     @Test\n-    public void testFindBitMapProducer() {\n+    public void testFindBitMapExtractor() {\n         final LayeredBloomFilter<BloomFilter> filter = setupFindTest();\n \n-        IndexProducer idxProducer = TestingHashers.FROM1.indices(getTestShape());\n-        BitMapProducer producer = BitMapProducer.fromIndexProducer(idxProducer, getTestShape().getNumberOfBits());\n+        IndexExtractor indexExtractor = TestingHashers.FROM1.indices(getTestShape());\n+        BitMapExtractor bitMapExtractor = BitMapExtractor.fromIndexExtractor(indexExtractor, getTestShape().getNumberOfBits());\n \n         int[] expected = {0, 3};\n-        int[] result = filter.find(producer);\n+        int[] result = filter.find(bitMapExtractor);\n         assertArrayEquals(expected, result);\n \n         expected = new int[]{1, 3};\n-        idxProducer = TestingHashers.FROM11.indices(getTestShape());\n-        producer = BitMapProducer.fromIndexProducer(idxProducer, getTestShape().getNumberOfBits());\n-        result = filter.find(producer);\n+        indexExtractor = TestingHashers.FROM11.indices(getTestShape());\n+        bitMapExtractor = BitMapExtractor.fromIndexExtractor(indexExtractor, getTestShape().getNumberOfBits());\n+        result = filter.find(bitMapExtractor);\n         assertArrayEquals(expected, result);\n     }\n \n@@ -346,17 +346,17 @@ public void testFindBloomFilter() {\n     }\n \n     @Test\n-    public void testFindIndexProducer() {\n-        IndexProducer producer = TestingHashers.FROM1.indices(getTestShape());\n+    public void testFindIndexExtractor() {\n+        IndexExtractor indexExtractor = TestingHashers.FROM1.indices(getTestShape());\n         final LayeredBloomFilter<BloomFilter> filter = setupFindTest();\n \n         int[] expected = {0, 3};\n-        int[] result = filter.find(producer);\n+        int[] result = filter.find(indexExtractor);\n         assertArrayEquals(expected, result);\n \n         expected = new int[] {1, 3};\n-        producer = TestingHashers.FROM11.indices(getTestShape());\n-        result = filter.find(producer);\n+        indexExtractor = TestingHashers.FROM11.indices(getTestShape());\n+        result = filter.find(indexExtractor);\n         assertArrayEquals(expected, result);\n     }\n \ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/NullHasher.java b/src/test/java/org/apache/commons/collections4/bloomfilter/NullHasher.java\nindex 1bafc5ea9f..290eaf7c1a 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/NullHasher.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/NullHasher.java\n@@ -31,14 +31,14 @@ final class NullHasher implements Hasher {\n      */\n     static final NullHasher INSTANCE = new NullHasher();\n \n-    private static final IndexProducer PRODUCER = new IndexProducer() {\n+    private static final IndexExtractor INDEX_EXTRACTOR = new IndexExtractor() {\n         @Override\n         public int[] asIndexArray() {\n             return new int[0];\n         }\n \n         @Override\n-        public boolean forEachIndex(final IntPredicate consumer) {\n+        public boolean processIndices(final IntPredicate consumer) {\n             Objects.requireNonNull(consumer, \"consumer\");\n             return true;\n         }\n@@ -49,8 +49,8 @@ private NullHasher() {\n     }\n \n     @Override\n-    public IndexProducer indices(final Shape shape) {\n+    public IndexExtractor indices(final Shape shape) {\n         Objects.requireNonNull(shape, \"shape\");\n-        return PRODUCER;\n+        return INDEX_EXTRACTOR;\n     }\n }\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/SetOperationsTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/SetOperationsTest.java\nindex 075cddb729..5abb6bfbe7 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/SetOperationsTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/SetOperationsTest.java\n@@ -48,25 +48,25 @@ private BloomFilter createFilter(final Shape shape, final Hasher hasher) {\n         return bf;\n     }\n \n-    private BloomFilter createFilter(final Shape shape, final IndexProducer producer) {\n+    private BloomFilter createFilter(final Shape shape, final IndexExtractor indexExtractor) {\n         final BloomFilter bf = new SparseBloomFilter(shape);\n-        bf.merge(producer);\n+        bf.merge(indexExtractor);\n         return bf;\n     }\n \n     @Test\n     public final void testAndCardinality() {\n         final Shape shape = Shape.fromKM(3, 128);\n-        BloomFilter filter1 = createFilter(shape, IndexProducer.fromIndexArray(1, 63, 64));\n-        BloomFilter filter2 = createFilter(shape, IndexProducer.fromIndexArray(5, 64, 69));\n+        BloomFilter filter1 = createFilter(shape, IndexExtractor.fromIndexArray(1, 63, 64));\n+        BloomFilter filter2 = createFilter(shape, IndexExtractor.fromIndexArray(5, 64, 69));\n         assertSymmetricOperation(1, SetOperations::andCardinality, filter1, filter2);\n \n-        filter1 = createFilter(shape, IndexProducer.fromIndexArray(1, 63));\n-        filter2 = createFilter(shape, IndexProducer.fromIndexArray(5, 64, 69));\n+        filter1 = createFilter(shape, IndexExtractor.fromIndexArray(1, 63));\n+        filter2 = createFilter(shape, IndexExtractor.fromIndexArray(5, 64, 69));\n         assertSymmetricOperation(0, SetOperations::andCardinality, filter1, filter2);\n \n-        filter1 = createFilter(shape, IndexProducer.fromIndexArray(5, 63));\n-        filter2 = createFilter(shape, IndexProducer.fromIndexArray(5, 64, 69));\n+        filter1 = createFilter(shape, IndexExtractor.fromIndexArray(5, 63));\n+        filter2 = createFilter(shape, IndexExtractor.fromIndexArray(5, 64, 69));\n         assertSymmetricOperation(1, SetOperations::andCardinality, filter1, filter2);\n     }\n \n@@ -74,23 +74,23 @@ public final void testAndCardinality() {\n     public final void testAndCardinalityWithDifferentLengthFilters() {\n         final Shape shape = Shape.fromKM(3, 128);\n         final Shape shape2 = Shape.fromKM(3, 192);\n-        BloomFilter filter1 = createFilter(shape, IndexProducer.fromIndexArray(1, 63, 64));\n-        BloomFilter filter2 = createFilter(shape2, IndexProducer.fromIndexArray(5, 64, 169));\n+        BloomFilter filter1 = createFilter(shape, IndexExtractor.fromIndexArray(1, 63, 64));\n+        BloomFilter filter2 = createFilter(shape2, IndexExtractor.fromIndexArray(5, 64, 169));\n         assertSymmetricOperation(1, SetOperations::andCardinality, filter1, filter2);\n \n-        filter1 = createFilter(shape, IndexProducer.fromIndexArray(1, 63));\n-        filter2 = createFilter(shape2, IndexProducer.fromIndexArray(5, 64, 169));\n+        filter1 = createFilter(shape, IndexExtractor.fromIndexArray(1, 63));\n+        filter2 = createFilter(shape2, IndexExtractor.fromIndexArray(5, 64, 169));\n         assertSymmetricOperation(0, SetOperations::andCardinality, filter1, filter2);\n \n-        filter1 = createFilter(shape, IndexProducer.fromIndexArray(5, 63));\n-        filter2 = createFilter(shape2, IndexProducer.fromIndexArray(5, 64, 169));\n+        filter1 = createFilter(shape, IndexExtractor.fromIndexArray(5, 63));\n+        filter2 = createFilter(shape2, IndexExtractor.fromIndexArray(5, 64, 169));\n         assertSymmetricOperation(1, SetOperations::andCardinality, filter1, filter2);\n     }\n \n     @Test\n     public final void testCommutativityOnMismatchedSizes() {\n-        final BitMapProducer p1 = BitMapProducer.fromBitMapArray(0x3L, 0x5L);\n-        final BitMapProducer p2 = BitMapProducer.fromBitMapArray(0x1L);\n+        final BitMapExtractor p1 = BitMapExtractor.fromBitMapArray(0x3L, 0x5L);\n+        final BitMapExtractor p2 = BitMapExtractor.fromBitMapArray(0x1L);\n \n         assertEquals(SetOperations.orCardinality(p1, p2), SetOperations.orCardinality(p2, p1));\n         assertEquals(SetOperations.xorCardinality(p1, p2), SetOperations.xorCardinality(p2, p1));\n@@ -256,16 +256,16 @@ public final void testJaccardSimilarity() {\n     @Test\n     public final void testOrCardinality() {\n         final Shape shape = Shape.fromKM(3, 128);\n-        BloomFilter filter1 = createFilter(shape, IndexProducer.fromIndexArray(1, 63, 64));\n-        BloomFilter filter2 = createFilter(shape, IndexProducer.fromIndexArray(5, 64, 69));\n+        BloomFilter filter1 = createFilter(shape, IndexExtractor.fromIndexArray(1, 63, 64));\n+        BloomFilter filter2 = createFilter(shape, IndexExtractor.fromIndexArray(5, 64, 69));\n         assertSymmetricOperation(5, SetOperations::orCardinality, filter1, filter2);\n \n-        filter1 = createFilter(shape, IndexProducer.fromIndexArray(1, 63));\n-        filter2 = createFilter(shape, IndexProducer.fromIndexArray(5, 64, 69));\n+        filter1 = createFilter(shape, IndexExtractor.fromIndexArray(1, 63));\n+        filter2 = createFilter(shape, IndexExtractor.fromIndexArray(5, 64, 69));\n         assertSymmetricOperation(5, SetOperations::orCardinality, filter1, filter2);\n \n-        filter1 = createFilter(shape, IndexProducer.fromIndexArray(5, 63));\n-        filter2 = createFilter(shape, IndexProducer.fromIndexArray(5, 64, 69));\n+        filter1 = createFilter(shape, IndexExtractor.fromIndexArray(5, 63));\n+        filter2 = createFilter(shape, IndexExtractor.fromIndexArray(5, 64, 69));\n         assertSymmetricOperation(4, SetOperations::orCardinality, filter1, filter2);\n     }\n \n@@ -273,37 +273,37 @@ public final void testOrCardinality() {\n     public final void testOrCardinalityWithDifferentLengthFilters() {\n         final Shape shape = Shape.fromKM(3, 128);\n         final Shape shape2 = Shape.fromKM(3, 192);\n-        BloomFilter filter1 = createFilter(shape, IndexProducer.fromIndexArray(1, 63, 64));\n-        BloomFilter filter2 = createFilter(shape2, IndexProducer.fromIndexArray(5, 64, 169));\n+        BloomFilter filter1 = createFilter(shape, IndexExtractor.fromIndexArray(1, 63, 64));\n+        BloomFilter filter2 = createFilter(shape2, IndexExtractor.fromIndexArray(5, 64, 169));\n         assertSymmetricOperation(5, SetOperations::orCardinality, filter1, filter2);\n \n-        filter1 = createFilter(shape, IndexProducer.fromIndexArray(1, 63));\n-        filter2 = createFilter(shape2, IndexProducer.fromIndexArray(5, 64, 169));\n+        filter1 = createFilter(shape, IndexExtractor.fromIndexArray(1, 63));\n+        filter2 = createFilter(shape2, IndexExtractor.fromIndexArray(5, 64, 169));\n         assertSymmetricOperation(5, SetOperations::orCardinality, filter1, filter2);\n \n-        filter1 = createFilter(shape, IndexProducer.fromIndexArray(5, 63));\n-        filter2 = createFilter(shape2, IndexProducer.fromIndexArray(5, 64, 169));\n+        filter1 = createFilter(shape, IndexExtractor.fromIndexArray(5, 63));\n+        filter2 = createFilter(shape2, IndexExtractor.fromIndexArray(5, 64, 169));\n         assertSymmetricOperation(4, SetOperations::orCardinality, filter1, filter2);\n     }\n \n     @Test\n     public final void testXorCardinality() {\n         final Shape shape = Shape.fromKM(3, 128);\n-        BloomFilter filter1 = createFilter(shape, IndexProducer.fromIndexArray(1, 63, 64));\n-        BloomFilter filter2 = createFilter(shape, IndexProducer.fromIndexArray(5, 64, 69));\n+        BloomFilter filter1 = createFilter(shape, IndexExtractor.fromIndexArray(1, 63, 64));\n+        BloomFilter filter2 = createFilter(shape, IndexExtractor.fromIndexArray(5, 64, 69));\n         assertSymmetricOperation(4, SetOperations::xorCardinality, filter1, filter2);\n \n-        filter1 = createFilter(shape, IndexProducer.fromIndexArray(1, 63));\n-        filter2 = createFilter(shape, IndexProducer.fromIndexArray(5, 64, 69));\n+        filter1 = createFilter(shape, IndexExtractor.fromIndexArray(1, 63));\n+        filter2 = createFilter(shape, IndexExtractor.fromIndexArray(5, 64, 69));\n         assertSymmetricOperation(5, SetOperations::xorCardinality, filter1, filter2);\n \n-        filter1 = createFilter(shape, IndexProducer.fromIndexArray(5, 63));\n-        filter2 = createFilter(shape, IndexProducer.fromIndexArray(5, 64, 69));\n+        filter1 = createFilter(shape, IndexExtractor.fromIndexArray(5, 63));\n+        filter2 = createFilter(shape, IndexExtractor.fromIndexArray(5, 64, 69));\n         assertSymmetricOperation(3, SetOperations::xorCardinality, filter1, filter2);\n \n         final Shape bigShape = Shape.fromKM(3, 192);\n-        filter1 = createFilter(bigShape, IndexProducer.fromIndexArray(1, 63, 185));\n-        filter2 = createFilter(shape, IndexProducer.fromIndexArray(5, 63, 69));\n+        filter1 = createFilter(bigShape, IndexExtractor.fromIndexArray(1, 63, 185));\n+        filter2 = createFilter(shape, IndexExtractor.fromIndexArray(5, 63, 69));\n         assertSymmetricOperation(4, SetOperations::xorCardinality, filter1, filter2);\n     }\n \n@@ -312,16 +312,16 @@ public final void testXorCardinalityWithDifferentLengthFilters() {\n         final Shape shape = Shape.fromKM(3, 128);\n         final Shape shape2 = Shape.fromKM(3, 192);\n \n-        BloomFilter filter1 = createFilter(shape, IndexProducer.fromIndexArray(1, 63, 64));\n-        BloomFilter filter2 = createFilter(shape2, IndexProducer.fromIndexArray(5, 64, 169));\n+        BloomFilter filter1 = createFilter(shape, IndexExtractor.fromIndexArray(1, 63, 64));\n+        BloomFilter filter2 = createFilter(shape2, IndexExtractor.fromIndexArray(5, 64, 169));\n         assertSymmetricOperation(4, SetOperations::xorCardinality, filter1, filter2);\n \n-        filter1 = createFilter(shape, IndexProducer.fromIndexArray(1, 63));\n-        filter2 = createFilter(shape2, IndexProducer.fromIndexArray(5, 64, 169));\n+        filter1 = createFilter(shape, IndexExtractor.fromIndexArray(1, 63));\n+        filter2 = createFilter(shape2, IndexExtractor.fromIndexArray(5, 64, 169));\n         assertSymmetricOperation(5, SetOperations::xorCardinality, filter1, filter2);\n \n-        filter1 = createFilter(shape, IndexProducer.fromIndexArray(5, 63));\n-        filter2 = createFilter(shape2, IndexProducer.fromIndexArray(5, 64, 169));\n+        filter1 = createFilter(shape, IndexExtractor.fromIndexArray(5, 63));\n+        filter2 = createFilter(shape2, IndexExtractor.fromIndexArray(5, 64, 169));\n         assertSymmetricOperation(3, SetOperations::xorCardinality, filter1, filter2);\n     }\n }\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/SimpleBloomFilterTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/SimpleBloomFilterTest.java\nindex 1552e9c763..5710a4ca13 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/SimpleBloomFilterTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/SimpleBloomFilterTest.java\n@@ -31,12 +31,12 @@ protected SimpleBloomFilter createEmptyFilter(final Shape shape) {\n     }\n \n     @Test\n-    public void testMergeShortBitMapProducer() {\n+    public void testMergeShortBitMapExtractor() {\n         final SimpleBloomFilter filter = createEmptyFilter(getTestShape());\n-        // create a producer that returns too few values\n+        // create a bitMapExtractor that returns too few values\n         // shape expects 2 longs we are sending 1.\n-        final BitMapProducer producer = p -> p.test(2L);\n-        assertTrue(filter.merge(producer));\n+        final BitMapExtractor bitMapExtractor = p -> p.test(2L);\n+        assertTrue(filter.merge(bitMapExtractor));\n         assertEquals(1, filter.cardinality());\n     }\n }\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/SparseBloomFilterTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/SparseBloomFilterTest.java\nindex aa9a4cd6db..eb5483dd91 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/SparseBloomFilterTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/SparseBloomFilterTest.java\n@@ -32,22 +32,22 @@ protected SparseBloomFilter createEmptyFilter(final Shape shape) {\n     }\n \n     @Test\n-    public void testBitMapProducerEdgeCases() {\n+    public void testBitMapExtractorEdgeCases() {\n         int[] values = {1, 2, 3, 4, 5, 6, 7, 8, 9, 65, 66, 67, 68, 69, 70, 71};\n-        BloomFilter bf = createFilter(getTestShape(), IndexProducer.fromIndexArray(values));\n+        BloomFilter bf = createFilter(getTestShape(), IndexExtractor.fromIndexArray(values));\n \n         // verify exit early before bitmap boundary\n         final int[] passes = new int[1];\n-        assertFalse(bf.forEachBitMap(l -> {\n+        assertFalse(bf.processBitMaps(l -> {\n             passes[0]++;\n             return false;\n         }));\n         assertEquals(1, passes[0]);\n \n         // verify exit early at bitmap boundary\n-        bf = createFilter(getTestShape(), IndexProducer.fromIndexArray(values));\n+        bf = createFilter(getTestShape(), IndexExtractor.fromIndexArray(values));\n         passes[0] = 0;\n-        assertFalse(bf.forEachBitMap(l -> {\n+        assertFalse(bf.processBitMaps(l -> {\n             final boolean result = passes[0] == 0;\n             if (result) {\n                 passes[0]++;\n@@ -58,9 +58,9 @@ public void testBitMapProducerEdgeCases() {\n \n         // verify add extra if all values in first bitmap\n         values = new int[] {1, 2, 3, 4};\n-        bf = createFilter(getTestShape(), IndexProducer.fromIndexArray(values));\n+        bf = createFilter(getTestShape(), IndexExtractor.fromIndexArray(values));\n         passes[0] = 0;\n-        assertTrue(bf.forEachBitMap(l -> {\n+        assertTrue(bf.processBitMaps(l -> {\n             passes[0]++;\n             return true;\n         }));\n@@ -69,9 +69,9 @@ public void testBitMapProducerEdgeCases() {\n         // verify exit early if all values in first bitmap and predicate returns false\n         // on 2nd block\n         values = new int[] {1, 2, 3, 4};\n-        bf = createFilter(getTestShape(), IndexProducer.fromIndexArray(values));\n+        bf = createFilter(getTestShape(), IndexExtractor.fromIndexArray(values));\n         passes[0] = 0;\n-        assertFalse(bf.forEachBitMap(l -> {\n+        assertFalse(bf.processBitMaps(l -> {\n             final boolean result = passes[0] == 0;\n             if (result) {\n                 passes[0]++;\n@@ -87,6 +87,6 @@ public void testBloomFilterBasedMergeEdgeCases() {\n         final BloomFilter bf2 = new SimpleBloomFilter(getTestShape());\n         bf2.merge(TestingHashers.FROM1);\n         bf1.merge(bf2);\n-        assertTrue(bf2.forEachBitMapPair(bf1, (x, y) -> x == y));\n+        assertTrue(bf2.processBitMapPairs(bf1, (x, y) -> x == y));\n     }\n }\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/TestingHashers.java b/src/test/java/org/apache/commons/collections4/bloomfilter/TestingHashers.java\nindex 78f95ace20..391444c54c 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/TestingHashers.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/TestingHashers.java\n@@ -75,7 +75,7 @@ public static <T extends BloomFilter> T populateFromHashersFrom1AndFrom11(final\n      * @return {@code filter} for chaining\n      */\n     public static <T extends BloomFilter> T populateRange(final T filter, final int start, final int end) {\n-        filter.merge((IndexProducer) p -> {\n+        filter.merge((IndexExtractor) p -> {\n             for (int i = start; i <= end; i++) {\n                 if (!p.test(i)) {\n                     return false;\n",
  "problem_statement" : "[COLLECTIONS-854] renaming bloomfilter components and methods as per ticket\n\nFixes the issues listed in COLLECTIONS-854 and as agreed in the dev discussions.\r\n\r\nOnly names and documentation changes are applied here with the following exceptions as noted in the 854 ticket.\r\n\r\n- Changed `forEachRemaining()` in `CountingLongPredicate` and `CountingPredicate` classes to `processRemaining()` to keep in spirit with Extractor usage.\r\n- Added missing `FunctionalInterface` annotation to `BloomFilterExtractor`.\r\n\r\n",
  "hints_text" : null,
  "created_at" : "Fri May 17 13:18:02 CEST 2024",
  "version" : null,
  "FAIL_TO_PASS" : [ "CountingPredicateTest", "AbstractHasherTest", "BitMapExtractorFromWrappedBloomFilterTest", "BloomFilterExtractorFromBloomFilterArrayTest", "CellProducerFromDefaultIndexProducerTest", "AbstractIndexProducerTest", "DefaultIndexProducerTest", "IndexExtractorFromUniqueHasherTest", "BitMapProducerFromSimpleBloomFilterTest", "CellExtractorFromArrayCountingBloomFilterTest", "IndexExtractorFromBitmapExtractorTest", "IndexExtractorFromHasherTest", "CellProducerFromLayeredBloomFilterTest", "CellExtractorFromDefaultIndexExtractorTest", "AbstractCellExtractorTest", "IndexExtractorFromSparseBloomFilterTest", "ArrayHasher", "BloomFilteExtractorFromLayeredBloomFilterTest", "CellExtractorFromLayeredBloomFilterTest", "IndexExtractorFromIntArrayTest", "DefaultCellExtractorTest", "AbstractBloomFilterExtractorTest", "BitMapProducerFromLongArrayTest", "BloomFilterProducerFromLayeredBloomFilterTest", "IndexProducerFromArrayCountingBloomFilterTest", "AbstractCountingBloomFilterTest", "BitMapExtractorFromLayeredBloomFilterTest", "BitMapProducerFromArrayCountingBloomFilterTest", "BitMapExtractorFromLongArrayTest", "BitMapExtractorFromArrayCountingBloomFilterTest", "AbstractBitMapExtractorTest", "DefaultBitMapExtractorTest", "AbstractCellProducerTest", "IncrementingHasher", "LayeredBloomFilterTest", "AbstractBloomFilterTest", "BitMapProducerFromSparseBloomFilterTest", "BitMapExtractorFromSparseBloomFilterTest", "IndexExtractorFromArrayCountingBloomFilterTest", "LayerManagerTest", "DefaultBloomFilterExtractorTest", "BitMapTest", "IndexProducerFromBitmapProducerTest", "IndexProducerFromSimpleBloomFilterTest", "BitMapExtractorFromSimpleBloomFilterTest", "BitMapProducerFromWrappedBloomFilterTest", "BitMapExtractorFromIndexExtractorTest", "DefaultBloomFilterProducerTest", "AbstractIndexExtractorTest", "DefaultIndexExtractorTest", "BitMapProducerFromIndexProducerTest", "DefaultCellProducerTest", "IndexProducerFromHasherTest", "IndexProducerFromUniqueHasherTest", "TestingHashers", "AbstractBitMapProducerTest", "DefaultBitMapProducerTest", "DefaultBloomFilterTest", "IndexProducerFromSparseBloomFilterTest", "IndexProducerFromIntArrayTest", "IndexProducerTest", "NullHasher", "SparseBloomFilterTest", "IndexExtractorFromSimpleBloomFilterTest", "SetOperationsTest", "IndexExtractorTest", "BloomFilterProducerFromBloomFilterArrayTest", "AbstractBloomFilterProducerTest", "BitMapProducerFromLayeredBloomFilterTest", "CellProducerFromArrayCountingBloomFilterTest", "SimpleBloomFilterTest", "BitMapsTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=CountingPredicateTest,AbstractHasherTest,BitMapExtractorFromWrappedBloomFilterTest,BloomFilterExtractorFromBloomFilterArrayTest,CellProducerFromDefaultIndexProducerTest,AbstractIndexProducerTest,DefaultIndexProducerTest,IndexExtractorFromUniqueHasherTest,BitMapProducerFromSimpleBloomFilterTest,CellExtractorFromArrayCountingBloomFilterTest,IndexExtractorFromBitmapExtractorTest,IndexExtractorFromHasherTest,CellProducerFromLayeredBloomFilterTest,CellExtractorFromDefaultIndexExtractorTest,AbstractCellExtractorTest,IndexExtractorFromSparseBloomFilterTest,ArrayHasher,BloomFilteExtractorFromLayeredBloomFilterTest,CellExtractorFromLayeredBloomFilterTest,IndexExtractorFromIntArrayTest,DefaultCellExtractorTest,AbstractBloomFilterExtractorTest,BitMapProducerFromLongArrayTest,BloomFilterProducerFromLayeredBloomFilterTest,IndexProducerFromArrayCountingBloomFilterTest,AbstractCountingBloomFilterTest,BitMapExtractorFromLayeredBloomFilterTest,BitMapProducerFromArrayCountingBloomFilterTest,BitMapExtractorFromLongArrayTest,BitMapExtractorFromArrayCountingBloomFilterTest,AbstractBitMapExtractorTest,DefaultBitMapExtractorTest,AbstractCellProducerTest,IncrementingHasher,LayeredBloomFilterTest,AbstractBloomFilterTest,BitMapProducerFromSparseBloomFilterTest,BitMapExtractorFromSparseBloomFilterTest,IndexExtractorFromArrayCountingBloomFilterTest,LayerManagerTest,DefaultBloomFilterExtractorTest,BitMapTest,IndexProducerFromBitmapProducerTest,IndexProducerFromSimpleBloomFilterTest,BitMapExtractorFromSimpleBloomFilterTest,BitMapProducerFromWrappedBloomFilterTest,BitMapExtractorFromIndexExtractorTest,DefaultBloomFilterProducerTest,AbstractIndexExtractorTest,DefaultIndexExtractorTest,BitMapProducerFromIndexProducerTest,DefaultCellProducerTest,IndexProducerFromHasherTest,IndexProducerFromUniqueHasherTest,TestingHashers,AbstractBitMapProducerTest,DefaultBitMapProducerTest,DefaultBloomFilterTest,IndexProducerFromSparseBloomFilterTest,IndexProducerFromIntArrayTest,IndexProducerTest,NullHasher,SparseBloomFilterTest,IndexExtractorFromSimpleBloomFilterTest,SetOperationsTest,IndexExtractorTest,BloomFilterProducerFromBloomFilterArrayTest,AbstractBloomFilterProducerTest,BitMapProducerFromLayeredBloomFilterTest,CellProducerFromArrayCountingBloomFilterTest,SimpleBloomFilterTest,BitMapsTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 492,
  "metadata" : null
}, {
  "instance_id" : "apache-commons-collections-PR-485",
  "repo" : "apache/commons-collections",
  "base_commit" : "1dc530e6fa2e0c87e9bf1f377834312169a5fc3f",
  "patch" : "diff --git a/src/main/java/org/apache/commons/collections4/list/AbstractLinkedList.java b/src/main/java/org/apache/commons/collections4/list/AbstractLinkedList.java\nindex aecb2e9482..1d66a792fa 100644\n--- a/src/main/java/org/apache/commons/collections4/list/AbstractLinkedList.java\n+++ b/src/main/java/org/apache/commons/collections4/list/AbstractLinkedList.java\n@@ -43,7 +43,9 @@\n  *\n  * @param <E> the type of elements in this list\n  * @since 3.0\n+ * @deprecated use {@link AbstractLinkedListForJava21} instead\n  */\n+@Deprecated\n public abstract class AbstractLinkedList<E> implements List<E> {\n \n     /*\ndiff --git a/src/main/java/org/apache/commons/collections4/list/AbstractLinkedListForJava21.java b/src/main/java/org/apache/commons/collections4/list/AbstractLinkedListForJava21.java\nnew file mode 100644\nindex 0000000000..b6563597db\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/list/AbstractLinkedListForJava21.java\n@@ -0,0 +1,1079 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.list;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.lang.reflect.Array;\n+import java.util.AbstractList;\n+import java.util.Collection;\n+import java.util.ConcurrentModificationException;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.NoSuchElementException;\n+import java.util.Objects;\n+\n+import org.apache.commons.collections4.CollectionUtils;\n+import org.apache.commons.collections4.OrderedIterator;\n+\n+/**\n+ * An abstract implementation of a linked list which provides numerous points for\n+ * subclasses to override.\n+ * <p>\n+ * Overridable methods are provided to change the storage node and to change how\n+ * nodes are added to and removed. Hopefully, all you need for unusual subclasses\n+ * is here.\n+ * <p>\n+ * This is a copy of AbstractLinkedList, modified to be compatible with Java 21\n+ * (see COLLECTIONS-842 for details).\n+ *\n+ * @param <E> the type of elements in this list\n+ * @since 3.0\n+ */\n+public abstract class AbstractLinkedListForJava21<E> implements List<E> {\n+\n+    /*\n+     * Implementation notes:\n+     * - a standard circular doubly-linked list\n+     * - a marker node is stored to mark the start and the end of the list\n+     * - node creation and removal always occurs through createNode() and\n+     *   removeNode().\n+     * - a modification count is kept, with the same semantics as\n+     * {@link java.util.LinkedList}.\n+     * - respects {@link AbstractList#modCount}\n+     */\n+\n+    /**\n+     * A list iterator over the linked list.\n+     *\n+     * @param <E> the type of elements in this iterator.\n+     */\n+    protected static class LinkedListIterator<E> implements ListIterator<E>, OrderedIterator<E> {\n+\n+        /** The parent list */\n+        protected final AbstractLinkedListForJava21<E> parent;\n+\n+        /**\n+         * The node that will be returned by {@link #next()}. If this is equal\n+         * to {@link AbstractLinkedListForJava21#header} then there are no more values to return.\n+         */\n+        protected Node<E> next;\n+\n+        /**\n+         * The index of {@link #next}.\n+         */\n+        protected int nextIndex;\n+\n+        /**\n+         * The last node that was returned by {@link #next()} or {@link\n+         * #previous()}. Set to {@code null} if {@link #next()} or {@link\n+         * #previous()} haven't been called, or if the node has been removed\n+         * with {@link #remove()} or a new node added with {@link #add(Object)}.\n+         * Should be accessed through {@link #getLastNodeReturned()} to enforce\n+         * this behavior.\n+         */\n+        protected Node<E> current;\n+\n+        /**\n+         * The modification count that the list is expected to have. If the list\n+         * doesn't have this count, then a\n+         * {@link java.util.ConcurrentModificationException} may be thrown by\n+         * the operations.\n+         */\n+        protected int expectedModCount;\n+\n+        /**\n+         * Create a ListIterator for a list.\n+         *\n+         * @param parent  the parent list\n+         * @param fromIndex  the index to start at\n+         * @throws IndexOutOfBoundsException if fromIndex is less than 0 or greater than the size of the list\n+         */\n+        protected LinkedListIterator(final AbstractLinkedListForJava21<E> parent, final int fromIndex)\n+                throws IndexOutOfBoundsException {\n+            this.parent = parent;\n+            this.expectedModCount = parent.modCount;\n+            this.next = parent.getNode(fromIndex, true);\n+            this.nextIndex = fromIndex;\n+        }\n+\n+        @Override\n+        public void add(final E obj) {\n+            checkModCount();\n+            parent.addNodeBefore(next, obj);\n+            current = null;\n+            nextIndex++;\n+            expectedModCount++;\n+        }\n+\n+        /**\n+         * Checks the modification count of the list is the value that this\n+         * object expects.\n+         *\n+         * @throws ConcurrentModificationException If the list's modification\n+         * count isn't the value that was expected.\n+         */\n+        protected void checkModCount() {\n+            if (parent.modCount != expectedModCount) {\n+                throw new ConcurrentModificationException();\n+            }\n+        }\n+\n+        /**\n+         * Gets the last node returned.\n+         *\n+         * @return the last node returned\n+         * @throws IllegalStateException If {@link #next()} or {@link #previous()} haven't been called,\n+         * or if the node has been removed with {@link #remove()} or a new node added with {@link #add(Object)}.\n+         */\n+        protected Node<E> getLastNodeReturned() throws IllegalStateException {\n+            if (current == null) {\n+                throw new IllegalStateException();\n+            }\n+            return current;\n+        }\n+\n+        @Override\n+        public boolean hasNext() {\n+            return next != parent.header;\n+        }\n+\n+        @Override\n+        public boolean hasPrevious() {\n+            return next.previous != parent.header;\n+        }\n+\n+        @Override\n+        public E next() {\n+            checkModCount();\n+            if (!hasNext()) {\n+                throw new NoSuchElementException(\"No element at index \" + nextIndex + \".\");\n+            }\n+            final E value = next.getValue();\n+            current = next;\n+            next = next.next;\n+            nextIndex++;\n+            return value;\n+        }\n+\n+        @Override\n+        public int nextIndex() {\n+            return nextIndex;\n+        }\n+\n+        @Override\n+        public E previous() {\n+            checkModCount();\n+            if (!hasPrevious()) {\n+                throw new NoSuchElementException(\"Already at start of list.\");\n+            }\n+            next = next.previous;\n+            final E value = next.getValue();\n+            current = next;\n+            nextIndex--;\n+            return value;\n+        }\n+\n+        @Override\n+        public int previousIndex() {\n+            // not normally overridden, as relative to nextIndex()\n+            return nextIndex() - 1;\n+        }\n+\n+        @Override\n+        public void remove() {\n+            checkModCount();\n+            if (current == next) {\n+                // remove() following previous()\n+                next = next.next;\n+                parent.removeNode(getLastNodeReturned());\n+            } else {\n+                // remove() following next()\n+                parent.removeNode(getLastNodeReturned());\n+                nextIndex--;\n+            }\n+            current = null;\n+            expectedModCount++;\n+        }\n+\n+        @Override\n+        public void set(final E obj) {\n+            checkModCount();\n+            getLastNodeReturned().setValue(obj);\n+        }\n+\n+    }\n+\n+    /**\n+     * The sublist implementation for AbstractLinkedListForJava21.\n+     *\n+     * @param <E> the type of elements in this list.\n+     */\n+    protected static class LinkedSubList<E> extends AbstractList<E> {\n+        /** The main list */\n+        AbstractLinkedListForJava21<E> parent;\n+        /** Offset from the main list */\n+        int offset;\n+        /** Sublist size */\n+        int size;\n+        /** Sublist modCount */\n+        int expectedModCount;\n+\n+        protected LinkedSubList(final AbstractLinkedListForJava21<E> parent, final int fromIndex, final int toIndex) {\n+            if (fromIndex < 0) {\n+                throw new IndexOutOfBoundsException(\"fromIndex = \" + fromIndex);\n+            }\n+            if (toIndex > parent.size()) {\n+                throw new IndexOutOfBoundsException(\"toIndex = \" + toIndex);\n+            }\n+            if (fromIndex > toIndex) {\n+                throw new IllegalArgumentException(\"fromIndex(\" + fromIndex + \") > toIndex(\" + toIndex + \")\");\n+            }\n+            this.parent = parent;\n+            this.offset = fromIndex;\n+            this.size = toIndex - fromIndex;\n+            this.expectedModCount = parent.modCount;\n+        }\n+\n+        @Override\n+        public void add(final int index, final E obj) {\n+            rangeCheck(index, size + 1);\n+            checkModCount();\n+            parent.add(index + offset, obj);\n+            expectedModCount = parent.modCount;\n+            size++;\n+            modCount++;\n+        }\n+\n+        @Override\n+        public boolean addAll(final Collection<? extends E> coll) {\n+            return addAll(size, coll);\n+        }\n+\n+        @Override\n+        public boolean addAll(final int index, final Collection<? extends E> coll) {\n+            rangeCheck(index, size + 1);\n+            final int cSize = coll.size();\n+            if (cSize == 0) {\n+                return false;\n+            }\n+\n+            checkModCount();\n+            parent.addAll(offset + index, coll);\n+            expectedModCount = parent.modCount;\n+            size += cSize;\n+            modCount++;\n+            return true;\n+        }\n+\n+        protected void checkModCount() {\n+            if (parent.modCount != expectedModCount) {\n+                throw new ConcurrentModificationException();\n+            }\n+        }\n+\n+        @Override\n+        public void clear() {\n+            checkModCount();\n+            final Iterator<E> it = iterator();\n+            while (it.hasNext()) {\n+                it.next();\n+                it.remove();\n+            }\n+        }\n+\n+        @Override\n+        public E get(final int index) {\n+            rangeCheck(index, size);\n+            checkModCount();\n+            return parent.get(index + offset);\n+        }\n+\n+        @Override\n+        public Iterator<E> iterator() {\n+            checkModCount();\n+            return parent.createSubListIterator(this);\n+        }\n+\n+        @Override\n+        public ListIterator<E> listIterator(final int index) {\n+            rangeCheck(index, size + 1);\n+            checkModCount();\n+            return parent.createSubListListIterator(this, index);\n+        }\n+\n+        protected void rangeCheck(final int index, final int beyond) {\n+            if (index < 0 || index >= beyond) {\n+                throw new IndexOutOfBoundsException(\"Index '\" + index + \"' out of bounds for size '\" + size + \"'\");\n+            }\n+        }\n+\n+        @Override\n+        public E remove(final int index) {\n+            rangeCheck(index, size);\n+            checkModCount();\n+            final E result = parent.remove(index + offset);\n+            expectedModCount = parent.modCount;\n+            size--;\n+            modCount++;\n+            return result;\n+        }\n+\n+        @Override\n+        public E set(final int index, final E obj) {\n+            rangeCheck(index, size);\n+            checkModCount();\n+            return parent.set(index + offset, obj);\n+        }\n+\n+        @Override\n+        public int size() {\n+            checkModCount();\n+            return size;\n+        }\n+\n+        @Override\n+        public List<E> subList(final int fromIndexInclusive, final int toIndexExclusive) {\n+            return new LinkedSubList<>(parent, fromIndexInclusive + offset, toIndexExclusive + offset);\n+        }\n+    }\n+\n+    /**\n+     * A list iterator over the linked sub list.\n+     *\n+     * @param <E> the type of elements in this iterator.\n+     */\n+    protected static class LinkedSubListIterator<E> extends LinkedListIterator<E> {\n+\n+        /** The sub list */\n+        protected final LinkedSubList<E> sub;\n+\n+        protected LinkedSubListIterator(final LinkedSubList<E> sub, final int startIndex) {\n+            super(sub.parent, startIndex + sub.offset);\n+            this.sub = sub;\n+        }\n+\n+        @Override\n+        public void add(final E obj) {\n+            super.add(obj);\n+            sub.expectedModCount = parent.modCount;\n+            sub.size++;\n+        }\n+\n+        @Override\n+        public boolean hasNext() {\n+            return nextIndex() < sub.size;\n+        }\n+\n+        @Override\n+        public boolean hasPrevious() {\n+            return previousIndex() >= 0;\n+        }\n+\n+        @Override\n+        public int nextIndex() {\n+            return super.nextIndex() - sub.offset;\n+        }\n+\n+        @Override\n+        public void remove() {\n+            super.remove();\n+            sub.expectedModCount = parent.modCount;\n+            sub.size--;\n+        }\n+    }\n+\n+    /**\n+     * A node within the linked list.\n+     * <p>\n+     * From Commons Collections 3.1, all access to the {@code value} property\n+     * is via the methods on this class.\n+     */\n+    protected static class Node<E> {\n+\n+        /** A pointer to the node before this node */\n+        protected Node<E> previous;\n+        /** A pointer to the node after this node */\n+        protected Node<E> next;\n+        /** The object contained within this node */\n+        protected E value;\n+\n+        /**\n+         * Constructs a new header node.\n+         */\n+        protected Node() {\n+            previous = this;\n+            next = this;\n+        }\n+\n+        /**\n+         * Constructs a new node.\n+         *\n+         * @param value  the value to store\n+         */\n+        protected Node(final E value) {\n+            this.value = value;\n+        }\n+\n+        /**\n+         * Constructs a new node.\n+         *\n+         * @param previous  the previous node in the list\n+         * @param next  the next node in the list\n+         * @param value  the value to store\n+         */\n+        protected Node(final Node<E> previous, final Node<E> next, final E value) {\n+            this.previous = previous;\n+            this.next = next;\n+            this.value = value;\n+        }\n+\n+        /**\n+         * Gets the next node.\n+         *\n+         * @return the next node\n+         * @since 3.1\n+         */\n+        protected Node<E> getNextNode() {\n+            return next;\n+        }\n+\n+        /**\n+         * Gets the previous node.\n+         *\n+         * @return the previous node\n+         * @since 3.1\n+         */\n+        protected Node<E> getPreviousNode() {\n+            return previous;\n+        }\n+\n+        /**\n+         * Gets the value of the node.\n+         *\n+         * @return the value\n+         * @since 3.1\n+         */\n+        protected E getValue() {\n+            return value;\n+        }\n+\n+        /**\n+         * Sets the next node.\n+         *\n+         * @param next  the next node\n+         * @since 3.1\n+         */\n+        protected void setNextNode(final Node<E> next) {\n+            this.next = next;\n+        }\n+\n+        /**\n+         * Sets the previous node.\n+         *\n+         * @param previous  the previous node\n+         * @since 3.1\n+         */\n+        protected void setPreviousNode(final Node<E> previous) {\n+            this.previous = previous;\n+        }\n+\n+        /**\n+         * Sets the value of the node.\n+         *\n+         * @param value  the value\n+         * @since 3.1\n+         */\n+        protected void setValue(final E value) {\n+            this.value = value;\n+        }\n+    }\n+\n+    /**\n+     * A {@link Node} which indicates the start and end of the list and does not\n+     * hold a value. The value of {@code next} is the first item in the\n+     * list. The value of {@code previous} is the last item in the list.\n+     */\n+    transient Node<E> header;\n+\n+    /** The size of the list */\n+    transient int size;\n+\n+    /** Modification count for iterators */\n+    transient int modCount;\n+\n+    /**\n+     * Constructor that does nothing (intended for deserialization).\n+     * <p>\n+     * If this constructor is used by a serializable subclass then the init()\n+     * method must be called.\n+     */\n+    protected AbstractLinkedListForJava21() {\n+    }\n+\n+    /**\n+     * Constructs a list copying data from the specified collection.\n+     *\n+     * @param coll  the collection to copy\n+     */\n+    protected AbstractLinkedListForJava21(final Collection<? extends E> coll) {\n+        init();\n+        addAll(coll);\n+    }\n+\n+    @Override\n+    public boolean add(final E value) {\n+        addLast(value);\n+        return true;\n+    }\n+\n+    @Override\n+    public void add(final int index, final E value) {\n+        final Node<E> node = getNode(index, true);\n+        addNodeBefore(node, value);\n+    }\n+\n+    @Override\n+    public boolean addAll(final Collection<? extends E> coll) {\n+        return addAll(size, coll);\n+    }\n+\n+    @Override\n+    public boolean addAll(final int index, final Collection<? extends E> coll) {\n+        final Node<E> node = getNode(index, true);\n+        for (final E e : coll) {\n+            addNodeBefore(node, e);\n+        }\n+        return true;\n+    }\n+\n+    public void addFirst(final E o) {\n+        addNodeAfter(header, o);\n+    }\n+\n+    public void addLast(final E o) {\n+        addNodeBefore(header, o);\n+    }\n+\n+    /**\n+     * Inserts a new node into the list.\n+     *\n+     * @param nodeToInsert  new node to insert\n+     * @param insertBeforeNode  node to insert before\n+     * @throws NullPointerException if either node is null\n+     */\n+    protected void addNode(final Node<E> nodeToInsert, final Node<E> insertBeforeNode) {\n+        Objects.requireNonNull(nodeToInsert, \"nodeToInsert\");\n+        Objects.requireNonNull(insertBeforeNode, \"insertBeforeNode\");\n+        nodeToInsert.next = insertBeforeNode;\n+        nodeToInsert.previous = insertBeforeNode.previous;\n+        insertBeforeNode.previous.next = nodeToInsert;\n+        insertBeforeNode.previous = nodeToInsert;\n+        size++;\n+        modCount++;\n+    }\n+\n+    /**\n+     * Creates a new node with the specified object as its\n+     * {@code value} and inserts it after {@code node}.\n+     * <p>\n+     * This implementation uses {@link #createNode(Object)} and\n+     * {@link #addNode(AbstractLinkedListForJava21.Node,AbstractLinkedListForJava21.Node)}.\n+     *\n+     * @param node  node to insert after\n+     * @param value  value of the newly added node\n+     * @throws NullPointerException if {@code node} is null\n+     */\n+    protected void addNodeAfter(final Node<E> node, final E value) {\n+        final Node<E> newNode = createNode(value);\n+        addNode(newNode, node.next);\n+    }\n+\n+    /**\n+     * Creates a new node with the specified object as its\n+     * {@code value} and inserts it before {@code node}.\n+     * <p>\n+     * This implementation uses {@link #createNode(Object)} and\n+     * {@link #addNode(AbstractLinkedListForJava21.Node,AbstractLinkedListForJava21.Node)}.\n+     *\n+     * @param node  node to insert before\n+     * @param value  value of the newly added node\n+     * @throws NullPointerException if {@code node} is null\n+     */\n+    protected void addNodeBefore(final Node<E> node, final E value) {\n+        final Node<E> newNode = createNode(value);\n+        addNode(newNode, node);\n+    }\n+\n+    @Override\n+    public void clear() {\n+        removeAllNodes();\n+    }\n+\n+    @Override\n+    public boolean contains(final Object value) {\n+        return indexOf(value) != -1;\n+    }\n+\n+    @Override\n+    public boolean containsAll(final Collection<?> coll) {\n+        for (final Object o : coll) {\n+            if (!contains(o)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Creates a new node with previous, next and element all set to null.\n+     * This implementation creates a new empty Node.\n+     * Subclasses can override this to create a different class.\n+     *\n+     * @return  newly created node\n+     */\n+    protected Node<E> createHeaderNode() {\n+        return new Node<>();\n+    }\n+\n+    /**\n+     * Creates a new node with the specified properties.\n+     * This implementation creates a new Node with data.\n+     * Subclasses can override this to create a different class.\n+     *\n+     * @param value  value of the new node\n+     * @return a new node containing the value\n+     */\n+    protected Node<E> createNode(final E value) {\n+        return new Node<>(value);\n+    }\n+\n+    /**\n+     * Creates an iterator for the sublist.\n+     *\n+     * @param subList  the sublist to get an iterator for\n+     * @return a new iterator on the given sublist\n+     */\n+    protected Iterator<E> createSubListIterator(final LinkedSubList<E> subList) {\n+        return createSubListListIterator(subList, 0);\n+    }\n+\n+    /**\n+     * Creates a list iterator for the sublist.\n+     *\n+     * @param subList  the sublist to get an iterator for\n+     * @param fromIndex  the index to start from, relative to the sublist\n+     * @return a new list iterator on the given sublist\n+     */\n+    protected ListIterator<E> createSubListListIterator(final LinkedSubList<E> subList, final int fromIndex) {\n+        return new LinkedSubListIterator<>(subList, fromIndex);\n+    }\n+\n+    /**\n+     * Deserializes the data held in this object to the stream specified.\n+     * <p>\n+     * The first serializable subclass must call this method from\n+     * {@code readObject}.\n+     *\n+     * @param inputStream  the stream to read the object from\n+     * @throws IOException  if any error occurs while reading from the stream\n+     * @throws ClassNotFoundException  if a class read from the stream can not be loaded\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    protected void doReadObject(final ObjectInputStream inputStream) throws IOException, ClassNotFoundException {\n+        init();\n+        final int size = inputStream.readInt();\n+        for (int i = 0; i < size; i++) {\n+            add((E) inputStream.readObject());\n+        }\n+    }\n+\n+    /**\n+     * Serializes the data held in this object to the stream specified.\n+     * <p>\n+     * The first serializable subclass must call this method from\n+     * {@code writeObject}.\n+     *\n+     * @param outputStream  the stream to write the object to\n+     * @throws IOException  if anything goes wrong\n+     */\n+    protected void doWriteObject(final ObjectOutputStream outputStream) throws IOException {\n+        // Write the size so we know how many nodes to read back\n+        outputStream.writeInt(size());\n+        for (final E e : this) {\n+            outputStream.writeObject(e);\n+        }\n+    }\n+\n+    @Override\n+    public boolean equals(final Object obj) {\n+        if (obj == this) {\n+            return true;\n+        }\n+        if (!(obj instanceof List)) {\n+            return false;\n+        }\n+        final List<?> other = (List<?>) obj;\n+        if (other.size() != size()) {\n+            return false;\n+        }\n+        final ListIterator<?> it1 = listIterator();\n+        final ListIterator<?> it2 = other.listIterator();\n+        while (it1.hasNext() && it2.hasNext()) {\n+            if (!Objects.equals(it1.next(), it2.next())) {\n+                return false;\n+            }\n+        }\n+        return !(it1.hasNext() || it2.hasNext());\n+    }\n+\n+    @Override\n+    public E get(final int index) {\n+        final Node<E> node = getNode(index, false);\n+        return node.getValue();\n+    }\n+\n+    public E getFirst() {\n+        final Node<E> node = header.next;\n+        if (node == header) {\n+            throw new NoSuchElementException();\n+        }\n+        return node.getValue();\n+    }\n+\n+    public E getLast() {\n+        final Node<E> node = header.previous;\n+        if (node == header) {\n+            throw new NoSuchElementException();\n+        }\n+        return node.getValue();\n+    }\n+\n+    /**\n+     * Gets the node at a particular index.\n+     *\n+     * @param index  the index, starting from 0\n+     * @param endMarkerAllowed  whether or not the end marker can be returned if\n+     * startIndex is set to the list's size\n+     * @return the node at the given index\n+     * @throws IndexOutOfBoundsException if the index is less than 0; equal to\n+     * the size of the list and endMakerAllowed is false; or greater than the\n+     * size of the list\n+     */\n+    protected Node<E> getNode(final int index, final boolean endMarkerAllowed) throws IndexOutOfBoundsException {\n+        // Check the index is within the bounds\n+        if (index < 0) {\n+            throw new IndexOutOfBoundsException(\"Couldn't get the node: \" +\n+                    \"index (\" + index + \") less than zero.\");\n+        }\n+        if (!endMarkerAllowed && index == size) {\n+            throw new IndexOutOfBoundsException(\"Couldn't get the node: \" +\n+                    \"index (\" + index + \") is the size of the list.\");\n+        }\n+        if (index > size) {\n+            throw new IndexOutOfBoundsException(\"Couldn't get the node: \" +\n+                    \"index (\" + index + \") greater than the size of the \" +\n+                    \"list (\" + size + \").\");\n+        }\n+        // Search the list and get the node\n+        Node<E> node;\n+        if (index < size / 2) {\n+            // Search forwards\n+            node = header.next;\n+            for (int currentIndex = 0; currentIndex < index; currentIndex++) {\n+                node = node.next;\n+            }\n+        } else {\n+            // Search backwards\n+            node = header;\n+            for (int currentIndex = size; currentIndex > index; currentIndex--) {\n+                node = node.previous;\n+            }\n+        }\n+        return node;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        int hashCode = 1;\n+        for (final E e : this) {\n+            hashCode = 31 * hashCode + (e == null ? 0 : e.hashCode());\n+        }\n+        return hashCode;\n+    }\n+\n+    @Override\n+    public int indexOf(final Object value) {\n+        int i = 0;\n+        for (Node<E> node = header.next; node != header; node = node.next) {\n+            if (isEqualValue(node.getValue(), value)) {\n+                return i;\n+            }\n+            i++;\n+        }\n+        return CollectionUtils.INDEX_NOT_FOUND;\n+    }\n+\n+    /**\n+     * The equivalent of a default constructor, broken out so it can be called\n+     * by any constructor and by {@code readObject}.\n+     * Subclasses which override this method should make sure they call super,\n+     * so the list is initialized properly.\n+     */\n+    protected void init() {\n+        header = createHeaderNode();\n+    }\n+\n+    @Override\n+    public boolean isEmpty() {\n+        return size() == 0;\n+    }\n+\n+    /**\n+     * Compares two values for equals.\n+     * This implementation uses the equals method.\n+     * Subclasses can override this to match differently.\n+     *\n+     * @param value1  the first value to compare, may be null\n+     * @param value2  the second value to compare, may be null\n+     * @return true if equal\n+     */\n+    protected boolean isEqualValue(final Object value1, final Object value2) {\n+        return Objects.equals(value1, value2);\n+    }\n+\n+    @Override\n+    public Iterator<E> iterator() {\n+        return listIterator();\n+    }\n+\n+    @Override\n+    public int lastIndexOf(final Object value) {\n+        int i = size - 1;\n+        for (Node<E> node = header.previous; node != header; node = node.previous) {\n+            if (isEqualValue(node.getValue(), value)) {\n+                return i;\n+            }\n+            i--;\n+        }\n+        return CollectionUtils.INDEX_NOT_FOUND;\n+    }\n+\n+    @Override\n+    public ListIterator<E> listIterator() {\n+        return new LinkedListIterator<>(this, 0);\n+    }\n+\n+    @Override\n+    public ListIterator<E> listIterator(final int fromIndex) {\n+        return new LinkedListIterator<>(this, fromIndex);\n+    }\n+\n+    @Override\n+    public E remove(final int index) {\n+        final Node<E> node = getNode(index, false);\n+        final E oldValue = node.getValue();\n+        removeNode(node);\n+        return oldValue;\n+    }\n+\n+    @Override\n+    public boolean remove(final Object value) {\n+        for (Node<E> node = header.next; node != header; node = node.next) {\n+            if (isEqualValue(node.getValue(), value)) {\n+                removeNode(node);\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * <p>\n+     * This implementation iterates over the elements of this list, checking each element in\n+     * turn to see if it's contained in {@code coll}. If it's contained, it's removed\n+     * from this list. As a consequence, it is advised to use a collection type for\n+     * {@code coll} that provides a fast (e.g. O(1)) implementation of\n+     * {@link Collection#contains(Object)}.\n+     */\n+    @Override\n+    public boolean removeAll(final Collection<?> coll) {\n+        boolean modified = false;\n+        final Iterator<E> it = iterator();\n+        while (it.hasNext()) {\n+            if (coll.contains(it.next())) {\n+                it.remove();\n+                modified = true;\n+            }\n+        }\n+        return modified;\n+    }\n+\n+    /**\n+     * Removes all nodes by resetting the circular list marker.\n+     */\n+    protected void removeAllNodes() {\n+        header.next = header;\n+        header.previous = header;\n+        size = 0;\n+        modCount++;\n+    }\n+\n+    public E removeFirst() {\n+        final Node<E> node = header.next;\n+        if (node == header) {\n+            throw new NoSuchElementException();\n+        }\n+        final E oldValue = node.getValue();\n+        removeNode(node);\n+        return oldValue;\n+    }\n+\n+    public E removeLast() {\n+        final Node<E> node = header.previous;\n+        if (node == header) {\n+            throw new NoSuchElementException();\n+        }\n+        final E oldValue = node.getValue();\n+        removeNode(node);\n+        return oldValue;\n+    }\n+\n+    /**\n+     * Removes the specified node from the list.\n+     *\n+     * @param node  the node to remove\n+     * @throws NullPointerException if {@code node} is null\n+     */\n+    protected void removeNode(final Node<E> node) {\n+        Objects.requireNonNull(node, \"node\");\n+        node.previous.next = node.next;\n+        node.next.previous = node.previous;\n+        size--;\n+        modCount++;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * <p>\n+     * This implementation iterates over the elements of this list, checking each element in\n+     * turn to see if it's contained in {@code coll}. If it's not contained, it's removed\n+     * from this list. As a consequence, it is advised to use a collection type for\n+     * {@code coll} that provides a fast (e.g. O(1)) implementation of\n+     * {@link Collection#contains(Object)}.\n+     */\n+    @Override\n+    public boolean retainAll(final Collection<?> coll) {\n+        boolean modified = false;\n+        final Iterator<E> it = iterator();\n+        while (it.hasNext()) {\n+            if (!coll.contains(it.next())) {\n+                it.remove();\n+                modified = true;\n+            }\n+        }\n+        return modified;\n+    }\n+\n+    @Override\n+    public E set(final int index, final E value) {\n+        final Node<E> node = getNode(index, false);\n+        final E oldValue = node.getValue();\n+        updateNode(node, value);\n+        return oldValue;\n+    }\n+\n+    @Override\n+    public int size() {\n+        return size;\n+    }\n+\n+    /**\n+     * Gets a sublist of the main list.\n+     *\n+     * @param fromIndexInclusive  the index to start from\n+     * @param toIndexExclusive  the index to end at\n+     * @return the new sublist\n+     */\n+    @Override\n+    public List<E> subList(final int fromIndexInclusive, final int toIndexExclusive) {\n+        return new LinkedSubList<>(this, fromIndexInclusive, toIndexExclusive);\n+    }\n+\n+    @Override\n+    public Object[] toArray() {\n+        return toArray(new Object[size]);\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public <T> T[] toArray(T[] array) {\n+        // Extend the array if needed\n+        if (array.length < size) {\n+            final Class<?> componentType = array.getClass().getComponentType();\n+            array = (T[]) Array.newInstance(componentType, size);\n+        }\n+        // Copy the values into the array\n+        int i = 0;\n+        for (Node<E> node = header.next; node != header; node = node.next, i++) {\n+            array[i] = (T) node.getValue();\n+        }\n+        // Set the value after the last value to null\n+        if (array.length > size) {\n+            array[size] = null;\n+        }\n+        return array;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        if (isEmpty()) {\n+            return \"[]\";\n+        }\n+        final StringBuilder buf = new StringBuilder(16 * size());\n+        buf.append(CollectionUtils.DEFAULT_TOSTRING_PREFIX);\n+\n+        final Iterator<E> it = iterator();\n+        boolean hasNext = it.hasNext();\n+        while (hasNext) {\n+            final Object value = it.next();\n+            buf.append(value == this ? \"(this Collection)\" : value);\n+            hasNext = it.hasNext();\n+            if (hasNext) {\n+                buf.append(\", \");\n+            }\n+        }\n+        buf.append(CollectionUtils.DEFAULT_TOSTRING_SUFFIX);\n+        return buf.toString();\n+    }\n+\n+    /**\n+     * Updates the node with a new value.\n+     * This implementation sets the value on the node.\n+     * Subclasses can override this to record the change.\n+     *\n+     * @param node  node to update\n+     * @param value  new value of the node\n+     */\n+    protected void updateNode(final Node<E> node, final E value) {\n+        node.setValue(value);\n+    }\n+\n+}\ndiff --git a/src/main/java/org/apache/commons/collections4/list/CursorableLinkedList.java b/src/main/java/org/apache/commons/collections4/list/CursorableLinkedList.java\nindex 12bce5c704..d39cb1c1a0 100644\n--- a/src/main/java/org/apache/commons/collections4/list/CursorableLinkedList.java\n+++ b/src/main/java/org/apache/commons/collections4/list/CursorableLinkedList.java\n@@ -57,7 +57,9 @@\n  *\n  * @see java.util.LinkedList\n  * @since 1.0\n+ * @deprecated parent {@link AbstractLinkedList} is source incompatible with List methods added in Java 21\n  */\n+@Deprecated\n public class CursorableLinkedList<E> extends AbstractLinkedList<E> implements Serializable {\n \n     /**\ndiff --git a/src/main/java/org/apache/commons/collections4/list/NodeCachingLinkedList.java b/src/main/java/org/apache/commons/collections4/list/NodeCachingLinkedList.java\nindex 1b379dd4db..defd429af9 100644\n--- a/src/main/java/org/apache/commons/collections4/list/NodeCachingLinkedList.java\n+++ b/src/main/java/org/apache/commons/collections4/list/NodeCachingLinkedList.java\n@@ -40,7 +40,9 @@\n  * </p>\n  *\n  * @since 3.0\n+ * @deprecated parent {@link AbstractLinkedList} is source incompatible with List methods added in Java 21\n  */\n+@Deprecated\n public class NodeCachingLinkedList<E> extends AbstractLinkedList<E> implements Serializable {\n \n     /** Serialization version */\n",
  "test_patch" : "diff --git a/src/test/java/org/apache/commons/collections4/list/DefaultAbstractLinkedListForJava21Test.java b/src/test/java/org/apache/commons/collections4/list/DefaultAbstractLinkedListForJava21Test.java\nnew file mode 100644\nindex 0000000000..79f4c97afd\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/list/DefaultAbstractLinkedListForJava21Test.java\n@@ -0,0 +1,316 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.list;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.junit.jupiter.api.Test;\n+\n+/**\n+ * Test case for {@link AbstractLinkedListForJava21}.\n+ */\n+public class DefaultAbstractLinkedListForJava21Test<E> extends AbstractListTest<E> {\n+\n+    public DefaultAbstractLinkedListForJava21Test() {\n+        super(DefaultAbstractLinkedListForJava21Test.class.getSimpleName());\n+    }\n+\n+    protected void checkNodes() {\n+        final AbstractLinkedListForJava21<E> list = getCollection();\n+        for (int i = 0; i < list.size; i++) {\n+            assertEquals(list.getNode(i, false).next, list.getNode(i + 1, true));\n+            if (i < list.size - 1) {\n+                assertEquals(list.getNode(i + 1, false).previous,\n+                    list.getNode(i, false));\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @SuppressWarnings(\"unchecked\")\n+    public void testAddNodeAfter() {\n+        resetEmpty();\n+        final AbstractLinkedListForJava21<E> list = getCollection();\n+        if (!isAddSupported()) {\n+            try {\n+                list.addFirst(null);\n+            } catch (final UnsupportedOperationException ex) {}\n+        }\n+\n+        list.addFirst((E) \"value1\");\n+        list.addNodeAfter(list.getNode(0, false), (E) \"value2\");\n+        assertEquals(\"value1\", list.getFirst());\n+        assertEquals(\"value2\", list.getLast());\n+        list.removeFirst();\n+        checkNodes();\n+        list.addNodeAfter(list.getNode(0, false), (E) \"value3\");\n+        checkNodes();\n+        assertEquals(\"value2\", list.getFirst());\n+        assertEquals(\"value3\", list.getLast());\n+        list.addNodeAfter(list.getNode(0, false), (E) \"value4\");\n+        checkNodes();\n+        assertEquals(\"value2\", list.getFirst());\n+        assertEquals(\"value3\", list.getLast());\n+        assertEquals(\"value4\", list.get(1));\n+        list.addNodeAfter(list.getNode(2, false), (E) \"value5\");\n+        checkNodes();\n+        assertEquals(\"value2\", list.getFirst());\n+        assertEquals(\"value4\", list.get(1));\n+        assertEquals(\"value3\", list.get(2));\n+        assertEquals(\"value5\", list.getLast());\n+    }\n+\n+    @Test\n+    @SuppressWarnings(\"unchecked\")\n+    public void testGetNode() {\n+        resetEmpty();\n+        final AbstractLinkedListForJava21<E> list = getCollection();\n+        // get marker\n+        assertEquals(list.getNode(0, true).previous, list.getNode(0, true).next);\n+        assertThrows(IndexOutOfBoundsException.class, () -> list.getNode(0, false),\n+                \"Expecting IndexOutOfBoundsException.\");\n+        list.addAll( Arrays.asList((E[]) new String[]{\"value1\", \"value2\"}));\n+        checkNodes();\n+        list.addFirst((E) \"value0\");\n+        checkNodes();\n+        list.removeNode(list.getNode(1, false));\n+        checkNodes();\n+        assertThrows(IndexOutOfBoundsException.class, () -> list.getNode(2, false),\n+                \"Expecting IndexOutOfBoundsException.\");\n+        assertThrows(IndexOutOfBoundsException.class, () -> list.getNode(-1, false),\n+                \"Expecting IndexOutOfBoundsException.\");\n+        assertThrows(IndexOutOfBoundsException.class, () -> list.getNode(3, true),\n+                \"Expecting IndexOutOfBoundsException.\");\n+    }\n+\n+    @Test\n+    @SuppressWarnings(\"unchecked\")\n+    public void testRemoveFirst() {\n+        resetEmpty();\n+        final AbstractLinkedListForJava21<E> list = getCollection();\n+        if (!isRemoveSupported()) {\n+            try {\n+                list.removeFirst();\n+            } catch (final UnsupportedOperationException ex) {}\n+        }\n+\n+        list.addAll(Arrays.asList((E[]) new String[] { \"value1\", \"value2\" }));\n+        assertEquals(\"value1\", list.removeFirst());\n+        checkNodes();\n+        list.addLast((E) \"value3\");\n+        checkNodes();\n+        assertEquals(\"value2\", list.removeFirst());\n+        assertEquals(\"value3\", list.removeFirst());\n+        checkNodes();\n+        list.addLast((E) \"value4\");\n+        checkNodes();\n+        assertEquals(\"value4\", list.removeFirst());\n+        checkNodes();\n+    }\n+\n+    @Test\n+    @SuppressWarnings(\"unchecked\")\n+    public void testRemoveLast() {\n+        resetEmpty();\n+        final AbstractLinkedListForJava21<E> list = getCollection();\n+        if (!isRemoveSupported()) {\n+            try {\n+                list.removeLast();\n+            } catch (final UnsupportedOperationException ex) {}\n+        }\n+\n+        list.addAll(Arrays.asList((E[]) new String[] { \"value1\", \"value2\" }));\n+        assertEquals(\"value2\", list.removeLast());\n+        list.addFirst((E) \"value3\");\n+        checkNodes();\n+        assertEquals(\"value1\", list.removeLast());\n+        assertEquals(\"value3\", list.removeLast());\n+        list.addFirst((E) \"value4\");\n+        checkNodes();\n+        assertEquals(\"value4\", list.removeFirst());\n+    }\n+\n+    @Test\n+    @SuppressWarnings(\"unchecked\")\n+    public void testRemoveNode() {\n+        resetEmpty();\n+        if (!isAddSupported() || !isRemoveSupported()) {\n+            return;\n+        }\n+        final AbstractLinkedListForJava21<E> list = getCollection();\n+\n+        list.addAll(Arrays.asList((E[]) new String[] { \"value1\", \"value2\" }));\n+        list.removeNode(list.getNode(0, false));\n+        checkNodes();\n+        assertEquals(\"value2\", list.getFirst());\n+        assertEquals(\"value2\", list.getLast());\n+        list.addFirst((E) \"value1\");\n+        list.addFirst((E) \"value0\");\n+        checkNodes();\n+        list.removeNode(list.getNode(1, false));\n+        assertEquals(\"value0\", list.getFirst());\n+        assertEquals(\"value2\", list.getLast());\n+        checkNodes();\n+        list.removeNode(list.getNode(1, false));\n+        assertEquals(\"value0\", list.getFirst());\n+        assertEquals(\"value0\", list.getLast());\n+        checkNodes();\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return null;\n+    }\n+\n+    @Override\n+    protected boolean skipSerializedCanonicalTests() {\n+        return true;\n+    }\n+\n+    @Override\n+    public AbstractLinkedListForJava21<E> getCollection() {\n+        return (AbstractLinkedListForJava21<E>) super.getCollection();\n+    }\n+\n+    @Override\n+    public List<E> makeObject() {\n+        return new DefaultAbstractLinkedListForJava21<>();\n+    }\n+\n+    @Test\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSubList() {\n+        List<E> list = makeObject();\n+        list.add((E) \"A\");\n+        list.add((E) \"B\");\n+        list.add((E) \"C\");\n+        list.add((E) \"D\");\n+        list.add((E) \"E\");\n+\n+        assertEquals(\"[A, B, C, D, E]\", list.toString());\n+        assertEquals(\"[A, B, C, D, E]\", list.subList(0, 5).toString());\n+        assertEquals(\"[B, C, D, E]\", list.subList(1, 5).toString());\n+        assertEquals(\"[C, D, E]\", list.subList(2, 5).toString());\n+        assertEquals(\"[D, E]\", list.subList(3, 5).toString());\n+        assertEquals(\"[E]\", list.subList(4, 5).toString());\n+        assertEquals(\"[]\", list.subList(5, 5).toString());\n+    }\n+\n+    @Test\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSubListAddBegin() {\n+        List<E> list = makeObject();\n+        list.add((E) \"A\");\n+        list.add((E) \"B\");\n+        list.add((E) \"C\");\n+        list.add((E) \"D\");\n+        list.add((E) \"E\");\n+\n+        final List<E> sublist = list.subList(0, 0);\n+        sublist.add((E) \"a\");\n+        assertEquals(\"[a, A, B, C, D, E]\", list.toString());\n+        assertEquals(\"[a]\", sublist.toString());\n+        sublist.add((E) \"b\");\n+        assertEquals(\"[a, b, A, B, C, D, E]\", list.toString());\n+        assertEquals(\"[a, b]\", sublist.toString());\n+    }\n+\n+    @Test\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSubListAddEnd() {\n+        List<E> list = makeObject();\n+        list.add((E) \"A\");\n+        list.add((E) \"B\");\n+        list.add((E) \"C\");\n+        list.add((E) \"D\");\n+        list.add((E) \"E\");\n+\n+        final List<E> sublist = list.subList(5, 5);\n+        sublist.add((E) \"F\");\n+        assertEquals(\"[A, B, C, D, E, F]\", list.toString());\n+        assertEquals(\"[F]\", sublist.toString());\n+        sublist.add((E) \"G\");\n+        assertEquals(\"[A, B, C, D, E, F, G]\", list.toString());\n+        assertEquals(\"[F, G]\", sublist.toString());\n+    }\n+\n+    @Test\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSubListAddMiddle() {\n+        List<E> list = makeObject();\n+        list.add((E) \"A\");\n+        list.add((E) \"B\");\n+        list.add((E) \"C\");\n+        list.add((E) \"D\");\n+        list.add((E) \"E\");\n+\n+        final List<E> sublist = list.subList(1, 3);\n+        sublist.add((E) \"a\");\n+        assertEquals(\"[A, B, C, a, D, E]\", list.toString());\n+        assertEquals(\"[B, C, a]\", sublist.toString());\n+        sublist.add((E) \"b\");\n+        assertEquals(\"[A, B, C, a, b, D, E]\", list.toString());\n+        assertEquals(\"[B, C, a, b]\", sublist.toString());\n+    }\n+\n+    @Test\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSubListRemove() {\n+        List<E> list = makeObject();\n+        list.add((E) \"A\");\n+        list.add((E) \"B\");\n+        list.add((E) \"C\");\n+        list.add((E) \"D\");\n+        list.add((E) \"E\");\n+\n+        final List<E> sublist = list.subList(1, 4);\n+        assertEquals(\"[B, C, D]\", sublist.toString());\n+        assertEquals(\"[A, B, C, D, E]\", list.toString());\n+        sublist.remove(\"C\");\n+        assertEquals(\"[B, D]\", sublist.toString());\n+        assertEquals(\"[A, B, D, E]\", list.toString());\n+        sublist.remove(1);\n+        assertEquals(\"[B]\", sublist.toString());\n+        assertEquals(\"[A, B, E]\", list.toString());\n+        sublist.clear();\n+        assertEquals(\"[]\", sublist.toString());\n+        assertEquals(\"[A, E]\", list.toString());\n+    }\n+\n+    private static class DefaultAbstractLinkedListForJava21<E> extends AbstractLinkedListForJava21<E> {\n+        DefaultAbstractLinkedListForJava21() {\n+            init();\n+        }\n+\n+        private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n+            in.defaultReadObject();\n+            doReadObject(in);\n+        }\n+\n+        private void writeObject(final ObjectOutputStream out) throws IOException {\n+            out.defaultWriteObject();\n+            doWriteObject(out);\n+        }\n+    }\n+}\n",
  "problem_statement" : "COLLECTIONS-842: deprecate Lists incompatible with Java 21, add new variant of AbstractLinkedList\n\nThis is a minimal PR. We may need to improve the deprecation notes.\r\n\r\nCoverage tests are failing; we'd need to add test coverage for the new variant, which IMHO requires having an implementation using it.\r\n\r\nI've verified that this change would work for Jackrabbit, see https://issues.apache.org/jira/browse/JCR-5049 for details.",
  "hints_text" : null,
  "created_at" : "Thu May 02 14:02:21 CEST 2024",
  "version" : null,
  "FAIL_TO_PASS" : [ "DefaultAbstractLinkedListForJava21Test" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=DefaultAbstractLinkedListForJava21Test",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 485,
  "metadata" : null
}, {
  "instance_id" : "apache-commons-collections-PR-481",
  "repo" : "apache/commons-collections",
  "base_commit" : "4d40c035ab25cf97cf2604688c5c72f706292a29",
  "patch" : "diff --git a/src/main/java/org/apache/commons/collections4/bloomfilter/BloomFilter.java b/src/main/java/org/apache/commons/collections4/bloomfilter/BloomFilter.java\nindex d991c0eee2..feb32a483d 100644\n--- a/src/main/java/org/apache/commons/collections4/bloomfilter/BloomFilter.java\n+++ b/src/main/java/org/apache/commons/collections4/bloomfilter/BloomFilter.java\n@@ -120,7 +120,7 @@ default boolean contains(final Hasher hasher) {\n      * Creates a new instance of the BloomFilter with the same properties as the current one.\n      * @return a copy of this BloomFilter\n      */\n-    BloomFilter copy();\n+    <T extends BloomFilter> T copy();\n \n     // update operations\n \ndiff --git a/src/main/java/org/apache/commons/collections4/bloomfilter/LayerManager.java b/src/main/java/org/apache/commons/collections4/bloomfilter/LayerManager.java\nindex b139d16ced..0e984b0aa6 100644\n--- a/src/main/java/org/apache/commons/collections4/bloomfilter/LayerManager.java\n+++ b/src/main/java/org/apache/commons/collections4/bloomfilter/LayerManager.java\n@@ -16,6 +16,7 @@\n  */\n package org.apache.commons.collections4.bloomfilter;\n \n+import java.util.Deque;\n import java.util.LinkedList;\n import java.util.NoSuchElementException;\n import java.util.Objects;\n@@ -50,15 +51,15 @@\n  *\n  * @since 4.5\n  */\n-public class LayerManager implements BloomFilterProducer {\n+public class LayerManager<T extends BloomFilter> implements BloomFilterProducer {\n \n     /**\n      * Builder to create Layer Manager\n      */\n-    public static class Builder {\n-        private Predicate<LayerManager> extendCheck;\n-        private Supplier<BloomFilter> supplier;\n-        private Consumer<LinkedList<BloomFilter>> cleanup;\n+    public static class Builder<T extends BloomFilter> {\n+        private Predicate<LayerManager<T>> extendCheck;\n+        private Supplier<T> supplier;\n+        private Consumer<Deque<T>> cleanup;\n \n         private Builder() {\n             extendCheck = ExtendCheck.neverAdvance();\n@@ -70,11 +71,11 @@ private Builder() {\n          *\n          * @return a new LayerManager.\n          */\n-        public LayerManager build() {\n+        public LayerManager<T> build() {\n             Objects.requireNonNull(supplier, \"Supplier must not be null\");\n             Objects.requireNonNull(extendCheck, \"ExtendCheck must not be null\");\n             Objects.requireNonNull(cleanup, \"Cleanup must not be null\");\n-            return new LayerManager(supplier, extendCheck, cleanup, true);\n+            return new LayerManager<>(supplier, extendCheck, cleanup, true);\n         }\n \n         /**\n@@ -84,7 +85,7 @@ public LayerManager build() {\n          *                dated or stale filters.\n          * @return this\n          */\n-        public Builder setCleanup(Consumer<LinkedList<BloomFilter>> cleanup) {\n+        public Builder<T> setCleanup(Consumer<Deque<T>> cleanup) {\n             this.cleanup = cleanup;\n             return this;\n         }\n@@ -97,7 +98,7 @@ public Builder setCleanup(Consumer<LinkedList<BloomFilter>> cleanup) {\n          *                    created.\n          * @return this for chaining.\n          */\n-        public Builder setExtendCheck(Predicate<LayerManager> extendCheck) {\n+        public Builder<T> setExtendCheck(Predicate<LayerManager<T>> extendCheck) {\n             this.extendCheck = extendCheck;\n             return this;\n         }\n@@ -109,14 +110,14 @@ public Builder setExtendCheck(Predicate<LayerManager> extendCheck) {\n          * @param supplier The supplier of new Bloom filter instances.\n          * @return this for chaining.\n          */\n-        public Builder setSupplier(Supplier<BloomFilter> supplier) {\n+        public Builder<T> setSupplier(Supplier<T> supplier) {\n             this.supplier = supplier;\n             return this;\n         }\n     }\n \n     /**\n-     * Static methods to create a Consumer of a LinkedList of BloomFilter perform\n+     * Static methods to create a Consumer of a List of BloomFilter perform\n      * tests on whether to reduce the collection of Bloom filters.\n      */\n     public static final class Cleanup {\n@@ -124,7 +125,7 @@ public static final class Cleanup {\n          * A Cleanup that never removes anything.\n          * @return A Consumer suitable for the LayerManager {@code cleanup} parameter.\n          */\n-        public static Consumer<LinkedList<BloomFilter>> noCleanup() {\n+        public static  <T extends BloomFilter>  Consumer<Deque<T>> noCleanup() {\n             return x -> {};\n         }\n \n@@ -137,7 +138,7 @@ public static Consumer<LinkedList<BloomFilter>> noCleanup() {\n          * @return A Consumer suitable for the LayerManager {@code cleanup} parameter.\n          * @throws IllegalArgumentException if {@code maxSize <= 0}.\n          */\n-        public static Consumer<LinkedList<BloomFilter>> onMaxSize(int maxSize) {\n+        public static <T extends BloomFilter> Consumer<Deque<T>> onMaxSize(int maxSize) {\n             if (maxSize <= 0) {\n                 throw new IllegalArgumentException(\"'maxSize' must be greater than 0\");\n             }\n@@ -154,14 +155,24 @@ public static Consumer<LinkedList<BloomFilter>> onMaxSize(int maxSize) {\n          *\n          * @return A Consumer suitable for the LayerManager {@code cleanup} parameter.\n          */\n-        public static Consumer<LinkedList<BloomFilter>> removeEmptyTarget() {\n+        public static <T extends BloomFilter> Consumer<Deque<T>> removeEmptyTarget() {\n             return x -> {\n-                if (x.getLast().cardinality() == 0) {\n+                if (!x.isEmpty() && x.getLast().isEmpty()) {\n                     x.removeLast();\n                 }\n             };\n         }\n \n+        /**\n+         * Removes any layer identified by the predicate.\n+         *\n+         * @param test Predicate.\n+         * @return A Consumer suitable for the LayerManager {@code cleanup} parameter.\n+         */\n+        public static <T extends BloomFilter> Consumer<Deque<T>> removeIf(Predicate<? super T> test) {\n+            return x -> x.removeIf(test);\n+        }\n+\n         private Cleanup() {\n         }\n     }\n@@ -179,16 +190,20 @@ public static final class ExtendCheck {\n          * @return A Predicate suitable for the LayerManager {@code extendCheck} parameter.\n          * @throws IllegalArgumentException if {@code breakAt <= 0}\n          */\n-        public static Predicate<LayerManager> advanceOnCount(int breakAt) {\n+        public static <T extends BloomFilter> Predicate<LayerManager<T>> advanceOnCount(int breakAt) {\n             if (breakAt <= 0) {\n                 throw new IllegalArgumentException(\"'breakAt' must be greater than 0\");\n             }\n-            return new Predicate<LayerManager>() {\n+            return new Predicate<LayerManager<T>>() {\n                 int count;\n \n                 @Override\n-                public boolean test(LayerManager filter) {\n-                    return ++count % breakAt == 0;\n+                public boolean test(LayerManager<T> filter) {\n+                    if (++count == breakAt) {\n+                        count = 0;\n+                        return true;\n+                    }\n+                    return false;\n                 }\n             };\n         }\n@@ -197,8 +212,8 @@ public boolean test(LayerManager filter) {\n          * Advances the target once a merge has been performed.\n          * @return A Predicate suitable for the LayerManager {@code extendCheck} parameter.\n          */\n-        public static Predicate<LayerManager> advanceOnPopulated() {\n-            return lm -> !lm.filters.peekLast().isEmpty();\n+        public static <T extends BloomFilter> Predicate<LayerManager<T>> advanceOnPopulated() {\n+            return lm -> !lm.last().isEmpty();\n         }\n \n         /**\n@@ -212,12 +227,12 @@ public static Predicate<LayerManager> advanceOnPopulated() {\n          * @return A Predicate suitable for the LayerManager {@code extendCheck} parameter.\n          * @throws IllegalArgumentException if {@code maxN <= 0}\n          */\n-        public static Predicate<LayerManager> advanceOnSaturation(double maxN) {\n+        public static <T extends BloomFilter> Predicate<LayerManager<T>> advanceOnSaturation(double maxN) {\n             if (maxN <= 0) {\n                 throw new IllegalArgumentException(\"'maxN' must be greater than 0\");\n             }\n             return manager -> {\n-                BloomFilter bf = manager.filters.peekLast();\n+                BloomFilter bf = manager.last();\n                 return maxN <= bf.getShape().estimateN(bf.cardinality());\n             };\n         }\n@@ -227,7 +242,7 @@ public static Predicate<LayerManager> advanceOnSaturation(double maxN) {\n          * perform the advance.\n          * @return A Predicate suitable for the LayerManager {@code extendCheck} parameter.\n          */\n-        public static Predicate<LayerManager> neverAdvance() {\n+        public static <T extends BloomFilter> Predicate<LayerManager<T>> neverAdvance() {\n             return x -> false;\n         }\n \n@@ -242,15 +257,15 @@ private ExtendCheck() {\n      * @see ExtendCheck#neverAdvance()\n      * @see Cleanup#noCleanup()\n      */\n-    public static Builder builder() {\n-        return new Builder();\n+    public static <T extends BloomFilter> Builder<T> builder() {\n+        return new Builder<>();\n     }\n-    private final LinkedList<BloomFilter> filters = new LinkedList<>();\n-    private final Consumer<LinkedList<BloomFilter>> filterCleanup;\n+    private final LinkedList<T> filters = new LinkedList<>();\n+    private final Consumer<Deque<T>> filterCleanup;\n \n-    private final Predicate<LayerManager> extendCheck;\n+    private final Predicate<LayerManager<T>> extendCheck;\n \n-    private final Supplier<BloomFilter> filterSupplier;\n+    private final Supplier<T> filterSupplier;\n \n     /**\n      * Constructor.\n@@ -263,8 +278,8 @@ public static Builder builder() {\n      *                       list.\n      * @param initialize     true if the filter list should be initialized.\n      */\n-    private LayerManager(Supplier<BloomFilter> filterSupplier, Predicate<LayerManager> extendCheck,\n-            Consumer<LinkedList<BloomFilter>> filterCleanup, boolean initialize) {\n+    private LayerManager(Supplier<T> filterSupplier, Predicate<LayerManager<T>> extendCheck,\n+            Consumer<Deque<T>> filterCleanup, boolean initialize) {\n         this.filterSupplier = filterSupplier;\n         this.extendCheck = extendCheck;\n         this.filterCleanup = filterCleanup;\n@@ -277,7 +292,7 @@ private LayerManager(Supplier<BloomFilter> filterSupplier, Predicate<LayerManage\n      * Adds a new Bloom filter to the list.\n      */\n     private void addFilter() {\n-        BloomFilter bf = filterSupplier.get();\n+        T bf = filterSupplier.get();\n         if (bf == null) {\n             throw new NullPointerException(\"filterSupplier returned null.\");\n         }\n@@ -302,9 +317,9 @@ public final void clear() {\n      *\n      * @return a copy of this layer Manager.\n      */\n-    public LayerManager copy() {\n-        LayerManager newMgr = new LayerManager(filterSupplier, extendCheck, filterCleanup, false);\n-        for (BloomFilter bf : filters) {\n+    public LayerManager<T> copy() {\n+        LayerManager<T> newMgr = new LayerManager<>(filterSupplier, extendCheck, filterCleanup, false);\n+        for (T bf : filters) {\n             newMgr.filters.add(bf.copy());\n         }\n         return newMgr;\n@@ -337,7 +352,7 @@ public boolean forEachBloomFilter(Predicate<BloomFilter> bloomFilterPredicate) {\n      * @throws NoSuchElementException if depth is not in the range\n      *                                [0,filters.size())\n      */\n-    public final BloomFilter get(int depth) {\n+    public final T get(int depth) {\n         if (depth < 0 || depth >= filters.size()) {\n             throw new NoSuchElementException(String.format(\"Depth must be in the range [0,%s)\", filters.size()));\n         }\n@@ -346,7 +361,7 @@ public final BloomFilter get(int depth) {\n \n     /**\n      * Returns the number of filters in the LayerManager.  In the default LayerManager implementation\n-     * there is alwasy at least one layer.\n+     * there is always at least one layer.\n      *\n      * @return the current depth.\n      */\n@@ -354,17 +369,37 @@ public final int getDepth() {\n         return filters.size();\n     }\n \n+    /**\n+     * Gets the Bloom filter from the first layer.\n+     * No extension check is performed during this call.\n+     * @return The Bloom filter from the first layer.\n+     * @see #getTarget()\n+     */\n+    public final T first() {\n+        return filters.getFirst();\n+    }\n+\n+    /**\n+     * Gets the Bloom filter from the last layer.\n+     * No extension check is performed during this call.\n+     * @return The Bloom filter from the last layer.\n+     * @see #getTarget()\n+     */\n+    public final T last() {\n+        return filters.getLast();\n+    }\n+\n     /**\n      * Returns the current target filter. If a new filter should be created based on\n      * {@code extendCheck} it will be created before this method returns.\n      *\n      * @return the current target filter after any extension.\n      */\n-    public final BloomFilter getTarget() {\n+    public final T getTarget() {\n         if (extendCheck.test(this)) {\n             next();\n         }\n-        return filters.peekLast();\n+        return last();\n     }\n \n     /**\ndiff --git a/src/main/java/org/apache/commons/collections4/bloomfilter/LayeredBloomFilter.java b/src/main/java/org/apache/commons/collections4/bloomfilter/LayeredBloomFilter.java\nindex 9ed2688bbc..0a79537dcf 100644\n--- a/src/main/java/org/apache/commons/collections4/bloomfilter/LayeredBloomFilter.java\n+++ b/src/main/java/org/apache/commons/collections4/bloomfilter/LayeredBloomFilter.java\n@@ -59,9 +59,10 @@\n  * removes them. It also checks it a new layer should be added, and if so adds\n  * it and sets the {@code target} before the operation.</li>\n  * </ul>\n+ * @param <T> The type of Bloom Filter that is used for the layers.\n  * @since 4.5\n  */\n-public class LayeredBloomFilter implements BloomFilter, BloomFilterProducer {\n+public class LayeredBloomFilter<T extends BloomFilter> implements BloomFilter, BloomFilterProducer {\n     /**\n      * A class used to locate matching filters across all the layers.\n      */\n@@ -88,24 +89,10 @@ public boolean test(BloomFilter x) {\n             return true;\n         }\n     }\n-    /**\n-     * Creates a fixed size layered bloom filter that adds new filters to the list,\n-     * but never merges them. List will never exceed maxDepth. As additional filters\n-     * are added earlier filters are removed.\n-     *\n-     * @param shape    The shape for the enclosed Bloom filters.\n-     * @param maxDepth The maximum depth of layers.\n-     * @return An empty layered Bloom filter of the specified shape and depth.\n-     */\n-    public static LayeredBloomFilter fixed(final Shape shape, int maxDepth) {\n-        LayerManager manager = LayerManager.builder().setExtendCheck(LayerManager.ExtendCheck.advanceOnPopulated())\n-                .setCleanup(LayerManager.Cleanup.onMaxSize(maxDepth)).setSupplier(() -> new SimpleBloomFilter(shape)).build();\n-        return new LayeredBloomFilter(shape, manager);\n-    }\n \n     private final Shape shape;\n \n-    private LayerManager layerManager;\n+    private final LayerManager<T> layerManager;\n \n     /**\n      * Constructor.\n@@ -113,7 +100,7 @@ public static LayeredBloomFilter fixed(final Shape shape, int maxDepth) {\n      * @param shape        the Shape of the enclosed Bloom filters\n      * @param layerManager the LayerManager to manage the layers.\n      */\n-    public LayeredBloomFilter(Shape shape, LayerManager layerManager) {\n+    public LayeredBloomFilter(Shape shape, LayerManager<T> layerManager) {\n         this.shape = shape;\n         this.layerManager = layerManager;\n     }\n@@ -184,8 +171,8 @@ public boolean contains(IndexProducer indexProducer) {\n     }\n \n     @Override\n-    public LayeredBloomFilter copy() {\n-        return new LayeredBloomFilter(shape, layerManager.copy());\n+    public LayeredBloomFilter<T> copy() {\n+        return new LayeredBloomFilter<>(shape, layerManager.copy());\n     }\n \n     /**\n@@ -329,7 +316,7 @@ public boolean forEachIndex(IntPredicate predicate) {\n      * @return the Bloom filter at the specified depth.\n      * @throws NoSuchElementException if depth is not in the range [0,getDepth())\n      */\n-    public BloomFilter get(int depth) {\n+    public T get(int depth) {\n         return layerManager.get(depth);\n     }\n \ndiff --git a/src/main/java/org/apache/commons/collections4/bloomfilter/WrappedBloomFilter.java b/src/main/java/org/apache/commons/collections4/bloomfilter/WrappedBloomFilter.java\nindex b1d661e890..18aa6f5d80 100644\n--- a/src/main/java/org/apache/commons/collections4/bloomfilter/WrappedBloomFilter.java\n+++ b/src/main/java/org/apache/commons/collections4/bloomfilter/WrappedBloomFilter.java\n@@ -25,7 +25,7 @@\n  * @since 4.5\n  */\n public abstract class WrappedBloomFilter implements BloomFilter {\n-    final BloomFilter wrapped;\n+    private final BloomFilter wrapped;\n \n     /**\n      * Wraps a Bloom filter.  The wrapped filter is maintained as a reference\n@@ -36,6 +36,10 @@ public WrappedBloomFilter(BloomFilter bf) {\n         this.wrapped = bf;\n     }\n \n+    protected BloomFilter getWrapped() {\n+        return wrapped;\n+    }\n+\n     @Override\n     public long[] asBitMapArray() {\n         return wrapped.asBitMapArray();\n@@ -81,11 +85,6 @@ public boolean contains(IndexProducer indexProducer) {\n         return wrapped.contains(indexProducer);\n     }\n \n-    @Override\n-    public BloomFilter copy() {\n-        return wrapped.copy();\n-    }\n-\n     @Override\n     public int estimateIntersection(BloomFilter other) {\n         return wrapped.estimateIntersection(other);\n",
  "test_patch" : "diff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/BitMapProducerFromLayeredBloomFilterTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/BitMapProducerFromLayeredBloomFilterTest.java\nindex bd71067bbe..246ef518cc 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/BitMapProducerFromLayeredBloomFilterTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/BitMapProducerFromLayeredBloomFilterTest.java\n@@ -22,13 +22,13 @@ public class BitMapProducerFromLayeredBloomFilterTest extends AbstractBitMapProd\n \n     @Override\n     protected BitMapProducer createEmptyProducer() {\n-        return LayeredBloomFilter.fixed(shape, 10);\n+        return LayeredBloomFilterTest.fixed(shape, 10);\n     }\n \n     @Override\n     protected BitMapProducer createProducer() {\n         final Hasher hasher = new IncrementingHasher(0, 1);\n-        final BloomFilter bf = LayeredBloomFilter.fixed(shape, 10);\n+        final BloomFilter bf = LayeredBloomFilterTest.fixed(shape, 10);\n         bf.merge(hasher);\n         return bf;\n     }\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/BitMapProducerFromWrappedBloomFilterTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/BitMapProducerFromWrappedBloomFilterTest.java\nindex ebb78ab43d..27befb1e60 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/BitMapProducerFromWrappedBloomFilterTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/BitMapProducerFromWrappedBloomFilterTest.java\n@@ -23,6 +23,12 @@ public class BitMapProducerFromWrappedBloomFilterTest extends AbstractBitMapProd\n     @Override\n     protected BitMapProducer createEmptyProducer() {\n         return new WrappedBloomFilter(new DefaultBloomFilterTest.SparseDefaultBloomFilter(shape)) {\n+            @Override\n+            public BloomFilter copy() {\n+                BloomFilter result = new DefaultBloomFilterTest.SparseDefaultBloomFilter(shape);\n+                result.merge(getWrapped());\n+                return result;\n+            }\n         };\n     }\n \n@@ -30,6 +36,12 @@ protected BitMapProducer createEmptyProducer() {\n     protected BitMapProducer createProducer() {\n         final Hasher hasher = new IncrementingHasher(0, 1);\n         final BloomFilter bf = new WrappedBloomFilter(new DefaultBloomFilterTest.SparseDefaultBloomFilter(shape)) {\n+            @Override\n+            public BloomFilter copy() {\n+                BloomFilter result = new DefaultBloomFilterTest.SparseDefaultBloomFilter(shape);\n+                result.merge(getWrapped());\n+                return result;\n+            }\n         };\n         bf.merge(hasher);\n         return bf;\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/CellProducerFromLayeredBloomFilterTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/CellProducerFromLayeredBloomFilterTest.java\nindex 0c340061c4..ad3fa8c1c0 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/CellProducerFromLayeredBloomFilterTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/CellProducerFromLayeredBloomFilterTest.java\n@@ -22,13 +22,13 @@ public class CellProducerFromLayeredBloomFilterTest extends AbstractCellProducer\n \n     @Override\n     protected CellProducer createEmptyProducer() {\n-        return CellProducer.from(LayeredBloomFilter.fixed(shape, 10));\n+        return CellProducer.from(LayeredBloomFilterTest.fixed(shape, 10));\n     }\n \n     @Override\n     protected CellProducer createProducer() {\n         final Hasher hasher = new IncrementingHasher(3, 2);\n-        final BloomFilter bf = LayeredBloomFilter.fixed(shape, 10);\n+        final BloomFilter bf = LayeredBloomFilterTest.fixed(shape, 10);\n         bf.merge(hasher);\n         return CellProducer.from(bf);\n     }\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/LayerManagerTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/LayerManagerTest.java\nindex 4ee438b89f..74e8b98e59 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/LayerManagerTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/LayerManagerTest.java\n@@ -16,9 +16,9 @@\n  */\n package org.apache.commons.collections4.bloomfilter;\n \n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertNotEquals;\n-import static org.junit.Assert.assertNotSame;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotSame;\n import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n import static org.junit.jupiter.api.Assertions.assertFalse;\n import static org.junit.jupiter.api.Assertions.assertSame;\n@@ -27,6 +27,7 @@\n \n import java.util.ArrayList;\n import java.util.Arrays;\n+import java.util.Deque;\n import java.util.LinkedList;\n import java.util.List;\n import java.util.NoSuchElementException;\n@@ -39,13 +40,13 @@\n \n public class LayerManagerTest {\n \n-    private Shape shape = Shape.fromKM(17, 72);\n+    private final Shape shape = Shape.fromKM(17, 72);\n \n     @ParameterizedTest\n     @ValueSource(ints = {4, 10, 2, 1})\n     public void testAdvanceOnCount(int breakAt) {\n-        Predicate<LayerManager> underTest = LayerManager.ExtendCheck.advanceOnCount(breakAt);\n-        LayerManager layerManager = testingBuilder().build();\n+        Predicate<LayerManager<BloomFilter>> underTest = LayerManager.ExtendCheck.advanceOnCount(breakAt);\n+        LayerManager<BloomFilter> layerManager = testingBuilder().build();\n         for (int i = 0; i < breakAt - 1; i++) {\n             assertFalse(underTest.test(layerManager), \"at \" + i);\n             layerManager.getTarget().merge(TestingHashers.FROM1);\n@@ -61,8 +62,8 @@ public void testAdvanceOnCountInvalidArguments() {\n \n     @Test\n     public void testAdvanceOnPopulated() {\n-        Predicate<LayerManager> underTest = LayerManager.ExtendCheck.advanceOnPopulated();\n-        LayerManager layerManager = testingBuilder().build();\n+        Predicate<LayerManager<BloomFilter>> underTest = LayerManager.ExtendCheck.advanceOnPopulated();\n+        LayerManager<BloomFilter> layerManager = testingBuilder().build();\n         assertFalse(underTest.test(layerManager));\n         layerManager.getTarget().merge(TestingHashers.FROM1);\n         assertTrue(underTest.test(layerManager));\n@@ -70,10 +71,10 @@ public void testAdvanceOnPopulated() {\n \n     @Test\n     public void testAdvanceOnSaturation() {\n-        Double maxN = shape.estimateMaxN();\n+        double maxN = shape.estimateMaxN();\n         int hashStart = 0;\n-        Predicate<LayerManager> underTest = LayerManager.ExtendCheck.advanceOnSaturation(maxN);\n-        LayerManager layerManager = testingBuilder().build();\n+        Predicate<LayerManager<BloomFilter>> underTest = LayerManager.ExtendCheck.advanceOnSaturation(maxN);\n+        LayerManager<BloomFilter> layerManager = testingBuilder().build();\n         while (layerManager.getTarget().getShape().estimateN(layerManager.getTarget().cardinality()) < maxN) {\n             assertFalse(underTest.test(layerManager));\n             layerManager.getTarget().merge(new IncrementingHasher(hashStart, shape.getNumberOfHashFunctions()));\n@@ -86,15 +87,15 @@ public void testAdvanceOnSaturation() {\n \n     @Test\n     public void testBuilder() {\n-        LayerManager.Builder underTest = LayerManager.builder();\n-        NullPointerException npe = assertThrows(NullPointerException.class, () -> underTest.build());\n+        LayerManager.Builder<BloomFilter> underTest = LayerManager.builder();\n+        NullPointerException npe = assertThrows(NullPointerException.class, underTest::build);\n         assertTrue(npe.getMessage().contains(\"Supplier must not be null\"));\n         underTest.setSupplier(() -> null).setCleanup(null);\n-        npe = assertThrows(NullPointerException.class, () -> underTest.build());\n+        npe = assertThrows(NullPointerException.class, underTest::build);\n         assertTrue(npe.getMessage().contains(\"Cleanup must not be null\"));\n         underTest.setCleanup(x -> {\n         }).setExtendCheck(null);\n-        npe = assertThrows(NullPointerException.class, () -> underTest.build());\n+        npe = assertThrows(NullPointerException.class, underTest::build);\n         assertTrue(npe.getMessage().contains(\"ExtendCheck must not be null\"));\n \n         npe = assertThrows(NullPointerException.class, () -> LayerManager.builder().setSupplier(() -> null).build());\n@@ -104,7 +105,7 @@ public void testBuilder() {\n \n     @Test\n     public void testClear() {\n-        LayerManager underTest = LayerManager.builder().setSupplier(() -> new SimpleBloomFilter(shape)).build();\n+        LayerManager<BloomFilter> underTest = LayerManager.builder().setSupplier(() -> new SimpleBloomFilter(shape)).build();\n         underTest.getTarget().merge(TestingHashers.randomHasher());\n         underTest.next();\n         underTest.getTarget().merge(TestingHashers.randomHasher());\n@@ -118,7 +119,7 @@ public void testClear() {\n \n     @Test\n     public void testCopy() {\n-        LayerManager underTest = LayerManager.builder().setSupplier(() -> new SimpleBloomFilter(shape)).build();\n+        LayerManager<BloomFilter> underTest = LayerManager.builder().setSupplier(() -> new SimpleBloomFilter(shape)).build();\n         underTest.getTarget().merge(TestingHashers.randomHasher());\n         underTest.next();\n         underTest.getTarget().merge(TestingHashers.randomHasher());\n@@ -126,7 +127,7 @@ public void testCopy() {\n         underTest.getTarget().merge(TestingHashers.randomHasher());\n         assertEquals(3, underTest.getDepth());\n \n-        LayerManager copy = underTest.copy();\n+        LayerManager<BloomFilter> copy = underTest.copy();\n         assertNotSame(underTest, copy);\n         // object equals not implemented\n         assertNotEquals(underTest, copy);\n@@ -138,7 +139,7 @@ public void testCopy() {\n \n     @Test\n     public void testForEachBloomFilter() {\n-        LayerManager underTest = LayerManager.builder().setSupplier(() -> new SimpleBloomFilter(shape))\n+        LayerManager<BloomFilter> underTest = LayerManager.builder().setSupplier(() -> new SimpleBloomFilter(shape))\n                 .setExtendCheck(LayerManager.ExtendCheck.advanceOnPopulated()).build();\n \n         List<BloomFilter> lst = new ArrayList<>();\n@@ -160,21 +161,21 @@ public void testForEachBloomFilter() {\n     @Test\n     public void testGet() {\n         SimpleBloomFilter f = new SimpleBloomFilter(shape);\n-        LayerManager underTest = LayerManager.builder().setSupplier(() -> f).build();\n+        LayerManager<BloomFilter> underTest = LayerManager.builder().setSupplier(() -> f).build();\n         assertEquals(1, underTest.getDepth());\n         assertSame(f, underTest.get(0));\n         assertThrows(NoSuchElementException.class, () -> underTest.get(-1));\n         assertThrows(NoSuchElementException.class, () -> underTest.get(1));\n     }\n \n-    private LayerManager.Builder testingBuilder() {\n+    private LayerManager.Builder<BloomFilter> testingBuilder() {\n         return LayerManager.builder().setSupplier(() -> new SimpleBloomFilter(shape));\n     }\n \n     @Test\n     public void testNeverAdvance() {\n-        Predicate<LayerManager> underTest = LayerManager.ExtendCheck.neverAdvance();\n-        LayerManager layerManager = testingBuilder().build();\n+        Predicate<LayerManager<BloomFilter>> underTest = LayerManager.ExtendCheck.neverAdvance();\n+        LayerManager<BloomFilter> layerManager = testingBuilder().build();\n         assertFalse(underTest.test(layerManager));\n         for (int i = 0; i < 10; i++) {\n             layerManager.getTarget().merge(TestingHashers.randomHasher());\n@@ -184,7 +185,7 @@ public void testNeverAdvance() {\n \n     @Test\n     public void testNextAndGetDepth() {\n-        LayerManager underTest = LayerManager.builder().setSupplier(() -> new SimpleBloomFilter(shape)).build();\n+        LayerManager<BloomFilter> underTest = LayerManager.builder().setSupplier(() -> new SimpleBloomFilter(shape)).build();\n         assertEquals(1, underTest.getDepth());\n         underTest.getTarget().merge(TestingHashers.randomHasher());\n         assertEquals(1, underTest.getDepth());\n@@ -194,8 +195,8 @@ public void testNextAndGetDepth() {\n \n     @Test\n     public void testNoCleanup() {\n-        Consumer<LinkedList<BloomFilter>> underTest = LayerManager.Cleanup.noCleanup();\n-        LinkedList<BloomFilter> list = new LinkedList<>();\n+        Consumer<Deque<BloomFilter>> underTest = LayerManager.Cleanup.noCleanup();\n+        Deque<BloomFilter> list = new LinkedList<>();\n         for (int i = 0; i < 20; i++) {\n             assertEquals(i, list.size());\n             list.add(new SimpleBloomFilter(shape));\n@@ -206,7 +207,7 @@ public void testNoCleanup() {\n     @ParameterizedTest\n     @ValueSource(ints = {5, 100, 2, 1})\n     public void testOnMaxSize(int maxSize) {\n-        Consumer<LinkedList<BloomFilter>> underTest = LayerManager.Cleanup.onMaxSize(maxSize);\n+        Consumer<Deque<BloomFilter>> underTest = LayerManager.Cleanup.onMaxSize(maxSize);\n         LinkedList<BloomFilter> list = new LinkedList<>();\n         for (int i = 0; i < maxSize; i++) {\n             assertEquals(i, list.size());\n@@ -230,7 +231,7 @@ public void testOnMaxSizeIllegalValues() {\n \n     @Test\n     public void testRemoveEmptyTarget() {\n-        Consumer<LinkedList<BloomFilter>> underTest = LayerManager.Cleanup.removeEmptyTarget();\n+        Consumer<Deque<BloomFilter>> underTest = LayerManager.Cleanup.removeEmptyTarget();\n         LinkedList<BloomFilter> list = new LinkedList<>();\n \n         // removes an empty filter\n@@ -265,7 +266,6 @@ public void testRemoveEmptyTarget() {\n         underTest.accept(list);\n         assertEquals(2, list.size());\n         assertEquals(bf, list.get(0));\n-\n     }\n \n     @Test\n@@ -273,7 +273,7 @@ public void testTarget() {\n         boolean[] extendCheckCalled = { false };\n         boolean[] cleanupCalled = { false };\n         int[] supplierCount = { 0 };\n-        LayerManager underTest = LayerManager.builder().setSupplier(() -> {\n+        LayerManager<BloomFilter> underTest = LayerManager.builder().setSupplier(() -> {\n             supplierCount[0]++;\n             return new SimpleBloomFilter(shape);\n         }).setExtendCheck(lm -> {\n@@ -291,13 +291,4 @@ public void testTarget() {\n         assertEquals(2, supplierCount[0]);\n     }\n \n-    static class NumberedBloomFilter extends WrappedBloomFilter {\n-        int value;\n-        int sequence;\n-        NumberedBloomFilter(Shape shape, int value, int sequence) {\n-            super(new SimpleBloomFilter(shape));\n-            this.value = value;\n-            this.sequence = sequence;\n-        }\n-    }\n }\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/LayeredBloomFilterTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/LayeredBloomFilterTest.java\nindex 0859e58c65..25f807a80d 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/LayeredBloomFilterTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/LayeredBloomFilterTest.java\n@@ -16,30 +16,60 @@\n  */\n package org.apache.commons.collections4.bloomfilter;\n \n-import static org.junit.Assert.assertEquals;\n import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n import static org.junit.jupiter.api.Assertions.assertEquals;\n import static org.junit.jupiter.api.Assertions.assertFalse;\n import static org.junit.jupiter.api.Assertions.assertTrue;\n \n import java.util.ArrayList;\n-import java.util.LinkedList;\n+import java.util.Deque;\n+import java.util.Iterator;\n import java.util.List;\n import java.util.concurrent.TimeUnit;\n import java.util.function.Consumer;\n import java.util.function.Predicate;\n+import java.util.function.Supplier;\n \n import org.apache.commons.collections4.bloomfilter.LayerManager.Cleanup;\n import org.apache.commons.collections4.bloomfilter.LayerManager.ExtendCheck;\n-import org.apache.commons.collections4.bloomfilter.LayerManagerTest.NumberedBloomFilter;\n import org.junit.jupiter.api.Test;\n \n-public class LayeredBloomFilterTest extends AbstractBloomFilterTest<LayeredBloomFilter> {\n+public class LayeredBloomFilterTest extends AbstractBloomFilterTest<LayeredBloomFilter<?>> {\n+\n+    /**\n+     * Creates a fixed size layered bloom filter that adds new filters to the list,\n+     * but never merges them. List will never exceed maxDepth. As additional filters\n+     * are added earlier filters are removed.  Uses SimpleBloomFilters.\n+     *\n+     * @param shape    The shape for the enclosed Bloom filters.\n+     * @param maxDepth The maximum depth of layers.\n+     * @return An empty layered Bloom filter of the specified shape and depth.\n+     */\n+    public static  LayeredBloomFilter<BloomFilter> fixed(final Shape shape, int maxDepth) {\n+        return fixed(shape, maxDepth, () -> new SimpleBloomFilter(shape));\n+    }\n+\n+    /**\n+     * Creates a fixed size layered bloom filter that adds new filters to the list,\n+     * but never merges them. List will never exceed maxDepth. As additional filters\n+     * are added earlier filters are removed.\n+     *\n+     * @param shape    The shape for the enclosed Bloom filters.\n+     * @param maxDepth The maximum depth of layers.\n+     * @param supplier A supplier of the Bloom filters to create layers with.\n+     * @return An empty layered Bloom filter of the specified shape and depth.\n+     */\n+    public static <T extends BloomFilter> LayeredBloomFilter<T> fixed(final Shape shape, int maxDepth, Supplier<T> supplier) {\n+        LayerManager.Builder<T> builder = LayerManager.builder();\n+        builder.setExtendCheck(LayerManager.ExtendCheck.advanceOnPopulated())\n+                .setCleanup(LayerManager.Cleanup.onMaxSize(maxDepth)).setSupplier(supplier);\n+        return new LayeredBloomFilter<>(shape, builder.build());\n+    }\n \n     /**\n      * A Predicate that advances after a quantum of time.\n      */\n-    static class AdvanceOnTimeQuanta implements Predicate<LayerManager> {\n+    static class AdvanceOnTimeQuanta implements Predicate<LayerManager<TimestampedBloomFilter>> {\n         long quanta;\n \n         AdvanceOnTimeQuanta(long quanta, TimeUnit unit) {\n@@ -47,10 +77,9 @@ static class AdvanceOnTimeQuanta implements Predicate<LayerManager> {\n         }\n \n         @Override\n-        public boolean test(LayerManager lm) {\n+        public boolean test(LayerManager<TimestampedBloomFilter> lm) {\n             // can not use getTarget() as it causes recursion.\n-            TimestampedBloomFilter bf = (TimestampedBloomFilter) lm.get(lm.getDepth() - 1);\n-            return bf.timestamp + quanta < System.currentTimeMillis();\n+            return lm.last().timestamp + quanta < System.currentTimeMillis();\n         }\n     }\n \n@@ -58,7 +87,7 @@ public boolean test(LayerManager lm) {\n      * A Consumer that cleans the list based on how long each filters has been in\n      * the list.\n      */\n-    static class CleanByTime implements Consumer<LinkedList<BloomFilter>> {\n+    static class CleanByTime<T extends TimestampedBloomFilter> implements Consumer<List<T>> {\n         long elapsedTime;\n \n         CleanByTime(long duration, TimeUnit unit) {\n@@ -66,13 +95,18 @@ static class CleanByTime implements Consumer<LinkedList<BloomFilter>> {\n         }\n \n         @Override\n-        public void accept(LinkedList<BloomFilter> t) {\n+        public void accept(List<T> t) {\n             long min = System.currentTimeMillis() - elapsedTime;\n-            while (!t.isEmpty() && ((TimestampedBloomFilter) t.getFirst()).getTimestamp() < min) {\n-                TimestampedBloomFilter bf = (TimestampedBloomFilter) t.getFirst();\n-                dbgInstrument.add(String.format(\"Removing old entry: T:%s (Aged: %s) \\n\", bf.getTimestamp(),\n-                        (min - bf.getTimestamp())));\n-                t.removeFirst();\n+            Iterator<T> iter = t.iterator();\n+            while (iter.hasNext()) {\n+                TimestampedBloomFilter bf = iter.next();\n+                if (bf.getTimestamp() < min) {\n+                    dbgInstrument.add(String.format(\"Removing old entry: T:%s (Aged: %s) \\n\", bf.getTimestamp(),\n+                            (min - bf.getTimestamp())));\n+                    iter.remove();\n+                } else {\n+                    return;\n+                }\n             }\n         }\n     }\n@@ -80,7 +114,7 @@ public void accept(LinkedList<BloomFilter> t) {\n     /**\n      * A Bloomfilter implementation that tracks the creation time.\n      */\n-    static class TimestampedBloomFilter extends WrappedBloomFilter {\n+    public static class TimestampedBloomFilter extends WrappedBloomFilter {\n         final long timestamp;\n \n         TimestampedBloomFilter(BloomFilter bf) {\n@@ -88,13 +122,23 @@ static class TimestampedBloomFilter extends WrappedBloomFilter {\n             this.timestamp = System.currentTimeMillis();\n         }\n \n+        TimestampedBloomFilter(BloomFilter bf, long timestamp) {\n+            super(bf);\n+            this.timestamp = timestamp;\n+        }\n+\n         public long getTimestamp() {\n             return timestamp;\n         }\n+\n+        @Override\n+        public TimestampedBloomFilter copy() {\n+            return new TimestampedBloomFilter(this.getWrapped().copy(), timestamp);\n+        }\n     }\n \n     // ***example of instrumentation ***\n-    private static List<String> dbgInstrument = new ArrayList<>();\n+    private static final List<String> dbgInstrument = new ArrayList<>();\n \n     /**\n      * Creates a LayeredBloomFilter that retains enclosed filters for\n@@ -109,19 +153,21 @@ public long getTimestamp() {\n      * @param qUnit    the unit of time to apply to quanta.\n      * @return LayeredBloomFilter with the above properties.\n      */\n-    static LayeredBloomFilter createTimedLayeredFilter(Shape shape, long duration, TimeUnit dUnit, long quanta,\n+    static LayeredBloomFilter<TimestampedBloomFilter> createTimedLayeredFilter(Shape shape, long duration, TimeUnit dUnit, long quanta,\n             TimeUnit qUnit) {\n-        LayerManager layerManager = LayerManager.builder()\n+        LayerManager.Builder<TimestampedBloomFilter> builder = LayerManager.builder();\n+        Consumer<Deque<TimestampedBloomFilter>> cleanup = Cleanup.removeEmptyTarget().andThen(new CleanByTime(duration, dUnit));\n+        LayerManager<TimestampedBloomFilter> layerManager = builder\n                 .setSupplier(() -> new TimestampedBloomFilter(new SimpleBloomFilter(shape)))\n-                .setCleanup(Cleanup.removeEmptyTarget().andThen(new CleanByTime(duration, dUnit)))\n+                .setCleanup(cleanup)\n                 .setExtendCheck(new AdvanceOnTimeQuanta(quanta, qUnit)\n                         .or(LayerManager.ExtendCheck.advanceOnSaturation(shape.estimateMaxN())))\n                 .build();\n-        return new LayeredBloomFilter(shape, layerManager);\n+        return new LayeredBloomFilter<>(shape, layerManager);\n     }\n \n     // instrumentation to record timestamps in dbgInstrument list\n-    private Predicate<BloomFilter> dbg = (bf) -> {\n+    private final Predicate<BloomFilter> dbg = (bf) -> {\n         TimestampedBloomFilter tbf = (TimestampedBloomFilter) bf;\n         long ts = System.currentTimeMillis();\n         dbgInstrument.add(String.format(\"T:%s (Elapsed:%s)- EstN:%s (Card:%s)\\n\", tbf.timestamp, ts - tbf.timestamp,\n@@ -131,8 +177,8 @@ static LayeredBloomFilter createTimedLayeredFilter(Shape shape, long duration, T\n     // *** end of instrumentation ***\n \n     @Override\n-    protected LayeredBloomFilter createEmptyFilter(Shape shape) {\n-        return LayeredBloomFilter.fixed(shape, 10);\n+    protected LayeredBloomFilter<BloomFilter> createEmptyFilter(Shape shape) {\n+        return LayeredBloomFilterTest.fixed(shape, 10);\n     }\n \n     protected BloomFilter makeFilter(Hasher h) {\n@@ -151,8 +197,8 @@ protected BloomFilter makeFilter(int... values) {\n         return makeFilter(IndexProducer.fromIndexArray(values));\n     }\n \n-    private LayeredBloomFilter setupFindTest() {\n-        LayeredBloomFilter filter = LayeredBloomFilter.fixed(getTestShape(), 10);\n+    private LayeredBloomFilter<BloomFilter> setupFindTest() {\n+        LayeredBloomFilter<BloomFilter> filter = LayeredBloomFilterTest.fixed(getTestShape(), 10);\n         filter.merge(TestingHashers.FROM1);\n         filter.merge(TestingHashers.FROM11);\n         filter.merge(new IncrementingHasher(11, 2));\n@@ -163,9 +209,9 @@ private LayeredBloomFilter setupFindTest() {\n     @Override\n     @Test\n     public void testCardinalityAndIsEmpty() {\n-        LayerManager layerManager = LayerManager.builder().setExtendCheck(ExtendCheck.neverAdvance())\n+        LayerManager<BloomFilter> layerManager = LayerManager.builder().setExtendCheck(ExtendCheck.neverAdvance())\n                 .setSupplier(() -> new SimpleBloomFilter(getTestShape())).build();\n-        testCardinalityAndIsEmpty(new LayeredBloomFilter(getTestShape(), layerManager));\n+        testCardinalityAndIsEmpty(new LayeredBloomFilter<>(getTestShape(), layerManager));\n     }\n \n     /**\n@@ -194,7 +240,7 @@ public void testExpiration() throws InterruptedException {\n \n         // create a filter that removes filters that are 4 seconds old\n         // and quantises time to 1 second intervals.\n-        LayeredBloomFilter underTest = createTimedLayeredFilter(shape, 600, TimeUnit.MILLISECONDS, 150,\n+        LayeredBloomFilter<TimestampedBloomFilter> underTest = createTimedLayeredFilter(shape, 600, TimeUnit.MILLISECONDS, 150,\n                 TimeUnit.MILLISECONDS);\n \n         for (int i = 0; i < 10; i++) {\n@@ -226,7 +272,7 @@ public void testExpiration() throws InterruptedException {\n     }\n     @Test\n     public void testFindBitMapProducer() {\n-        LayeredBloomFilter filter = setupFindTest();\n+        LayeredBloomFilter<BloomFilter> filter = setupFindTest();\n \n         IndexProducer idxProducer = TestingHashers.FROM1.indices(getTestShape());\n         BitMapProducer producer = BitMapProducer.fromIndexProducer(idxProducer, getTestShape().getNumberOfBits());\n@@ -244,7 +290,7 @@ public void testFindBitMapProducer() {\n \n     @Test\n     public void testFindBloomFilter() {\n-        LayeredBloomFilter filter = setupFindTest();\n+        LayeredBloomFilter<BloomFilter> filter = setupFindTest();\n         int[] expected = {0, 3};\n         int[] result = filter.find(TestingHashers.FROM1);\n         assertArrayEquals(expected, result);\n@@ -256,7 +302,7 @@ public void testFindBloomFilter() {\n     @Test\n     public void testFindIndexProducer() {\n         IndexProducer producer = TestingHashers.FROM1.indices(getTestShape());\n-        LayeredBloomFilter filter = setupFindTest();\n+        LayeredBloomFilter<BloomFilter> filter = setupFindTest();\n \n         int[] expected = {0, 3};\n         int[] result = filter.find(producer);\n@@ -272,7 +318,7 @@ public void testFindIndexProducer() {\n     public final void testGetLayer() {\n         BloomFilter bf = new SimpleBloomFilter(getTestShape());\n         bf.merge(TestingHashers.FROM11);\n-        LayeredBloomFilter filter = LayeredBloomFilter.fixed(getTestShape(), 10);\n+        LayeredBloomFilter<BloomFilter> filter = LayeredBloomFilterTest.fixed(getTestShape(), 10);\n         filter.merge(TestingHashers.FROM1);\n         filter.merge(TestingHashers.FROM11);\n         filter.merge(new IncrementingHasher(11, 2));\n@@ -282,7 +328,7 @@ public final void testGetLayer() {\n \n     @Test\n     public void testMultipleFilters() {\n-        LayeredBloomFilter filter = LayeredBloomFilter.fixed(getTestShape(), 10);\n+        LayeredBloomFilter<BloomFilter> filter = LayeredBloomFilterTest.fixed(getTestShape(), 10);\n         filter.merge(TestingHashers.FROM1);\n         filter.merge(TestingHashers.FROM11);\n         assertEquals(2, filter.getDepth());\n@@ -296,10 +342,10 @@ public void testMultipleFilters() {\n \n     @Test\n     public final void testNext() {\n-        LayerManager layerManager = LayerManager.builder().setSupplier(() -> new SimpleBloomFilter(getTestShape()))\n+        LayerManager<BloomFilter> layerManager = LayerManager.builder().setSupplier(() -> new SimpleBloomFilter(getTestShape()))\n                 .build();\n \n-        LayeredBloomFilter filter = new LayeredBloomFilter(getTestShape(), layerManager);\n+        LayeredBloomFilter<BloomFilter> filter = new LayeredBloomFilter<>(getTestShape(), layerManager);\n         filter.merge(TestingHashers.FROM1);\n         filter.merge(TestingHashers.FROM11);\n         assertEquals(1, filter.getDepth());\n@@ -345,4 +391,19 @@ public void testCleanup() {\n         f = (NumberedBloomFilter) underTest.get(0);\n         assertEquals(3, f.sequence);  // it is a new one.\n     }\n+\n+    static class NumberedBloomFilter extends WrappedBloomFilter {\n+        int value;\n+        int sequence;\n+        NumberedBloomFilter(Shape shape, int value, int sequence) {\n+            super(new SimpleBloomFilter(shape));\n+            this.value = value;\n+            this.sequence = sequence;\n+        }\n+\n+        @Override\n+        public BloomFilter copy() {\n+            return new NumberedBloomFilter(getShape(), value, sequence);\n+        }\n+    }\n }\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/WrappedBloomFilterTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/WrappedBloomFilterTest.java\nindex eca4a21a3b..5e346b95a2 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/WrappedBloomFilterTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/WrappedBloomFilterTest.java\n@@ -26,6 +26,12 @@ public class WrappedBloomFilterTest extends AbstractBloomFilterTest<WrappedBloom\n     @Override\n     protected WrappedBloomFilter createEmptyFilter(Shape shape) {\n         return new WrappedBloomFilter(new DefaultBloomFilterTest.SparseDefaultBloomFilter(shape)) {\n+            @Override\n+            public BloomFilter copy() {\n+                BloomFilter result = new DefaultBloomFilterTest.SparseDefaultBloomFilter(shape);\n+                result.merge(this.getWrapped());\n+                return result;\n+            }\n         };\n     }\n \n@@ -39,7 +45,14 @@ public int characteristics() {\n                 return characteristics;\n             }\n         };\n-        WrappedBloomFilter underTest = new WrappedBloomFilter(inner) {};\n+        WrappedBloomFilter underTest = new WrappedBloomFilter(inner) {\n+            @Override\n+            public BloomFilter copy() {\n+                BloomFilter result = new DefaultBloomFilterTest.SparseDefaultBloomFilter(shape);\n+                result.merge(this.getWrapped());\n+                return result;\n+            }\n+        };\n         assertEquals(characteristics, underTest.characteristics());\n     }\n }\n",
  "problem_statement" : "[COLLECTIONS-853] Change LayerManager to use List and added generics to LayerdedBloomFilter\n\nChanges to the is code:\r\n\r\n1. Added generics to LayeredBloomFilter and LayerManager so that the implementation of the enclosed Bloom filter can be specified.\r\n2. Modified WrappedBloomfFilter to require copy() implementation.\r\n3.  Changed the LayerManager internal LinkedList declaration to List.",
  "hints_text" : null,
  "created_at" : "Thu Apr 25 08:16:31 CEST 2024",
  "version" : null,
  "FAIL_TO_PASS" : [ "LayeredBloomFilterTest", "BitMapProducerFromWrappedBloomFilterTest", "BitMapProducerFromLayeredBloomFilterTest", "LayerManagerTest", "CellProducerFromLayeredBloomFilterTest", "WrappedBloomFilterTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=LayeredBloomFilterTest,BitMapProducerFromWrappedBloomFilterTest,BitMapProducerFromLayeredBloomFilterTest,LayerManagerTest,CellProducerFromLayeredBloomFilterTest,WrappedBloomFilterTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 481,
  "metadata" : null
}, {
  "instance_id" : "apache-commons-collections-PR-476",
  "repo" : "apache/commons-collections",
  "base_commit" : "de7c51e3093fad1a56318f7612952b9c2d1fa3f2",
  "patch" : "diff --git a/src/main/java/org/apache/commons/collections4/bloomfilter/LayerManager.java b/src/main/java/org/apache/commons/collections4/bloomfilter/LayerManager.java\nindex a80d3c4ccf..b139d16ced 100644\n--- a/src/main/java/org/apache/commons/collections4/bloomfilter/LayerManager.java\n+++ b/src/main/java/org/apache/commons/collections4/bloomfilter/LayerManager.java\n@@ -82,7 +82,7 @@ public LayerManager build() {\n          *\n          * @param cleanup the Consumer that will modify the list of filters removing out\n          *                dated or stale filters.\n-         * @return this for chaining.\n+         * @return this\n          */\n         public Builder setCleanup(Consumer<LinkedList<BloomFilter>> cleanup) {\n             this.cleanup = cleanup;\n@@ -375,9 +375,23 @@ public final BloomFilter getTarget() {\n      * Ths method is used within {@link #getTarget()} when the configured\n      * {@code ExtendCheck} returns {@code true}.\n      * </p>\n+     * @see LayerManager.Builder#setExtendCheck(Predicate)\n+     * @see LayerManager.Builder#setCleanup(Consumer)\n      */\n     void next() {\n         this.filterCleanup.accept(filters);\n         addFilter();\n     }\n+\n+    /**\n+     * Forces execution the configured cleanup without creating a new filter except in cases\n+     * where the cleanup removes all the layers.\n+     * @see LayerManager.Builder#setCleanup(Consumer)\n+     */\n+    void cleanup() {\n+        this.filterCleanup.accept(filters);\n+        if (filters.isEmpty()) {\n+            addFilter();\n+        }\n+    }\n }\ndiff --git a/src/main/java/org/apache/commons/collections4/bloomfilter/LayeredBloomFilter.java b/src/main/java/org/apache/commons/collections4/bloomfilter/LayeredBloomFilter.java\nindex 01e32d8b6d..9ed2688bbc 100644\n--- a/src/main/java/org/apache/commons/collections4/bloomfilter/LayeredBloomFilter.java\n+++ b/src/main/java/org/apache/commons/collections4/bloomfilter/LayeredBloomFilter.java\n@@ -369,12 +369,24 @@ public boolean merge(IndexProducer indexProducer) {\n     }\n \n     /**\n-     * Forces and advance to the next layer. Executes the same logic as when\n-     * LayerManager.extendCheck returns {@code true}\n+     * Forces and advance to the next layer. This method will clean-up the current\n+     * layers and generate a new filter layer. In most cases is it unnecessary to\n+     * call this method directly.\n      *\n-     * @see LayerManager\n+     * @see LayerManager.Builder#setCleanup(java.util.function.Consumer)\n+     * @see LayerManager.Builder#setExtendCheck(Predicate)\n      */\n     public void next() {\n         layerManager.next();\n     }\n+\n+    /**\n+     * Forces the execution of the cleanup Consumer that was provided when the associated LayerManager\n+     * was built.\n+     *\n+     * @see LayerManager.Builder#setCleanup(java.util.function.Consumer)\n+     */\n+    public void cleanup() {\n+        layerManager.cleanup();\n+    }\n }\n",
  "test_patch" : "diff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/LayerManagerTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/LayerManagerTest.java\nindex 679f263e35..4ee438b89f 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/LayerManagerTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/LayerManagerTest.java\n@@ -291,4 +291,13 @@ public void testTarget() {\n         assertEquals(2, supplierCount[0]);\n     }\n \n+    static class NumberedBloomFilter extends WrappedBloomFilter {\n+        int value;\n+        int sequence;\n+        NumberedBloomFilter(Shape shape, int value, int sequence) {\n+            super(new SimpleBloomFilter(shape));\n+            this.value = value;\n+            this.sequence = sequence;\n+        }\n+    }\n }\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/LayeredBloomFilterTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/LayeredBloomFilterTest.java\nindex bd4e59ca9b..0859e58c65 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/LayeredBloomFilterTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/LayeredBloomFilterTest.java\n@@ -16,6 +16,7 @@\n  */\n package org.apache.commons.collections4.bloomfilter;\n \n+import static org.junit.Assert.assertEquals;\n import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n import static org.junit.jupiter.api.Assertions.assertEquals;\n import static org.junit.jupiter.api.Assertions.assertFalse;\n@@ -30,6 +31,7 @@\n \n import org.apache.commons.collections4.bloomfilter.LayerManager.Cleanup;\n import org.apache.commons.collections4.bloomfilter.LayerManager.ExtendCheck;\n+import org.apache.commons.collections4.bloomfilter.LayerManagerTest.NumberedBloomFilter;\n import org.junit.jupiter.api.Test;\n \n public class LayeredBloomFilterTest extends AbstractBloomFilterTest<LayeredBloomFilter> {\n@@ -311,4 +313,36 @@ public final void testNext() {\n         assertFalse(filter.get(1).contains(TestingHashers.FROM11));\n         assertTrue(filter.get(1).contains(new IncrementingHasher(11, 2)));\n     }\n+\n+    @Test\n+    public void testCleanup() {\n+        int[] sequence = {1};\n+        LayerManager layerManager = LayerManager.builder()\n+                .setSupplier(() -> new NumberedBloomFilter(getTestShape(), 3, sequence[0]++))\n+                .setExtendCheck(ExtendCheck.neverAdvance())\n+                .setCleanup(ll -> ll.removeIf( f -> (((NumberedBloomFilter) f).value-- == 0))).build();\n+        LayeredBloomFilter underTest = new LayeredBloomFilter(getTestShape(), layerManager );\n+        assertEquals(1, underTest.getDepth());\n+        underTest.merge(TestingHashers.randomHasher());\n+        underTest.cleanup(); // first count == 2\n+        assertEquals(1, underTest.getDepth());\n+        underTest.next(); // first count == 1\n+        assertEquals(2, underTest.getDepth());\n+        underTest.merge(TestingHashers.randomHasher());\n+        underTest.cleanup(); // first count == 0\n+        NumberedBloomFilter f = (NumberedBloomFilter) underTest.get(0);\n+        assertEquals(1, f.sequence);\n+\n+        assertEquals(2, underTest.getDepth());\n+        underTest.cleanup(); // should be removed ; second is now 1st with value 1\n+        assertEquals(1, underTest.getDepth());\n+        f = (NumberedBloomFilter) underTest.get(0);\n+        assertEquals(2, f.sequence);\n+\n+        underTest.cleanup(); // first count == 0\n+        underTest.cleanup(); // should be removed.  But there is always at least one\n+        assertEquals(1, underTest.getDepth());\n+        f = (NumberedBloomFilter) underTest.get(0);\n+        assertEquals(3, f.sequence);  // it is a new one.\n+    }\n }\n",
  "problem_statement" : "[COLLECTIONS-852] Add layerd bloom filter clean method\n\nProvides a method to call the LayerManager cleanup consumer without adding additional layers to the LayeredBloomFilter.\r\n\r\nfix for [COLLECTIONS-852](https://issues.apache.org/jira/browse/COLLECTIONS-852)\r\n",
  "hints_text" : null,
  "created_at" : "Fri Apr 12 13:42:23 CEST 2024",
  "version" : null,
  "FAIL_TO_PASS" : [ "LayeredBloomFilterTest", "LayerManagerTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=LayeredBloomFilterTest,LayerManagerTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 476,
  "metadata" : null
}, {
  "instance_id" : "apache-commons-collections-PR-406",
  "repo" : "apache/commons-collections",
  "base_commit" : "14215e5bdd1aeea699da63ff2b2a6b7d2c663bef",
  "patch" : "diff --git a/src/main/java/org/apache/commons/collections4/bloomfilter/ArrayCountingBloomFilter.java b/src/main/java/org/apache/commons/collections4/bloomfilter/ArrayCountingBloomFilter.java\nindex 21d7ce7c9e..5fa0296f84 100644\n--- a/src/main/java/org/apache/commons/collections4/bloomfilter/ArrayCountingBloomFilter.java\n+++ b/src/main/java/org/apache/commons/collections4/bloomfilter/ArrayCountingBloomFilter.java\n@@ -23,17 +23,16 @@\n import java.util.stream.IntStream;\n \n /**\n- * A counting Bloom filter using an int array to track counts for each enabled bit\n- * index.\n+ * A counting Bloom filter using an int array to track cells for each enabled bit.\n  *\n  * <p>Any operation that results in negative counts or integer overflow of\n  * counts will mark this filter as invalid. This transition is not reversible.\n  * The operation is completed in full, no exception is raised and the state is\n- * set to invalid. This allows the counts for the filter immediately prior to the\n+ * set to invalid. This allows the cells for the filter immediately prior to the\n  * operation that created the invalid state to be recovered. See the documentation\n  * in {@link #isValid()} for details.</p>\n  *\n- * <p>All the operations in the filter assume the counts are currently valid,\n+ * <p>All the operations in the filter assume the cells are currently valid,\n  * for example {@code cardinality} or {@code contains} operations. Behavior of an invalid\n  * filter is undefined. It will no longer function identically to a standard\n  * Bloom filter that is the merge of all the Bloom filters that have been added\n@@ -47,6 +46,7 @@\n  * consumption of approximately 8 GB.\n  *\n  * @see Shape\n+ * @see CellProducer\n  * @since 4.5\n  */\n public final class ArrayCountingBloomFilter implements CountingBloomFilter {\n@@ -57,30 +57,30 @@ public final class ArrayCountingBloomFilter implements CountingBloomFilter {\n     private final Shape shape;\n \n     /**\n-     * The count of each bit index in the filter.\n+     * The cell for each bit index in the filter.\n      */\n-    private final int[] counts;\n+    private final int[] cells;\n \n     /**\n      * The state flag. This is a bitwise @{code OR} of the entire history of all updated\n-     * counts. If negative then a negative count or integer overflow has occurred on\n-     * one or more counts in the history of the filter and the state is invalid.\n+     * cells. If negative then a negative cell or integer overflow has occurred on\n+     * one or more cells in the history of the filter and the state is invalid.\n      *\n      * <p>Maintenance of this state flag is branch-free for improved performance. It\n-     * eliminates a conditional check for a negative count during remove/subtract\n+     * eliminates a conditional check for a negative cell during remove/subtract\n      * operations and a conditional check for integer overflow during merge/add\n      * operations.</p>\n      *\n-     * <p>Note: Integer overflow is unlikely in realistic usage scenarios. A count\n+     * <p>Note: Integer overflow is unlikely in realistic usage scenarios. A cell\n      * that overflows indicates that the number of items in the filter exceeds the\n      * maximum possible size (number of bits) of any Bloom filter constrained by\n      * integer indices. At this point the filter is most likely full (all bits are\n      * non-zero) and thus useless.</p>\n      *\n-     * <p>Negative counts are a concern if the filter is used incorrectly by\n+     * <p>Negative cells are a concern if the filter is used incorrectly by\n      * removing an item that was never added. It is expected that a user of a\n      * counting Bloom filter will not perform this action as it is a mistake.\n-     * Enabling an explicit recovery path for negative or overflow counts is a major\n+     * Enabling an explicit recovery path for negative or overflow cells is a major\n      * performance burden not deemed necessary for the unlikely scenarios when an\n      * invalid state is created. Maintenance of the state flag is a concession to\n      * flag improper use that should not have a major performance impact.</p>\n@@ -96,18 +96,23 @@ public final class ArrayCountingBloomFilter implements CountingBloomFilter {\n     public ArrayCountingBloomFilter(final Shape shape) {\n         Objects.requireNonNull(shape, \"shape\");\n         this.shape = shape;\n-        counts = new int[shape.getNumberOfBits()];\n+        cells = new int[shape.getNumberOfBits()];\n     }\n \n     private ArrayCountingBloomFilter(final ArrayCountingBloomFilter source) {\n         this.shape = source.shape;\n         this.state = source.state;\n-        this.counts = source.counts.clone();\n+        this.cells = source.cells.clone();\n     }\n \n     @Override\n     public void clear() {\n-        Arrays.fill(counts, 0);\n+        Arrays.fill(cells, 0);\n+    }\n+\n+    @Override\n+    public int getMaxCell() {\n+        return Integer.MAX_VALUE;\n     }\n \n     @Override\n@@ -122,20 +127,20 @@ public int characteristics() {\n \n     @Override\n     public int cardinality() {\n-        return (int) IntStream.range(0, counts.length).filter(i -> counts[i] > 0).count();\n+        return (int) IntStream.range(0, cells.length).filter(i -> cells[i] > 0).count();\n     }\n \n     @Override\n-    public boolean add(final BitCountProducer other) {\n+    public boolean add(final CellProducer other) {\n         Objects.requireNonNull(other, \"other\");\n-        other.forEachCount(this::add);\n+        other.forEachCell(this::add);\n         return isValid();\n     }\n \n     @Override\n-    public boolean subtract(final BitCountProducer other) {\n+    public boolean subtract(final CellProducer other) {\n         Objects.requireNonNull(other, \"other\");\n-        other.forEachCount(this::subtract);\n+        other.forEachCell(this::subtract);\n         return isValid();\n     }\n \n@@ -146,12 +151,12 @@ public boolean subtract(final BitCountProducer other) {\n      *\n      * <p>The state transition to invalid is permanent.</p>\n      *\n-     * <p>This implementation does not correct negative counts to zero or integer\n-     * overflow counts to {@link Integer#MAX_VALUE}. Thus the operation that\n-     * generated invalid counts can be reversed by using the complement of the\n-     * original operation with the same Bloom filter. This will restore the counts\n-     * to the state prior to the invalid operation. Counts can then be extracted\n-     * using {@link #forEachCount(BitCountConsumer)}.</p>\n+     * <p>This implementation does not correct negative cells to zero or integer\n+     * overflow cells to {@link Integer#MAX_VALUE}. Thus the operation that\n+     * generated invalid cells can be reversed by using the complement of the\n+     * original operation with the same Bloom filter. This will restore the cells\n+     * to the state prior to the invalid operation. Cells can then be extracted\n+     * using {@link #forEachCell(CellConsumer)}.</p>\n      */\n     @Override\n     public boolean isValid() {\n@@ -159,10 +164,10 @@ public boolean isValid() {\n     }\n \n     @Override\n-    public boolean forEachCount(final BitCountProducer.BitCountConsumer consumer) {\n+    public boolean forEachCell(final CellProducer.CellConsumer consumer) {\n         Objects.requireNonNull(consumer, \"consumer\");\n-        for (int i = 0; i < counts.length; i++) {\n-            if (counts[i] != 0 && !consumer.test(i, counts[i])) {\n+        for (int i = 0; i < cells.length; i++) {\n+            if (cells[i] != 0 && !consumer.test(i, cells[i])) {\n                 return false;\n             }\n         }\n@@ -172,8 +177,8 @@ public boolean forEachCount(final BitCountProducer.BitCountConsumer consumer) {\n     @Override\n     public boolean forEachIndex(final IntPredicate consumer) {\n         Objects.requireNonNull(consumer, \"consumer\");\n-        for (int i = 0; i < counts.length; i++) {\n-            if (counts[i] != 0 && !consumer.test(i)) {\n+        for (int i = 0; i < cells.length; i++) {\n+            if (cells[i] != 0 && !consumer.test(i)) {\n                 return false;\n             }\n         }\n@@ -183,14 +188,14 @@ public boolean forEachIndex(final IntPredicate consumer) {\n     @Override\n     public boolean forEachBitMap(final LongPredicate consumer) {\n         Objects.requireNonNull(consumer, \"consumer\");\n-        final int blocksm1 = BitMap.numberOfBitMaps(counts.length) - 1;\n+        final int blocksm1 = BitMap.numberOfBitMaps(cells.length) - 1;\n         int i = 0;\n         long value;\n         // must break final block separate as the number of bits may not fall on the long boundary\n         for (int j = 0; j < blocksm1; j++) {\n             value = 0;\n             for (int k = 0; k < Long.SIZE; k++) {\n-                if (counts[i++] != 0) {\n+                if (cells[i++] != 0) {\n                     value |= BitMap.getLongBit(k);\n                 }\n             }\n@@ -200,8 +205,8 @@ public boolean forEachBitMap(final LongPredicate consumer) {\n         }\n         // Final block\n         value = 0;\n-        for (int k = 0; i < counts.length; k++) {\n-            if (counts[i++] != 0) {\n+        for (int k = 0; i < cells.length; k++) {\n+            if (cells[i++] != 0) {\n                 value |= BitMap.getLongBit(k);\n             }\n         }\n@@ -209,31 +214,41 @@ public boolean forEachBitMap(final LongPredicate consumer) {\n     }\n \n     /**\n-     * Add to the count for the bit index.\n+     * Add to the cell for the bit index.\n      *\n      * @param idx the index\n      * @param addend the amount to add\n      * @return {@code true} always.\n      */\n     private boolean add(final int idx, final int addend) {\n-        final int updated = counts[idx] + addend;\n-        state |= updated;\n-        counts[idx] = updated;\n-        return true;\n+        try {\n+            final int updated = cells[idx] + addend;\n+            state |= updated;\n+            cells[idx] = updated;\n+            return true;\n+        } catch (final IndexOutOfBoundsException e) {\n+            throw new IllegalArgumentException(\n+                    String.format(\"Filter only accepts values in the [0,%d) range\", getShape().getNumberOfBits()), e);\n+        }\n     }\n \n     /**\n-     * Subtract from the count for the bit index.\n+     * Subtract from the cell for the bit index.\n      *\n      * @param idx the index\n      * @param subtrahend the amount to subtract\n      * @return {@code true} always.\n      */\n     private boolean subtract(final int idx, final int subtrahend) {\n-        final int updated = counts[idx] - subtrahend;\n-        state |= updated;\n-        counts[idx] = updated;\n-        return true;\n+        try {\n+            final int updated = cells[idx] - subtrahend;\n+            state |= updated;\n+            cells[idx] = updated;\n+            return true;\n+        } catch (final IndexOutOfBoundsException e) {\n+            throw new IllegalArgumentException(\n+                    String.format(\"Filter only accepts values in the [0,%d) range\", getShape().getNumberOfBits()), e);\n+        }\n     }\n \n     @Override\n@@ -243,7 +258,7 @@ public Shape getShape() {\n \n     @Override\n     public boolean contains(final IndexProducer indexProducer) {\n-        return indexProducer.forEachIndex(idx -> this.counts[idx] != 0);\n+        return indexProducer.forEachIndex(idx -> this.cells[idx] != 0);\n     }\n \n     @Override\n@@ -253,6 +268,19 @@ public boolean contains(final BitMapProducer bitMapProducer) {\n \n     @Override\n     public int[] asIndexArray() {\n-        return IntStream.range(0, counts.length).filter(i -> counts[i] > 0).toArray();\n+        return IntStream.range(0, cells.length).filter(i -> cells[i] > 0).toArray();\n+    }\n+\n+    @Override\n+    public int getMaxInsert(CellProducer cellProducer) {\n+        int[] max = {Integer.MAX_VALUE};\n+        cellProducer.forEachCell( (x, y) -> {\n+            int count = cells[x] / y;\n+            if (count < max[0]) {\n+                max[0] = count;\n+            }\n+            return max[0] > 0;\n+        });\n+        return max[0];\n     }\n }\ndiff --git a/src/main/java/org/apache/commons/collections4/bloomfilter/BitCountProducer.java b/src/main/java/org/apache/commons/collections4/bloomfilter/BitCountProducer.java\ndeleted file mode 100644\nindex 7ccd8bc924..0000000000\n--- a/src/main/java/org/apache/commons/collections4/bloomfilter/BitCountProducer.java\n+++ /dev/null\n@@ -1,126 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.commons.collections4.bloomfilter;\n-\n-import java.util.function.IntPredicate;\n-\n-/**\n- * Defines a mapping of index to counts.\n- *\n- * <p>Note that a BitCountProducer may return duplicate indices and may be unordered.\n- *\n- * <p>Implementations must guarantee that:\n- *\n- * <ul>\n- * <li>The mapping of index to counts is the combined sum of counts at each index.\n- * <li>For every unique value produced by the IndexProducer there will be at least one matching\n- * index and count produced by the BitCountProducer.\n- * <li>The BitCountProducer will not generate indices that are not output by the IndexProducer.\n- * </ul>\n- *\n- * <p>Note that implementations that do not output duplicate indices for BitCountProducer and\n- * do for IndexProducer, or vice versa, are consistent if the distinct indices from each are\n- * the same.\n- *\n- * <p>For example the mapping [(1,2),(2,3),(3,1)] can be output with many combinations including:\n- * <pre>\n- * [(1,2),(2,3),(3,1)]\n- * [(1,1),(1,1),(2,1),(2,1),(2,1),(3,1)]\n- * [(1,1),(3,1),(1,1),(2,1),(2,1),(2,1)]\n- * [(3,1),(1,1),(2,2),(1,1),(2,1)]\n- * ...\n- * </pre>\n- *\n- * @since 4.5\n- */\n-@FunctionalInterface\n-public interface BitCountProducer extends IndexProducer {\n-\n-    /**\n-     * Performs the given action for each {@code <index, count>} pair where the count is non-zero.\n-     * Any exceptions thrown by the action are relayed to the caller. The consumer is applied to each\n-     * index-count pair, if the consumer returns {@code false} the execution is stopped, {@code false}\n-     * is returned, and no further pairs are processed.\n-     *\n-     * Duplicate indices are not required to be aggregated. Duplicates may be output by the producer as\n-     * noted in the class javadoc.\n-     *\n-     * @param consumer the action to be performed for each non-zero bit count\n-     * @return {@code true} if all count pairs return true from consumer, {@code false} otherwise.\n-     * @throws NullPointerException if the specified consumer is null\n-     */\n-    boolean forEachCount(BitCountConsumer consumer);\n-\n-    /**\n-     * The default implementation returns indices with ordering and uniqueness of {@code forEachCount()}.\n-     */\n-    @Override\n-    default boolean forEachIndex(final IntPredicate predicate) {\n-        return forEachCount((i, v) -> predicate.test(i));\n-    }\n-\n-    /**\n-     * Creates a BitCountProducer from an IndexProducer. The resulting\n-     * producer will return every index from the IndexProducer with a count of 1.\n-     *\n-     * <p>Note that the BitCountProducer does not remove duplicates. Any use of the\n-     * BitCountProducer to create an aggregate mapping of index to counts, such as a\n-     * CountingBloomFilter, should use the same BitCountProducer in both add and\n-     * subtract operations to maintain consistency.\n-     * </p>\n-     * @param idx An index producer.\n-     * @return A BitCountProducer with the same indices as the IndexProducer.\n-     */\n-    static BitCountProducer from(final IndexProducer idx) {\n-        return new BitCountProducer() {\n-            @Override\n-            public boolean forEachCount(final BitCountConsumer consumer) {\n-                return idx.forEachIndex(i -> consumer.test(i, 1));\n-            }\n-\n-            @Override\n-            public int[] asIndexArray() {\n-                return idx.asIndexArray();\n-            }\n-\n-            @Override\n-            public boolean forEachIndex(final IntPredicate predicate) {\n-                return idx.forEachIndex(predicate);\n-            }\n-        };\n-    }\n-\n-    /**\n-     * Represents an operation that accepts an {@code <index, count>} pair representing\n-     * the count for a bit index. Returns {@code true}\n-     * if processing should continue, {@code false} otherwise.\n-     *\n-     * <p>Note: This is a functional interface as a specialization of\n-     * {@link java.util.function.BiPredicate} for {@code int}.</p>\n-     */\n-    @FunctionalInterface\n-    interface BitCountConsumer {\n-        /**\n-         * Performs an operation on the given {@code <index, count>} pair.\n-         *\n-         * @param index the bit index.\n-         * @param count the count at the specified bit index.\n-         * @return {@code true} if processing should continue, {@code false} if processing should stop.\n-         */\n-        boolean test(int index, int count);\n-    }\n-}\ndiff --git a/src/main/java/org/apache/commons/collections4/bloomfilter/BloomFilter.java b/src/main/java/org/apache/commons/collections4/bloomfilter/BloomFilter.java\nindex f51eb081fc..e4783bf3e1 100644\n--- a/src/main/java/org/apache/commons/collections4/bloomfilter/BloomFilter.java\n+++ b/src/main/java/org/apache/commons/collections4/bloomfilter/BloomFilter.java\n@@ -309,4 +309,12 @@ default int estimateIntersection(final BloomFilter other) {\n         }\n         return estimate>Integer.MAX_VALUE?Integer.MAX_VALUE:(int) estimate;\n     }\n+\n+    /**\n+     * Most Bloom filters create unique IndexProducers.\n+     */\n+    @Override\n+    default IndexProducer uniqueIndices() {\n+        return this;\n+    }\n }\ndiff --git a/src/main/java/org/apache/commons/collections4/bloomfilter/CellProducer.java b/src/main/java/org/apache/commons/collections4/bloomfilter/CellProducer.java\nnew file mode 100644\nindex 0000000000..6949a13c64\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/bloomfilter/CellProducer.java\n@@ -0,0 +1,166 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.bloomfilter;\n+\n+import java.util.TreeMap;\n+import java.util.function.IntPredicate;\n+\n+\n+/**\n+ * Some Bloom filter implementations use a count rather than a bit flag. The term {@code Cell} is used to\n+ * refer to these counts and their associated index.  This class is the equivalent of the index producer except\n+ * that it produces cells.\n+ *\n+ * <p>Note that a CellProducer must not return duplicate indices and must be ordered.</p>\n+ *\n+ * <p>Implementations must guarantee that:</p>\n+ *\n+ * <ul>\n+ * <li>The IndexProducer implementation returns unique ordered indices.</li>\n+ * <li>The cells are produced in IndexProducer order.</li>\n+ * <li>For every value produced by the IndexProducer there will be only one matching\n+ * cell produced by the CellProducer.</li>\n+ * <li>The CellProducer will not generate cells with indices that are not output by the IndexProducer.</li>\n+ * <li>The IndexProducer will not generate indices that have a zero count for the cell.</li>\n+ * </ul>\n+ *\n+ * @since 4.5\n+ */\n+@FunctionalInterface\n+public interface CellProducer extends IndexProducer {\n+\n+    /**\n+     * Performs the given action for each {@code cell}  where the cell count is non-zero.\n+     *\n+     * <p>Some Bloom filter implementations use a count rather than a bit flag.  The term {@code Cell} is used to\n+     * refer to these counts.</p>\n+     *\n+     * <p>Any exceptions thrown by the action are relayed to the caller. The consumer is applied to each\n+     * cell. If the consumer returns {@code false} the execution is stopped, {@code false}\n+     * is returned, and no further pairs are processed.</p>\n+     *\n+     * @param consumer the action to be performed for each non-zero cell.\n+     * @return {@code true} if all cells return true from consumer, {@code false} otherwise.\n+     * @throws NullPointerException if the specified consumer is null\n+     */\n+    boolean forEachCell(CellConsumer consumer);\n+\n+    /**\n+     * The default implementation returns distinct and ordered indices for all cells with a non-zero count.\n+     */\n+    @Override\n+    default boolean forEachIndex(final IntPredicate predicate) {\n+        return forEachCell((i, v) -> predicate.test(i));\n+    }\n+\n+    /**\n+     * Creates a CellProducer from an IndexProducer.\n+     *\n+     * <p>Note the following properties:\n+     * <ul>\n+     * <li>Each index returned from the IndexProducer is assumed to have a cell value of 1.</li>\n+     * <li>The CellProducer aggregates duplicate indices from the IndexProducer.</li>\n+     * </ul>\n+     *\n+     * <p>A CellProducer that outputs the mapping [(1,2),(2,3),(3,1)] can be created from many combinations\n+     * of indices including:\n+     * <pre>\n+     * [1, 1, 2, 2, 2, 3]\n+     * [1, 3, 1, 2, 2, 2]\n+     * [3, 2, 1, 2, 1, 2]\n+     * ...\n+     * </pre>\n+     *\n+     * @param producer An index producer.\n+     * @return A CellProducer with the same indices as the IndexProducer.\n+     */\n+    static CellProducer from(final IndexProducer producer) {\n+        return new CellProducer() {\n+            TreeMap<CounterCell, CounterCell> counterCells = new TreeMap<>();\n+\n+            private void populate() {\n+                if (counterCells.isEmpty()) {\n+                    producer.forEachIndex( idx -> {\n+                        CounterCell cell = new CounterCell(idx, 1);\n+                        CounterCell counter = counterCells.get(cell);\n+                        if (counter == null) {\n+                            counterCells.put(cell, cell);\n+                        } else {\n+                            counter.count++;\n+                        }\n+                        return true;\n+                    });\n+                }\n+            }\n+\n+            @Override\n+            public int[] asIndexArray() {\n+                populate();\n+                return counterCells.keySet().stream().mapToInt(c -> c.idx).toArray();\n+            }\n+\n+            @Override\n+            public boolean forEachCell(CellConsumer consumer) {\n+                populate();\n+                for (CounterCell cell : counterCells.values()) {\n+                    if (!consumer.test(cell.idx, cell.count)) {\n+                        return false;\n+                    }\n+                }\n+                return true;\n+            }\n+\n+            /**\n+             * Class to track cell values in the TreeMap.\n+             */\n+            final class CounterCell implements Comparable<CounterCell> {\n+                final int idx;\n+                int count;\n+\n+                CounterCell(int idx, int count) {\n+                    this.idx = idx;\n+                    this.count = count;\n+                }\n+\n+                @Override\n+                public int compareTo(CounterCell other) {\n+                    return Integer.compare(idx, other.idx);\n+                }\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Represents an operation that accepts an {@code <index, count>} pair.\n+     * Returns {@code true} if processing should continue, {@code false} otherwise.\n+     *\n+     * <p>Note: This is a functional interface as a specialization of\n+     * {@link java.util.function.BiPredicate} for {@code int}.</p>\n+     */\n+    @FunctionalInterface\n+    interface CellConsumer {\n+        /**\n+         * Performs an operation on the given {@code <index, count>} pair.\n+         *\n+         * @param index the bit index.\n+         * @param count the cell value at the specified bit index.\n+         * @return {@code true} if processing should continue, {@code false} if processing should stop.\n+         */\n+        boolean test(int index, int count);\n+    }\n+}\n+\ndiff --git a/src/main/java/org/apache/commons/collections4/bloomfilter/CountingBloomFilter.java b/src/main/java/org/apache/commons/collections4/bloomfilter/CountingBloomFilter.java\nindex a86afa1f36..7c9310f406 100644\n--- a/src/main/java/org/apache/commons/collections4/bloomfilter/CountingBloomFilter.java\n+++ b/src/main/java/org/apache/commons/collections4/bloomfilter/CountingBloomFilter.java\n@@ -20,7 +20,8 @@\n \n /**\n  * The interface that describes a Bloom filter that associates a count with each\n- * bit index to allow reversal of merge operations with remove operations.\n+ * bit index rather than a bit.  This allows reversal of merge operations with\n+ * remove operations.\n  *\n  * <p>A counting Bloom filter is expected to function identically to a standard\n  * Bloom filter that is the merge of all the Bloom filters that have been added\n@@ -30,29 +31,30 @@\n  * remove order, is expected to be the same.</p>\n  *\n  * <p>Removal of a filter that has not previously been merged results in an\n- * invalid state where the counts no longer represent a sum of merged Bloom\n+ * invalid state where the cells no longer represent a sum of merged Bloom\n  * filters. It is impossible to validate merge and remove exactly without\n  * explicitly storing all filters. Consequently such an operation may go\n  * undetected. The CountingBloomFilter maintains a state flag that is used as a\n- * warning that an operation was performed that resulted in invalid counts and\n- * thus an invalid state. For example this may occur if a count for an index was\n+ * warning that an operation was performed that resulted in invalid cells and\n+ * thus an invalid state. For example this may occur if a cell for an index was\n  * set to negative following a remove operation.</p>\n  *\n  * <p>Implementations should document the expected state of the filter after an\n- * operation that generates invalid counts, and any potential recovery options.\n+ * operation that generates invalid cells, and any potential recovery options.\n  * An implementation may support a reversal of the operation to restore the\n- * state to that prior to the operation. In the event that invalid counts are\n+ * state to that prior to the operation. In the event that invalid cells are\n  * adjusted to a valid range then it should be documented if there has been\n  * irreversible information loss.</p>\n  *\n  * <p>Implementations may choose to throw an exception during an operation that\n- * generates invalid counts. Implementations should document the expected state\n- * of the filter after such an operation. For example are the counts not updated,\n+ * generates invalid cells. Implementations should document the expected state\n+ * of the filter after such an operation. For example are the cells not updated,\n  * partially updated or updated entirely before the exception is raised.</p>\n  *\n+ * @see CellProducer\n  * @since 4.5\n  */\n-public interface CountingBloomFilter extends BloomFilter, BitCountProducer {\n+public interface CountingBloomFilter extends BloomFilter, CellProducer {\n \n     // Query Operations\n \n@@ -60,9 +62,9 @@ public interface CountingBloomFilter extends BloomFilter, BitCountProducer {\n      * Returns {@code true} if the internal state is valid.\n      *\n      * <p>This flag is a warning that an addition or\n-     * subtraction of counts from this filter resulted in an invalid count for one or more\n-     * indexes. For example this may occur if a count for an index was\n-     * set to negative following a subtraction operation, or overflows an {@code int} following an\n+     * subtraction of cells from this filter resulted in an invalid cell for one or more\n+     * indexes. For example this may occur if a cell for an index was\n+     * set to negative following a subtraction operation, or overflows the value specified by {@code getMaxCell()} following an\n      * addition operation.</p>\n      *\n      * <p>A counting Bloom filter that has an invalid state is no longer ensured to function\n@@ -77,14 +79,81 @@ public interface CountingBloomFilter extends BloomFilter, BitCountProducer {\n      */\n     boolean isValid();\n \n+    /**\n+     * Returns the maximum allowable value for a cell count in this Counting filter.\n+     * @return the maximum allowable value for a cell count in this Counting filter.\n+     */\n+    int getMaxCell();\n+\n+    /**\n+     * Determines the maximum number of times the Bloom filter could have been merged\n+     * into this counting filter.\n+     * @param bloomFilter the Bloom filter the check for.\n+     * @return the maximum number of times the Bloom filter could have been inserted.\n+     */\n+    default int getMaxInsert(BloomFilter bloomFilter) {\n+        return getMaxInsert((BitMapProducer) bloomFilter);\n+    }\n+\n+    /**\n+     * Determines the maximum number of times the IndexProducer could have been merged\n+     * into this counting filter.\n+     * <p>To determine how many times an indxProducer could have been added create a CellProducer\n+     * from the indexProducer and check that</p>\n+     * @param idxProducer the producer to drive the count check.\n+     * @return the maximum number of times the IndexProducer could have been inserted.\n+     * @see #getMaxInsert(CellProducer)\n+     */\n+    default int getMaxInsert(IndexProducer idxProducer) {\n+        return getMaxInsert(CellProducer.from(idxProducer.uniqueIndices()) );\n+    }\n+\n+    /**\n+     * Determines the maximum number of times the Cell Producer could have been add.\n+     * @param cellProducer the producer of cells.\n+     * @return the maximum number of times the CellProducer could have been inserted.\n+     */\n+    int getMaxInsert(CellProducer cellProducer);\n+\n+    /**\n+     * Determines the maximum number of times the Hasher could have been merged into this\n+     * counting filter.\n+     * @param hasher the Hasher to provide the indices.\n+     * @return the maximum number of times the hasher could have been inserted.\n+     */\n+    default int getMaxInsert(Hasher hasher) {\n+        return getMaxInsert(hasher.indices(getShape()));\n+    }\n+\n+    /**\n+     * Determines the maximum number of times the BitMapProducer could have been merged into this\n+     * counting filter.\n+     * @param bitMapProducer the BitMapProducer to provide the indices.\n+     * @return the maximum number of times the BitMapProducer could have been inserted.\n+     */\n+    default int getMaxInsert(BitMapProducer bitMapProducer) {\n+        if (!contains(bitMapProducer)) {\n+            return 0;\n+        }\n+        long[] bitMaps = bitMapProducer.asBitMapArray();\n+        int[] max = { Integer.MAX_VALUE };\n+        forEachCell((x, y) -> {\n+            if ((bitMaps[BitMap.getLongIndex(x)] & BitMap.getLongBit(x)) != 0) {\n+                max[0] = max[0] <= y ? max[0] : y;\n+            }\n+            return true;\n+        });\n+        return max[0];\n+    }\n+\n     // Modification Operations\n \n     /**\n      * Merges the specified Bloom filter into this Bloom filter.\n      *\n-     * <p>Specifically: all counts for the indexes identified by the {@code other} filter will be incremented by 1.</p>\n+     * <p>Specifically: all cells for the indexes identified by the {@code other} filter will be incremented by 1.</p>\n      *\n-     * <p>Note: If the other filter is a counting Bloom filter the index counts are ignored and it is treated as an\n+     * <p>Note: If the other filter is a counting Bloom filter the other filter's cells are ignored and it is treated as an\n      * IndexProducer.</p>\n      *\n      * <p>This method will return {@code true} if the filter is valid after the operation.</p>\n@@ -92,7 +161,7 @@ public interface CountingBloomFilter extends BloomFilter, BitCountProducer {\n      * @param other the other Bloom filter\n      * @return {@code true} if the removal was successful and the state is valid\n      * @see #isValid()\n-     * @see #add(BitCountProducer)\n+     * @see #add(CellProducer)\n      */\n     @Override\n     default boolean merge(final BloomFilter other) {\n@@ -103,40 +172,41 @@ default boolean merge(final BloomFilter other) {\n     /**\n      * Merges the specified Hasher into this Bloom filter.\n      *\n-     * <p>Specifically: all counts for the unique indexes identified by the {@code hasher} will be incremented by 1.</p>\n+     * <p>Specifically: all cells for the unique indexes identified by the {@code hasher} will be incremented by 1.</p>\n      *\n      * <p>This method will return {@code true} if the filter is valid after the operation.</p>\n      *\n      * @param hasher the hasher\n      * @return {@code true} if the removal was successful and the state is valid\n      * @see #isValid()\n-     * @see #add(BitCountProducer)\n+     * @see #add(CellProducer)\n      */\n     @Override\n     default boolean merge(final Hasher hasher) {\n         Objects.requireNonNull(hasher, \"hasher\");\n-        return merge(hasher.uniqueIndices(getShape()));\n+        return merge(hasher.indices(getShape()));\n     }\n \n     /**\n      * Merges the specified index producer into this Bloom filter.\n      *\n-     * <p>Specifically: all counts for the indexes identified by the {@code indexProducer} will be incremented by 1.</p>\n+     * <p>Specifically: all unique cells for the indices identified by the {@code indexProducer} will be incremented by 1.</p>\n      *\n      * <p>This method will return {@code true} if the filter is valid after the operation.</p>\n      *\n-     * <p>Note: Indices that are returned multiple times will be incremented multiple times.</p>\n+     * <p>Note: If indices that are returned multiple times should be incremented multiple times convert the IndexProducer\n+     * to a CellProducer and add that.</p>\n      *\n      * @param indexProducer the IndexProducer\n      * @return {@code true} if the removal was successful and the state is valid\n      * @see #isValid()\n-     * @see #add(BitCountProducer)\n+     * @see #add(CellProducer)\n      */\n     @Override\n     default boolean merge(final IndexProducer indexProducer) {\n         Objects.requireNonNull(indexProducer, \"indexProducer\");\n         try {\n-            return add(BitCountProducer.from(indexProducer));\n+            return add(CellProducer.from(indexProducer.uniqueIndices()));\n         } catch (final IndexOutOfBoundsException e) {\n             throw new IllegalArgumentException(\n                     String.format(\"Filter only accepts values in the [0,%d) range\", getShape().getNumberOfBits()), e);\n@@ -146,14 +216,14 @@ default boolean merge(final IndexProducer indexProducer) {\n     /**\n      * Merges the specified BitMap producer into this Bloom filter.\n      *\n-     * <p>Specifically: all counts for the indexes identified by the {@code bitMapProducer} will be incremented by 1.</p>\n+     * <p>Specifically: all cells for the indexes identified by the {@code bitMapProducer} will be incremented by 1.</p>\n      *\n      * <p>This method will return {@code true} if the filter is valid after the operation.</p>\n      *\n      * @param bitMapProducer the BitMapProducer\n      * @return {@code true} if the removal was successful and the state is valid\n      * @see #isValid()\n-     * @see #add(BitCountProducer)\n+     * @see #add(CellProducer)\n      */\n     @Override\n     default boolean merge(final BitMapProducer bitMapProducer) {\n@@ -164,9 +234,9 @@ default boolean merge(final BitMapProducer bitMapProducer) {\n     /**\n      * Removes the specified Bloom filter from this Bloom filter.\n      *\n-     * <p>Specifically: all counts for the indexes identified by the {@code other} filter will be decremented by 1.</p>\n+     * <p>Specifically: all cells for the indexes identified by the {@code other} filter will be decremented by 1.</p>\n      *\n-     * <p>Note: If the other filter is a counting Bloom filter the index counts are ignored and it is treated as an\n+     * <p>Note: If the other filter is a counting Bloom filter the other filter's cells are ignored and it is treated as an\n      * IndexProducer.</p>\n      *\n      * <p>This method will return {@code true} if the filter is valid after the operation.</p>\n@@ -174,7 +244,7 @@ default boolean merge(final BitMapProducer bitMapProducer) {\n      * @param other the other Bloom filter\n      * @return {@code true} if the removal was successful and the state is valid\n      * @see #isValid()\n-     * @see #subtract(BitCountProducer)\n+     * @see #subtract(CellProducer)\n      */\n     default boolean remove(final BloomFilter other) {\n         Objects.requireNonNull(other, \"other\");\n@@ -184,7 +254,7 @@ default boolean remove(final BloomFilter other) {\n     /**\n      * Removes the unique values from the specified hasher from this Bloom filter.\n      *\n-     * <p>Specifically all counts for the unique indices produced by the {@code hasher} will be\n+     * <p>Specifically all cells for the unique indices produced by the {@code hasher} will be\n      * decremented by 1.</p>\n      *\n      * <p>This method will return {@code true} if the filter is valid after the operation.</p>\n@@ -192,32 +262,33 @@ default boolean remove(final BloomFilter other) {\n      * @param hasher the hasher to provide the indexes\n      * @return {@code true} if the removal was successful and the state is valid\n      * @see #isValid()\n-     * @see #subtract(BitCountProducer)\n+     * @see #subtract(CellProducer)\n      */\n     default boolean remove(final Hasher hasher) {\n         Objects.requireNonNull(hasher, \"hasher\");\n-        return remove(hasher.uniqueIndices(getShape()));\n+        return remove(hasher.indices(getShape()));\n     }\n \n     /**\n      * Removes the values from the specified IndexProducer from the Bloom filter from this Bloom filter.\n      *\n-     * <p>Specifically all counts for the unique indices produced by the {@code hasher} will be\n+     * <p>Specifically all cells for the unique indices produced by the {@code hasher} will be\n      * decremented by 1.</p>\n      *\n      * <p>This method will return {@code true} if the filter is valid after the operation.</p>\n      *\n-     * <p>Node: This method expects index producers that produce unique values.</p>\n+     * <p>Note: If indices that are returned multiple times should be decremented multiple times convert the IndexProducer\n+     * to a CellProducer and subtract that.</p>\n      *\n      * @param indexProducer the IndexProducer to provide the indexes\n      * @return {@code true} if the removal was successful and the state is valid\n      * @see #isValid()\n-     * @see #subtract(BitCountProducer)\n+     * @see #subtract(CellProducer)\n      */\n     default boolean remove(final IndexProducer indexProducer) {\n         Objects.requireNonNull(indexProducer, \"indexProducer\");\n         try {\n-            return subtract(BitCountProducer.from(indexProducer));\n+            return subtract(CellProducer.from(indexProducer.uniqueIndices()));\n         } catch (final IndexOutOfBoundsException e) {\n             throw new IllegalArgumentException(\n                     String.format(\"Filter only accepts values in the [0,%d) range\", getShape().getNumberOfBits()));\n@@ -227,7 +298,7 @@ default boolean remove(final IndexProducer indexProducer) {\n     /**\n      * Removes the specified BitMapProducer from this Bloom filter.\n      *\n-     * <p>Specifically all counts for the indices produced by the {@code bitMapProducer} will be\n+     * <p>Specifically all cells for the indices produced by the {@code bitMapProducer} will be\n      * decremented by 1.</p>\n      *\n      * <p>This method will return {@code true} if the filter is valid after the operation.</p>\n@@ -235,7 +306,7 @@ default boolean remove(final IndexProducer indexProducer) {\n      * @param bitMapProducer the BitMapProducer to provide the indexes\n      * @return {@code true} if the removal was successful and the state is valid\n      * @see #isValid()\n-     * @see #subtract(BitCountProducer)\n+     * @see #subtract(CellProducer)\n      */\n     default boolean remove(final BitMapProducer bitMapProducer) {\n         Objects.requireNonNull(bitMapProducer, \"bitMapProducer\");\n@@ -243,36 +314,36 @@ default boolean remove(final BitMapProducer bitMapProducer) {\n     }\n \n     /**\n-     * Adds the specified BitCountProducer to this Bloom filter.\n+     * Adds the specified CellProducer to this Bloom filter.\n      *\n      * <p>Specifically\n-     * all counts for the indexes identified by the {@code other} will be incremented\n+     * all cells for the indexes identified by the {@code other} will be incremented\n      * by their corresponding values in the {@code other}.</p>\n      *\n      * <p>This method will return {@code true} if the filter is valid after the operation.</p>\n      *\n-     * @param other the BitCountProducer to add.\n+     * @param other the CellProducer to add.\n      * @return {@code true} if the addition was successful and the state is valid\n      * @see #isValid()\n-     * @see #subtract(BitCountProducer)\n+     * @see #subtract(CellProducer)\n      */\n-    boolean add(BitCountProducer other);\n+    boolean add(CellProducer other);\n \n     /**\n-     * Adds the specified BitCountProducer to this Bloom filter.\n+     * Adds the specified CellProducer to this Bloom filter.\n      *\n      * <p>Specifically\n-     * all counts for the indexes identified by the {@code other} will be decremented\n+     * all cells for the indexes identified by the {@code other} will be decremented\n      * by their corresponding values in the {@code other}.</p>\n      *\n      * <p>This method will return true if the filter is valid after the operation.</p>\n      *\n-     * @param other the BitCountProducer to subtract.\n+     * @param other the CellProducer to subtract.\n      * @return {@code true} if the subtraction was successful and the state is valid\n      * @see #isValid()\n-     * @see #add(BitCountProducer)\n+     * @see #add(CellProducer)\n      */\n-    boolean subtract(BitCountProducer other);\n+    boolean subtract(CellProducer other);\n \n \n     /**\n@@ -281,4 +352,9 @@ default boolean remove(final BitMapProducer bitMapProducer) {\n      */\n     @Override\n     CountingBloomFilter copy();\n+\n+    @Override\n+    default IndexProducer uniqueIndices() {\n+        return this;\n+    }\n }\ndiff --git a/src/main/java/org/apache/commons/collections4/bloomfilter/Hasher.java b/src/main/java/org/apache/commons/collections4/bloomfilter/Hasher.java\nindex d8b3a43aa9..5b1b6a127b 100644\n--- a/src/main/java/org/apache/commons/collections4/bloomfilter/Hasher.java\n+++ b/src/main/java/org/apache/commons/collections4/bloomfilter/Hasher.java\n@@ -16,8 +16,6 @@\n  */\n package org.apache.commons.collections4.bloomfilter;\n \n-import java.util.Objects;\n-\n /**\n  * A Hasher creates IndexProducer based on the hash implementation and the\n  * provided Shape.\n@@ -44,21 +42,4 @@ public interface Hasher {\n      * @return the iterator of integers\n      */\n     IndexProducer indices(Shape shape);\n-\n-    /**\n-     * Creates an IndexProducer of unique indices for this hasher based on the Shape.\n-     *\n-     * <p>This is like the `indices(Shape)` method except that it adds the guarantee that no\n-     * duplicate values will be returned. The indices produced are equivalent to those returned\n-     * from by a Bloom filter created from this hasher.</p>\n-     *\n-     * @param shape the shape of the desired Bloom filter.\n-     * @return the iterator of integers\n-     */\n-    default IndexProducer uniqueIndices(final Shape shape) {\n-        return consumer -> {\n-            Objects.requireNonNull(consumer, \"consumer\");\n-            return indices(shape).forEachIndex(IndexFilter.create(shape, consumer));\n-        };\n-    }\n }\ndiff --git a/src/main/java/org/apache/commons/collections4/bloomfilter/IndexFilter.java b/src/main/java/org/apache/commons/collections4/bloomfilter/IndexFilter.java\nindex c7e6ca1861..57f70f5638 100644\n--- a/src/main/java/org/apache/commons/collections4/bloomfilter/IndexFilter.java\n+++ b/src/main/java/org/apache/commons/collections4/bloomfilter/IndexFilter.java\n@@ -72,7 +72,10 @@ public boolean test(final int number) {\n         if (number >= size) {\n             throw new IndexOutOfBoundsException(String.format(\"number too large %d >= %d\", number, size));\n         }\n-        return !tracker.test(number) || consumer.test(number);\n+        if (tracker.test(number)) {\n+            return  consumer.test(number);\n+        }\n+        return true;\n     }\n \n     /**\ndiff --git a/src/main/java/org/apache/commons/collections4/bloomfilter/IndexProducer.java b/src/main/java/org/apache/commons/collections4/bloomfilter/IndexProducer.java\nindex dbaf0908c7..0269d34eac 100644\n--- a/src/main/java/org/apache/commons/collections4/bloomfilter/IndexProducer.java\n+++ b/src/main/java/org/apache/commons/collections4/bloomfilter/IndexProducer.java\n@@ -16,6 +16,7 @@\n  */\n package org.apache.commons.collections4.bloomfilter;\n \n+import java.util.Arrays;\n import java.util.BitSet;\n import java.util.Objects;\n import java.util.function.IntPredicate;\n@@ -107,21 +108,69 @@ public boolean test(long word) {\n      * <p>Indices ordering and uniqueness is not guaranteed.</p>\n      *\n      * <p><em>\n-     * The default implementation of this method is slow. It is recommended\n-     * that implementing classes reimplement this method.\n+     * The default implementation of this method creates an array and populates\n+     * it.  Implementations that have access to an index array should consider\n+     * returning a copy of that array if possible.\n      * </em></p>\n      *\n-     * <p><em>\n-     * The default implementation of this method returns unique values in order.\n-     * </em></p>\n      * @return An int array of the data.\n      */\n     default int[] asIndexArray() {\n-        final BitSet result = new BitSet();\n+        class Indices {\n+            private int[] data = new int[32];\n+            private int size;\n+\n+            boolean add(final int index) {\n+                data = IndexUtils.ensureCapacityForAdd(data, size);\n+                data[size++] = index;\n+                return true;\n+            }\n+\n+            int[] toArray() {\n+                // Edge case to avoid a large array copy\n+                return size == data.length ? data : Arrays.copyOf(data, size);\n+            }\n+        }\n+        Indices indices = new Indices();\n+        forEachIndex(indices::add);\n+        return indices.toArray();\n+    }\n+\n+    /**\n+     * Creates an IndexProducer comprising the unique indices for this producer.\n+     *\n+     * <p>By default creates a new producer with some overhead to remove\n+     * duplicates.  IndexProducers that return unique indices by default\n+     * should override this to return {@code this}.</p>\n+     *\n+     * <p>The default implementation will filter the indices from this instance\n+     * and return them in ascending order.</p>\n+     *\n+     * @return the IndexProducer of unique values.\n+     * @throws IndexOutOfBoundsException if any index is less than zero.\n+     */\n+    default IndexProducer uniqueIndices() {\n+        final BitSet bitSet = new BitSet();\n         forEachIndex(i -> {\n-            result.set(i);\n+            bitSet.set(i);\n             return true;\n         });\n-        return result.stream().toArray();\n+\n+        return new IndexProducer() {\n+            @Override\n+            public boolean forEachIndex(IntPredicate predicate) {\n+                for (int idx = bitSet.nextSetBit(0); idx >= 0; idx = bitSet.nextSetBit(idx + 1)) {\n+                    if (!predicate.test(idx)) {\n+                        return false;\n+                    }\n+                }\n+                return true;\n+            }\n+\n+            @Override\n+            public IndexProducer uniqueIndices() {\n+                return this;\n+            }\n+        };\n     }\n }\ndiff --git a/src/main/java/org/apache/commons/collections4/bloomfilter/IndexUtils.java b/src/main/java/org/apache/commons/collections4/bloomfilter/IndexUtils.java\nnew file mode 100644\nindex 0000000000..96bfefec02\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/bloomfilter/IndexUtils.java\n@@ -0,0 +1,47 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.bloomfilter;\n+\n+import java.util.Arrays;\n+\n+/**\n+ * Provides functions to assist in IndexProducer creation and manipulation.\n+ * @see IndexProducer\n+ */\n+final class IndexUtils {\n+\n+    /**\n+     * The maximum array size for the methods in this class.\n+     */\n+    static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;\n+\n+    // do not instantiate\n+    private IndexUtils() {}\n+\n+    /**\n+     * Ensure the array can add an element at the specified index.\n+     * @param array the array to check.\n+     * @param index the index to add at.\n+     * @return the array or a newly allocated copy of the array.\n+     */\n+    static int[] ensureCapacityForAdd(int[] array, int index) {\n+        if (index >= array.length) {\n+            return Arrays.copyOf(array, (int) Math.min(IndexUtils.MAX_ARRAY_SIZE, Math.max(array.length * 2L, index + 1)));\n+        }\n+        return array;\n+    }\n+}\ndiff --git a/src/main/java/org/apache/commons/collections4/bloomfilter/package-info.java b/src/main/java/org/apache/commons/collections4/bloomfilter/package-info.java\nindex a7fb009540..7df764182d 100644\n--- a/src/main/java/org/apache/commons/collections4/bloomfilter/package-info.java\n+++ b/src/main/java/org/apache/commons/collections4/bloomfilter/package-info.java\n@@ -32,6 +32,9 @@\n  * list. There are lots of other uses, and in most cases the reason is to perform a fast check as a gateway for a longer\n  * operation.</p>\n  *\n+ * <p>Some Bloom filters (e.g. CountingBloomFilter) use counters rather than bits. In this case each counter\n+ * is called a {@code cell}.</p>\n+ *\n  * <h3>BloomFilter</h3>\n  *\n  * <p>The Bloom filter architecture here is designed for speed of execution, so some methods like {@code merge}, {@code remove},\n",
  "test_patch" : "diff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBitCountProducerTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBitCountProducerTest.java\ndeleted file mode 100644\nindex 2a5aa0a622..0000000000\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBitCountProducerTest.java\n+++ /dev/null\n@@ -1,168 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.commons.collections4.bloomfilter;\n-\n-import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n-import static org.junit.jupiter.api.Assertions.assertFalse;\n-import static org.junit.jupiter.api.Assertions.assertTrue;\n-import static org.junit.jupiter.api.Assertions.fail;\n-import static org.junit.jupiter.api.Assumptions.assumeTrue;\n-\n-import java.util.Arrays;\n-import java.util.BitSet;\n-\n-import org.apache.commons.collections4.bag.TreeBag;\n-import org.apache.commons.collections4.bloomfilter.BitCountProducer.BitCountConsumer;\n-import org.junit.jupiter.api.Test;\n-\n-public abstract class AbstractBitCountProducerTest extends AbstractIndexProducerTest {\n-\n-    /**\n-     * A testing BitCountConsumer that always returns true.\n-     */\n-    private static final BitCountConsumer TRUE_CONSUMER = (i, j) -> true;\n-    /**\n-     * A testing BitCountConsumer that always returns false.\n-     */\n-    private static final BitCountConsumer FALSE_CONSUMER = (i, j) -> false;\n-\n-    /**\n-     * Creates an array of integer pairs comprising the index and the expected count for the index.\n-     * The order and count for each index is dependent upon the producer created by the {@code createProducer()}\n-     * method.\n-     * By default returns the each {@code getExpectedIndices()} value paired with 1 (one).\n-     * @return an array of integer pairs comprising the index and the expected count for the index.\n-     */\n-    protected int[][] getExpectedBitCount() {\n-        return Arrays.stream(getExpectedIndices()).mapToObj(x -> new int[] {x, 1}).toArray(int[][]::new);\n-    }\n-\n-    /**\n-     * Creates a producer with some data.\n-     * @return a producer with some data\n-     */\n-    @Override\n-    protected abstract BitCountProducer createProducer();\n-\n-    /**\n-     * Creates a producer without data.\n-     * @return a producer that has no data.\n-     */\n-    @Override\n-    protected abstract BitCountProducer createEmptyProducer();\n-\n-    /**\n-     * Gets the behavior of the {@link BitCountProducer#forEachCount(BitCountConsumer)} method.\n-     * By default returns the value of {@code getAsIndexArrayBehaviour()} method.\n-     * @return the behavior.\n-     */\n-    protected int getForEachCountBehaviour() {\n-        return getAsIndexArrayBehaviour();\n-    }\n-\n-    @Test\n-    public final void testForEachCountPredicates() {\n-        final BitCountProducer populated = createProducer();\n-        final BitCountProducer empty = createEmptyProducer();\n-\n-        assertFalse(populated.forEachCount(FALSE_CONSUMER), \"non-empty should be false\");\n-        assertTrue(empty.forEachCount(FALSE_CONSUMER), \"empty should be true\");\n-\n-        assertTrue(populated.forEachCount(TRUE_CONSUMER), \"non-empty should be true\");\n-        assertTrue(empty.forEachCount(TRUE_CONSUMER), \"empty should be true\");\n-    }\n-\n-    @Test\n-    public final void testEmptyBitCountProducer() {\n-        final BitCountProducer empty = createEmptyProducer();\n-        final int ary[] = empty.asIndexArray();\n-        assertEquals(0, ary.length);\n-        assertTrue(empty.forEachCount((i, j) -> {\n-            fail(\"forEachCount consumer should not be called\");\n-            return false;\n-        }));\n-    }\n-\n-    @Test\n-    public final void testIndexConsistency() {\n-        final BitCountProducer producer = createProducer();\n-        final BitSet bs1 = new BitSet();\n-        final BitSet bs2 = new BitSet();\n-        producer.forEachIndex(i -> {\n-            bs1.set(i);\n-            return true;\n-        });\n-        producer.forEachCount((i, j) -> {\n-            bs2.set(i);\n-            return true;\n-        });\n-        assertEquals(bs1, bs2);\n-    }\n-\n-    @Test\n-    public void testForEachCountValues() {\n-        // Assumes the collections bag works. Could be replaced with Map<Integer,Integer> with more work.\n-        final TreeBag<Integer> expected = new TreeBag<>();\n-        Arrays.stream(getExpectedBitCount()).forEach(c -> expected.add(c[0], c[1]));\n-        final TreeBag<Integer> actual = new TreeBag<>();\n-        // can not return actual.add as it returns false on duplicate 'i'\n-        createProducer().forEachCount((i, j) -> {\n-            actual.add(i, j);\n-            return true;\n-        });\n-        assertEquals(expected, actual);\n-    }\n-\n-    /**\n-     * Test the behavior of {@link BitCountProducer#forEachCount(BitCountConsumer)} with respect\n-     * to ordered and distinct indices. Currently the behavior is assumed to be the same as\n-     * {@link IndexProducer#forEachIndex(java.util.function.IntPredicate)}.\n-     */\n-    @Test\n-    public final void testBehaviourForEachCount() {\n-        final int flags = getForEachCountBehaviour();\n-        assumeTrue((flags & (ORDERED | DISTINCT)) != 0);\n-        final IntList list = new IntList();\n-        createProducer().forEachCount((i, j) -> list.add(i));\n-        final int[] actual = list.toArray();\n-        if ((flags & ORDERED) != 0) {\n-            final int[] expected = Arrays.stream(actual).sorted().toArray();\n-            assertArrayEquals(expected, actual);\n-        }\n-        if ((flags & DISTINCT) != 0) {\n-            final long count = Arrays.stream(actual).distinct().count();\n-            assertEquals(count, actual.length);\n-        }\n-    }\n-\n-    @Test\n-    public void testForEachCountEarlyExit() {\n-        final int[] passes = new int[1];\n-        assertTrue(createEmptyProducer().forEachCount((i, j) -> {\n-            passes[0]++;\n-            return false;\n-        }));\n-        assertEquals(0, passes[0]);\n-\n-        assertFalse(createProducer().forEachCount((i, j) -> {\n-            passes[0]++;\n-            return false;\n-        }));\n-        assertEquals(1, passes[0]);\n-    }\n-}\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBloomFilterTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBloomFilterTest.java\nindex 7e1666a074..e4a9082771 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBloomFilterTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBloomFilterTest.java\n@@ -94,9 +94,6 @@ protected final T createFilter(final Shape shape, final IndexProducer producer)\n         return bf;\n     }\n \n-    /**\n-     *\n-     */\n     @Test\n     public void testMergeWithBadHasher() {\n         // value too large\n@@ -451,10 +448,5 @@ public BadHasher(final int value) {\n         public IndexProducer indices(final Shape shape) {\n             return producer;\n         }\n-\n-        @Override\n-        public IndexProducer uniqueIndices(final Shape shape) {\n-            return producer;\n-        }\n     }\n }\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractCellProducerTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractCellProducerTest.java\nnew file mode 100644\nindex 0000000000..8433161d1d\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractCellProducerTest.java\n@@ -0,0 +1,155 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.bloomfilter;\n+\n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+import java.util.Arrays;\n+import java.util.BitSet;\n+\n+import org.apache.commons.collections4.bloomfilter.CellProducer.CellConsumer;\n+import org.junit.jupiter.api.Test;\n+\n+public abstract class AbstractCellProducerTest extends AbstractIndexProducerTest {\n+\n+    /**\n+     * A testing CellConsumer that always returns true.\n+     */\n+    private static final CellConsumer TRUE_CONSUMER = (i, j) -> true;\n+    /**\n+     * A testing CellConsumer that always returns false.\n+     */\n+    private static final CellConsumer FALSE_CONSUMER = (i, j) -> false;\n+\n+    /**\n+     * Creates an array of expected values that aligns with the expected indices entries.\n+     * @return an array of expected values.\n+     * @see AbstractIndexProducerTest#getExpectedIndices()\n+     */\n+    protected abstract int[] getExpectedValues();\n+\n+    @Override\n+    protected final int getAsIndexArrayBehaviour() {\n+        return ORDERED | DISTINCT;\n+    }\n+\n+    /**\n+     * Creates a producer with some data.\n+     * @return a producer with some data\n+     */\n+    @Override\n+    protected abstract CellProducer createProducer();\n+\n+    /**\n+     * Creates a producer without data.\n+     * @return a producer that has no data.\n+     */\n+    @Override\n+    protected abstract CellProducer createEmptyProducer();\n+\n+    @Test\n+    public final void testForEachCellPredicates() {\n+        final CellProducer populated = createProducer();\n+        final CellProducer empty = createEmptyProducer();\n+\n+        assertFalse(populated.forEachCell(FALSE_CONSUMER), \"non-empty should be false\");\n+        assertTrue(empty.forEachCell(FALSE_CONSUMER), \"empty should be true\");\n+\n+        assertTrue(populated.forEachCell(TRUE_CONSUMER), \"non-empty should be true\");\n+        assertTrue(empty.forEachCell(TRUE_CONSUMER), \"empty should be true\");\n+    }\n+\n+    @Test\n+    public final void testEmptyCellProducer() {\n+        final CellProducer empty = createEmptyProducer();\n+        final int ary[] = empty.asIndexArray();\n+        assertEquals(0, ary.length);\n+        assertTrue(empty.forEachCell((i, j) -> {\n+            fail(\"forEachCell consumer should not be called\");\n+            return false;\n+        }));\n+    }\n+\n+    @Test\n+    public final void testIndexConsistency() {\n+        final CellProducer producer = createProducer();\n+        final BitSet bs1 = new BitSet();\n+        final BitSet bs2 = new BitSet();\n+        producer.forEachIndex(i -> {\n+            bs1.set(i);\n+            return true;\n+        });\n+        producer.forEachCell((i, j) -> {\n+            bs2.set(i);\n+            return true;\n+        });\n+        assertEquals(bs1, bs2);\n+    }\n+\n+    @Test\n+    public void testForEachCellValues() {\n+        int[] expectedIdx = getExpectedIndices();\n+        int[] expectedValue = getExpectedValues();\n+        assertEquals(expectedIdx.length, expectedValue.length, \"expected index length and value length do not match\");\n+        int[] idx = {0};\n+        createProducer().forEachCell((i, j) -> {\n+            assertEquals(expectedIdx[idx[0]], i, \"bad index at \" + idx[0]);\n+            assertEquals(expectedValue[idx[0]], j, \"bad value at \" + idx[0]);\n+            idx[0]++;\n+            return true;\n+        });\n+    }\n+\n+    /**\n+     * Test the behavior of {@link CellProducer#forEachCell(CellConsumer)} with respect\n+     * to ordered and distinct indices. Currently the behavior is assumed to be the same as\n+     * {@link IndexProducer#forEachIndex(java.util.function.IntPredicate)}.\n+     */\n+    @Test\n+    public final void testBehaviourForEachCell() {\n+        final IntList list = new IntList();\n+        createProducer().forEachCell((i, j) -> list.add(i));\n+        final int[] actual = list.toArray();\n+        // check order\n+        final int[] expected = Arrays.stream(actual).sorted().toArray();\n+        assertArrayEquals(expected, actual);\n+        // check distinct\n+        final long count = Arrays.stream(actual).distinct().count();\n+        assertEquals(count, actual.length);\n+    }\n+\n+    @Test\n+    public void testForEachCellEarlyExit() {\n+        final int[] passes = new int[1];\n+        assertTrue(createEmptyProducer().forEachCell((i, j) -> {\n+            passes[0]++;\n+            return false;\n+        }));\n+        assertEquals(0, passes[0]);\n+\n+        assertFalse(createProducer().forEachCell((i, j) -> {\n+            passes[0]++;\n+            return false;\n+        }));\n+        assertEquals(1, passes[0]);\n+    }\n+}\n+\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractCountingBloomFilterTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractCountingBloomFilterTest.java\nindex de424111f0..6d489d8d13 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractCountingBloomFilterTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractCountingBloomFilterTest.java\n@@ -39,14 +39,16 @@ public abstract class AbstractCountingBloomFilterTest<T extends CountingBloomFil\n \n     private static final long bigHashValue = 0xffffffeL;\n \n-    protected final BitCountProducer maximumValueProducer = consumer -> {\n-        for (int i = 1; i < 18; i++) {\n-            if (!consumer.test(i, Integer.MAX_VALUE)) {\n-                return false;\n+    protected final CellProducer getMaximumValueProducer(int maxValue) {\n+        return consumer -> {\n+            for (int i = 1; i < 18; i++) {\n+                if (!consumer.test(i, maxValue)) {\n+                    return false;\n+                }\n             }\n-        }\n-        return true;\n-    };\n+            return true;\n+        };\n+    }\n \n     /**\n      * Assert the counts match the expected values. Values are for indices starting\n@@ -57,7 +59,7 @@ public abstract class AbstractCountingBloomFilterTest<T extends CountingBloomFil\n      */\n     private static void assertCounts(final CountingBloomFilter bf, final int[] expected) {\n         final Map<Integer, Integer> m = new HashMap<>();\n-        bf.forEachCount((i, c) -> {\n+        bf.forEachCell((i, c) -> {\n             m.put(i, c);\n             return true;\n         });\n@@ -82,7 +84,7 @@ public final void testCountingSpecificConstructor() {\n         // verify hasher duplicates are counted.\n         // bit hasher has duplicates for 11, 12,13,14,15,16, and 17\n         final CountingBloomFilter bf = createFilter(getTestShape(), TestingHashers.FROM1);\n-        bf.add(BitCountProducer.from(TestingHashers.FROM11.indices(getTestShape())));\n+        bf.add(CellProducer.from(TestingHashers.FROM11.indices(getTestShape())));\n \n         final long[] lb = bf.asBitMapArray();\n         assertEquals(2, lb.length);\n@@ -130,7 +132,7 @@ public final void testCountingSpecificMerge() {\n         // test overflow\n \n         final CountingBloomFilter bf5 = createEmptyFilter(getTestShape());\n-        assertTrue(bf5.add(maximumValueProducer), \"Should add to empty\");\n+        assertTrue(bf5.add(getMaximumValueProducer(bf5.getMaxCell())), \"Should add to empty\");\n         assertTrue(bf5.isValid(), \"Should be valid\");\n \n         final CountingBloomFilter bf6 = bf5.copy();\n@@ -155,7 +157,7 @@ public void testAdd() {\n         // test overflow\n \n         final CountingBloomFilter bf2 = createEmptyFilter(getTestShape());\n-        assertTrue(bf2.add(maximumValueProducer), \"Should add to empty\");\n+        assertTrue(bf2.add(getMaximumValueProducer(bf2.getMaxCell())), \"Should add to empty\");\n         assertTrue(bf2.isValid(), \"Should be valid\");\n \n         assertFalse(bf2.add(createFilter(getTestShape(), TestingHashers.FROM1)), \"Should not add\");\n@@ -169,7 +171,7 @@ public void testAdd() {\n     @Test\n     public final void testSubtract() {\n         final CountingBloomFilter bf1 = createFilter(getTestShape(), TestingHashers.FROM1);\n-        bf1.add(BitCountProducer.from(TestingHashers.FROM11.indices(getTestShape())));\n+        bf1.add(CellProducer.from(TestingHashers.FROM11.indices(getTestShape())));\n \n         final CountingBloomFilter bf2 = createFilter(getTestShape(), TestingHashers.FROM11);\n \n@@ -190,6 +192,9 @@ public final void testSubtract() {\n         assertFalse(bf3.contains(bf4), \"Should not contain\");\n \n         assertCounts(bf3, new int[] {0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0});\n+\n+        assertThrows(IllegalArgumentException.class, () -> bf3.remove( new BadHasher(-1)));\n+        assertThrows(IllegalArgumentException.class, () -> bf3.remove( new BadHasher(getTestShape().getNumberOfBits())));;\n     }\n \n     /**\n@@ -202,7 +207,7 @@ public final void testRemove() {\n         simple.merge(TestingHashers.FROM11);\n \n         final CountingBloomFilter bf1 = createFilter(getTestShape(), TestingHashers.FROM1);\n-        bf1.add(BitCountProducer.from(TestingHashers.FROM11.indices(getTestShape())));\n+        bf1.add(CellProducer.from(TestingHashers.FROM11.indices(getTestShape())));\n \n         assertTrue(bf1.remove(simple), \"Remove should work\");\n         assertFalse(bf1.contains(TestingHashers.FROM11), \"Should not contain\");\n@@ -212,7 +217,7 @@ public final void testRemove() {\n \n         // with hasher\n         final CountingBloomFilter bf2 = createFilter(getTestShape(), TestingHashers.FROM1);\n-        bf2.add(BitCountProducer.from(TestingHashers.FROM11.indices(getTestShape())));\n+        bf2.add(CellProducer.from(TestingHashers.FROM11.indices(getTestShape())));\n \n         assertTrue(bf2.remove(TestingHashers.FROM11), \"Remove should work\");\n         assertFalse(bf2.contains(TestingHashers.FROM11), \"Should not contain\");\n@@ -233,7 +238,7 @@ public final void testRemove() {\n         final IndexProducer ip = TestingHashers.FROM11.indices(getTestShape());\n \n         final CountingBloomFilter bf4 = createFilter(getTestShape(), TestingHashers.FROM1);\n-        bf4.add(BitCountProducer.from(TestingHashers.FROM11.indices(getTestShape())));\n+        bf4.add(CellProducer.from(TestingHashers.FROM11.indices(getTestShape())));\n \n         assertTrue(bf4.remove(ip), \"Remove should work\");\n         assertFalse(bf4.contains(TestingHashers.FROM11), \"Should not contain\");\n@@ -244,7 +249,7 @@ public final void testRemove() {\n         // with BitMapProducer\n         final BitMapProducer bmp = BitMapProducer.fromIndexProducer(ip, getTestShape().getNumberOfBits());\n         final CountingBloomFilter bf5 = createFilter(getTestShape(), TestingHashers.FROM1);\n-        bf5.add(BitCountProducer.from(TestingHashers.FROM11.indices(getTestShape())));\n+        bf5.add(CellProducer.from(TestingHashers.FROM11.indices(getTestShape())));\n \n         assertTrue(bf5.remove(bmp), \"Remove should work\");\n         assertFalse(bf5.contains(TestingHashers.FROM11), \"Should not contain\");\n@@ -260,6 +265,8 @@ public final void testRemove() {\n         final CountingBloomFilter bf7 = createFilter(getTestShape(), TestingHashers.FROM1);\n         final BitMapProducer bmp2 = BitMapProducer.fromIndexProducer(ip2, getTestShape().getNumberOfBits());\n         assertThrows(IllegalArgumentException.class, () -> bf7.remove(bmp2));\n+        assertThrows(IllegalArgumentException.class, () -> bf7.remove( new BadHasher(-1)));\n+        assertThrows(IllegalArgumentException.class, () -> bf7.remove( new BadHasher(getTestShape().getNumberOfBits())));;\n     }\n \n     @Test\n@@ -272,7 +279,7 @@ public void testExcludesDuplicates() {\n \n         CountingBloomFilter bf1 = createFilter(shape, hasher);\n         assertEquals(6, bf1.cardinality());\n-        bf1.forEachCount((x, y) -> {\n+        bf1.forEachCell((x, y) -> {\n             assertEquals(1, y, \"Hasher in constructor results in value not equal to 1\");\n             return true;\n         });\n@@ -280,7 +287,7 @@ public void testExcludesDuplicates() {\n         bf1 = createEmptyFilter(shape);\n         bf1.merge(hasher);\n         assertEquals(6, bf1.cardinality());\n-        bf1.forEachCount((x, y) -> {\n+        bf1.forEachCell((x, y) -> {\n             assertEquals(1, y, \"Hasher in merge results in value not equal to 1\");\n             return true;\n         });\n@@ -289,6 +296,110 @@ public void testExcludesDuplicates() {\n         bf1.merge(hasher);\n         bf1.remove(hasher);\n         assertEquals(0, bf1.cardinality());\n-        assertTrue(bf1.forEachCount((x, y) -> false), \"Hasher in removes results in value not equal to 0\");\n+        assertTrue(bf1.forEachCell((x, y) -> false), \"Hasher in removes results in value not equal to 0\");\n+    }\n+\n+    private void verifyMaxInsert(CountingBloomFilter bf, int from1, int from11) {\n+        BloomFilter bfFrom0 = new DefaultBloomFilterTest.SparseDefaultBloomFilter(getTestShape());\n+        bfFrom0.merge(new IncrementingHasher(0, 1));\n+        BloomFilter bfFrom1 = new DefaultBloomFilterTest.SparseDefaultBloomFilter(getTestShape());\n+        bfFrom1.merge(TestingHashers.FROM1);\n+        BloomFilter bfFrom11 = new DefaultBloomFilterTest.SparseDefaultBloomFilter(getTestShape());\n+        bfFrom11.merge(TestingHashers.FROM11);\n+\n+        assertEquals(0, bf.getMaxInsert(new IncrementingHasher(0, 1)));\n+        assertEquals(0, bf.getMaxInsert(bfFrom0));\n+        assertEquals(0, bf.getMaxInsert((BitMapProducer) bfFrom0));\n+        assertEquals(0, bf.getMaxInsert((IndexProducer) bfFrom0));\n+\n+        assertEquals(from1, bf.getMaxInsert(TestingHashers.FROM1));\n+        assertEquals(from1, bf.getMaxInsert(bfFrom1));\n+        assertEquals(from1, bf.getMaxInsert((BitMapProducer) bfFrom1));\n+        assertEquals(from1, bf.getMaxInsert((IndexProducer) bfFrom1));\n+\n+        assertEquals(from11, bf.getMaxInsert(TestingHashers.FROM11));\n+        assertEquals(from11, bf.getMaxInsert(bfFrom11));\n+        assertEquals(from11, bf.getMaxInsert((BitMapProducer) bfFrom11));\n+        assertEquals(from11, bf.getMaxInsert((IndexProducer) bfFrom11));\n+    }\n+\n+    @Test\n+    public void testGetMaxInsert() {\n+        CountingBloomFilter bf = createEmptyFilter(getTestShape());\n+        verifyMaxInsert(bf, 0, 0);\n+        bf.merge(TestingHashers.FROM1);\n+        verifyMaxInsert(bf, 1, 0);\n+        bf.merge(TestingHashers.FROM1);\n+        verifyMaxInsert(bf, 2, 0);\n+        bf.merge(TestingHashers.FROM11);\n+        verifyMaxInsert(bf, 2, 1);\n+        bf.remove(TestingHashers.FROM1);\n+        verifyMaxInsert(bf, 1, 1);\n+        // verify remove false positive works\n+        // Incrementing hasher 5,1 spans the single count cells for both FROM1 and FROM11\n+        assertEquals(1, bf.getMaxInsert(new IncrementingHasher(5, 1)));\n+        bf.remove(new IncrementingHasher(5, 1));\n+        verifyMaxInsert(bf, 0, 0);\n+        assertEquals(0, bf.getMaxInsert(new IncrementingHasher(5, 1)));\n+    }\n+\n+    private void assertCell3(CountingBloomFilter bf, int value) {\n+        bf.forEachCell((k, v) -> {\n+            if (k == 3) {\n+                assertEquals(value, v, \"Mismatch at position 3\");\n+            } else {\n+                assertEquals(0, v, \"Mismatch at position \" + k);\n+            }\n+            return true;\n+        });\n+    }\n+\n+    @Test\n+    public void mergeIncrementsAllCellsTest() {\n+        CountingBloomFilter f1 = createEmptyFilter(Shape.fromKM(1, 10));\n+        CountingBloomFilter f2 = f1.copy();\n+        CountingBloomFilter f3 = f1.copy();\n+        // index producer produces 3 two times.\n+        IndexProducer ip = p -> {\n+            p.test(3);\n+            p.test(3);\n+            return true;\n+        };\n+        // The merge should increment cell 3 by 1\n+        f1.merge(ip);\n+        assertCell3(f1, 1);\n+\n+        // The add should increment cells 3 by 2\n+        f2.add(CellProducer.from(ip));\n+        assertCell3(f2, 2);\n+    }\n+\n+    @Test\n+    public void removeDecrementsAllCellsTest() {\n+        CountingBloomFilter f1 = createEmptyFilter(Shape.fromKM(1, 10));\n+        CellProducer cp = p -> {\n+            p.test(3, 3);\n+            return true;\n+        };\n+        f1.add(cp);\n+        CountingBloomFilter f2 = f1.copy();\n+        CountingBloomFilter f3 = f1.copy();\n+        // index producer produces 3 two times.\n+        IndexProducer ip = p -> {\n+            p.test(3);\n+            p.test(3);\n+            return true;\n+        };\n+        // The merge should decrement cell 3 by 1\n+        f1.remove(ip);\n+        assertCell3(f1, 2);\n+\n+        // The add should decrement cells 3 by 2\n+        f2.subtract(CellProducer.from(ip));\n+        assertCell3(f2, 1);\n+\n+        // This merge will decrement by 1 as the round-trip makes the indices unique\n+        f3.remove(IndexProducer.fromIndexArray(ip.asIndexArray()));\n+        assertCell3(f3, 2);\n     }\n }\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractIndexProducerTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractIndexProducerTest.java\nindex 542f9a6875..917f361a2d 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractIndexProducerTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractIndexProducerTest.java\n@@ -16,6 +16,7 @@\n  */\n package org.apache.commons.collections4.bloomfilter;\n \n+import static org.junit.Assert.assertSame;\n import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n import static org.junit.jupiter.api.Assertions.assertEquals;\n import static org.junit.jupiter.api.Assertions.assertFalse;\n@@ -245,4 +246,10 @@ public void testForEachIndexEarlyExit() {\n         }));\n         assertEquals(0, passes[0]);\n     }\n+\n+    @Test\n+    public void testUniqueReturnsSelf() {\n+        IndexProducer expected = createProducer().uniqueIndices();\n+        assertSame(expected, expected.uniqueIndices());\n+    }\n }\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/ArrayHasher.java b/src/test/java/org/apache/commons/collections4/bloomfilter/ArrayHasher.java\nindex f2a18c426a..753decc6e2 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/ArrayHasher.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/ArrayHasher.java\n@@ -37,12 +37,6 @@ public IndexProducer indices(final Shape shape) {\n         return new Producer(shape);\n     }\n \n-    @Override\n-    public IndexProducer uniqueIndices(final Shape shape) {\n-        Objects.requireNonNull(shape, \"shape\");\n-        return new Producer(shape);\n-    }\n-\n     private class Producer implements IndexProducer {\n         Shape shape;\n \ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/BitCountProducerFromHasherTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/BitCountProducerFromHasherTest.java\ndeleted file mode 100644\nindex 8c1e846989..0000000000\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/BitCountProducerFromHasherTest.java\n+++ /dev/null\n@@ -1,47 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.commons.collections4.bloomfilter;\n-\n-public class BitCountProducerFromHasherTest extends AbstractBitCountProducerTest {\n-\n-    @Override\n-    protected BitCountProducer createProducer() {\n-        // hasher has collisions and wraps\n-        return BitCountProducer.from(new IncrementingHasher(4, 8).indices(Shape.fromKM(17, 72)));\n-    }\n-\n-    @Override\n-    protected BitCountProducer createEmptyProducer() {\n-        return BitCountProducer.from(NullHasher.INSTANCE.indices(Shape.fromKM(17, 72)));\n-    }\n-\n-    @Override\n-    protected int getAsIndexArrayBehaviour() {\n-        // Hasher allows duplicates and may be unordered\n-        return 0;\n-    }\n-\n-    @Override\n-    protected int[] getExpectedIndices() {\n-        return new int[] {4, 12, 20, 28, 36, 44, 52, 60, 68, 4, 12, 20, 28, 36, 44, 52, 60};\n-    }\n-\n-    @Override\n-    protected int[][] getExpectedBitCount() {\n-        return new int[][] {{4, 2}, {12, 2}, {20, 2}, {28, 2}, {36, 2}, {44, 2}, {52, 2}, {60, 2}, {68, 1}};\n-    }\n-}\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/CellProducerFromArrayCountingBloomFilterTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/CellProducerFromArrayCountingBloomFilterTest.java\nnew file mode 100644\nindex 0000000000..454e16492a\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/CellProducerFromArrayCountingBloomFilterTest.java\n@@ -0,0 +1,45 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.bloomfilter;\n+\n+public class CellProducerFromArrayCountingBloomFilterTest extends AbstractCellProducerTest {\n+\n+    protected Shape shape = Shape.fromKM(17, 72);\n+\n+    @Override\n+    protected CellProducer createProducer() {\n+        final ArrayCountingBloomFilter filter = new ArrayCountingBloomFilter(shape);\n+        filter.merge(new IncrementingHasher(0, 1));\n+        filter.merge(new IncrementingHasher(5, 1));\n+        return filter;\n+    }\n+\n+    @Override\n+    protected CellProducer createEmptyProducer() {\n+        return new ArrayCountingBloomFilter(shape);\n+    }\n+\n+    @Override\n+    protected int[] getExpectedIndices() {\n+        return new int[] {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21};\n+    }\n+\n+    @Override\n+    protected int[] getExpectedValues() {\n+        return new int[] {1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1};\n+    }\n+}\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/CellProducerFromDefaultIndexProducerTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/CellProducerFromDefaultIndexProducerTest.java\nnew file mode 100644\nindex 0000000000..8f97d8388d\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/CellProducerFromDefaultIndexProducerTest.java\n@@ -0,0 +1,45 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.bloomfilter;\n+\n+public class CellProducerFromDefaultIndexProducerTest extends AbstractCellProducerTest {\n+\n+    int[] data = {0, 63, 1, 64, 128, 1, 127};\n+    int[] indices = {0, 1, 63, 64, 127, 128};\n+    int[] values = {1, 2, 1, 1, 1, 1 };\n+\n+    @Override\n+    protected CellProducer createProducer() {\n+        return CellProducer.from(IndexProducer.fromIndexArray(data));\n+    }\n+\n+    @Override\n+    protected CellProducer createEmptyProducer() {\n+        return CellProducer.from(IndexProducer.fromIndexArray(new int[0]));\n+    }\n+\n+    @Override\n+    protected int[] getExpectedIndices() {\n+        return indices;\n+    }\n+\n+    @Override\n+    protected int[] getExpectedValues() {\n+        return values;\n+    }\n+\n+}\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/DefaultBitCountProducerTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/DefaultCellProducerTest.java\nsimilarity index 69%\nrename from src/test/java/org/apache/commons/collections4/bloomfilter/DefaultBitCountProducerTest.java\nrename to src/test/java/org/apache/commons/collections4/bloomfilter/DefaultCellProducerTest.java\nindex a85b90b29d..e99a9aaeb4 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/DefaultBitCountProducerTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/DefaultCellProducerTest.java\n@@ -16,21 +16,27 @@\n  */\n package org.apache.commons.collections4.bloomfilter;\n \n-public class DefaultBitCountProducerTest extends AbstractBitCountProducerTest {\n+public class DefaultCellProducerTest extends AbstractCellProducerTest {\n \n     /** Make forEachIndex unordered and contain duplicates. */\n-    private final int[] values = {10, 1, 10, 1};\n+    private final int[] indices = {1, 2, 3, 5};\n+    private final int[] values = {1, 4, 9, 25};\n \n     @Override\n     protected int[] getExpectedIndices() {\n+        return indices;\n+    }\n+\n+    @Override\n+    protected int[] getExpectedValues() {\n         return values;\n     }\n \n     @Override\n-    protected BitCountProducer createProducer() {\n+    protected CellProducer createProducer() {\n         return consumer -> {\n-            for (final int i : values) {\n-                if (!consumer.test(i, 1)) {\n+            for (int i = 0; i < indices.length; i++) {\n+                if (!consumer.test(indices[i], values[i] )) {\n                     return false;\n                 }\n             }\n@@ -39,25 +45,13 @@ protected BitCountProducer createProducer() {\n     }\n \n     @Override\n-    protected BitCountProducer createEmptyProducer() {\n+    protected CellProducer createEmptyProducer() {\n         return consumer -> true;\n     }\n \n-    @Override\n-    protected int getAsIndexArrayBehaviour() {\n-        // The default method streams a BitSet so is distinct and ordered.\n-        return ORDERED | DISTINCT;\n-    }\n-\n     @Override\n     protected int getForEachIndexBehaviour() {\n         // The default method has the same behavior as the forEachCount() method.\n         return 0;\n     }\n-\n-    @Override\n-    protected int getForEachCountBehaviour() {\n-        // The implemented method returns unordered duplicates.\n-        return 0;\n-    }\n }\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/DefaultIndexProducerTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/DefaultIndexProducerTest.java\nindex 2682a96a7e..73a3a58dc9 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/DefaultIndexProducerTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/DefaultIndexProducerTest.java\n@@ -22,8 +22,11 @@\n import java.util.BitSet;\n import java.util.Objects;\n import java.util.concurrent.ThreadLocalRandom;\n+import java.util.stream.IntStream;\n \n import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n \n public class DefaultIndexProducerTest extends AbstractIndexProducerTest {\n \n@@ -58,8 +61,7 @@ protected IndexProducer createEmptyProducer() {\n \n     @Override\n     protected int getAsIndexArrayBehaviour() {\n-        // The default method streams a BitSet so is distinct and ordered.\n-        return DISTINCT | ORDERED;\n+        return 0;\n     }\n \n     @Override\n@@ -119,4 +121,21 @@ public void testFromIndexArray() {\n             assertArrayEquals(expected, ip.asIndexArray());\n         }\n     }\n+\n+    @ParameterizedTest\n+    @ValueSource(ints = {32, 33})\n+    public void testEntries(int size) {\n+        int[] values = IntStream.range(0, size).toArray();\n+        IndexProducer producer =  predicate -> {\n+            Objects.requireNonNull(predicate);\n+            for (final int i : values) {\n+                if (!predicate.test(i)) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        };\n+        int[] other = producer.asIndexArray();\n+        assertArrayEquals(values, other);\n+    }\n }\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/BitCountProducerFromArrayCountingBloomFilterTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromArrayCountingBloomFilterTest.java\nsimilarity index 71%\nrename from src/test/java/org/apache/commons/collections4/bloomfilter/BitCountProducerFromArrayCountingBloomFilterTest.java\nrename to src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromArrayCountingBloomFilterTest.java\nindex 1cfe291a50..f9d7f18fcf 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/BitCountProducerFromArrayCountingBloomFilterTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromArrayCountingBloomFilterTest.java\n@@ -16,12 +16,12 @@\n  */\n package org.apache.commons.collections4.bloomfilter;\n \n-public class BitCountProducerFromArrayCountingBloomFilterTest extends AbstractBitCountProducerTest {\n+public class IndexProducerFromArrayCountingBloomFilterTest extends AbstractIndexProducerTest {\n \n     protected Shape shape = Shape.fromKM(17, 72);\n \n     @Override\n-    protected BitCountProducer createProducer() {\n+    protected IndexProducer createProducer() {\n         final ArrayCountingBloomFilter filter = new ArrayCountingBloomFilter(shape);\n         filter.merge(new IncrementingHasher(0, 1));\n         filter.merge(new IncrementingHasher(5, 1));\n@@ -29,25 +29,18 @@ protected BitCountProducer createProducer() {\n     }\n \n     @Override\n-    protected BitCountProducer createEmptyProducer() {\n+    protected IndexProducer createEmptyProducer() {\n         return new ArrayCountingBloomFilter(shape);\n     }\n \n     @Override\n-    protected int getAsIndexArrayBehaviour() {\n-        // CountingBloomFilter based on an array will be distinct and ordered\n-        return DISTINCT | ORDERED;\n+    protected int[] getExpectedIndices() {\n+        return new int[] {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21};\n     }\n \n     @Override\n-    protected int[][] getExpectedBitCount() {\n-        return new int[][] {{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 2}, {6, 2}, {7, 2},\n-            {8, 2}, {9, 2}, {10, 2}, {11, 2}, {12, 2}, {13, 2}, {14, 2}, {15, 2}, {16, 2},\n-            {17, 1}, {18, 1}, {19, 1}, {20, 1}, {21, 1}};\n+    protected int getAsIndexArrayBehaviour() {\n+        return DISTINCT | ORDERED;\n     }\n \n-    @Override\n-    protected int[] getExpectedIndices() {\n-        return new int[] {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21};\n-    }\n }\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/BitCountProducerFromDefaultIndexProducerTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromHasherTest.java\nsimilarity index 69%\nrename from src/test/java/org/apache/commons/collections4/bloomfilter/BitCountProducerFromDefaultIndexProducerTest.java\nrename to src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromHasherTest.java\nindex 56a5c792a6..f6fdd91008 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/BitCountProducerFromDefaultIndexProducerTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromHasherTest.java\n@@ -16,27 +16,26 @@\n  */\n package org.apache.commons.collections4.bloomfilter;\n \n-public class BitCountProducerFromDefaultIndexProducerTest extends AbstractBitCountProducerTest {\n-\n-    int[] data = {0, 63, 1, 1, 64, 127, 128};\n+public class IndexProducerFromHasherTest extends AbstractIndexProducerTest {\n \n     @Override\n-    protected BitCountProducer createProducer() {\n-        return BitCountProducer.from(IndexProducer.fromIndexArray(data));\n+    protected int getAsIndexArrayBehaviour() {\n+        return 0;\n     }\n \n     @Override\n-    protected BitCountProducer createEmptyProducer() {\n-        return BitCountProducer.from(IndexProducer.fromIndexArray(new int[0]));\n+    protected IndexProducer createProducer() {\n+        // hasher has collisions and wraps\n+        return new IncrementingHasher(4, 8).indices(Shape.fromKM(17, 72));\n     }\n \n     @Override\n-    protected int getAsIndexArrayBehaviour() {\n-        return 0;\n+    protected IndexProducer createEmptyProducer() {\n+        return NullHasher.INSTANCE.indices(Shape.fromKM(17, 72));\n     }\n \n     @Override\n     protected int[] getExpectedIndices() {\n-        return data;\n+        return new int[] {4, 12, 20, 28, 36, 44, 52, 60, 68, 4, 12, 20, 28, 36, 44, 52, 60};\n     }\n }\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/BitCountProducerFromIntArrayTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromIntArrayTest.java\nsimilarity index 76%\nrename from src/test/java/org/apache/commons/collections4/bloomfilter/BitCountProducerFromIntArrayTest.java\nrename to src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromIntArrayTest.java\nindex d0a598a17d..4b0281dccc 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/BitCountProducerFromIntArrayTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromIntArrayTest.java\n@@ -16,27 +16,28 @@\n  */\n package org.apache.commons.collections4.bloomfilter;\n \n-public class BitCountProducerFromIntArrayTest extends AbstractBitCountProducerTest {\n+public class IndexProducerFromIntArrayTest extends AbstractIndexProducerTest {\n \n     int[] data = {6, 8, 1, 2, 4, 4, 5};\n \n     @Override\n-    protected BitCountProducer createEmptyProducer() {\n-        return BitCountProducer.from(IndexProducer.fromIndexArray(new int[0]));\n+    protected IndexProducer createEmptyProducer() {\n+        return IndexProducer.fromIndexArray(new int[0]);\n     }\n \n     @Override\n-    protected BitCountProducer createProducer() {\n-        return BitCountProducer.from(IndexProducer.fromIndexArray(data));\n+    protected IndexProducer createProducer() {\n+        return IndexProducer.fromIndexArray(data);\n     }\n \n     @Override\n-    protected int getAsIndexArrayBehaviour() {\n-        return 0;\n+    protected int[] getExpectedIndices() {\n+        return data;\n     }\n \n     @Override\n-    protected int[] getExpectedIndices() {\n-        return data;\n+    protected int getAsIndexArrayBehaviour() {\n+        return 0;\n     }\n+\n }\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/BitCountProducerFromSimpleBloomFilterTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromSimpleBloomFilterTest.java\nsimilarity index 77%\nrename from src/test/java/org/apache/commons/collections4/bloomfilter/BitCountProducerFromSimpleBloomFilterTest.java\nrename to src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromSimpleBloomFilterTest.java\nindex a6b2be2099..b2f3e947a6 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/BitCountProducerFromSimpleBloomFilterTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromSimpleBloomFilterTest.java\n@@ -16,31 +16,30 @@\n  */\n package org.apache.commons.collections4.bloomfilter;\n \n-public class BitCountProducerFromSimpleBloomFilterTest extends AbstractBitCountProducerTest {\n+public class IndexProducerFromSimpleBloomFilterTest extends AbstractIndexProducerTest {\n \n     protected Shape shape = Shape.fromKM(17, 72);\n \n     @Override\n-    protected BitCountProducer createProducer() {\n+    protected IndexProducer createProducer() {\n         final Hasher hasher = new IncrementingHasher(3, 2);\n         final BloomFilter bf = new SimpleBloomFilter(shape);\n         bf.merge(hasher);\n-        return BitCountProducer.from(bf);\n+        return bf;\n     }\n \n     @Override\n-    protected BitCountProducer createEmptyProducer() {\n-        return BitCountProducer.from(new SimpleBloomFilter(shape));\n+    protected IndexProducer createEmptyProducer() {\n+        return new SimpleBloomFilter(shape);\n     }\n \n     @Override\n-    protected int getAsIndexArrayBehaviour() {\n-        // BloomFilter based on a bit map array will be distinct and ordered\n-        return DISTINCT | ORDERED;\n+    protected int[] getExpectedIndices() {\n+        return new int[] {3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35};\n     }\n \n     @Override\n-    protected int[] getExpectedIndices() {\n-        return new int[] {3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35};\n+    protected int getAsIndexArrayBehaviour() {\n+        return DISTINCT | ORDERED;\n     }\n }\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/BitCountProducerFromSparseBloomFilterTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromSparseBloomFilterTest.java\nsimilarity index 70%\nrename from src/test/java/org/apache/commons/collections4/bloomfilter/BitCountProducerFromSparseBloomFilterTest.java\nrename to src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromSparseBloomFilterTest.java\nindex 7e05bb9961..d7bf45cba9 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/BitCountProducerFromSparseBloomFilterTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromSparseBloomFilterTest.java\n@@ -16,33 +16,30 @@\n  */\n package org.apache.commons.collections4.bloomfilter;\n \n-public class BitCountProducerFromSparseBloomFilterTest extends AbstractBitCountProducerTest {\n+public class IndexProducerFromSparseBloomFilterTest extends AbstractIndexProducerTest {\n \n     protected Shape shape = Shape.fromKM(17, 72);\n \n     @Override\n-    protected BitCountProducer createProducer() {\n+    protected IndexProducer createProducer() {\n         final Hasher hasher = new IncrementingHasher(4, 7);\n         final BloomFilter bf = new SparseBloomFilter(shape);\n         bf.merge(hasher);\n-        return BitCountProducer.from(bf);\n+        return bf;\n     }\n \n     @Override\n-    protected BitCountProducer createEmptyProducer() {\n-        return BitCountProducer.from(new SparseBloomFilter(shape));\n+    protected IndexProducer createEmptyProducer() {\n+        return new SparseBloomFilter(shape);\n     }\n \n     @Override\n-    protected int getAsIndexArrayBehaviour() {\n-        // A sparse BloomFilter will be distinct but it may not be ordered.\n-        // Currently the ordered behavior is asserted as the implementation uses\n-        // an ordered TreeSet. This may change in the future.\n-        return DISTINCT | ORDERED;\n+    protected int[] getExpectedIndices() {\n+        return new int[] {2, 4, 9, 11, 16, 18, 23, 25, 30, 32, 37, 39, 44, 46, 53, 60, 67};\n     }\n \n     @Override\n-    protected int[] getExpectedIndices() {\n-        return new int[] {2, 4, 9, 11, 16, 18, 23, 25, 30, 32, 37, 39, 44, 46, 53, 60, 67};\n+    protected int getAsIndexArrayBehaviour() {\n+        return DISTINCT |ORDERED;\n     }\n }\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/BitCountProducerFromUniqueHasherTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromUniqueHasherTest.java\nsimilarity index 73%\nrename from src/test/java/org/apache/commons/collections4/bloomfilter/BitCountProducerFromUniqueHasherTest.java\nrename to src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromUniqueHasherTest.java\nindex 18e7f7936d..c7cbd217cb 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/BitCountProducerFromUniqueHasherTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromUniqueHasherTest.java\n@@ -16,27 +16,26 @@\n  */\n package org.apache.commons.collections4.bloomfilter;\n \n-public class BitCountProducerFromUniqueHasherTest extends AbstractBitCountProducerTest {\n+public class IndexProducerFromUniqueHasherTest extends AbstractIndexProducerTest {\n \n     @Override\n-    protected BitCountProducer createProducer() {\n+    protected IndexProducer createProducer() {\n         // hasher has collisions and wraps\n-        return BitCountProducer.from(new IncrementingHasher(4, 8).uniqueIndices(Shape.fromKM(17, 72)));\n+        return new IncrementingHasher(4, 8).indices(Shape.fromKM(17, 72)).uniqueIndices();\n     }\n \n     @Override\n-    protected BitCountProducer createEmptyProducer() {\n-        return BitCountProducer.from(NullHasher.INSTANCE.indices(Shape.fromKM(17, 72)));\n+    protected IndexProducer createEmptyProducer() {\n+        return NullHasher.INSTANCE.indices(Shape.fromKM(17, 72));\n     }\n \n     @Override\n-    protected int getAsIndexArrayBehaviour() {\n-        // Hasher may be unordered\n-        return DISTINCT;\n+    protected int[] getExpectedIndices() {\n+        return new int[] {4, 12, 20, 28, 36, 44, 52, 60, 68};\n     }\n \n     @Override\n-    protected int[] getExpectedIndices() {\n-        return new int[] {4, 12, 20, 28, 36, 44, 52, 60, 68};\n+    protected int getAsIndexArrayBehaviour() {\n+        return DISTINCT;\n     }\n }\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerTest.java\nindex 52f557a834..655dfeed9d 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerTest.java\n@@ -22,7 +22,10 @@\n import java.util.List;\n import java.util.function.LongPredicate;\n \n+import org.junit.jupiter.api.Assertions;\n import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n \n public class IndexProducerTest {\n \n@@ -68,4 +71,17 @@ public boolean forEachBitMap(final LongPredicate consumer) {\n             return true;\n         }\n     }\n+\n+    @ParameterizedTest\n+    @ValueSource(ints = {32, 33})\n+    void testAsIndexArray(int n) {\n+        IndexProducer ip = i -> {\n+            for (int j = 0; j < n; j++) {\n+                // Always test index zero\n+                i.test(0);\n+            }\n+            return true;\n+        };\n+        Assertions.assertArrayEquals(new int[n], ip.asIndexArray());\n+    }\n }\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/NullHasher.java b/src/test/java/org/apache/commons/collections4/bloomfilter/NullHasher.java\nindex 9ab0fb76d5..6ac6d04eae 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/NullHasher.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/NullHasher.java\n@@ -53,10 +53,4 @@ public IndexProducer indices(final Shape shape) {\n         Objects.requireNonNull(shape, \"shape\");\n         return PRODUCER;\n     }\n-\n-    @Override\n-    public IndexProducer uniqueIndices(final Shape shape) {\n-        Objects.requireNonNull(shape, \"shape\");\n-        return PRODUCER;\n-    }\n }\n",
  "problem_statement" : "COLLECTIONS-844 - allow counting Bloom filters with cell size other than Integer.SIZE\n\nCounting bloom filter tests are dependant upon the maximum value that can be stored in a cell in a Bloom filter.\r\n\r\nThis pull adds a `getMaxValue()` method to the CountingBloomFilter interface.  This is to indicate the maximum value that can be stored in a single cell of the counting filter.  A cell is the counter that replaces the bit in the counting filter.\r\n\r\nAlso adds the missing standard function `getMaxInsert()` which returns the maximum times an item could have been merged into the counting filter.\r\n\r\nChanges to tests\r\n\r\nFix for COLLECTIONS-844",
  "hints_text" : null,
  "created_at" : "Sun Jul 16 20:13:06 CEST 2023",
  "version" : null,
  "FAIL_TO_PASS" : [ "BitCountProducerFromArrayCountingBloomFilterTest", "CellProducerFromDefaultIndexProducerTest", "AbstractIndexProducerTest", "IndexProducerFromSimpleBloomFilterTest", "DefaultIndexProducerTest", "BitCountProducerFromSimpleBloomFilterTest", "DefaultCellProducerTest", "IndexProducerFromHasherTest", "IndexProducerFromUniqueHasherTest", "ArrayHasher", "IndexProducerFromSparseBloomFilterTest", "DefaultBitCountProducerTest", "BitCountProducerFromSparseBloomFilterTest", "BitCountProducerFromUniqueHasherTest", "IndexProducerFromArrayCountingBloomFilterTest", "AbstractCountingBloomFilterTest", "IndexProducerFromIntArrayTest", "AbstractCellProducerTest", "AbstractBitCountProducerTest", "IndexProducerTest", "BitCountProducerFromDefaultIndexProducerTest", "NullHasher", "AbstractBloomFilterTest", "BitCountProducerFromHasherTest", "CellProducerFromArrayCountingBloomFilterTest", "BitCountProducerFromIntArrayTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=BitCountProducerFromArrayCountingBloomFilterTest,CellProducerFromDefaultIndexProducerTest,AbstractIndexProducerTest,IndexProducerFromSimpleBloomFilterTest,DefaultIndexProducerTest,BitCountProducerFromSimpleBloomFilterTest,DefaultCellProducerTest,IndexProducerFromHasherTest,IndexProducerFromUniqueHasherTest,ArrayHasher,IndexProducerFromSparseBloomFilterTest,DefaultBitCountProducerTest,BitCountProducerFromSparseBloomFilterTest,BitCountProducerFromUniqueHasherTest,IndexProducerFromArrayCountingBloomFilterTest,AbstractCountingBloomFilterTest,IndexProducerFromIntArrayTest,AbstractCellProducerTest,AbstractBitCountProducerTest,IndexProducerTest,BitCountProducerFromDefaultIndexProducerTest,NullHasher,AbstractBloomFilterTest,BitCountProducerFromHasherTest,CellProducerFromArrayCountingBloomFilterTest,BitCountProducerFromIntArrayTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 406,
  "metadata" : null
}, {
  "instance_id" : "apache-commons-collections-PR-402",
  "repo" : "apache/commons-collections",
  "base_commit" : "1df5606b821047e9cda52b728027d7ddb8e6fb4c",
  "patch" : "diff --git a/src/main/java/org/apache/commons/collections4/bloomfilter/BloomFilter.java b/src/main/java/org/apache/commons/collections4/bloomfilter/BloomFilter.java\nindex 1f3c7ab6f8..eb9b6f3896 100644\n--- a/src/main/java/org/apache/commons/collections4/bloomfilter/BloomFilter.java\n+++ b/src/main/java/org/apache/commons/collections4/bloomfilter/BloomFilter.java\n@@ -209,6 +209,21 @@ default boolean isFull() {\n      */\n     int cardinality();\n \n+    /**\n+     * Determines if all the bits are off. This is equivalent to\n+     * {@code cardinality() == 0}.\n+     *\n+     * <p>\n+     * <em>Note: This method is optimised for non-sparse filters.</em> Implementers\n+     * are encouraged to implement faster checks if possible.\n+     * </p>\n+     *\n+     * @return {@code true} if no bits are enabled, {@code false} otherwise.\n+     */\n+    default boolean isEmpty() {\n+        return forEachBitMap(y -> y == 0);\n+    }\n+\n     /**\n      * Estimates the number of items in the Bloom filter.\n      *\ndiff --git a/src/main/java/org/apache/commons/collections4/bloomfilter/BloomFilterProducer.java b/src/main/java/org/apache/commons/collections4/bloomfilter/BloomFilterProducer.java\nnew file mode 100644\nindex 0000000000..7008a7e3d8\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/bloomfilter/BloomFilterProducer.java\n@@ -0,0 +1,143 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.bloomfilter;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.function.BiPredicate;\n+import java.util.function.Predicate;\n+\n+/**\n+ * Produces Bloom filters from a collection (e.g. LayeredBloomFilter).\n+ *\n+ * @since 4.5\n+ */\n+public interface BloomFilterProducer {\n+\n+    /**\n+     * Executes a Bloom filter Predicate on each Bloom filter in the collection. The\n+     * ordering of the Bloom filters is not specified by this interface.\n+     *\n+     * @param bloomFilterPredicate the predicate to evaluate each Bloom filter with.\n+     * @return {@code false} when the first filter fails the predicate test. Returns\n+     *         {@code true} if all filters pass the test.\n+     */\n+    boolean forEachBloomFilter(Predicate<BloomFilter> bloomFilterPredicate);\n+\n+    /**\n+     * Return an array of the Bloom filters in the collection.\n+     * <p><em>Implementations should specify if the array contains deep copies, immutable instances,\n+     * or references to the filters in the collection.</em></p>\n+     * <p>The default method returns a deep copy of the enclosed filters.</p>\n+     *\n+     * @return An array of Bloom filters.\n+     */\n+    default BloomFilter[] asBloomFilterArray() {\n+        final List<BloomFilter> filters = new ArrayList<>();\n+        forEachBloomFilter(f -> filters.add(f.copy()));\n+        return filters.toArray(new BloomFilter[0]);\n+    }\n+\n+    /**\n+     * Applies the {@code func} to each Bloom filter pair in order. Will apply all\n+     * of the Bloom filters from the other BloomFilterProducer to this producer. If\n+     * either {@code this} producer or {@code other} producer has fewer BloomFilters\n+     * ths method will provide {@code null} for all excess calls to the {@code func}.\n+     *\n+     * <p><em>This implementation returns references to the Bloom filter.  Other implementations\n+     * should specify if the array contains deep copies, immutable instances,\n+     * or references to the filters in the collection.</em></p>\n+     *\n+     * @param other The other BloomFilterProducer that provides the y values in the\n+     *              (x,y) pair.\n+     * @param func  The function to apply.\n+     * @return {@code true} if the {@code func} returned {@code true} for every pair,\n+     *         {@code false} otherwise.\n+     */\n+    default boolean forEachBloomFilterPair(final BloomFilterProducer other,\n+            final BiPredicate<BloomFilter, BloomFilter> func) {\n+        final CountingPredicate<BloomFilter> p = new CountingPredicate<>(asBloomFilterArray(), func);\n+        return other.forEachBloomFilter(p) && p.forEachRemaining();\n+    }\n+\n+    /**\n+     * Create a standard (non-layered) Bloom filter by merging all of the layers. If\n+     * the filter is empty this method will return an empty Bloom filter.\n+     *\n+     * @return the merged bloom filter.\n+     */\n+    default BloomFilter flatten() {\n+        BloomFilter[] bf = {null};\n+        forEachBloomFilter( x -> {\n+            if (bf[0] == null) {\n+                bf[0] = new SimpleBloomFilter( x.getShape());\n+            }\n+            return bf[0].merge( x );\n+        });\n+        return bf[0];\n+    }\n+\n+    /**\n+     * Creates a BloomFilterProducer from an array of Bloom filters.\n+     *\n+     * <ul>\n+     * <li>The asBloomFilterArray() method returns a copy of the original array\n+     * with references to the original filters.</li>\n+     * <li>The forEachBloomFilterPair() method uses references to the original filters.</li>\n+     * </ul>\n+     * <p><em>All modifications to the Bloom filters are reflected in the original filters</em></p>\n+     *\n+     * @param filters The filters to be returned by the producer.\n+     * @return THe BloomFilterProducer containing the filters.\n+     */\n+    static BloomFilterProducer fromBloomFilterArray(BloomFilter... filters) {\n+        Objects.requireNonNull(filters, \"filters\");\n+        return new BloomFilterProducer() {\n+            @Override\n+            public boolean forEachBloomFilter(final Predicate<BloomFilter> predicate) {\n+                for (final BloomFilter filter : filters) {\n+                    if (!predicate.test(filter)) {\n+                        return false;\n+                    }\n+                }\n+                return true;\n+            }\n+\n+            /**\n+             * This implementation returns a copy the original array, the contained Bloom filters\n+             * are references to the originals, any modifications to them are reflected in the original\n+             * filters.\n+             */\n+            @Override\n+            public BloomFilter[] asBloomFilterArray() {\n+                return filters.clone();\n+            }\n+\n+            /**\n+             * This implementation uses references to the original filters.  Any modifications to the\n+             * filters are reflected in the originals.\n+             */\n+            @Override\n+            public boolean forEachBloomFilterPair(final BloomFilterProducer other,\n+                    final BiPredicate<BloomFilter, BloomFilter> func) {\n+                final CountingPredicate<BloomFilter> p = new CountingPredicate<>(filters, func);\n+                return other.forEachBloomFilter(p) && p.forEachRemaining();\n+            }\n+        };\n+    }\n+}\ndiff --git a/src/main/java/org/apache/commons/collections4/bloomfilter/CellProducer.java b/src/main/java/org/apache/commons/collections4/bloomfilter/CellProducer.java\nindex ecb984e2ce..4207e0a54d 100644\n--- a/src/main/java/org/apache/commons/collections4/bloomfilter/CellProducer.java\n+++ b/src/main/java/org/apache/commons/collections4/bloomfilter/CellProducer.java\n@@ -67,6 +67,11 @@ default boolean forEachIndex(final IntPredicate predicate) {\n         return forEachCell((i, v) -> predicate.test(i));\n     }\n \n+    @Override\n+    default IndexProducer uniqueIndices() {\n+        return this;\n+    }\n+\n     /**\n      * Creates a CellProducer from an IndexProducer.\n      *\ndiff --git a/src/main/java/org/apache/commons/collections4/bloomfilter/CountingLongPredicate.java b/src/main/java/org/apache/commons/collections4/bloomfilter/CountingLongPredicate.java\nindex 1f638d4b11..6d933e1a3a 100644\n--- a/src/main/java/org/apache/commons/collections4/bloomfilter/CountingLongPredicate.java\n+++ b/src/main/java/org/apache/commons/collections4/bloomfilter/CountingLongPredicate.java\n@@ -22,7 +22,8 @@\n  * A long predicate that applies the test func to each member of the {@code ary} in sequence for each call to {@code test()}.\n  * if the {@code ary} is exhausted, the subsequent calls to {@code test} are executed with a zero value.\n  * If the calls to {@code test} do not exhaust the {@code ary} the {@code forEachRemaining} method can be called to\n- * execute the @code{text} with a zero value for each remaining {@code idx} value.\n+ * execute the @{code test} with a zero value for each remaining {@code idx} value.\n+ * @since 4.5\n  */\n class CountingLongPredicate implements LongPredicate {\n     private int idx;\ndiff --git a/src/main/java/org/apache/commons/collections4/bloomfilter/CountingPredicate.java b/src/main/java/org/apache/commons/collections4/bloomfilter/CountingPredicate.java\nnew file mode 100644\nindex 0000000000..8ee70040ef\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/bloomfilter/CountingPredicate.java\n@@ -0,0 +1,75 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.bloomfilter;\n+\n+import java.util.function.BiPredicate;\n+import java.util.function.Predicate;\n+\n+/**\n+ * A predicate that applies the test {@code func} to each member of the {@code ary} in\n+ * sequence for each call to {@code test()}. if the {@code ary} is exhausted,\n+ * the subsequent calls to {@code test} are executed with a {@code null} value.\n+ * If the calls to {@code test} do not exhaust the {@code ary} the {@code\n+ * forEachRemaining} method can be called to execute the @{code test} with a\n+ * {@code null} value for each remaining {@code idx} value.\n+ *\n+ * @param <T> the type of object being compared.\n+ * @since 4.5\n+ */\n+class CountingPredicate<T> implements Predicate<T> {\n+    private int idx;\n+    private final T[] ary;\n+    private final BiPredicate<T, T> func;\n+\n+    /**\n+     * Constructs an instance that will compare the elements in {@code ary} with the\n+     * elements returned by {@code func}. function is called as {@code func.test(\n+     * idxValue, otherValue )}. If there are more {@code otherValue} values than\n+     * {@code idxValues} then {@code func} is called as {@code func.test(null, otherValue)}.\n+     *\n+     * @param ary  The array of long values to compare.\n+     * @param func The function to apply to the pairs of long values.\n+     */\n+    CountingPredicate(final T[] ary, final BiPredicate<T, T> func) {\n+        this.ary = ary;\n+        this.func = func;\n+    }\n+\n+    @Override\n+    public boolean test(final T other) {\n+        return func.test(idx == ary.length ? null : ary[idx++], other);\n+    }\n+\n+    /**\n+     * Call {@code BiPredicate<T, T>} for each remaining unpaired {@code <T>} in the\n+     * input array. This method should be invoked after the predicate has been\n+     * passed to a {@code Producer.forEach<T>(BiPredicate<T, T>)} to consume any\n+     * unpaired {@code <T>}s. The second argument to the BiPredicate will be {@code null}.\n+     *\n+     * @return true if all calls the predicate were successful\n+     */\n+    boolean forEachRemaining() {\n+        // uses local references for optimization benefit.\n+        int i = idx;\n+        final T[] a = ary;\n+        final int limit = a.length;\n+        while (i != limit && func.test(a[i], null)) {\n+            i++;\n+        }\n+        return i == limit;\n+    }\n+}\ndiff --git a/src/main/java/org/apache/commons/collections4/bloomfilter/LayerManager.java b/src/main/java/org/apache/commons/collections4/bloomfilter/LayerManager.java\nnew file mode 100644\nindex 0000000000..710bfb53a6\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/bloomfilter/LayerManager.java\n@@ -0,0 +1,383 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.bloomfilter;\n+\n+import java.util.LinkedList;\n+import java.util.NoSuchElementException;\n+import java.util.Objects;\n+import java.util.function.Consumer;\n+import java.util.function.Predicate;\n+import java.util.function.Supplier;\n+\n+/**\n+ * Implementation of the methods to manage the layers in a layered Bloom filter.\n+ * <p>\n+ * The manager comprises a list of Bloom filters that are managed based on\n+ * various rules. The last filter in the list is known as the {@code target} and\n+ * is the filter into which merges are performed. The Layered manager utilizes\n+ * three methods to manage the list.\n+ * </p>\n+ * <ul>\n+ * <li>ExtendCheck - A Predicate that if true causes a new Bloom filter to be\n+ * created as the new target.</li>\n+ * <li>FilterSupplier - A Supplier that produces empty Bloom filters to be used\n+ * as a new target.</li>\n+ * <li>Cleanup - A Consumer of a {@code LinkedList} of BloomFilter that removes any\n+ * expired or out dated filters from the list.</li>\n+ * </ul>\n+ * <p>\n+ * When extendCheck returns {@code true} the following steps are taken:\n+ * </p>\n+ * <ol>\n+ * <li>{@code Cleanup} is called</li>\n+ * <li>{@code FilterSuplier} is executed and the new filter added to the list as\n+ * the {@code target} filter.</li>\n+ * </ol>\n+ *\n+ * @since 4.5\n+ */\n+public class LayerManager implements BloomFilterProducer {\n+\n+    /**\n+     * A collection of common ExtendCheck implementations to test whether to extend\n+     * the depth of a LayerManager.\n+     */\n+    public static final class ExtendCheck {\n+        private ExtendCheck() {\n+        }\n+\n+        /**\n+         * Advances the target once a merge has been performed.\n+         * @return A Predicate suitable for the LayerManager {@code extendCheck} parameter.\n+         */\n+        public static Predicate<LayerManager> advanceOnPopulated() {\n+            return lm -> !lm.filters.peekLast().isEmpty();\n+        }\n+\n+        /**\n+         * Does not automatically advance the target. @{code next()} must be called directly to\n+         * perform the advance.\n+         * @return A Predicate suitable for the LayerManager {@code extendCheck} parameter.\n+         */\n+        public static Predicate<LayerManager> neverAdvance() {\n+            return x -> false;\n+        }\n+\n+        /**\n+         * Creates a new target after a specific number of filters have been added to\n+         * the current target.\n+         *\n+         * @param breakAt the number of filters to merge into each filter in the list.\n+         * @return A Predicate suitable for the LayerManager {@code extendCheck} parameter.\n+         * @throws IllegalArgumentException if {@code breakAt <= 0}\n+         */\n+        public static Predicate<LayerManager> advanceOnCount(int breakAt) {\n+            if (breakAt <= 0) {\n+                throw new IllegalArgumentException(\"'breakAt' must be greater than 0\");\n+            }\n+            return new Predicate<LayerManager>() {\n+                int count;\n+\n+                @Override\n+                public boolean test(LayerManager filter) {\n+                    return ++count % breakAt == 0;\n+                }\n+            };\n+        }\n+\n+        /**\n+         * Creates a new target after the current target is saturated. Saturation is\n+         * defined as the {@code Bloom filter estimated N >= maxN}.\n+         *\n+         * <p>An example usage is advancing on a calculated saturation by calling:\n+         * {@code ExtendCheck.advanceOnSaturation(shape.estimateMaxN()) }</p>\n+         *\n+         * @param maxN the maximum number of estimated items in the filter.\n+         * @return A Predicate suitable for the LayerManager {@code extendCheck} parameter.\n+         * @throws IllegalArgumentException if {@code maxN <= 0}\n+         */\n+        public static Predicate<LayerManager> advanceOnSaturation(double maxN) {\n+            if (maxN <= 0) {\n+                throw new IllegalArgumentException(\"'maxN' must be greater than 0\");\n+            }\n+            return manager -> {\n+                BloomFilter bf = manager.filters.peekLast();\n+                return maxN <= bf.getShape().estimateN(bf.cardinality());\n+            };\n+        }\n+    }\n+\n+    /**\n+     * Static methods to create a Consumer of a LinkedList of BloomFilter perform\n+     * tests on whether to reduce the collection of Bloom filters.\n+     */\n+    public static final class Cleanup {\n+        private Cleanup() {\n+        }\n+\n+        /**\n+         * A Cleanup that never removes anything.\n+         * @return A Consumer suitable for the LayerManager {@code cleanup} parameter.\n+         */\n+        public static Consumer<LinkedList<BloomFilter>> noCleanup() {\n+            return x -> {};\n+        }\n+\n+        /**\n+         * Removes the earliest filters in the list when the the number of filters\n+         * exceeds maxSize.\n+         *\n+         * @param maxSize the maximum number of filters for the list. Must be greater\n+         *                than 0\n+         * @return A Consumer suitable for the LayerManager {@code cleanup} parameter.\n+         * @throws IllegalArgumentException if {@code maxSize <= 0}.\n+         */\n+        public static Consumer<LinkedList<BloomFilter>> onMaxSize(int maxSize) {\n+            if (maxSize <= 0) {\n+                throw new IllegalArgumentException(\"'maxSize' must be greater than 0\");\n+            }\n+            return ll -> {\n+                while (ll.size() > maxSize) {\n+                    ll.removeFirst();\n+                }\n+            };\n+        }\n+\n+        /**\n+         * Removes the last added target if it is empty.  Useful as the first in a chain\n+         * of cleanup consumers.  (e.g. {@code Cleanup.removeEmptyTarget.andThen( otherConsumer )})\n+         *\n+         * @return A Consumer suitable for the LayerManager {@code cleanup} parameter.\n+         */\n+        public static Consumer<LinkedList<BloomFilter>> removeEmptyTarget() {\n+            return x -> {\n+                if (x.getLast().cardinality() == 0) {\n+                    x.removeLast();\n+                }\n+            };\n+        }\n+    }\n+\n+    private final LinkedList<BloomFilter> filters = new LinkedList<>();\n+    private final Consumer<LinkedList<BloomFilter>> filterCleanup;\n+    private final Predicate<LayerManager> extendCheck;\n+    private final Supplier<BloomFilter> filterSupplier;\n+\n+    /**\n+     * Creates a new Builder with defaults of {@code ExtendCheck.neverAdvance()} and\n+     * {@code Cleanup.noCleanup()}.\n+     *\n+     * @return A builder.\n+     * @see ExtendCheck#neverAdvance()\n+     * @see Cleanup#noCleanup()\n+     */\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param filterSupplier the supplier of new Bloom filters to add the the list\n+     *                       when necessary.\n+     * @param extendCheck    The predicate that checks if a new filter should be\n+     *                       added to the list.\n+     * @param filterCleanup  the consumer that removes any old filters from the\n+     *                       list.\n+     * @param initialize     true if the filter list should be initialized.\n+     */\n+    private LayerManager(Supplier<BloomFilter> filterSupplier, Predicate<LayerManager> extendCheck,\n+            Consumer<LinkedList<BloomFilter>> filterCleanup, boolean initialize) {\n+        this.filterSupplier = filterSupplier;\n+        this.extendCheck = extendCheck;\n+        this.filterCleanup = filterCleanup;\n+        if (initialize) {\n+            addFilter();\n+        }\n+    }\n+\n+    /**\n+     * Adds a new Bloom filter to the list.\n+     */\n+    private void addFilter() {\n+        BloomFilter bf = filterSupplier.get();\n+        if (bf == null) {\n+            throw new NullPointerException(\"filterSupplier returned null.\");\n+        }\n+        filters.add(bf);\n+    }\n+\n+    /**\n+     * Creates a deep copy of this LayerManager.\n+     * <p><em>Filters in the copy are deep copies, not references, so changes in the copy\n+     * are NOT reflected in the original.</em></p>\n+     * <p>The {@code filterSupplier}, {@code extendCheck}, and the {@code filterCleanup} are shared between\n+     * the copy and this instance.</p>\n+     *\n+     * @return a copy of this layer Manager.\n+     */\n+    public LayerManager copy() {\n+        LayerManager newMgr = new LayerManager(filterSupplier, extendCheck, filterCleanup, false);\n+        for (BloomFilter bf : filters) {\n+            newMgr.filters.add(bf.copy());\n+        }\n+        return newMgr;\n+    }\n+\n+    /**\n+     * Forces an advance to the next depth. This method will clean-up the current\n+     * layers and generate a new filter layer. In most cases is it unnecessary to\n+     * call this method directly.\n+     * <p>\n+     * Ths method is used within {@link #getTarget()} when the configured\n+     * {@code ExtendCheck} returns {@code true}.\n+     * </p>\n+     */\n+    void next() {\n+        this.filterCleanup.accept(filters);\n+        addFilter();\n+    }\n+\n+    /**\n+     * Returns the number of filters in the LayerManager.  In the default LayerManager implementation\n+     * there is alwasy at least one layer.\n+     *\n+     * @return the current depth.\n+     */\n+    public final int getDepth() {\n+        return filters.size();\n+    }\n+\n+    /**\n+     * Gets the Bloom filter at the specified depth. The filter at depth 0 is the\n+     * oldest filter.\n+     *\n+     * @param depth the depth at which the desired filter is to be found.\n+     * @return the filter.\n+     * @throws NoSuchElementException if depth is not in the range\n+     *                                [0,filters.size())\n+     */\n+    public final BloomFilter get(int depth) {\n+        if (depth < 0 || depth >= filters.size()) {\n+            throw new NoSuchElementException(String.format(\"Depth must be in the range [0,%s)\", filters.size()));\n+        }\n+        return filters.get(depth);\n+    }\n+\n+    /**\n+     * Returns the current target filter. If a new filter should be created based on\n+     * {@code extendCheck} it will be created before this method returns.\n+     *\n+     * @return the current target filter after any extension.\n+     */\n+    public final BloomFilter getTarget() {\n+        if (extendCheck.test(this)) {\n+            next();\n+        }\n+        return filters.peekLast();\n+    }\n+\n+    /**\n+     * Removes all the filters from the layer manager, and sets up a new one as the\n+     * target.\n+     */\n+    public final void clear() {\n+        filters.clear();\n+        addFilter();\n+    }\n+\n+    /**\n+     * Executes a Bloom filter Predicate on each Bloom filter in the manager in\n+     * depth order. Oldest filter first.\n+     *\n+     * @param bloomFilterPredicate the predicate to evaluate each Bloom filter with.\n+     * @return {@code false} when the a filter fails the predicate test. Returns\n+     *         {@code true} if all filters pass the test.\n+     */\n+    @Override\n+    public boolean forEachBloomFilter(Predicate<BloomFilter> bloomFilterPredicate) {\n+        for (BloomFilter bf : filters) {\n+            if (!bloomFilterPredicate.test(bf)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Builder to create Layer Manager\n+     */\n+    public static class Builder {\n+        private Predicate<LayerManager> extendCheck;\n+        private Supplier<BloomFilter> supplier;\n+        private Consumer<LinkedList<BloomFilter>> cleanup;\n+\n+        private Builder() {\n+            extendCheck = ExtendCheck.neverAdvance();\n+            cleanup = Cleanup.noCleanup();\n+        }\n+\n+        /**\n+         * Builds the layer manager with the specified properties.\n+         *\n+         * @return a new LayerManager.\n+         */\n+        public LayerManager build() {\n+            Objects.requireNonNull(supplier, \"Supplier must not be null\");\n+            Objects.requireNonNull(extendCheck, \"ExtendCheck must not be null\");\n+            Objects.requireNonNull(cleanup, \"Cleanup must not be null\");\n+            return new LayerManager(supplier, extendCheck, cleanup, true);\n+        }\n+\n+        /**\n+         * Sets the extendCheck predicate. When the predicate returns {@code true} a new\n+         * target will be created.\n+         *\n+         * @param extendCheck The predicate to determine if a new target should be\n+         *                    created.\n+         * @return this for chaining.\n+         */\n+        public Builder setExtendCheck(Predicate<LayerManager> extendCheck) {\n+            this.extendCheck = extendCheck;\n+            return this;\n+        }\n+\n+        /**\n+         * Sets the supplier of Bloom filters. When extendCheck creates a new target,\n+         * the supplier provides the instance of the Bloom filter.\n+         *\n+         * @param supplier The supplier of new Bloom filter instances.\n+         * @return this for chaining.\n+         */\n+        public Builder setSupplier(Supplier<BloomFilter> supplier) {\n+            this.supplier = supplier;\n+            return this;\n+        }\n+\n+        /**\n+         * Sets the Consumer that cleans the list of Bloom filters.\n+         *\n+         * @param cleanup the Consumer that will modify the list of filters removing out\n+         *                dated or stale filters.\n+         * @return this for chaining.\n+         */\n+        public Builder setCleanup(Consumer<LinkedList<BloomFilter>> cleanup) {\n+            this.cleanup = cleanup;\n+            return this;\n+        }\n+    }\n+}\ndiff --git a/src/main/java/org/apache/commons/collections4/bloomfilter/LayeredBloomFilter.java b/src/main/java/org/apache/commons/collections4/bloomfilter/LayeredBloomFilter.java\nnew file mode 100644\nindex 0000000000..cff8e87efc\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/bloomfilter/LayeredBloomFilter.java\n@@ -0,0 +1,380 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.bloomfilter;\n+\n+import java.util.Arrays;\n+import java.util.NoSuchElementException;\n+import java.util.Objects;\n+import java.util.function.IntPredicate;\n+import java.util.function.LongPredicate;\n+import java.util.function.Predicate;\n+\n+/**\n+ * Layered Bloom filters are described in Zhiwang, Cen; Jungang, Xu; Jian, Sun\n+ * (2010), \"A multi-layer Bloom filter for duplicated URL detection\", Proc. 3rd\n+ * International Conference on Advanced Computer Theory and Engineering (ICACTE\n+ * 2010), vol. 1, pp. V1-586-V1-591, doi:10.1109/ICACTE.2010.5578947, ISBN\n+ * 978-1-4244-6539-2, S2CID 3108985\n+ * <p>\n+ * In short, Layered Bloom filter contains several bloom filters arranged in\n+ * layers.\n+ * </p>\n+ * <ul>\n+ * <li>When membership in the filter is checked each layer in turn is checked\n+ * and if a match is found {@code true} is returned.</li>\n+ * <li>When merging each bloom filter is merged into the newest filter in the\n+ * list of layers.</li>\n+ * <li>When questions of cardinality are asked the cardinality of the union of\n+ * the enclosed Bloom filters is used.</li>\n+ * </ul>\n+ * <p>\n+ * The net result is that the layered Bloom filter can be populated with more\n+ * items than the Shape would indicate and yet still return a false positive\n+ * rate in line with the Shape and not the over population.\n+ * </p>\n+ * <p>\n+ * This implementation uses a LayerManager to handle the manipulation of the\n+ * layers.\n+ * </p>\n+ * <ul>\n+ * <li>Level 0 is the oldest layer and the highest level is the newest.</li>\n+ * <li>There is always at least one enclosed filter.</li>\n+ * <li>The newest filter is the {@code target} into which merges are performed.\n+ * <li>Whenever the target is retrieved, or a {@code merge} operation is\n+ * performed the code checks if any older layers should be removed, and if so\n+ * removes them. It also checks it a new layer should be added, and if so adds\n+ * it and sets the {@code target} before the operation.</li>\n+ * </ul>\n+ * @since 4.5\n+ */\n+public class LayeredBloomFilter implements BloomFilter, BloomFilterProducer {\n+    private final Shape shape;\n+    private LayerManager layerManager;\n+\n+    /**\n+     * Creates a fixed size layered bloom filter that adds new filters to the list,\n+     * but never merges them. List will never exceed maxDepth. As additional filters\n+     * are added earlier filters are removed.\n+     *\n+     * @param shape    The shape for the enclosed Bloom filters.\n+     * @param maxDepth The maximum depth of layers.\n+     * @return An empty layered Bloom filter of the specified shape and depth.\n+     */\n+    public static LayeredBloomFilter fixed(final Shape shape, int maxDepth) {\n+        LayerManager manager = LayerManager.builder().setExtendCheck(LayerManager.ExtendCheck.advanceOnPopulated())\n+                .setCleanup(LayerManager.Cleanup.onMaxSize(maxDepth)).setSupplier(() -> new SimpleBloomFilter(shape)).build();\n+        return new LayeredBloomFilter(shape, manager);\n+    }\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param shape        the Shape of the enclosed Bloom filters\n+     * @param layerManager the LayerManager to manage the layers.\n+     */\n+    public LayeredBloomFilter(Shape shape, LayerManager layerManager) {\n+        this.shape = shape;\n+        this.layerManager = layerManager;\n+    }\n+\n+    @Override\n+    public LayeredBloomFilter copy() {\n+        return new LayeredBloomFilter(shape, layerManager.copy());\n+    }\n+\n+    /**\n+     * Gets the depth of the deepest layer. The minimum value returned by this\n+     * method is 1.\n+     *\n+     * @return the depth of the deepest layer.\n+     */\n+    public final int getDepth() {\n+        return layerManager.getDepth();\n+    }\n+\n+    /**\n+     * Gets the Bloom filter at the specified depth\n+     *\n+     * @param depth the depth of the filter to return.\n+     * @return the Bloom filter at the specified depth.\n+     * @throws NoSuchElementException if depth is not in the range [0,getDepth())\n+     */\n+    public BloomFilter get(int depth) {\n+        return layerManager.get(depth);\n+    }\n+\n+    @Override\n+    public int cardinality() {\n+        return SetOperations.cardinality(this);\n+    }\n+\n+    @Override\n+    public boolean isEmpty() {\n+        return forEachBloomFilter(BloomFilter::isEmpty);\n+    }\n+\n+    @Override\n+    public final void clear() {\n+        layerManager.clear();\n+    }\n+\n+    /**\n+     * Processes the Bloom filters in depth order with the most recent filters\n+     * first. Each filter is passed to the predicate in turn. The function exits on\n+     * the first {@code false} returned by the predicate.\n+     *\n+     * @param bloomFilterPredicate the predicate to execute.\n+     * @return {@code true} if all filters passed the predicate, {@code false}\n+     *         otherwise.\n+     */\n+    @Override\n+    public final boolean forEachBloomFilter(Predicate<BloomFilter> bloomFilterPredicate) {\n+        return layerManager.forEachBloomFilter(bloomFilterPredicate);\n+    }\n+\n+    /**\n+     * Create a standard (non-layered) Bloom filter by merging all of the layers. If\n+     * the filter is empty this method will return an empty Bloom filter.\n+     *\n+     * @return the merged bloom filter.\n+     */\n+    @Override\n+    public BloomFilter flatten() {\n+        BloomFilter bf = new SimpleBloomFilter(shape);\n+        forEachBloomFilter(bf::merge);\n+        return bf;\n+    }\n+\n+    /**\n+     * Finds the layers in which the Hasher is found.\n+     *\n+     * @param hasher the Hasher to search for.\n+     * @return an array of layer indices in which the Bloom filter is found.\n+     */\n+    public int[] find(final Hasher hasher) {\n+        SimpleBloomFilter bf = new SimpleBloomFilter(shape);\n+        bf.merge(hasher);\n+        return find(bf);\n+    }\n+\n+    /**\n+     * Finds the layers in which the IndexProducer is found.\n+     *\n+     * @param indexProducer the Index producer to search for.\n+     * @return an array of layer indices in which the Bloom filter is found.\n+     */\n+    public int[] find(final IndexProducer indexProducer) {\n+        SimpleBloomFilter bf = new SimpleBloomFilter(shape);\n+        bf.merge(indexProducer);\n+        return find(bf);\n+    }\n+\n+    /**\n+     * Finds the layers in which the BitMapProducer is found.\n+     *\n+     * @param bitMapProducer the BitMapProducer to search for.\n+     * @return an array of layer indices in which the Bloom filter is found.\n+     */\n+    public int[] find(final BitMapProducer bitMapProducer) {\n+        SimpleBloomFilter bf = new SimpleBloomFilter(shape);\n+        bf.merge(bitMapProducer);\n+        return find(bf);\n+    }\n+\n+    /**\n+     * Finds the layers in which the Bloom filter is found.\n+     *\n+     * @param bf the Bloom filter to search for.\n+     * @return an array of layer indices in which the Bloom filter is found.\n+     */\n+    public int[] find(BloomFilter bf) {\n+        Finder finder = new Finder(bf);\n+        forEachBloomFilter(finder);\n+        return finder.getResult();\n+    }\n+\n+    /**\n+     * Returns {@code true} if this any layer contained by this filter contains the\n+     * specified filter.\n+     * <p>\n+     * If the {@code other} is a BloomFilterProducer each filter within the\n+     * {@code other} is checked to see if it exits within this filter.\n+     * </p>\n+     *\n+     * @param other the other Bloom filter\n+     * @return {@code true} if this filter contains the other filter.\n+     */\n+    @Override\n+    public boolean contains(final BloomFilter other) {\n+        return other instanceof BloomFilterProducer ? contains((BloomFilterProducer) other)\n+                : !forEachBloomFilter(x -> !x.contains(other));\n+    }\n+\n+    /**\n+     * Returns {@code true} if each filter within the {@code producer} exits within\n+     * this filter.\n+     *\n+     * @param producer the BloomFilterProducer that provides the filters to check\n+     *                 for.\n+     * @return {@code true} if this filter contains all of the filters contained in\n+     *         the {@code producer}.\n+     */\n+    public boolean contains(final BloomFilterProducer producer) {\n+        boolean[] result = { true };\n+        // return false when we have found a match to short circuit checks\n+        return producer.forEachBloomFilter(x -> {\n+            result[0] &= contains(x);\n+            return result[0];\n+        });\n+    }\n+\n+    /**\n+     * Creates a Bloom filter from a Hasher.\n+     *\n+     * @param hasher the hasher to create the filter from.\n+     * @return the BloomFilter.\n+     */\n+    private BloomFilter createFilter(final Hasher hasher) {\n+        SimpleBloomFilter bf = new SimpleBloomFilter(shape);\n+        bf.merge(hasher);\n+        return bf;\n+    }\n+\n+    /**\n+     * Creates a Bloom filter from an IndexProducer.\n+     *\n+     * @param indexProducer the IndexProducer to create the filter from.\n+     * @return the BloomFilter.\n+     */\n+    private BloomFilter createFilter(final IndexProducer indexProducer) {\n+        SimpleBloomFilter bf = new SimpleBloomFilter(shape);\n+        bf.merge(indexProducer);\n+        return bf;\n+    }\n+\n+    /**\n+     * Creates a Bloom filter from a BitMapProducer.\n+     *\n+     * @param bitMapProducer the BitMapProducer to create the filter from.\n+     * @return the BloomFilter.\n+     */\n+    private BloomFilter createFilter(final BitMapProducer bitMapProducer) {\n+        SimpleBloomFilter bf = new SimpleBloomFilter(shape);\n+        bf.merge(bitMapProducer);\n+        return bf;\n+    }\n+\n+    @Override\n+    public int characteristics() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public final Shape getShape() {\n+        return shape;\n+    }\n+\n+    @Override\n+    public boolean contains(final Hasher hasher) {\n+        return contains(createFilter(hasher));\n+    }\n+\n+    @Override\n+    public boolean contains(final BitMapProducer bitMapProducer) {\n+        return contains(createFilter(bitMapProducer));\n+    }\n+\n+    @Override\n+    public boolean contains(IndexProducer indexProducer) {\n+        return contains(createFilter(indexProducer));\n+    }\n+\n+    @Override\n+    public boolean merge(BloomFilter bf) {\n+        return layerManager.getTarget().merge(bf);\n+    }\n+\n+    @Override\n+    public boolean merge(IndexProducer indexProducer) {\n+        return layerManager.getTarget().merge(indexProducer);\n+    }\n+\n+    @Override\n+    public boolean merge(BitMapProducer bitMapProducer) {\n+        return layerManager.getTarget().merge(bitMapProducer);\n+    }\n+\n+    @Override\n+    public boolean forEachIndex(IntPredicate predicate) {\n+        return forEachBloomFilter(bf -> bf.forEachIndex(predicate));\n+    }\n+\n+    @Override\n+    public boolean forEachBitMap(LongPredicate predicate) {\n+        return flatten().forEachBitMap(predicate);\n+    }\n+\n+    @Override\n+    public int estimateN() {\n+        return flatten().estimateN();\n+    }\n+\n+    @Override\n+    public int estimateUnion(final BloomFilter other) {\n+        Objects.requireNonNull(other, \"other\");\n+        final BloomFilter cpy = this.flatten();\n+        cpy.merge(other);\n+        return cpy.estimateN();\n+    }\n+\n+    /**\n+     * Forces and advance to the next layer. Executes the same logic as when\n+     * LayerManager.extendCheck returns {@code true}\n+     *\n+     * @see LayerManager\n+     */\n+    public void next() {\n+        layerManager.next();\n+    }\n+\n+    /**\n+     * A class used to locate matching filters across all the layers.\n+     */\n+    private class Finder implements Predicate<BloomFilter> {\n+        int[] result = new int[layerManager.getDepth()];\n+        int bfIdx;\n+        int resultIdx;\n+        BloomFilter bf;\n+\n+        Finder(BloomFilter bf) {\n+            this.bf = bf;\n+        }\n+\n+        @Override\n+        public boolean test(BloomFilter x) {\n+            if (x.contains(bf)) {\n+                result[resultIdx++] = bfIdx;\n+            }\n+            bfIdx++;\n+            return true;\n+        }\n+\n+        int[] getResult() {\n+            return Arrays.copyOf(result, resultIdx);\n+        }\n+    }\n+}\ndiff --git a/src/main/java/org/apache/commons/collections4/bloomfilter/Shape.java b/src/main/java/org/apache/commons/collections4/bloomfilter/Shape.java\nindex 883208f063..aeb1eb2685 100644\n--- a/src/main/java/org/apache/commons/collections4/bloomfilter/Shape.java\n+++ b/src/main/java/org/apache/commons/collections4/bloomfilter/Shape.java\n@@ -227,6 +227,23 @@ public double estimateN(final int cardinality) {\n         return -(m / k) * Math.log1p(-c / m);\n     }\n \n+    /**\n+     * Estimates the maximum number of elements that can be merged into a filter of\n+     * this shape before the false positive rate exceeds the desired rate. <p> The\n+     * formula for deriving {@code k} when {@code m} and {@code n} are known is:\n+     *\n+     * <p>{@code k = ln2 * m / n}</p>\n+     *\n+     * <p>Solving for {@code n} yields:</p>\n+     *\n+     * <p>{@code n = ln2 * m / k}</p>\n+     *\n+     * @return An estimate of max N.\n+     */\n+    public double estimateMaxN() {\n+        return numberOfBits * LN_2 / numberOfHashFunctions;\n+    }\n+\n     /**\n      * Constructs a filter configuration with a desired false-positive probability ({@code p}) and the\n      * specified number of bits ({@code m}) and hash functions ({@code k}).\ndiff --git a/src/main/java/org/apache/commons/collections4/bloomfilter/SimpleBloomFilter.java b/src/main/java/org/apache/commons/collections4/bloomfilter/SimpleBloomFilter.java\nindex 25114c1136..91d802c32c 100644\n--- a/src/main/java/org/apache/commons/collections4/bloomfilter/SimpleBloomFilter.java\n+++ b/src/main/java/org/apache/commons/collections4/bloomfilter/SimpleBloomFilter.java\n@@ -167,6 +167,11 @@ public int cardinality() {\n         return c;\n     }\n \n+    @Override\n+    public boolean isEmpty() {\n+        return cardinality == 0 || forEachBitMap(y -> y == 0);\n+    }\n+\n     @Override\n     public boolean forEachIndex(final IntPredicate consumer) {\n         Objects.requireNonNull(consumer, \"consumer\");\ndiff --git a/src/main/java/org/apache/commons/collections4/bloomfilter/SparseBloomFilter.java b/src/main/java/org/apache/commons/collections4/bloomfilter/SparseBloomFilter.java\nindex bd0ba87cc2..980f74f9c2 100644\n--- a/src/main/java/org/apache/commons/collections4/bloomfilter/SparseBloomFilter.java\n+++ b/src/main/java/org/apache/commons/collections4/bloomfilter/SparseBloomFilter.java\n@@ -136,6 +136,11 @@ public int cardinality() {\n         return indices.size();\n     }\n \n+    @Override\n+    public boolean isEmpty() {\n+        return indices.isEmpty();\n+    }\n+\n     @Override\n     public boolean forEachIndex(final IntPredicate consumer) {\n         Objects.requireNonNull(consumer, \"consumer\");\ndiff --git a/src/main/java/org/apache/commons/collections4/bloomfilter/WrappedBloomFilter.java b/src/main/java/org/apache/commons/collections4/bloomfilter/WrappedBloomFilter.java\nnew file mode 100644\nindex 0000000000..cff65d6e34\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/bloomfilter/WrappedBloomFilter.java\n@@ -0,0 +1,148 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.bloomfilter;\n+\n+import java.util.function.IntPredicate;\n+import java.util.function.LongPredicate;\n+\n+/**\n+ * An abstract class to assist in implementing Bloom filter decorators.\n+ *\n+ * @since 4.5\n+ */\n+public abstract class WrappedBloomFilter implements BloomFilter {\n+    final BloomFilter wrapped;\n+\n+    /**\n+     * Wraps a Bloom filter.  The wrapped filter is maintained as a reference\n+     * not a copy.  Changes in one will be reflected in the other.\n+     * @param bf The Bloom filter.\n+     */\n+    public WrappedBloomFilter(BloomFilter bf) {\n+        this.wrapped = bf;\n+    }\n+\n+    @Override\n+    public boolean forEachIndex(IntPredicate predicate) {\n+        return wrapped.forEachIndex(predicate);\n+    }\n+\n+    @Override\n+    public BloomFilter copy() {\n+        return wrapped.copy();\n+    }\n+\n+    @Override\n+    public boolean forEachBitMap(LongPredicate predicate) {\n+        return wrapped.forEachBitMap(predicate);\n+    }\n+\n+    @Override\n+    public int characteristics() {\n+        return wrapped.characteristics();\n+    }\n+\n+    @Override\n+    public Shape getShape() {\n+        return wrapped.getShape();\n+    }\n+\n+    @Override\n+    public void clear() {\n+        wrapped.clear();\n+    }\n+\n+    @Override\n+    public boolean contains(BloomFilter other) {\n+        return wrapped.contains(other);\n+    }\n+\n+    @Override\n+    public boolean forEachBitMapPair(BitMapProducer other, LongBiPredicate func) {\n+        return wrapped.forEachBitMapPair(other, func);\n+    }\n+\n+    @Override\n+    public boolean contains(Hasher hasher) {\n+        return wrapped.contains(hasher);\n+    }\n+\n+    @Override\n+    public long[] asBitMapArray() {\n+        return wrapped.asBitMapArray();\n+    }\n+\n+    @Override\n+    public int[] asIndexArray() {\n+        return wrapped.asIndexArray();\n+    }\n+\n+    @Override\n+    public boolean contains(IndexProducer indexProducer) {\n+        return wrapped.contains(indexProducer);\n+    }\n+\n+    @Override\n+    public boolean contains(BitMapProducer bitMapProducer) {\n+        return wrapped.contains(bitMapProducer);\n+    }\n+\n+    @Override\n+    public boolean merge(BloomFilter other) {\n+        return wrapped.merge(other);\n+    }\n+\n+    @Override\n+    public boolean merge(Hasher hasher) {\n+        return wrapped.merge(hasher);\n+    }\n+\n+    @Override\n+    public boolean merge(IndexProducer indexProducer) {\n+        return wrapped.merge(indexProducer);\n+    }\n+\n+    @Override\n+    public boolean merge(BitMapProducer bitMapProducer) {\n+        return wrapped.merge(bitMapProducer);\n+    }\n+\n+    @Override\n+    public boolean isFull() {\n+        return wrapped.isFull();\n+    }\n+\n+    @Override\n+    public int cardinality() {\n+        return wrapped.cardinality();\n+    }\n+\n+    @Override\n+    public int estimateN() {\n+        return wrapped.estimateN();\n+    }\n+\n+    @Override\n+    public int estimateUnion(BloomFilter other) {\n+        return wrapped.estimateUnion(other);\n+    }\n+\n+    @Override\n+    public int estimateIntersection(BloomFilter other) {\n+        return wrapped.estimateIntersection(other);\n+    }\n+}\ndiff --git a/src/main/java/org/apache/commons/collections4/bloomfilter/package-info.java b/src/main/java/org/apache/commons/collections4/bloomfilter/package-info.java\nindex 7df764182d..7a21f19834 100644\n--- a/src/main/java/org/apache/commons/collections4/bloomfilter/package-info.java\n+++ b/src/main/java/org/apache/commons/collections4/bloomfilter/package-info.java\n@@ -46,7 +46,7 @@\n  * representation of the internal structure. Additional methods are available in the {@code BitMap} to assist in\n  * manipulation of the representations.</p>\n  *\n- * <p>The bloom filter code is an interface that requires implementation of 9 methods:</p>\n+ * <p>The Bloom filter code is an interface that requires implementation of 9 methods:</p>\n  * <ul>\n  * <li>{@link BloomFilter#cardinality()} returns the number of bits enabled in the Bloom filter.</li>\n  *\n@@ -72,10 +72,15 @@\n  *\n  * <h3>CountingBloomFilter</h3>\n  *\n- * <p>The counting bloom filter extends the Bloom filter by counting the number of times a specific bit has been\n+ * <p>The counting Bloom filter extends the Bloom filter by counting the number of times a specific bit has been\n  * enabled or disabled. This allows the removal (opposite of merge) of Bloom filters at the expense of additional\n  * overhead.</p>\n  *\n+ * <h3>LayeredBloomFilter</h3>\n+ *\n+ * <p>The layered Bloom filter extends the Bloom filter by creating layers of Bloom filters that can be queried as a single\n+ * Filter or as a set of filters.  This adds the ability to perform windowing on streams of data.</p>\n+ *\n  * <h3>Shape</h3>\n  *\n  * <p>The Shape describes the Bloom filter using the number of bits and the number of hash functions</p>\n",
  "test_patch" : "diff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBloomFilterProducerTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBloomFilterProducerTest.java\nnew file mode 100644\nindex 0000000000..3d445add96\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBloomFilterProducerTest.java\n@@ -0,0 +1,146 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.bloomfilter;\n+\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import java.util.function.BiPredicate;\n+\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+public abstract class AbstractBloomFilterProducerTest {\n+    private Shape shape = Shape.fromKM(17, 72);\n+\n+    BloomFilter one = new SimpleBloomFilter(shape);\n+    BloomFilter two = new SimpleBloomFilter(shape);\n+    int[] nullCount = { 0, 0 };\n+    int[] equalityCount = { 0 };\n+    BiPredicate<BloomFilter, BloomFilter> counter = (x, y) -> {\n+        if (x == null) {\n+            nullCount[0]++;\n+        }\n+        if (y == null) {\n+            nullCount[1]++;\n+        }\n+        if (x != null && y != null && x.cardinality() == y.cardinality()) {\n+            equalityCount[0]++;\n+        }\n+        return true;\n+    };\n+\n+    /**\n+     * The shape of the Bloom filters for testing.\n+     * <ul>\n+     *  <li>Hash functions (k) = 17\n+     *  <li>Number of bits (m) = 72\n+     * </ul>\n+     * @return the testing shape.\n+     */\n+    protected Shape getTestShape() {\n+        return shape;\n+    }\n+\n+    @BeforeEach\n+    public void setup() {\n+        one.clear();\n+        one.merge(IndexProducer.fromIndexArray(1));\n+        two.clear();\n+        two.merge(IndexProducer.fromIndexArray(2, 3));\n+        nullCount[0] = 0;\n+        nullCount[1] = 0;\n+        equalityCount[0] = 0;\n+    }\n+\n+    /**\n+     * Creates a BloomFilterProducer that returns the filters (or their copy) in the order presented.\n+     * @param filters The filters to return.\n+     * @return A BloomFilterProducer that returns the filters in order.\n+     */\n+    protected abstract BloomFilterProducer createUnderTest(BloomFilter... filters);\n+\n+    private BloomFilterProducer createUnderTest() {\n+        return createUnderTest(one, two);\n+    }\n+\n+    @Test\n+    public void testAsBloomFilterArray() {\n+        BloomFilter[] result = createUnderTest().asBloomFilterArray();\n+        assertEquals(2, result.length);\n+        assertEquals(1, result[0].cardinality());\n+        assertEquals(2, result[1].cardinality());\n+    }\n+\n+    @Test\n+    public void testForEachPairCompleteMatch() {\n+        assertTrue(createUnderTest().forEachBloomFilterPair(createUnderTest(), counter));\n+        assertArrayEquals(new int[] { 0, 0 }, nullCount);\n+        assertEquals(2, equalityCount[0]);\n+    }\n+\n+    @Test\n+    public void testForEachPairArrayTooShort() {\n+        assertTrue(createUnderTest().forEachBloomFilterPair(BloomFilterProducer.fromBloomFilterArray(one), counter));\n+        assertEquals(0, nullCount[0]);\n+        assertEquals(1, nullCount[1]);\n+        assertEquals(1, equalityCount[0]);\n+    }\n+\n+    @Test\n+    public void testForEachPairArrayTooLong() {\n+        assertTrue(createUnderTest().forEachBloomFilterPair(BloomFilterProducer.fromBloomFilterArray(one, two, one),\n+                counter));\n+        assertEquals(1, nullCount[0]);\n+        assertEquals(0, nullCount[1]);\n+        assertEquals(2, equalityCount[0]);\n+    }\n+\n+    @Test\n+    public void testForEachPairReturnFalseLate() {\n+        assertFalse(createUnderTest().forEachBloomFilterPair(BloomFilterProducer.fromBloomFilterArray(one, two, one),\n+                counter.and((x, y) -> x != null && y != null)));\n+        assertEquals(1, nullCount[0]);\n+        assertEquals(0, nullCount[1]);\n+        assertEquals(2, equalityCount[0]);\n+    }\n+\n+    @Test\n+    public void testForEachPairReturnFalseLateShortArray() {\n+        assertFalse(createUnderTest().forEachBloomFilterPair(BloomFilterProducer.fromBloomFilterArray(one),\n+                counter.and((x, y) -> x != null && y != null)));\n+        assertEquals(0, nullCount[0]);\n+        assertEquals(1, nullCount[1]);\n+        assertEquals(1, equalityCount[0]);\n+    }\n+\n+    @Test\n+    public void testForEachPairReturnFalseEarly() {\n+        assertFalse(createUnderTest().forEachBloomFilterPair(BloomFilterProducer.fromBloomFilterArray(one, two, one),\n+                (x, y) -> false));\n+    }\n+\n+    @Test\n+    public void testFlatten() {\n+        BloomFilter underTest = createUnderTest().flatten();\n+        BloomFilter expected = new SimpleBloomFilter(shape);\n+        expected.merge(IndexProducer.fromIndexArray(1, 2, 3));\n+        assertArrayEquals(expected.asBitMapArray(), underTest.asBitMapArray());\n+    }\n+}\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBloomFilterTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBloomFilterTest.java\nindex 3d332146d5..32cb95d262 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBloomFilterTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBloomFilterTest.java\n@@ -174,10 +174,10 @@ public final void testContains() {\n         BloomFilter bf1 = createFilter(getTestShape(), TestingHashers.FROM1);\n         final BloomFilter bf2 = TestingHashers.populateFromHashersFrom1AndFrom11(createEmptyFilter(getTestShape()));\n \n-        assertTrue(bf1.contains(bf1), \"BF Should contain itself\");\n+        assertTrue(bf1.contains(bf1), \"BF1 Should contain itself\");\n         assertTrue(bf2.contains(bf2), \"BF2 Should contain itself\");\n-        assertFalse(bf1.contains(bf2), \"BF should not contain BF2\");\n-        assertTrue(bf2.contains(bf1), \"BF2 should contain BF\");\n+        assertFalse(bf1.contains(bf2), \"BF1 should not contain BF2\");\n+        assertTrue(bf2.contains(bf1), \"BF2 should contain BF1\");\n \n         assertTrue(bf2.contains(new IncrementingHasher(1, 1)), \"BF2 Should contain this hasher\");\n         assertFalse(bf2.contains(new IncrementingHasher(1, 3)), \"BF2 Should not contain this hasher\");\n@@ -433,6 +433,46 @@ public void testBitMapProducerSize() {\n         assertEquals(BitMap.numberOfBitMaps(getTestShape().getNumberOfBits()), idx[0]);\n     }\n \n+    /**\n+     * Test cardinality and isEmpty. Bloom filter must be able to accept multiple\n+     * IndexProducer merges until all the bits are populated.\n+     *\n+     * @param bf The Bloom filter to test.\n+     */\n+    protected void testCardinalityAndIsEmpty(BloomFilter bf) {\n+        assertTrue(bf.isEmpty());\n+        assertEquals(0, bf.cardinality());\n+        for (int i = 0; i < getTestShape().getNumberOfBits(); i++) {\n+            bf.merge(IndexProducer.fromIndexArray(i));\n+            assertFalse(bf.isEmpty(), \"Wrong value at \" + i);\n+            assertEquals(i + 1, bf.cardinality(), \"Wrong value at \" + i);\n+        }\n+\n+        // check operations in reverse order\n+        bf.clear();\n+        assertEquals(0, bf.cardinality());\n+        assertTrue(bf.isEmpty());\n+        for (int i = 0; i < getTestShape().getNumberOfBits(); i++) {\n+            bf.merge(IndexProducer.fromIndexArray(i));\n+            assertEquals(i + 1, bf.cardinality(), \"Wrong value at \" + i);\n+            assertFalse(bf.isEmpty(), \"Wrong value at \" + i);\n+        }\n+    }\n+\n+    @Test\n+    public void testCardinalityAndIsEmpty() {\n+        testCardinalityAndIsEmpty(createEmptyFilter(getTestShape()));\n+    }\n+\n+    @Test\n+    public void testEmptyAfterMergeWithNothing() {\n+        // test the case where is empty after merge\n+        // in this case the internal cardinality == -1\n+        BloomFilter bf = createEmptyFilter(getTestShape());\n+        bf.merge(IndexProducer.fromIndexArray());\n+        assertTrue(bf.isEmpty());\n+    }\n+\n     /**\n      * Testing class returns the value as the only value.\n      */\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractIndexProducerTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractIndexProducerTest.java\nindex faa66ead7b..044dcd1721 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractIndexProducerTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractIndexProducerTest.java\n@@ -16,10 +16,10 @@\n  */\n package org.apache.commons.collections4.bloomfilter;\n \n-import static org.junit.Assert.assertSame;\n import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n import static org.junit.jupiter.api.Assertions.assertEquals;\n import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertSame;\n import static org.junit.jupiter.api.Assertions.assertTrue;\n \n import java.util.Arrays;\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/BitMapProducerFromLayeredBloomFilterTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/BitMapProducerFromLayeredBloomFilterTest.java\nnew file mode 100644\nindex 0000000000..e8a2d0c78b\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/BitMapProducerFromLayeredBloomFilterTest.java\n@@ -0,0 +1,35 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.bloomfilter;\n+\n+public class BitMapProducerFromLayeredBloomFilterTest extends AbstractBitMapProducerTest {\n+\n+    protected Shape shape = Shape.fromKM(17, 72);\n+\n+    @Override\n+    protected BitMapProducer createProducer() {\n+        final Hasher hasher = new IncrementingHasher(0, 1);\n+        final BloomFilter bf = LayeredBloomFilter.fixed(shape, 10);\n+        bf.merge(hasher);\n+        return bf;\n+    }\n+\n+    @Override\n+    protected BitMapProducer createEmptyProducer() {\n+        return LayeredBloomFilter.fixed(shape, 10);\n+    }\n+}\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/BitMapProducerFromWrappedBloomFilterTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/BitMapProducerFromWrappedBloomFilterTest.java\nnew file mode 100644\nindex 0000000000..b665bc9e94\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/BitMapProducerFromWrappedBloomFilterTest.java\n@@ -0,0 +1,38 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.bloomfilter;\n+\n+public class BitMapProducerFromWrappedBloomFilterTest extends AbstractBitMapProducerTest {\n+\n+    protected Shape shape = Shape.fromKM(17, 72);\n+\n+    @Override\n+    protected BitMapProducer createProducer() {\n+        final Hasher hasher = new IncrementingHasher(0, 1);\n+        final BloomFilter bf = new WrappedBloomFilter(new DefaultBloomFilterTest.SparseDefaultBloomFilter(shape)) {\n+        };\n+        bf.merge(hasher);\n+        return bf;\n+    }\n+\n+    @Override\n+    protected BitMapProducer createEmptyProducer() {\n+        return new WrappedBloomFilter(new DefaultBloomFilterTest.SparseDefaultBloomFilter(shape)) {\n+        };\n+    }\n+\n+}\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/BloomFilterProducerFromBloomFilterArrayTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/BloomFilterProducerFromBloomFilterArrayTest.java\nnew file mode 100644\nindex 0000000000..8a6eba7de0\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/BloomFilterProducerFromBloomFilterArrayTest.java\n@@ -0,0 +1,25 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.bloomfilter;\n+\n+public class BloomFilterProducerFromBloomFilterArrayTest extends AbstractBloomFilterProducerTest{\n+\n+    @Override\n+    protected BloomFilterProducer createUnderTest(BloomFilter... filters) {\n+        return BloomFilterProducer.fromBloomFilterArray(filters);\n+    }\n+}\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/BloomFilterProducerFromLayeredBloomFilterTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/BloomFilterProducerFromLayeredBloomFilterTest.java\nnew file mode 100644\nindex 0000000000..de93190931\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/BloomFilterProducerFromLayeredBloomFilterTest.java\n@@ -0,0 +1,33 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.bloomfilter;\n+\n+public class BloomFilterProducerFromLayeredBloomFilterTest extends AbstractBloomFilterProducerTest{\n+\n+    @Override\n+    protected BloomFilterProducer createUnderTest(BloomFilter... filters) {\n+        Shape shape = filters[0].getShape();\n+        LayerManager layerManager = LayerManager.builder().setSupplier( () -> new SimpleBloomFilter(shape) )\n+                .setExtendCheck( LayerManager.ExtendCheck.advanceOnPopulated())\n+                .setCleanup(LayerManager.Cleanup.noCleanup()).build();\n+        LayeredBloomFilter underTest = new LayeredBloomFilter(shape, layerManager);\n+        for (BloomFilter bf : filters) {\n+            underTest.merge(bf);\n+        }\n+        return underTest;\n+    }\n+}\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/CellProducerFromLayeredBloomFilterTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/CellProducerFromLayeredBloomFilterTest.java\nnew file mode 100644\nindex 0000000000..6c22b37f86\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/CellProducerFromLayeredBloomFilterTest.java\n@@ -0,0 +1,45 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.bloomfilter;\n+\n+public class CellProducerFromLayeredBloomFilterTest extends AbstractCellProducerTest {\n+\n+    protected Shape shape = Shape.fromKM(17, 72);\n+\n+    @Override\n+    protected CellProducer createProducer() {\n+        final Hasher hasher = new IncrementingHasher(3, 2);\n+        final BloomFilter bf = LayeredBloomFilter.fixed(shape, 10);\n+        bf.merge(hasher);\n+        return CellProducer.from(bf);\n+    }\n+\n+    @Override\n+    protected CellProducer createEmptyProducer() {\n+        return CellProducer.from(LayeredBloomFilter.fixed(shape, 10));\n+    }\n+\n+    @Override\n+    protected int[] getExpectedIndices() {\n+        return new int[] {3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35};\n+    }\n+\n+    @Override\n+    protected int[] getExpectedValues() {\n+        return new int[] {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};\n+    }\n+}\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/CountingPredicateTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/CountingPredicateTest.java\nnew file mode 100644\nindex 0000000000..d03c94d180\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/CountingPredicateTest.java\n@@ -0,0 +1,118 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.bloomfilter;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.BiPredicate;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.junit.jupiter.api.Test;\n+\n+public class CountingPredicateTest {\n+\n+    private Integer[] ary = {Integer.valueOf(1), Integer.valueOf(2)};\n+\n+    private BiPredicate<Integer, Integer> makeFunc(BiPredicate<Integer, Integer> inner, List<Pair<Integer, Integer>> result) {\n+        return (x, y) -> {\n+            if (inner.test(x, y)) {\n+                result.add(Pair.of(x, y));\n+                return true;\n+            }\n+            return false;\n+        };\n+    }\n+\n+    /**\n+     * Test when the predicate array is shorter than other array as determined by the number\n+     * of times cp.test() is called and all other values result in a true statement.\n+     */\n+    @Test\n+    public void testPredicateShorter() {\n+        List<Pair<Integer, Integer>> expected = new ArrayList<>();\n+        List<Pair<Integer, Integer>> result = new ArrayList<>();\n+        Integer[] shortAry = {Integer.valueOf(3)};\n+        expected.add(Pair.of(3, 1));\n+        expected.add(Pair.of(null, 2));\n+        CountingPredicate<Integer> cp = new CountingPredicate<>(shortAry, makeFunc((x, y) -> true, result));\n+        for (Integer i : ary) {\n+            assertTrue(cp.test(i));\n+        }\n+        assertEquals(expected, result);\n+        assertTrue(cp.forEachRemaining());\n+        assertEquals(expected, result);\n+    }\n+\n+    /**\n+     * Test when the predicate array is shorter than other array as determined by the number\n+     * of times cp.test() is called and all other values result in a true statement.\n+     */\n+    @Test\n+    public void testPredicateSameLength() {\n+        List<Pair<Integer, Integer>> expected = new ArrayList<>();\n+        List<Pair<Integer, Integer>> result = new ArrayList<>();\n+        expected.add( Pair.of(1, 3));\n+        expected.add( Pair.of(2, 3));\n+        CountingPredicate<Integer> cp = new CountingPredicate<>(ary, makeFunc((x, y) -> true, result));\n+        assertTrue(cp.test(3));\n+        assertTrue(cp.test(3));\n+        assertEquals(expected, result);\n+        assertTrue(cp.forEachRemaining());\n+        assertEquals(expected, result);\n+    }\n+\n+    /**\n+     * Test when the predicate array is longer than other array as determined by the number\n+     * of times cp.test() is called and all other values result in a true statement.\n+     */\n+    @Test\n+    public void testPredicateLonger() {\n+        List<Pair<Integer, Integer>> expected = new ArrayList<>();\n+        List<Pair<Integer, Integer>> result = new ArrayList<>();\n+        expected.add(Pair.of(1, 3));\n+\n+        CountingPredicate<Integer> cp = new CountingPredicate<>(ary, makeFunc((x, y) -> x!=null, result));\n+        assertTrue(cp.test(Integer.valueOf(3)));\n+        assertEquals(expected, result);\n+        expected.add(Pair.of(2, null));\n+        assertTrue(cp.forEachRemaining());\n+        assertEquals(expected, result);\n+\n+        // if the other array is zero length then cp.test() will not be called so\n+        // we can just call cp.forEachRemaining() here.\n+        expected.clear();\n+        expected.add(Pair.of(1, null));\n+        expected.add(Pair.of(2, null));\n+        result.clear();\n+        cp = new CountingPredicate<>(ary, makeFunc((x, y) -> x!=null, result));\n+        assertTrue(cp.forEachRemaining());\n+        assertEquals( expected, result);\n+\n+        // If a test fails then the result should be false and the rest of the list should\n+        // not be processed.\n+        expected.clear();\n+        expected.add(Pair.of(1, null));\n+        result.clear();\n+        cp = new CountingPredicate<>(ary,  makeFunc((x, y) -> x == Integer.valueOf(1), result));\n+        assertFalse(cp.forEachRemaining());\n+        assertEquals(expected, result);\n+    }\n+}\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/DefaultBloomFilterProducerTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/DefaultBloomFilterProducerTest.java\nnew file mode 100644\nindex 0000000000..81d41abf99\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/DefaultBloomFilterProducerTest.java\n@@ -0,0 +1,37 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.bloomfilter;\n+\n+import java.util.function.Predicate;\n+\n+public class DefaultBloomFilterProducerTest extends AbstractBloomFilterProducerTest {\n+\n+    @Override\n+    protected BloomFilterProducer createUnderTest(BloomFilter... filters) {\n+        return new BloomFilterProducer() {\n+            @Override\n+            public boolean forEachBloomFilter(Predicate<BloomFilter> bloomFilterPredicate) {\n+                for (BloomFilter bf : filters) {\n+                    if (!bloomFilterPredicate.test(bf)) {\n+                        return false;\n+                    }\n+                }\n+                return true;\n+            }\n+        };\n+    }\n+}\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/DefaultBloomFilterTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/DefaultBloomFilterTest.java\nindex e716c42b56..bd7456c709 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/DefaultBloomFilterTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/DefaultBloomFilterTest.java\n@@ -215,9 +215,12 @@ public int cardinality() {\n         }\n     }\n \n-    static class SparseDefaultBloomFilter extends AbstractDefaultBloomFilter {\n+    /**\n+     * A default implementation of a Sparse bloom filter.\n+     */\n+    public static class SparseDefaultBloomFilter extends AbstractDefaultBloomFilter {\n \n-        SparseDefaultBloomFilter(final Shape shape) {\n+        public SparseDefaultBloomFilter(final Shape shape) {\n             super(shape);\n         }\n \n@@ -234,9 +237,12 @@ public AbstractDefaultBloomFilter copy() {\n         }\n     }\n \n-    static class NonSparseDefaultBloomFilter extends AbstractDefaultBloomFilter {\n+    /**\n+     * A default implementation of a non-sparse Bloom filter.\n+     */\n+    public static class NonSparseDefaultBloomFilter extends AbstractDefaultBloomFilter {\n \n-        NonSparseDefaultBloomFilter(final Shape shape) {\n+        public NonSparseDefaultBloomFilter(final Shape shape) {\n             super(shape);\n         }\n \ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/LayerManagerTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/LayerManagerTest.java\nnew file mode 100644\nindex 0000000000..c7023b1703\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/LayerManagerTest.java\n@@ -0,0 +1,294 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.bloomfilter;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotEquals;\n+import static org.junit.Assert.assertNotSame;\n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertSame;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.function.Consumer;\n+import java.util.function.Predicate;\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n+\n+public class LayerManagerTest {\n+\n+    private Shape shape = Shape.fromKM(17, 72);\n+\n+    private LayerManager.Builder testingBuilder() {\n+        return LayerManager.builder().setSupplier(() -> new SimpleBloomFilter(shape));\n+    }\n+\n+    @Test\n+    public void testAdvanceOnPopulated() {\n+        Predicate<LayerManager> underTest = LayerManager.ExtendCheck.advanceOnPopulated();\n+        LayerManager layerManager = testingBuilder().build();\n+        assertFalse(underTest.test(layerManager));\n+        layerManager.getTarget().merge(TestingHashers.FROM1);\n+        assertTrue(underTest.test(layerManager));\n+    }\n+\n+    @Test\n+    public void testNeverAdvance() {\n+        Predicate<LayerManager> underTest = LayerManager.ExtendCheck.neverAdvance();\n+        LayerManager layerManager = testingBuilder().build();\n+        assertFalse(underTest.test(layerManager));\n+        for (int i = 0; i < 10; i++) {\n+            layerManager.getTarget().merge(TestingHashers.randomHasher());\n+            assertFalse(underTest.test(layerManager));\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(ints = {4, 10, 2, 1})\n+    public void testAdvanceOnCount(int breakAt) {\n+        Predicate<LayerManager> underTest = LayerManager.ExtendCheck.advanceOnCount(breakAt);\n+        LayerManager layerManager = testingBuilder().build();\n+        for (int i = 0; i < breakAt - 1; i++) {\n+            assertFalse(underTest.test(layerManager), \"at \" + i);\n+            layerManager.getTarget().merge(TestingHashers.FROM1);\n+        }\n+        assertTrue(underTest.test(layerManager));\n+    }\n+\n+    @Test\n+    public void testAdvanceOnCountInvalidArguments() {\n+        assertThrows(IllegalArgumentException.class, () -> LayerManager.ExtendCheck.advanceOnCount(0));\n+        assertThrows(IllegalArgumentException.class, () -> LayerManager.ExtendCheck.advanceOnCount(-1));\n+    }\n+\n+    @Test\n+    public void testAdvanceOnSaturation() {\n+        Double maxN = shape.estimateMaxN();\n+        int hashStart = 0;\n+        Predicate<LayerManager> underTest = LayerManager.ExtendCheck.advanceOnSaturation(maxN);\n+        LayerManager layerManager = testingBuilder().build();\n+        while (layerManager.getTarget().getShape().estimateN(layerManager.getTarget().cardinality()) < maxN) {\n+            assertFalse(underTest.test(layerManager));\n+            layerManager.getTarget().merge(new IncrementingHasher(hashStart, shape.getNumberOfHashFunctions()));\n+            hashStart+=shape.getNumberOfHashFunctions();\n+        }\n+        assertTrue(underTest.test(layerManager));\n+        assertThrows(IllegalArgumentException.class, () -> LayerManager.ExtendCheck.advanceOnSaturation(0));\n+        assertThrows(IllegalArgumentException.class, () -> LayerManager.ExtendCheck.advanceOnSaturation(-1));\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(ints = {5, 100, 2, 1})\n+    public void testOnMaxSize(int maxSize) {\n+        Consumer<LinkedList<BloomFilter>> underTest = LayerManager.Cleanup.onMaxSize(maxSize);\n+        LinkedList<BloomFilter> list = new LinkedList<>();\n+        for (int i = 0; i < maxSize; i++) {\n+            assertEquals(i, list.size());\n+            list.add(new SimpleBloomFilter(shape));\n+            underTest.accept(list);\n+        }\n+        assertEquals(maxSize, list.size());\n+\n+        for (int i = 0; i < maxSize; i++) {\n+            list.add(new SimpleBloomFilter(shape));\n+            underTest.accept(list);\n+            assertEquals(maxSize, list.size());\n+        }\n+    }\n+\n+    @Test\n+    public void testOnMaxSizeIllegalValues() {\n+        assertThrows(IllegalArgumentException.class, () -> LayerManager.Cleanup.onMaxSize(0));\n+        assertThrows(IllegalArgumentException.class, () -> LayerManager.Cleanup.onMaxSize(-1));\n+    }\n+\n+    @Test\n+    public void testNoCleanup() {\n+        Consumer<LinkedList<BloomFilter>> underTest = LayerManager.Cleanup.noCleanup();\n+        LinkedList<BloomFilter> list = new LinkedList<>();\n+        for (int i = 0; i < 20; i++) {\n+            assertEquals(i, list.size());\n+            list.add(new SimpleBloomFilter(shape));\n+            underTest.accept(list);\n+        }\n+    }\n+\n+    @Test\n+    public void testRemoveEmptyTarget() {\n+        Consumer<LinkedList<BloomFilter>> underTest = LayerManager.Cleanup.removeEmptyTarget();\n+        LinkedList<BloomFilter> list = new LinkedList<>();\n+\n+        // removes an empty filter\n+        BloomFilter bf = new SimpleBloomFilter(shape);\n+        list.add(bf);\n+        assertEquals(bf, list.get(0));\n+        underTest.accept(list);\n+        assertTrue(list.isEmpty());\n+\n+        // does not remove a populated filter.\n+        bf.merge(IndexProducer.fromIndexArray(1));\n+        list.add(bf);\n+        assertEquals(bf, list.get(0));\n+        underTest.accept(list);\n+        assertEquals(bf, list.get(0));\n+\n+        // does not remove an empty filter followed by a populated filter.\n+        list.clear();\n+        list.add(new SimpleBloomFilter(shape));\n+        list.add(bf);\n+        assertEquals(2, list.size());\n+        underTest.accept(list);\n+        assertEquals(2, list.size());\n+\n+        // does not remove multiple empty filters at the end of the list, just the last\n+        // one.\n+        list.clear();\n+        list.add(bf);\n+        list.add(new SimpleBloomFilter(shape));\n+        list.add(new SimpleBloomFilter(shape));\n+        assertEquals(3, list.size());\n+        underTest.accept(list);\n+        assertEquals(2, list.size());\n+        assertEquals(bf, list.get(0));\n+\n+    }\n+\n+    @Test\n+    public void testCopy() {\n+        LayerManager underTest = LayerManager.builder().setSupplier(() -> new SimpleBloomFilter(shape)).build();\n+        underTest.getTarget().merge(TestingHashers.randomHasher());\n+        underTest.next();\n+        underTest.getTarget().merge(TestingHashers.randomHasher());\n+        underTest.next();\n+        underTest.getTarget().merge(TestingHashers.randomHasher());\n+        assertEquals(3, underTest.getDepth());\n+\n+        LayerManager copy = underTest.copy();\n+        assertNotSame(underTest, copy);\n+        // object equals not implemented\n+        assertNotEquals(underTest, copy);\n+\n+        assertEquals(underTest.getDepth(), copy.getDepth());\n+        assertTrue(\n+                underTest.forEachBloomFilterPair(copy, (x, y) -> Arrays.equals(x.asBitMapArray(), y.asBitMapArray())));\n+    }\n+\n+    @Test\n+    public void testBuilder() {\n+        LayerManager.Builder underTest = LayerManager.builder();\n+        NullPointerException npe = assertThrows(NullPointerException.class, () -> underTest.build());\n+        assertTrue(npe.getMessage().contains(\"Supplier must not be null\"));\n+        underTest.setSupplier(() -> null).setCleanup(null);\n+        npe = assertThrows(NullPointerException.class, () -> underTest.build());\n+        assertTrue(npe.getMessage().contains(\"Cleanup must not be null\"));\n+        underTest.setCleanup(x -> {\n+        }).setExtendCheck(null);\n+        npe = assertThrows(NullPointerException.class, () -> underTest.build());\n+        assertTrue(npe.getMessage().contains(\"ExtendCheck must not be null\"));\n+\n+        npe = assertThrows(NullPointerException.class, () -> LayerManager.builder().setSupplier(() -> null).build());\n+        assertTrue(npe.getMessage().contains(\"filterSupplier returned null.\"));\n+\n+    }\n+\n+    @Test\n+    public void testClear() {\n+        LayerManager underTest = LayerManager.builder().setSupplier(() -> new SimpleBloomFilter(shape)).build();\n+        underTest.getTarget().merge(TestingHashers.randomHasher());\n+        underTest.next();\n+        underTest.getTarget().merge(TestingHashers.randomHasher());\n+        underTest.next();\n+        underTest.getTarget().merge(TestingHashers.randomHasher());\n+        assertEquals(3, underTest.getDepth());\n+        underTest.clear();\n+        assertEquals(1, underTest.getDepth());\n+        assertEquals(0, underTest.getTarget().cardinality());\n+    }\n+\n+    @Test\n+    public void testNextAndGetDepth() {\n+        LayerManager underTest = LayerManager.builder().setSupplier(() -> new SimpleBloomFilter(shape)).build();\n+        assertEquals(1, underTest.getDepth());\n+        underTest.getTarget().merge(TestingHashers.randomHasher());\n+        assertEquals(1, underTest.getDepth());\n+        underTest.next();\n+        assertEquals(2, underTest.getDepth());\n+    }\n+\n+    @Test\n+    public void testGet() {\n+        SimpleBloomFilter f = new SimpleBloomFilter(shape);\n+        LayerManager underTest = LayerManager.builder().setSupplier(() -> f).build();\n+        assertEquals(1, underTest.getDepth());\n+        assertSame(f, underTest.get(0));\n+        assertThrows(NoSuchElementException.class, () -> underTest.get(-1));\n+        assertThrows(NoSuchElementException.class, () -> underTest.get(1));\n+    }\n+\n+    @Test\n+    public void testTarget() {\n+        boolean[] extendCheckCalled = { false };\n+        boolean[] cleanupCalled = { false };\n+        int[] supplierCount = { 0 };\n+        LayerManager underTest = LayerManager.builder().setSupplier(() -> {\n+            supplierCount[0]++;\n+            return new SimpleBloomFilter(shape);\n+        }).setExtendCheck(lm -> {\n+            extendCheckCalled[0] = true;\n+            return true;\n+        }).setCleanup(ll -> {\n+            cleanupCalled[0] = true;\n+        }).build();\n+        assertFalse(extendCheckCalled[0]);\n+        assertFalse(cleanupCalled[0]);\n+        assertEquals(1, supplierCount[0]);\n+        underTest.getTarget();\n+        assertTrue(extendCheckCalled[0]);\n+        assertTrue(cleanupCalled[0]);\n+        assertEquals(2, supplierCount[0]);\n+    }\n+\n+    @Test\n+    public void testForEachBloomFilter() {\n+        LayerManager underTest = LayerManager.builder().setSupplier(() -> new SimpleBloomFilter(shape))\n+                .setExtendCheck(LayerManager.ExtendCheck.advanceOnPopulated()).build();\n+\n+        List<BloomFilter> lst = new ArrayList<>();\n+        for (int i = 0; i < 10; i++) {\n+            BloomFilter bf = new SimpleBloomFilter(shape);\n+            bf.merge(TestingHashers.randomHasher());\n+            lst.add(bf);\n+            underTest.getTarget().merge(bf);\n+        }\n+        List<BloomFilter> lst2 = new ArrayList<>();\n+        underTest.forEachBloomFilter(lst2::add);\n+        assertEquals(10, lst.size());\n+        assertEquals(10, lst2.size());\n+        for (int i = 0; i < lst.size(); i++) {\n+            assertArrayEquals(lst.get(i).asBitMapArray(), lst2.get(i).asBitMapArray());\n+        }\n+    }\n+\n+}\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/LayeredBloomFilterTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/LayeredBloomFilterTest.java\nnew file mode 100644\nindex 0000000000..11164eca06\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/LayeredBloomFilterTest.java\n@@ -0,0 +1,315 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.bloomfilter;\n+\n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import java.util.ArrayList;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+import java.util.function.Predicate;\n+\n+import org.apache.commons.collections4.bloomfilter.LayerManager.Cleanup;\n+import org.apache.commons.collections4.bloomfilter.LayerManager.ExtendCheck;\n+import org.junit.jupiter.api.Test;\n+\n+public class LayeredBloomFilterTest extends AbstractBloomFilterTest<LayeredBloomFilter> {\n+\n+    @Override\n+    protected LayeredBloomFilter createEmptyFilter(Shape shape) {\n+        return LayeredBloomFilter.fixed(shape, 10);\n+    }\n+\n+    protected BloomFilter makeFilter(int... values) {\n+        return makeFilter(IndexProducer.fromIndexArray(values));\n+    }\n+\n+    protected BloomFilter makeFilter(IndexProducer p) {\n+        BloomFilter bf = new SparseBloomFilter(getTestShape());\n+        bf.merge(p);\n+        return bf;\n+    }\n+\n+    protected BloomFilter makeFilter(Hasher h) {\n+        BloomFilter bf = new SparseBloomFilter(getTestShape());\n+        bf.merge(h);\n+        return bf;\n+    }\n+\n+    @Test\n+    public void testMultipleFilters() {\n+        LayeredBloomFilter filter = LayeredBloomFilter.fixed(getTestShape(), 10);\n+        filter.merge(TestingHashers.FROM1);\n+        filter.merge(TestingHashers.FROM11);\n+        assertEquals(2, filter.getDepth());\n+        assertTrue(filter.contains(makeFilter(TestingHashers.FROM1)));\n+        assertTrue(filter.contains(makeFilter(TestingHashers.FROM11)));\n+        BloomFilter t1 = makeFilter(6, 7, 17, 18, 19);\n+        assertFalse(filter.contains(t1));\n+        assertFalse(filter.copy().contains(t1));\n+        assertTrue(filter.flatten().contains(t1));\n+    }\n+\n+    private LayeredBloomFilter setupFindTest() {\n+        LayeredBloomFilter filter = LayeredBloomFilter.fixed(getTestShape(), 10);\n+        filter.merge(TestingHashers.FROM1);\n+        filter.merge(TestingHashers.FROM11);\n+        filter.merge(new IncrementingHasher(11, 2));\n+        filter.merge(TestingHashers.populateFromHashersFrom1AndFrom11(new SimpleBloomFilter(getTestShape())));\n+        return filter;\n+    }\n+\n+    @Test\n+    public void testFindBloomFilter() {\n+        LayeredBloomFilter filter = setupFindTest();\n+        int[] expected = {0, 3};\n+        int[] result = filter.find(TestingHashers.FROM1);\n+        assertArrayEquals(expected, result);\n+        expected = new int[] {1, 3};\n+        result = filter.find(TestingHashers.FROM11);\n+        assertArrayEquals(expected, result);\n+    }\n+\n+    @Test\n+    public void testFindBitMapProducer() {\n+        LayeredBloomFilter filter = setupFindTest();\n+\n+        IndexProducer idxProducer = TestingHashers.FROM1.indices(getTestShape());\n+        BitMapProducer producer = BitMapProducer.fromIndexProducer(idxProducer, getTestShape().getNumberOfBits());\n+\n+        int[] expected = {0, 3};\n+        int[] result = filter.find(producer);\n+        assertArrayEquals(expected, result);\n+\n+        expected = new int[]{1, 3};\n+        idxProducer = TestingHashers.FROM11.indices(getTestShape());\n+        producer = BitMapProducer.fromIndexProducer(idxProducer, getTestShape().getNumberOfBits());\n+        result = filter.find(producer);\n+        assertArrayEquals(expected, result);\n+    }\n+\n+    @Test\n+    public void testFindIndexProducer() {\n+        IndexProducer producer = TestingHashers.FROM1.indices(getTestShape());\n+        LayeredBloomFilter filter = setupFindTest();\n+\n+        int[] expected = {0, 3};\n+        int[] result = filter.find(producer);\n+        assertArrayEquals(expected, result);\n+\n+        expected = new int[] {1, 3};\n+        producer = TestingHashers.FROM11.indices(getTestShape());\n+        result = filter.find(producer);\n+        assertArrayEquals(expected, result);\n+    }\n+\n+    /**\n+     * Tests that the estimated union calculations are correct.\n+     */\n+    @Test\n+    public final void testEstimateUnionCrossTypes() {\n+        final BloomFilter bf = createFilter(getTestShape(), TestingHashers.FROM1);\n+        final BloomFilter bf2 = new DefaultBloomFilterTest.SparseDefaultBloomFilter(getTestShape());\n+        bf2.merge(TestingHashers.FROM11);\n+\n+        assertEquals(2, bf.estimateUnion(bf2));\n+        assertEquals(2, bf2.estimateUnion(bf));\n+    }\n+\n+    @Test\n+    public final void testGetLayer() {\n+        BloomFilter bf = new SimpleBloomFilter(getTestShape());\n+        bf.merge(TestingHashers.FROM11);\n+        LayeredBloomFilter filter = LayeredBloomFilter.fixed(getTestShape(), 10);\n+        filter.merge(TestingHashers.FROM1);\n+        filter.merge(TestingHashers.FROM11);\n+        filter.merge(new IncrementingHasher(11, 2));\n+        filter.merge(TestingHashers.populateFromHashersFrom1AndFrom11(new SimpleBloomFilter(getTestShape())));\n+        assertArrayEquals(bf.asBitMapArray(), filter.get(1).asBitMapArray());\n+    }\n+\n+    @Test\n+    public final void testNext() {\n+        LayerManager layerManager = LayerManager.builder().setSupplier(() -> new SimpleBloomFilter(getTestShape()))\n+                .build();\n+\n+        LayeredBloomFilter filter = new LayeredBloomFilter(getTestShape(), layerManager);\n+        filter.merge(TestingHashers.FROM1);\n+        filter.merge(TestingHashers.FROM11);\n+        assertEquals(1, filter.getDepth());\n+        filter.next();\n+        filter.merge(new IncrementingHasher(11, 2));\n+        assertEquals(2, filter.getDepth());\n+        assertTrue(filter.get(0).contains(TestingHashers.FROM1));\n+        assertTrue(filter.get(0).contains(TestingHashers.FROM11));\n+        assertFalse(filter.get(0).contains(new IncrementingHasher(11, 2)));\n+        assertFalse(filter.get(1).contains(TestingHashers.FROM1));\n+        assertFalse(filter.get(1).contains(TestingHashers.FROM11));\n+        assertTrue(filter.get(1).contains(new IncrementingHasher(11, 2)));\n+    }\n+\n+    @Override\n+    @Test\n+    public void testCardinalityAndIsEmpty() {\n+        LayerManager layerManager = LayerManager.builder().setExtendCheck(ExtendCheck.neverAdvance())\n+                .setSupplier(() -> new SimpleBloomFilter(getTestShape())).build();\n+        testCardinalityAndIsEmpty(new LayeredBloomFilter(getTestShape(), layerManager));\n+    }\n+\n+    // ***** TESTS THAT CHECK LAYERED PROCESSING ******\n+\n+    // ***example of instrumentation ***\n+    private static List<String> dbgInstrument = new ArrayList<>();\n+    // instrumentation to record timestamps in dbgInstrument list\n+    private Predicate<BloomFilter> dbg = (bf) -> {\n+        TimestampedBloomFilter tbf = (TimestampedBloomFilter) bf;\n+        long ts = System.currentTimeMillis();\n+        dbgInstrument.add(String.format(\"T:%s (Elapsed:%s)- EstN:%s (Card:%s)\\n\", tbf.timestamp, ts - tbf.timestamp,\n+                tbf.estimateN(), tbf.cardinality()));\n+        return true;\n+    };\n+    // *** end of instrumentation ***\n+\n+    /**\n+     * Creates a LayeredBloomFilter that retains enclosed filters for\n+     * {@code duration} and limits the contents of each enclosed filter to a time\n+     * {@code quanta}. This filter uses the timestamped Bloom filter internally.\n+     *\n+     * @param shape    The shape of the Bloom filters.\n+     * @param duration The length of time to keep filters in the list.\n+     * @param dUnit    The unit of time to apply to duration.\n+     * @param quanta   The quantization factor for each filter. Individual filters\n+     *                 will span at most this much time.\n+     * @param qUnit    the unit of time to apply to quanta.\n+     * @return LayeredBloomFilter with the above properties.\n+     */\n+    static LayeredBloomFilter createTimedLayeredFilter(Shape shape, long duration, TimeUnit dUnit, long quanta,\n+            TimeUnit qUnit) {\n+        LayerManager layerManager = LayerManager.builder()\n+                .setSupplier(() -> new TimestampedBloomFilter(new SimpleBloomFilter(shape)))\n+                .setCleanup(Cleanup.removeEmptyTarget().andThen(new CleanByTime(duration, dUnit)))\n+                .setExtendCheck(new AdvanceOnTimeQuanta(quanta, qUnit)\n+                        .or(LayerManager.ExtendCheck.advanceOnSaturation(shape.estimateMaxN())))\n+                .build();\n+        return new LayeredBloomFilter(shape, layerManager);\n+    }\n+\n+    /**\n+     * A Predicate that advances after a quantum of time.\n+     */\n+    static class AdvanceOnTimeQuanta implements Predicate<LayerManager> {\n+        long quanta;\n+\n+        AdvanceOnTimeQuanta(long quanta, TimeUnit unit) {\n+            this.quanta = unit.toMillis(quanta);\n+        }\n+\n+        @Override\n+        public boolean test(LayerManager lm) {\n+            // can not use getTarget() as it causes recursion.\n+            TimestampedBloomFilter bf = (TimestampedBloomFilter) lm.get(lm.getDepth() - 1);\n+            return bf.timestamp + quanta < System.currentTimeMillis();\n+        }\n+    }\n+\n+    /**\n+     * A Consumer that cleans the list based on how long each filters has been in\n+     * the list.\n+     *\n+     */\n+    static class CleanByTime implements Consumer<LinkedList<BloomFilter>> {\n+        long elapsedTime;\n+\n+        CleanByTime(long duration, TimeUnit unit) {\n+            elapsedTime = unit.toMillis(duration);\n+        }\n+\n+        @Override\n+        public void accept(LinkedList<BloomFilter> t) {\n+            long min = System.currentTimeMillis() - elapsedTime;\n+            while (!t.isEmpty() && ((TimestampedBloomFilter) t.getFirst()).getTimestamp() < min) {\n+                TimestampedBloomFilter bf = (TimestampedBloomFilter) t.getFirst();\n+                dbgInstrument.add(String.format(\"Removing old entry: T:%s (Aged: %s) \\n\", bf.getTimestamp(),\n+                        (min - bf.getTimestamp())));\n+                t.removeFirst();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * A Bloomfilter implementation that tracks the creation time.\n+     */\n+    static class TimestampedBloomFilter extends WrappedBloomFilter {\n+        final long timestamp;\n+\n+        TimestampedBloomFilter(BloomFilter bf) {\n+            super(bf);\n+            this.timestamp = System.currentTimeMillis();\n+        }\n+\n+        public long getTimestamp() {\n+            return timestamp;\n+        }\n+    }\n+\n+    @Test\n+    public void testExpiration() throws InterruptedException {\n+        // this test uses the instrumentation noted above to track changes for debugging\n+        // purposes.\n+\n+        // list of timestamps that are expected to be expired.\n+        List<Long> lst = new ArrayList<>();\n+        Shape shape = Shape.fromNM(4, 64);\n+\n+        // create a filter that removes filters that are 4 seconds old\n+        // and quantises time to 1 second intervals.\n+        LayeredBloomFilter underTest = createTimedLayeredFilter(shape, 600, TimeUnit.MILLISECONDS, 150,\n+                TimeUnit.MILLISECONDS);\n+\n+        for (int i = 0; i < 10; i++) {\n+            underTest.merge(TestingHashers.randomHasher());\n+        }\n+        underTest.forEachBloomFilter(dbg.and(x -> lst.add(((TimestampedBloomFilter) x).timestamp)));\n+        assertTrue(underTest.getDepth() > 1);\n+\n+        Thread.sleep(300);\n+        for (int i = 0; i < 10; i++) {\n+            underTest.merge(TestingHashers.randomHasher());\n+        }\n+        dbgInstrument.add(\"=== AFTER 300 milliseconds ====\\n\");\n+        underTest.forEachBloomFilter(dbg);\n+\n+        Thread.sleep(150);\n+        for (int i = 0; i < 10; i++) {\n+            underTest.merge(TestingHashers.randomHasher());\n+        }\n+        dbgInstrument.add(\"=== AFTER 450 milliseconds ====\\n\");\n+        underTest.forEachBloomFilter(dbg);\n+\n+        // sleep 200 milliseconds to ensure we cross the 600 millisecond boundary\n+        Thread.sleep(200);\n+        underTest.merge(TestingHashers.randomHasher());\n+        dbgInstrument.add(\"=== AFTER 600 milliseconds ====\\n\");\n+        assertTrue(underTest.forEachBloomFilter(dbg.and(x -> !lst.contains(((TimestampedBloomFilter) x).timestamp))),\n+                \"Found filter that should have been deleted: \" + dbgInstrument.get(dbgInstrument.size() - 1));\n+    }\n+}\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/TestingHashers.java b/src/test/java/org/apache/commons/collections4/bloomfilter/TestingHashers.java\nindex 8222d4c253..bf9ab41de5 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/TestingHashers.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/TestingHashers.java\n@@ -16,6 +16,8 @@\n  */\n package org.apache.commons.collections4.bloomfilter;\n \n+import java.util.concurrent.ThreadLocalRandom;\n+\n /**\n  * A collection of methods and statics that represent standard hashers in testing.\n  */\n@@ -88,4 +90,11 @@ public static <T extends BloomFilter> T populateRange(final T filter, final int\n         });\n         return filter;\n     }\n+\n+    /**\n+     * Creates an EnhancedDoubleHasher hasher from 2 random longs.\n+     */\n+    public static Hasher randomHasher() {\n+        return new EnhancedDoubleHasher( ThreadLocalRandom.current().nextLong(), ThreadLocalRandom.current().nextLong() );\n+    }\n }\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/WrappedBloomFilterTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/WrappedBloomFilterTest.java\nnew file mode 100644\nindex 0000000000..eca4a21a3b\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/WrappedBloomFilterTest.java\n@@ -0,0 +1,45 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.bloomfilter;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n+\n+public class WrappedBloomFilterTest extends AbstractBloomFilterTest<WrappedBloomFilter> {\n+\n+    @Override\n+    protected WrappedBloomFilter createEmptyFilter(Shape shape) {\n+        return new WrappedBloomFilter(new DefaultBloomFilterTest.SparseDefaultBloomFilter(shape)) {\n+        };\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(ints = {0, 1, 34})\n+    public void testCharacteristics(int characteristics) {\n+        Shape shape = getTestShape();\n+        BloomFilter inner = new DefaultBloomFilterTest.SparseDefaultBloomFilter(shape) {\n+            @Override\n+            public int characteristics() {\n+                return characteristics;\n+            }\n+        };\n+        WrappedBloomFilter underTest = new WrappedBloomFilter(inner) {};\n+        assertEquals(characteristics, underTest.characteristics());\n+    }\n+}\n",
  "problem_statement" : "[COLLECTIONS-843] Implement Layered Bloom filter\n\nImplementation to fix [COLLECTIONS-843](https://issues.apache.org/jira/browse/COLLECTIONS-843).\r\n\r\nThis is a simple Layered Bloom filter implementation with complex configuration options.\r\n\r\nA static method to create a fixed level implementation that does not merge is provided.\r\nAn example of a complex time based Bloom filter is provided in the testing code where filters are added to until they are saturated or one second has elapsed and are removed after they are 4 seconds old.\r\n\r\nthis change is in support of Kafka KIP-936 \r\nhttps://cwiki.apache.org/confluence/display/KAFKA/KIP-936%3A+Throttle+number+of+active+PIDs",
  "hints_text" : null,
  "created_at" : "Thu Jun 29 20:52:12 CEST 2023",
  "version" : null,
  "FAIL_TO_PASS" : [ "CountingPredicateTest", "BloomFilterProducerFromLayeredBloomFilterTest", "AbstractIndexProducerTest", "BitMapProducerFromWrappedBloomFilterTest", "CellProducerFromLayeredBloomFilterTest", "DefaultBloomFilterProducerTest", "LayeredBloomFilterTest", "AbstractBloomFilterTest", "BloomFilterProducerFromBloomFilterArrayTest", "AbstractBloomFilterProducerTest", "BitMapProducerFromLayeredBloomFilterTest", "TestingHashers", "DefaultBloomFilterTest", "LayerManagerTest", "WrappedBloomFilterTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=CountingPredicateTest,BloomFilterProducerFromLayeredBloomFilterTest,AbstractIndexProducerTest,BitMapProducerFromWrappedBloomFilterTest,CellProducerFromLayeredBloomFilterTest,DefaultBloomFilterProducerTest,LayeredBloomFilterTest,AbstractBloomFilterTest,BloomFilterProducerFromBloomFilterArrayTest,AbstractBloomFilterProducerTest,BitMapProducerFromLayeredBloomFilterTest,TestingHashers,DefaultBloomFilterTest,LayerManagerTest,WrappedBloomFilterTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 402,
  "metadata" : null
}, {
  "instance_id" : "apache-commons-collections-PR-398",
  "repo" : "apache/commons-collections",
  "base_commit" : "5b668d23c6a980290f35a848fcac05191bc23488",
  "patch" : "diff --git a/src/main/java/org/apache/commons/collections4/bloomfilter/BloomFilter.java b/src/main/java/org/apache/commons/collections4/bloomfilter/BloomFilter.java\nindex acd5032643..f51eb081fc 100644\n--- a/src/main/java/org/apache/commons/collections4/bloomfilter/BloomFilter.java\n+++ b/src/main/java/org/apache/commons/collections4/bloomfilter/BloomFilter.java\n@@ -305,6 +305,7 @@ default int estimateIntersection(final BloomFilter other) {\n             // maximum estimate value using integer values is: 46144189292 thus\n             // eThis + eOther can not overflow the long value.\n             estimate = Math.round(eThis + eOther - eUnion);\n+            estimate = estimate < 0 ? 0 : estimate;\n         }\n         return estimate>Integer.MAX_VALUE?Integer.MAX_VALUE:(int) estimate;\n     }\n",
  "test_patch" : "diff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBloomFilterTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBloomFilterTest.java\nindex 4b5a275e57..5e9d91a186 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBloomFilterTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBloomFilterTest.java\n@@ -214,6 +214,17 @@ public void testClear() {\n         assertEquals(0, bf1.cardinality());\n     }\n \n+    @Test\n+    public final void testNegativeIntersection() {\n+        IndexProducer p1 = IndexProducer.fromIndexArray(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 20, 26, 28, 30, 32, 34, 35, 36, 37, 39, 40, 41, 42, 43, 45, 46, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71);\n+        IndexProducer p2 = IndexProducer.fromIndexArray(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27);\n+\n+        BloomFilter filter1 = createEmptyFilter(Shape.fromKM(17, 72));\n+        filter1.merge(p1);\n+        BloomFilter filter2 = createEmptyFilter(Shape.fromKM(17, 72));\n+        filter2.merge(p2);\n+        assertEquals(0, filter1.estimateIntersection(filter2));\n+    }\n     /**\n      * Tests that the estimated intersection calculations are correct.\n      */\n@@ -424,11 +435,11 @@ public void testBitMapProducerSize() {\n     /**\n      * Testing class returns the value as the only value.\n      */\n-    class BadHasher implements Hasher {\n+    public static class BadHasher implements Hasher {\n \n         IndexProducer producer;\n \n-        BadHasher(final int value) {\n+        public BadHasher(final int value) {\n             this.producer = IndexProducer.fromIndexArray(new int[] {value});\n         }\n \ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/ArrayHasher.java b/src/test/java/org/apache/commons/collections4/bloomfilter/ArrayHasher.java\nindex 84e223ddbf..f2a18c426a 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/ArrayHasher.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/ArrayHasher.java\n@@ -24,10 +24,10 @@\n  *\n  * <p>To be used for testing only.</p>\n  */\n-final class ArrayHasher implements Hasher {\n+public final class ArrayHasher implements Hasher {\n     private final int[] values;\n \n-    ArrayHasher(final int... values) {\n+    public ArrayHasher(final int... values) {\n         this.values = values;\n     }\n \ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/DefaultIndexProducerTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/DefaultIndexProducerTest.java\nindex c09158c355..2682a96a7e 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/DefaultIndexProducerTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/DefaultIndexProducerTest.java\n@@ -74,7 +74,7 @@ protected int getForEachIndexBehaviour() {\n      * @param bound the upper bound (exclusive) of the values in the array.\n      * @return an array of int.\n      */\n-    static int[] generateIntArray(final int size, final int bound) {\n+    public static int[] generateIntArray(final int size, final int bound) {\n         return ThreadLocalRandom.current().ints(size, 0, bound).toArray();\n     }\n \n@@ -83,7 +83,7 @@ static int[] generateIntArray(final int size, final int bound) {\n      * @param ary the array\n      * @return the set.\n      */\n-    static BitSet uniqueSet(final int[] ary) {\n+    public static BitSet uniqueSet(final int[] ary) {\n         final BitSet bs = new BitSet();\n         Arrays.stream(ary).forEach(bs::set);\n         return bs;\n@@ -94,7 +94,7 @@ static BitSet uniqueSet(final int[] ary) {\n      * @param ary the array to sort and make unique\n      * @return the sorted unique array.\n      */\n-    static int[] unique(final int[] ary) {\n+    public static int[] unique(final int[] ary) {\n         return Arrays.stream(ary).distinct().sorted().toArray();\n     }\n \ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/IncrementingHasher.java b/src/test/java/org/apache/commons/collections4/bloomfilter/IncrementingHasher.java\nindex ac0fd5111b..a680ac565e 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/IncrementingHasher.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/IncrementingHasher.java\n@@ -25,7 +25,7 @@\n  *\n  * <p>To be used for testing only.</p>\n  */\n-final class IncrementingHasher implements Hasher {\n+public final class IncrementingHasher implements Hasher {\n \n     /**\n      * The initial hash value.\n@@ -46,7 +46,7 @@ final class IncrementingHasher implements Hasher {\n      * @param initial The initial value for the hasher.\n      * @param increment The value to increment the hash by on each iteration.\n      */\n-    IncrementingHasher(final long initial, final long increment) {\n+    public IncrementingHasher(final long initial, final long increment) {\n         this.initial = initial;\n         this.increment = increment;\n     }\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/TestingHashers.java b/src/test/java/org/apache/commons/collections4/bloomfilter/TestingHashers.java\nindex 8589000fbb..27a13fd7c4 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/TestingHashers.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/TestingHashers.java\n@@ -18,16 +18,16 @@\n /**\n  * A collection of methods and statics that represent standard hashers in testing.\n  */\n-class TestingHashers {\n+public class TestingHashers {\n     /**\n      * Hasher that increments from 1.\n      */\n-    static final Hasher FROM1 = new IncrementingHasher(1, 1);\n+    public static final Hasher FROM1 = new IncrementingHasher(1, 1);\n \n     /**\n      * Hasher that increments from 11.\n      */\n-    static final Hasher FROM11 = new IncrementingHasher(11, 1);\n+    public static final Hasher FROM11 = new IncrementingHasher(11, 1);\n \n     /**\n      * Do not instantiate.\n@@ -41,7 +41,7 @@ private TestingHashers() {}\n      * @param hashers The hashers to merge\n      * @return {@code filter} for chaining\n      */\n-    static <T extends BloomFilter> T mergeHashers(T filter, Hasher...hashers) {\n+    public static <T extends BloomFilter> T mergeHashers(T filter, Hasher...hashers) {\n         for (Hasher h : hashers) {\n             filter.merge(h);\n         }\n@@ -54,7 +54,7 @@ static <T extends BloomFilter> T mergeHashers(T filter, Hasher...hashers) {\n      * @param filter The Bloom filter to populate\n      * @return {@code filter} for chaining\n      */\n-    static <T extends BloomFilter> T populateFromHashersFrom1AndFrom11(T filter) {\n+    public static <T extends BloomFilter> T populateFromHashersFrom1AndFrom11(T filter) {\n         return mergeHashers(filter, FROM1, FROM11);\n     }\n \n@@ -64,7 +64,7 @@ static <T extends BloomFilter> T populateFromHashersFrom1AndFrom11(T filter) {\n      * @param filter the Bloom filter to populate\n      * @return {@code filter} for chaining\n      */\n-    static <T extends BloomFilter> T populateEntireFilter(T filter) {\n+    public static <T extends BloomFilter> T populateEntireFilter(T filter) {\n         int n = filter.getShape().getNumberOfBits();\n         int k = filter.getShape().getNumberOfHashFunctions();\n         for (int i = 0; i < n; i += k) {\n",
  "problem_statement" : "Changes required to open testing to new implementations.\n\nMakes some previously package private classes and methods public so that they may be used in developing tests for new Bloom filter implementations.\r\n\r\nIn addition, a correction for an error where specific cases can lead to a negative value for an estimated intersection.  Test case is provided.",
  "hints_text" : null,
  "created_at" : "Wed Jun 14 17:06:16 CEST 2023",
  "version" : null,
  "FAIL_TO_PASS" : [ "IncrementingHasher", "AbstractBloomFilterTest", "DefaultIndexProducerTest", "ArrayHasher", "TestingHashers" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=IncrementingHasher,AbstractBloomFilterTest,DefaultIndexProducerTest,ArrayHasher,TestingHashers",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 398,
  "metadata" : null
}, {
  "instance_id" : "apache-commons-collections-PR-396",
  "repo" : "apache/commons-collections",
  "base_commit" : "1d07ca40667849742d8712bf55770c559cd6203d",
  "patch" : "diff --git a/src/main/java/org/apache/commons/collections4/bloomfilter/BitMap.java b/src/main/java/org/apache/commons/collections4/bloomfilter/BitMap.java\nindex 14366f96d6..8180af7086 100644\n--- a/src/main/java/org/apache/commons/collections4/bloomfilter/BitMap.java\n+++ b/src/main/java/org/apache/commons/collections4/bloomfilter/BitMap.java\n@@ -113,4 +113,24 @@ public static long getLongBit(final int bitIndex) {\n         // this will identify an incorrect bit.\n         return 1L << bitIndex;\n     }\n+\n+    /**\n+     * Performs a modulus calculation on an unsigned long and an positive integer divisor.\n+     *\n+     * <p><em>If the divisor is negative the behavior is not defined.</em></p>\n+     *\n+     * @param dividend a unsigned long value to calculate the modulus of.\n+     * @param divisor the divisor for the modulus calculation, must be positive.\n+     * @return the remainder or modulus value.\n+     * @since 4.5\n+     */\n+    public static int mod(final long dividend, final int divisor) {\n+        // See Hacker's Delight (2nd ed), section 9.3.\n+        // Assume divisor is positive.\n+        // Divide half the unsigned number and then double the quotient result.\n+        final long quotient = (dividend >>> 1) / divisor << 1;\n+        final long remainder = dividend - quotient * divisor;\n+        // remainder in [0, 2 * divisor)\n+        return (int) (remainder >= divisor ? remainder - divisor : remainder);\n+    }\n }\ndiff --git a/src/main/java/org/apache/commons/collections4/bloomfilter/EnhancedDoubleHasher.java b/src/main/java/org/apache/commons/collections4/bloomfilter/EnhancedDoubleHasher.java\nindex d4091cdd2f..c490ad6c54 100644\n--- a/src/main/java/org/apache/commons/collections4/bloomfilter/EnhancedDoubleHasher.java\n+++ b/src/main/java/org/apache/commons/collections4/bloomfilter/EnhancedDoubleHasher.java\n@@ -129,22 +129,6 @@ long getIncrement() {\n         return increment;\n     }\n \n-    /**\n-     * Performs a modulus calculation on an unsigned long and an integer divisor.\n-     * @param dividend a unsigned long value to calculate the modulus of.\n-     * @param divisor the divisor for the modulus calculation (must be strictly positive).\n-     * @return the remainder or modulus value.\n-     */\n-    static int mod(final long dividend, final int divisor) {\n-        // See Hacker's Delight (2nd ed), section 9.3.\n-        // Assume divisor is positive.\n-        // Divide half the unsigned number and then double the quotient result.\n-        final long quotient = (dividend >>> 1) / divisor << 1;\n-        final long remainder = dividend - quotient * divisor;\n-        // remainder in [0, 2 * divisor)\n-        return (int) (remainder >= divisor ? remainder - divisor : remainder);\n-    }\n-\n     @Override\n     public IndexProducer indices(final Shape shape) {\n         Objects.requireNonNull(shape, \"shape\");\n@@ -168,8 +152,8 @@ public boolean forEachIndex(final IntPredicate consumer) {\n                 // The final hash is:\n                 // hash[i] = ( h1(x) - i*h2(x) - (i*i*i - i)/6 ) wrapped in [0, bits)\n \n-                int index = mod(initial, bits);\n-                int inc = mod(increment, bits);\n+                int index = BitMap.mod(initial, bits);\n+                int inc = BitMap.mod(increment, bits);\n \n                 final int k = shape.getNumberOfHashFunctions();\n                 if (k > bits) {\n",
  "test_patch" : "diff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/BitMapTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/BitMapTest.java\nindex a0b7b8a927..ab0444e99b 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/BitMapTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/BitMapTest.java\n@@ -16,6 +16,7 @@\n  */\n package org.apache.commons.collections4.bloomfilter;\n \n+import static org.junit.Assert.assertNotEquals;\n import static org.junit.jupiter.api.Assertions.assertEquals;\n import static org.junit.jupiter.api.Assertions.assertFalse;\n import static org.junit.jupiter.api.Assertions.assertThrows;\n@@ -102,4 +103,19 @@ public final void testContains() {\n         ary[1] = 1;\n         assertTrue(BitMap.contains(ary, 64));\n     }\n+\n+    private void assertMod(long l, int i) {\n+        assertEquals(Math.floorMod(l, i), BitMap.mod(l, i));\n+    }\n+\n+    @Test\n+    public final void testMod() {\n+        assertMod(Long.MAX_VALUE, Integer.MAX_VALUE);\n+        assertMod(Long.MAX_VALUE, Integer.MAX_VALUE-1);\n+        assertThrows(ArithmeticException.class, () -> BitMap.mod(Long.MAX_VALUE, 0));\n+        assertMod(Long.MAX_VALUE-1, Integer.MAX_VALUE);\n+        assertMod(Long.MAX_VALUE-1, Integer.MAX_VALUE-1);\n+        assertMod(0, Integer.MAX_VALUE);\n+        assertNotEquals(Math.floorMod(5, -1), BitMap.mod(5, -1));\n+    }\n }\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/EnhancedDoubleHasherTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/EnhancedDoubleHasherTest.java\nindex 112b4def6a..107a063203 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/EnhancedDoubleHasherTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/EnhancedDoubleHasherTest.java\n@@ -99,7 +99,7 @@ void testModEdgeCases() {\n         for (final long dividend : new long[] {-1, -2, -3, -6378683, -23567468136887892L, Long.MIN_VALUE, 345, 678686,\n             67868768686878924L, Long.MAX_VALUE}) {\n             for (final int divisor : new int[] {1, 2, 3, 5, 13, Integer.MAX_VALUE}) {\n-                assertEquals((int) Long.remainderUnsigned(dividend, divisor), EnhancedDoubleHasher.mod(dividend, divisor),\n+                assertEquals((int) Long.remainderUnsigned(dividend, divisor), BitMap.mod(dividend, divisor),\n                         () -> String.format(\"failure with dividend=%s and divisor=%s.\", dividend, divisor));\n             }\n         }\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/IncrementingHasher.java b/src/test/java/org/apache/commons/collections4/bloomfilter/IncrementingHasher.java\nindex 94b77c5d5d..ac0fd5111b 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/IncrementingHasher.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/IncrementingHasher.java\n@@ -66,8 +66,8 @@ public boolean forEachIndex(final IntPredicate consumer) {\n                 // This avoids any modulus operation inside the while loop. It uses a long index\n                 // to avoid overflow.\n \n-                long index = EnhancedDoubleHasher.mod(initial, bits);\n-                final int inc = EnhancedDoubleHasher.mod(increment, bits);\n+                long index = BitMap.mod(initial, bits);\n+                final int inc = BitMap.mod(increment, bits);\n \n                 for (int functionalCount = 0; functionalCount < shape.getNumberOfHashFunctions(); functionalCount++) {\n                     if (!consumer.test((int) index)) {\n",
  "problem_statement" : "Move EnhancedDoubleHasher.mod() to a public BitMap API\n\nFixed COLLECTIONS-840\r\n\r\n",
  "hints_text" : null,
  "created_at" : "Sat Jun 10 10:01:24 CEST 2023",
  "version" : null,
  "FAIL_TO_PASS" : [ "BitMapTest", "IncrementingHasher", "EnhancedDoubleHasherTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=BitMapTest,IncrementingHasher,EnhancedDoubleHasherTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 396,
  "metadata" : null
}, {
  "instance_id" : "apache-commons-collections-PR-361",
  "repo" : "apache/commons-collections",
  "base_commit" : "69cad46a9249d7f0308547e2a0bfd5c959872feb",
  "patch" : "diff --git a/src/main/java/org/apache/commons/collections4/bloomfilter/CountingBloomFilter.java b/src/main/java/org/apache/commons/collections4/bloomfilter/CountingBloomFilter.java\nindex 1848e99faf..a86afa1f36 100644\n--- a/src/main/java/org/apache/commons/collections4/bloomfilter/CountingBloomFilter.java\n+++ b/src/main/java/org/apache/commons/collections4/bloomfilter/CountingBloomFilter.java\n@@ -187,9 +187,6 @@ default boolean remove(final BloomFilter other) {\n      * <p>Specifically all counts for the unique indices produced by the {@code hasher} will be\n      * decremented by 1.</p>\n      *\n-     * <p>For HasherCollections each enclosed Hasher will be considered a single item and decremented\n-     * from the counts separately.</p>\n-     *\n      * <p>This method will return {@code true} if the filter is valid after the operation.</p>\n      *\n      * @param hasher the hasher to provide the indexes\ndiff --git a/src/main/java/org/apache/commons/collections4/bloomfilter/HasherCollection.java b/src/main/java/org/apache/commons/collections4/bloomfilter/HasherCollection.java\ndeleted file mode 100644\nindex 337d03893f..0000000000\n--- a/src/main/java/org/apache/commons/collections4/bloomfilter/HasherCollection.java\n+++ /dev/null\n@@ -1,191 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.commons.collections4.bloomfilter;\n-\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collection;\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.Objects;\n-import java.util.function.IntPredicate;\n-\n-/**\n- * A collection of Hashers. Useful when the generation of a Bloom filter depends upon\n- * multiple items.\n- * <p>\n- * Hashers for each item are added to the HasherCollection and then\n- * the collection is used wherever a Hasher can be used in the API.\n- * </p>\n- * @since 4.5\n- */\n-public class HasherCollection implements Hasher {\n-\n-    /**\n-     * The list of hashers to be used to generate the indices.\n-     */\n-    private final List<Hasher> hashers;\n-\n-    /**\n-     * Constructs an empty HasherCollection.\n-     */\n-    public HasherCollection() {\n-        this.hashers = new ArrayList<>();\n-    }\n-\n-    /**\n-     * Constructs a HasherCollection from a collection of Hasher objects.\n-     *\n-     * @param hashers A collections of Hashers to build the indices with.\n-     */\n-    public HasherCollection(final Collection<Hasher> hashers) {\n-        Objects.requireNonNull(hashers, \"hashers\");\n-        this.hashers = new ArrayList<>(hashers);\n-    }\n-\n-    /**\n-     * Constructor.\n-     *\n-     * @param hashers A list of Hashers to initialize the collection with.\n-     */\n-    public HasherCollection(final Hasher... hashers) {\n-        this(Arrays.asList(hashers));\n-    }\n-\n-    /**\n-     * Adds a hasher to the collection.\n-     * @param hasher The hasher to add.\n-     */\n-    public void add(final Hasher hasher) {\n-        Objects.requireNonNull(hasher, \"hasher\");\n-        hashers.add(hasher);\n-    }\n-\n-    /**\n-     * Add all the Hashers in a collection to this HasherCollection.\n-     * @param hashers The hashers to add.\n-     */\n-    public void add(final Collection<Hasher> hashers) {\n-        Objects.requireNonNull(hashers, \"hashers\");\n-        this.hashers.addAll(hashers);\n-    }\n-\n-    @Override\n-    public IndexProducer indices(final Shape shape) {\n-        Objects.requireNonNull(shape, \"shape\");\n-        return new HasherCollectionIndexProducer(shape);\n-    }\n-\n-    /**\n-     * Creates an IndexProducer comprising the unique indices from each of the contained\n-     * hashers.\n-     *\n-     * <p>This method may return duplicates if the collection of unique values from each of the contained\n-     * hashers contain duplicates. This is equivalent to creating Bloom filters for each contained hasher\n-     * and returning an IndexProducer with the concatenated output indices from each filter.</p>\n-     *\n-     * <p>A BitCountProducer generated from this IndexProducer is equivalent to a BitCountProducer from a\n-     * counting Bloom filter that was constructed from the contained hashers unique indices.<p>\n-     *\n-     * @param shape the shape of the desired Bloom filter.\n-     * @return the iterator of integers\n-     */\n-    @Override\n-    public IndexProducer uniqueIndices(final Shape shape) {\n-        Objects.requireNonNull(shape, \"shape\");\n-        return new HasherCollectionIndexProducer(shape) {\n-            @Override\n-            public boolean forEachIndex(final IntPredicate consumer) {\n-                for (final Hasher hasher : hashers) {\n-                    if (!hasher.uniqueIndices(shape).forEachIndex(consumer)) {\n-                        return false;\n-                    }\n-                }\n-                return true;\n-            }\n-        };\n-    }\n-\n-    /**\n-     * Creates an IndexProducer comprising the unique indices across all the contained\n-     * hashers.\n-     *\n-     * <p>This is equivalent to an IndexProducer created from a Bloom filter that comprises all\n-     * the contained hashers.</p>\n-     *\n-     * @param shape the shape of the desired Bloom filter.\n-     * @return the iterator of integers\n-     */\n-    public IndexProducer absoluteUniqueIndices(final Shape shape) {\n-        final int kCount = hashers.size() > 0 ? hashers.size() : 1;\n-        return consumer -> {\n-            Objects.requireNonNull(consumer, \"consumer\");\n-            // shape must handle maximum unique indices\n-            return uniqueIndices(shape).forEachIndex(IndexFilter.create(\n-                    Shape.fromKM(shape.getNumberOfHashFunctions() * kCount,\n-                                 shape.getNumberOfBits()), consumer));\n-        };\n-    }\n-\n-    /**\n-     * Allow child classes access to the hashers.\n-     * @return hashers\n-     */\n-    protected List<Hasher> getHashers() {\n-        return Collections.unmodifiableList(hashers);\n-    }\n-\n-    /**\n-     * IndexProducer that will return duplicates from the collection.\n-     */\n-    private class HasherCollectionIndexProducer implements IndexProducer {\n-        private final Shape shape;\n-\n-        /**\n-         * Create an instance.\n-         *\n-         * @param shape The shape for the filter.\n-         */\n-        HasherCollectionIndexProducer(final Shape shape) {\n-            this.shape = shape;\n-        }\n-\n-        @Override\n-        public boolean forEachIndex(final IntPredicate consumer) {\n-            for (final Hasher hasher : hashers) {\n-                if (!hasher.indices(shape).forEachIndex(consumer)) {\n-                    return false;\n-                }\n-            }\n-            return true;\n-        }\n-\n-        @Override\n-        public int[] asIndexArray() {\n-            final int[] result = new int[shape.getNumberOfHashFunctions() * hashers.size()];\n-            final int[] idx = new int[1];\n-\n-            // This method needs to return duplicate indices\n-\n-            forEachIndex(i -> {\n-                result[idx[0]++] = i;\n-                return true;\n-            });\n-            return Arrays.copyOf(result, idx[0]);\n-        }\n-    }\n-}\ndiff --git a/src/main/java/org/apache/commons/collections4/bloomfilter/package-info.java b/src/main/java/org/apache/commons/collections4/bloomfilter/package-info.java\nindex a8d18c8c2d..a7fb009540 100644\n--- a/src/main/java/org/apache/commons/collections4/bloomfilter/package-info.java\n+++ b/src/main/java/org/apache/commons/collections4/bloomfilter/package-info.java\n@@ -79,9 +79,8 @@\n  *\n  * <h3>Hasher</h3>\n  *\n- * <p>A Hasher converts bytes into a series of integers based on a Shape. With the exception of the HasherCollecton,\n- * each hasher represents one item being added to the Bloom filter. The HasherCollection represents the number of\n- * items as the sum of the number of items represented by the Hashers in the collection.</p>\n+ * <p>A Hasher converts bytes into a series of integers based on a Shape. Each hasher represents one item being added\n+ * to the Bloom filter.</p>\n  *\n  * <p>The EnhancedDoubleHasher uses a combinatorial generation technique to create the integers. It is easily\n  * initialized by using a byte array returned by the standard {@code MessageDigest} or other hash function to\n",
  "test_patch" : "diff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBloomFilterTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBloomFilterTest.java\nindex d44ed9d59d..e525aca8b1 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBloomFilterTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBloomFilterTest.java\n@@ -34,18 +34,6 @@\n  */\n public abstract class AbstractBloomFilterTest<T extends BloomFilter> {\n \n-    protected final Hasher from1 = new IncrementingHasher(1, 1);\n-    protected final long from1Value = 0x3fffeL;\n-    protected final Hasher from11 = new IncrementingHasher(11, 1);\n-    protected final long from11Value = 0xffff800L;\n-    protected final HasherCollection bigHasher = new HasherCollection(from1, from11);\n-    protected final long bigHashValue = 0xffffffeL;\n-    protected final HasherCollection fullHasher = new HasherCollection(new IncrementingHasher(0, 1)/* 0-16 */,\n-            new IncrementingHasher(17, 1)/* 17-33 */, new IncrementingHasher(33, 1)/* 33-49 */, new IncrementingHasher(50, 1)/* 50-66 */,\n-            new IncrementingHasher(67, 1)/* 67-83 */\n-    );\n-    protected final long[] fullHashValue = {0xffffffffffffffffL, 0xfffffL};\n-\n     /**\n      * The shape of the Bloom filters for testing.\n      * <ul>\n@@ -182,8 +170,8 @@ public void testMergeWithIndexProducer() {\n \n     @Test\n     public final void testContains() {\n-        BloomFilter bf1 = createFilter(getTestShape(), from1);\n-        final BloomFilter bf2 = createFilter(getTestShape(), bigHasher);\n+        BloomFilter bf1 = createFilter(getTestShape(), TestingHashers.FROM1);\n+        final BloomFilter bf2 = TestingHashers.populateFromHashersFrom1AndFrom11(createEmptyFilter(getTestShape()));\n \n         assertTrue(bf1.contains(bf1), \"BF Should contain itself\");\n         assertTrue(bf2.contains(bf2), \"BF2 Should contain itself\");\n@@ -206,21 +194,21 @@ public final void testContains() {\n         assertFalse(bf2.contains(bitMapProducer), \"BF2 Should not contain this hasher\");\n \n         // Test different lengths\n-        bf1 = createFilter(getTestShape(), from1);\n+        bf1 = createFilter(getTestShape(), TestingHashers.FROM1);\n         final BloomFilter bf3 = createFilter(Shape.fromKM(getTestShape().getNumberOfHashFunctions(), Long.SIZE - 1),\n-                from1);\n+                TestingHashers.FROM1);\n         assertTrue(bf1.contains(bf3));\n         assertTrue(bf3.contains(bf1));\n \n-        final BloomFilter bf4 = createFilter(Shape.fromKM(getTestShape().getNumberOfHashFunctions(), Long.SIZE - 1),\n-                bigHasher);\n+        final BloomFilter bf4 = TestingHashers.populateFromHashersFrom1AndFrom11(createEmptyFilter(Shape.fromKM(getTestShape().getNumberOfHashFunctions(), Long.SIZE - 1)));\n+\n         assertFalse(bf1.contains(bf4));\n         assertTrue(bf4.contains(bf1));\n     }\n \n     @Test\n     public void testClear() {\n-        final BloomFilter bf1 = createFilter(getTestShape(), from1);\n+        final BloomFilter bf1 = createFilter(getTestShape(), TestingHashers.FROM1);\n         assertNotEquals(0, bf1.cardinality());\n         bf1.clear();\n         assertEquals(0, bf1.cardinality());\n@@ -232,8 +220,9 @@ public void testClear() {\n     @Test\n     public final void testEstimateIntersection() {\n \n-        final BloomFilter bf = createFilter(getTestShape(), from1);\n-        final BloomFilter bf2 = createFilter(getTestShape(), bigHasher);\n+        final BloomFilter bf = createFilter(getTestShape(), TestingHashers.FROM1);\n+        final BloomFilter bf2 = TestingHashers.populateFromHashersFrom1AndFrom11(createEmptyFilter(getTestShape()));\n+\n \n         assertEquals(1, bf.estimateIntersection(bf2));\n         assertEquals(1, bf2.estimateIntersection(bf));\n@@ -249,8 +238,8 @@ public final void testEstimateIntersection() {\n      */\n     @Test\n     public final void testEstimateUnion() {\n-        final BloomFilter bf = createFilter(getTestShape(), from1);\n-        final BloomFilter bf2 = createFilter(getTestShape(), from11);\n+        final BloomFilter bf = createFilter(getTestShape(), TestingHashers.FROM1);\n+        final BloomFilter bf2 = createFilter(getTestShape(), TestingHashers.FROM11);\n \n         assertEquals(2, bf.estimateUnion(bf2));\n         assertEquals(2, bf2.estimateUnion(bf));\n@@ -267,7 +256,7 @@ public final void testEstimateUnion() {\n     @Test\n     public final void testEstimateN() {\n         // build a filter\n-        final BloomFilter filter1 = createFilter(getTestShape(), from1);\n+        final BloomFilter filter1 = createFilter(getTestShape(), TestingHashers.FROM1);\n         assertEquals(1, filter1.estimateN());\n \n         // the data provided above do not generate an estimate that is equivalent to the\n@@ -306,7 +295,7 @@ public final void testIsFull() {\n         BloomFilter filter = createEmptyFilter(getTestShape());\n         assertFalse(filter.isFull(), \"Should not be full\");\n \n-        filter = createFilter(getTestShape(), fullHasher);\n+        filter = TestingHashers.populateEntireFilter(filter);\n         assertTrue(filter.isFull(), \"Should be full\");\n \n         filter = createFilter(getTestShape(), new IncrementingHasher(1, 3));\n@@ -319,8 +308,8 @@ public final void testIsFull() {\n     @Test\n     public final void testMerge() {\n \n-        final BloomFilter bf1 = createFilter(getTestShape(), from1);\n-        final BloomFilter bf2 = createFilter(getTestShape(), from11);\n+        final BloomFilter bf1 = createFilter(getTestShape(), TestingHashers.FROM1);\n+        final BloomFilter bf2 = createFilter(getTestShape(), TestingHashers.FROM11);\n         final BloomFilter bf3 = bf1.copy();\n         bf3.merge(bf2);\n \n@@ -343,8 +332,8 @@ public final void testMerge() {\n \n         // test with hasher\n \n-        final BloomFilter bf4 = createFilter(getTestShape(), from1);\n-        bf4.merge(from11);\n+        final BloomFilter bf4 = createFilter(getTestShape(), TestingHashers.FROM1);\n+        bf4.merge(TestingHashers.FROM11);\n \n         assertTrue(bf4.contains(bf2), \"Should contain Bf2\");\n         assertTrue(bf4.contains(bf3), \"Should contain Bf3\");\n@@ -403,7 +392,7 @@ public void testIndexProducerMerge() {\n     @Test\n     public void testBitMapProducerSize() {\n         final int[] idx = new int[1];\n-        createFilter(getTestShape(), from1).forEachBitMap(i -> {\n+        createFilter(getTestShape(), TestingHashers.FROM1).forEachBitMap(i -> {\n             idx[0]++;\n             return true;\n         });\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractCountingBloomFilterTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractCountingBloomFilterTest.java\nindex d90a13769b..d2892f4927 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractCountingBloomFilterTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractCountingBloomFilterTest.java\n@@ -31,12 +31,14 @@\n  */\n public abstract class AbstractCountingBloomFilterTest<T extends CountingBloomFilter>\n         extends AbstractBloomFilterTest<T> {\n-    protected int[] from1Counts = {0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0};\n-    protected int[] from11Counts = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n-        0};\n-    protected int[] bigHashCounts = {0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n+\n+    private static final int[] from1Counts = {0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0};\n+\n+    private static final int[] bigHashCounts = {0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n         1, 0};\n \n+    private static final long bigHashValue = 0xffffffeL;\n+\n     protected final BitCountProducer maximumValueProducer = consumer -> {\n         for (int i = 1; i < 18; i++) {\n             if (!consumer.test(i, Integer.MAX_VALUE)) {\n@@ -79,8 +81,8 @@ private static void assertCounts(final CountingBloomFilter bf, final int[] expec\n     public final void testCountingSpecificConstructor() {\n         // verify hasher duplicates are counted.\n         // bit hasher has duplicates for 11, 12,13,14,15,16, and 17\n-        final CountingBloomFilter bf = createFilter(getTestShape(), from1);\n-        bf.add(BitCountProducer.from(from11.indices(getTestShape())));\n+        final CountingBloomFilter bf = createFilter(getTestShape(), TestingHashers.FROM1);\n+        bf.add(BitCountProducer.from(TestingHashers.FROM11.indices(getTestShape())));\n \n         final long[] lb = bf.asBitMapArray();\n         assertEquals(2, lb.length);\n@@ -92,8 +94,8 @@ public final void testCountingSpecificConstructor() {\n     @Test\n     public final void testCountingBloomFilterSpecificContains() {\n         final BloomFilter bf = new SimpleBloomFilter(getTestShape());\n-        bf.merge(from1);\n-        final CountingBloomFilter bf2 = createFilter(getTestShape(), bigHasher);\n+        bf.merge(TestingHashers.FROM1);\n+        final CountingBloomFilter bf2 = TestingHashers.populateFromHashersFrom1AndFrom11( createEmptyFilter(getTestShape()));\n \n         assertTrue(bf.contains(bf), \"BF Should contain itself\");\n         assertTrue(bf2.contains(bf2), \"BF2 Should contain itself\");\n@@ -108,10 +110,10 @@ public final void testCountingBloomFilterSpecificContains() {\n      */\n     @Test\n     public final void testCountingSpecificMerge() {\n-        final BloomFilter bf1 = createFilter(getTestShape(), from1);\n+        final BloomFilter bf1 = createFilter(getTestShape(), TestingHashers.FROM1);\n \n         final BloomFilter bf2 = new SimpleBloomFilter(getTestShape());\n-        bf2.merge(from11);\n+        bf2.merge(TestingHashers.FROM11);\n \n         final BloomFilter bf3 = bf1.copy();\n         bf3.merge(bf2);\n@@ -133,7 +135,7 @@ public final void testCountingSpecificMerge() {\n \n         final CountingBloomFilter bf6 = bf5.copy();\n         final BloomFilter bf7 = new SimpleBloomFilter(getTestShape());\n-        bf7.merge(from1);\n+        bf7.merge(TestingHashers.FROM1);\n         bf6.merge(bf7);\n         assertFalse(bf6.isValid(), \"Should not be valid\");\n     }\n@@ -144,10 +146,10 @@ public final void testCountingSpecificMerge() {\n      */\n     @Test\n     public void testAdd() {\n-        final CountingBloomFilter bf1 = createFilter(getTestShape(), from1);\n-        assertTrue(bf1.add(createFilter(getTestShape(), from11)), \"Add should work\");\n-        assertTrue(bf1.contains(from1), \"Should contain\");\n-        assertTrue(bf1.contains(from11), \"Should contain\");\n+        final CountingBloomFilter bf1 = createFilter(getTestShape(), TestingHashers.FROM1);\n+        assertTrue(bf1.add(createFilter(getTestShape(), TestingHashers.FROM11)), \"Add should work\");\n+        assertTrue(bf1.contains(TestingHashers.FROM1), \"Should contain\");\n+        assertTrue(bf1.contains(TestingHashers.FROM11), \"Should contain\");\n         assertCounts(bf1, bigHashCounts);\n \n         // test overflow\n@@ -156,7 +158,7 @@ public void testAdd() {\n         assertTrue(bf2.add(maximumValueProducer), \"Should add to empty\");\n         assertTrue(bf2.isValid(), \"Should be valid\");\n \n-        assertFalse(bf2.add(createFilter(getTestShape(), from1)), \"Should not add\");\n+        assertFalse(bf2.add(createFilter(getTestShape(), TestingHashers.FROM1)), \"Should not add\");\n         assertFalse(bf2.isValid(), \"Should not be valid\");\n     }\n \n@@ -166,25 +168,25 @@ public void testAdd() {\n      */\n     @Test\n     public final void testSubtract() {\n-        final CountingBloomFilter bf1 = createFilter(getTestShape(), from1);\n-        bf1.add(BitCountProducer.from(from11.indices(getTestShape())));\n+        final CountingBloomFilter bf1 = createFilter(getTestShape(), TestingHashers.FROM1);\n+        bf1.add(BitCountProducer.from(TestingHashers.FROM11.indices(getTestShape())));\n \n-        final CountingBloomFilter bf2 = createFilter(getTestShape(), from11);\n+        final CountingBloomFilter bf2 = createFilter(getTestShape(), TestingHashers.FROM11);\n \n         assertTrue(bf1.subtract(bf2), \"Subtract should work\");\n-        assertFalse(bf1.contains(bigHasher), \"Should not contain bitHasher\");\n-        assertTrue(bf1.contains(from1), \"Should contain from1\");\n+        assertFalse(bf1.contains( TestingHashers.populateFromHashersFrom1AndFrom11(new SimpleBloomFilter(getTestShape()))), \"Should not contain bitHasher\");\n+        assertTrue(bf1.contains(TestingHashers.FROM1), \"Should contain TestingHashers.from1\");\n \n         assertCounts(bf1, from1Counts);\n \n         // test underflow\n-        final CountingBloomFilter bf3 = createFilter(getTestShape(), from1);\n+        final CountingBloomFilter bf3 = createFilter(getTestShape(), TestingHashers.FROM1);\n \n-        final CountingBloomFilter bf4 = createFilter(getTestShape(), from11);\n+        final CountingBloomFilter bf4 = createFilter(getTestShape(), TestingHashers.FROM11);\n \n         assertFalse(bf3.subtract(bf4), \"Subtract should not work\");\n         assertFalse(bf3.isValid(), \"isValid should return false\");\n-        assertFalse(bf3.contains(from1), \"Should not contain\");\n+        assertFalse(bf3.contains(TestingHashers.FROM1), \"Should not contain\");\n         assertFalse(bf3.contains(bf4), \"Should not contain\");\n \n         assertCounts(bf3, new int[] {0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0});\n@@ -197,65 +199,65 @@ public final void testSubtract() {\n     @Test\n     public final void testRemove() {\n         final BloomFilter simple = new SimpleBloomFilter(getTestShape());\n-        simple.merge(from11);\n+        simple.merge(TestingHashers.FROM11);\n \n-        final CountingBloomFilter bf1 = createFilter(getTestShape(), from1);\n-        bf1.add(BitCountProducer.from(from11.indices(getTestShape())));\n+        final CountingBloomFilter bf1 = createFilter(getTestShape(), TestingHashers.FROM1);\n+        bf1.add(BitCountProducer.from(TestingHashers.FROM11.indices(getTestShape())));\n \n         assertTrue(bf1.remove(simple), \"Remove should work\");\n-        assertFalse(bf1.contains(from11), \"Should not contain\");\n-        assertTrue(bf1.contains(from1), \"Should contain\");\n+        assertFalse(bf1.contains(TestingHashers.FROM11), \"Should not contain\");\n+        assertTrue(bf1.contains(TestingHashers.FROM1), \"Should contain\");\n \n         assertCounts(bf1, from1Counts);\n \n         // with hasher\n-        final CountingBloomFilter bf2 = createFilter(getTestShape(), from1);\n-        bf2.add(BitCountProducer.from(from11.indices(getTestShape())));\n+        final CountingBloomFilter bf2 = createFilter(getTestShape(), TestingHashers.FROM1);\n+        bf2.add(BitCountProducer.from(TestingHashers.FROM11.indices(getTestShape())));\n \n-        assertTrue(bf2.remove(from11), \"Remove should work\");\n-        assertFalse(bf2.contains(from11), \"Should not contain\");\n-        assertTrue(bf2.contains(from1), \"Should contain\");\n+        assertTrue(bf2.remove(TestingHashers.FROM11), \"Remove should work\");\n+        assertFalse(bf2.contains(TestingHashers.FROM11), \"Should not contain\");\n+        assertTrue(bf2.contains(TestingHashers.FROM1), \"Should contain\");\n \n         assertCounts(bf2, from1Counts);\n \n         // test underflow\n-        final CountingBloomFilter bf3 = createFilter(getTestShape(), from1);\n+        final CountingBloomFilter bf3 = createFilter(getTestShape(), TestingHashers.FROM1);\n         assertFalse(bf3.remove(simple), \"Subtract should not work\");\n         assertFalse(bf3.isValid(), \"isValid should return false\");\n-        assertFalse(bf3.contains(from1), \"Should not contain\");\n+        assertFalse(bf3.contains(TestingHashers.FROM1), \"Should not contain\");\n         assertFalse(bf3.contains(simple), \"Should not contain\");\n \n         assertCounts(bf3, new int[] {0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1});\n \n         // with IndexProducer\n-        final IndexProducer ip = from11.indices(getTestShape());\n+        final IndexProducer ip = TestingHashers.FROM11.indices(getTestShape());\n \n-        final CountingBloomFilter bf4 = createFilter(getTestShape(), from1);\n-        bf4.add(BitCountProducer.from(from11.indices(getTestShape())));\n+        final CountingBloomFilter bf4 = createFilter(getTestShape(), TestingHashers.FROM1);\n+        bf4.add(BitCountProducer.from(TestingHashers.FROM11.indices(getTestShape())));\n \n         assertTrue(bf4.remove(ip), \"Remove should work\");\n-        assertFalse(bf4.contains(from11), \"Should not contain\");\n-        assertTrue(bf4.contains(from1), \"Should contain\");\n+        assertFalse(bf4.contains(TestingHashers.FROM11), \"Should not contain\");\n+        assertTrue(bf4.contains(TestingHashers.FROM1), \"Should contain\");\n \n         assertCounts(bf4, from1Counts);\n \n         // with BitMapProducer\n         final BitMapProducer bmp = BitMapProducer.fromIndexProducer(ip, getTestShape().getNumberOfBits());\n-        final CountingBloomFilter bf5 = createFilter(getTestShape(), from1);\n-        bf5.add(BitCountProducer.from(from11.indices(getTestShape())));\n+        final CountingBloomFilter bf5 = createFilter(getTestShape(), TestingHashers.FROM1);\n+        bf5.add(BitCountProducer.from(TestingHashers.FROM11.indices(getTestShape())));\n \n         assertTrue(bf5.remove(bmp), \"Remove should work\");\n-        assertFalse(bf5.contains(from11), \"Should not contain\");\n-        assertTrue(bf5.contains(from1), \"Should contain\");\n+        assertFalse(bf5.contains(TestingHashers.FROM11), \"Should not contain\");\n+        assertTrue(bf5.contains(TestingHashers.FROM1), \"Should contain\");\n \n         assertCounts(bf5, from1Counts);\n \n         // test producer errors\n         final IndexProducer ip2 = IndexProducer.fromIndexArray(1, 2, getTestShape().getNumberOfBits());\n-        final CountingBloomFilter bf6 = createFilter(getTestShape(), from1);\n+        final CountingBloomFilter bf6 = createFilter(getTestShape(), TestingHashers.FROM1);\n         assertThrows(IllegalArgumentException.class, () -> bf6.remove(ip2));\n \n-        final CountingBloomFilter bf7 = createFilter(getTestShape(), from1);\n+        final CountingBloomFilter bf7 = createFilter(getTestShape(), TestingHashers.FROM1);\n         final BitMapProducer bmp2 = BitMapProducer.fromIndexProducer(ip2, getTestShape().getNumberOfBits());\n         assertThrows(IllegalArgumentException.class, () -> bf7.remove(bmp2));\n     }\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/BitCountProducerFromAbsoluteUniqueHasherCollectionTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/BitCountProducerFromAbsoluteUniqueHasherCollectionTest.java\ndeleted file mode 100644\nindex 47a6299df4..0000000000\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/BitCountProducerFromAbsoluteUniqueHasherCollectionTest.java\n+++ /dev/null\n@@ -1,43 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.commons.collections4.bloomfilter;\n-\n-public class BitCountProducerFromAbsoluteUniqueHasherCollectionTest extends AbstractBitCountProducerTest {\n-\n-    @Override\n-    protected BitCountProducer createProducer() {\n-        // hasher has collisions and wraps\n-        return BitCountProducer.from(new HasherCollection(\n-                new IncrementingHasher(1, 1),\n-                new IncrementingHasher(7, 2)).absoluteUniqueIndices(Shape.fromKM(5, 10)));\n-    }\n-\n-    @Override\n-    protected BitCountProducer createEmptyProducer() {\n-        return BitCountProducer.from(new HasherCollection().absoluteUniqueIndices(Shape.fromKM(11, 10)));\n-    }\n-\n-    @Override\n-    protected int getAsIndexArrayBehaviour() {\n-        return DISTINCT;\n-    }\n-\n-    @Override\n-    protected int[] getExpectedIndices() {\n-        return new int[] {1, 2, 3, 4, 5, 7, 9};\n-    }\n-}\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/BitCountProducerFromHasherCollectionTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/BitCountProducerFromHasherCollectionTest.java\ndeleted file mode 100644\nindex d339add488..0000000000\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/BitCountProducerFromHasherCollectionTest.java\n+++ /dev/null\n@@ -1,51 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.commons.collections4.bloomfilter;\n-\n-public class BitCountProducerFromHasherCollectionTest extends AbstractBitCountProducerTest {\n-\n-    @Override\n-    protected BitCountProducer createProducer() {\n-        // hasher has collisions and wraps\n-        return BitCountProducer.from(new HasherCollection(\n-                new IncrementingHasher(0, 1),\n-                new IncrementingHasher(2, 7)).indices(Shape.fromKM(17, 72)));\n-    }\n-\n-    @Override\n-    protected BitCountProducer createEmptyProducer() {\n-        return BitCountProducer.from(NullHasher.INSTANCE.indices(Shape.fromKM(17, 72)));\n-    }\n-\n-    @Override\n-    protected int getAsIndexArrayBehaviour() {\n-        return 0;\n-    }\n-\n-    @Override\n-    protected int[] getExpectedIndices() {\n-        return new int[] {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,\n-            2, 9, 16, 23, 30, 37, 44, 51, 58, 65, 0, 7, 14, 21, 28, 35, 42};\n-    }\n-\n-    @Override\n-    protected int[][] getExpectedBitCount() {\n-        return new int[][] {{0, 2}, {1, 1}, {2, 2}, {3, 1}, {4, 1}, {5, 1}, {6, 1}, {7, 2}, {8, 1},\n-            {9, 2}, {10, 1}, {11, 1}, {12, 1}, {13, 1}, {14, 2}, {15, 1}, {16, 2}, {21, 1}, {23, 1},\n-            {28, 1}, {30, 1}, {35, 1}, {37, 1}, {42, 1}, {44, 1}, {51, 1}, {58, 1}, {65, 1} };\n-    }\n-}\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/BitCountProducerFromUniqueHasherCollectionTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/BitCountProducerFromUniqueHasherCollectionTest.java\ndeleted file mode 100644\nindex f854f68f9c..0000000000\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/BitCountProducerFromUniqueHasherCollectionTest.java\n+++ /dev/null\n@@ -1,49 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.commons.collections4.bloomfilter;\n-\n-public class BitCountProducerFromUniqueHasherCollectionTest extends AbstractBitCountProducerTest {\n-\n-    @Override\n-    protected BitCountProducer createProducer() {\n-        // hasher has collisions and wraps\n-        return BitCountProducer.from(new HasherCollection(\n-                new IncrementingHasher(1, 1),\n-                new IncrementingHasher(7, 12)).uniqueIndices(Shape.fromKM(5, 10)));\n-    }\n-\n-    @Override\n-    protected BitCountProducer createEmptyProducer() {\n-        return BitCountProducer.from(NullHasher.INSTANCE.uniqueIndices(Shape.fromKM(5, 10)));\n-    }\n-\n-    @Override\n-    protected int getAsIndexArrayBehaviour() {\n-        // HasherCollection uniqueIndices() allows duplicates and may be unordered\n-        return 0;\n-    }\n-\n-    @Override\n-    protected int[] getExpectedIndices() {\n-        return new int[] {1, 2, 3, 4, 5, 7, 9, 1, 3, 5};\n-    }\n-\n-    @Override\n-    protected int[][] getExpectedBitCount() {\n-        return new int[][] {{1, 2}, {2, 1}, {3, 2}, {4, 1}, {5, 2}, {7, 1}, {9, 1}};\n-    }\n-}\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/HasherCollectionTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/HasherCollectionTest.java\ndeleted file mode 100644\nindex 7ae2510970..0000000000\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/HasherCollectionTest.java\n+++ /dev/null\n@@ -1,103 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.commons.collections4.bloomfilter;\n-\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n-\n-import java.util.Arrays;\n-import java.util.stream.IntStream;\n-\n-import org.junit.jupiter.api.Assertions;\n-import org.junit.jupiter.api.Test;\n-\n-/**\n- * Tests the {@link HasherCollection}.\n- */\n-\n-public class HasherCollectionTest extends AbstractHasherTest {\n-    @Override\n-    protected HasherCollection createHasher() {\n-        return new HasherCollection(new IncrementingHasher(1, 1),\n-                new IncrementingHasher(2, 2));\n-    }\n-\n-    @Override\n-    protected int[] getExpectedIndices() {\n-        return new int[] {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 2, 4, 6, 8, 10, 12, 14, 16, 18,\n-            20, 22, 24, 26, 28, 30, 32, 34};\n-    }\n-\n-    @Override\n-    protected HasherCollection createEmptyHasher() {\n-        return new HasherCollection();\n-    }\n-\n-    @Override\n-    protected int getAsIndexArrayBehaviour() {\n-        // Allows duplicates and may be unordered\n-        return 0;\n-    }\n-\n-    @Override\n-    protected int getHasherSize(final Hasher hasher) {\n-        return ((HasherCollection) hasher).getHashers().size();\n-    }\n-\n-    @Test\n-    public void testAdd() {\n-        final HasherCollection hasher = createHasher();\n-        hasher.add(new IncrementingHasher(2, 2));\n-        assertEquals(3, hasher.getHashers().size());\n-\n-        hasher.add(Arrays.asList(new IncrementingHasher(3, 2), new IncrementingHasher(4, 2)));\n-        assertEquals(5, hasher.getHashers().size());\n-    }\n-\n-    @Test\n-    void testHasherCollection() {\n-        final Hasher h1 = new IncrementingHasher(13, 4678);\n-        final Hasher h2 = new IncrementingHasher(42, 987);\n-        final Hasher h3 = new IncrementingHasher(454, 2342);\n-\n-        final HasherCollection hc1 = new HasherCollection(Arrays.asList(h1, h1));\n-        final HasherCollection hc2 = new HasherCollection(Arrays.asList(h2, h3));\n-        final HasherCollection hc3 = new HasherCollection(Arrays.asList(hc1, hc2));\n-\n-        final ArrayCountingBloomFilter bf = new ArrayCountingBloomFilter(Shape.fromKM(5, 10000));\n-\n-        // Should add h1, h1, h2, h3\n-        Assertions.assertTrue(bf.merge(hc3));\n-        Assertions.assertTrue(bf.remove(h1));\n-        Assertions.assertTrue(bf.remove(h1));\n-        Assertions.assertNotEquals(0, bf.cardinality());\n-        Assertions.assertTrue(bf.remove(hc2));\n-        Assertions.assertEquals(0, bf.cardinality());\n-    }\n-\n-    @Test\n-    public void testAbsoluteUniqueIndices() {\n-        final int[] actual = new HasherCollection(\n-            new IncrementingHasher(1, 1),\n-            new IncrementingHasher(10, 1)\n-        ).absoluteUniqueIndices(Shape.fromKM(5, 1000)).asIndexArray();\n-        final int[] expected = IntStream.concat(\n-                IntStream.range(1, 1 + 5),\n-                IntStream.range(10, 10 + 5)\n-            ).toArray();\n-        Assertions.assertArrayEquals(expected, actual);\n-    }\n-}\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/SetOperationsTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/SetOperationsTest.java\nindex 6b90e1151b..792917bc1d 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/SetOperationsTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/SetOperationsTest.java\n@@ -28,12 +28,6 @@\n  */\n public class SetOperationsTest {\n \n-    protected final Hasher from1 = new IncrementingHasher(1, 1);\n-    protected final long from1Value = 0x3FFFEL;\n-    protected final Hasher from11 = new IncrementingHasher(11, 1);\n-    protected final long from11Value = 0xFFFF800L;\n-    protected final HasherCollection bigHasher = new HasherCollection(from1, from11);\n-    protected final long bigHashValue = 0xFFFFFFEL;\n     private final Shape shape = Shape.fromKM(17, 72);\n \n     private static void assertSymmetricOperation(final int expected, final ToIntBiFunction<BloomFilter, BloomFilter> operation,\n@@ -66,15 +60,15 @@ private BloomFilter createFilter(final Shape shape, final IndexProducer producer\n     @Test\n     public final void testCosineDistance() {\n \n-        BloomFilter filter1 = createFilter(shape, from1);\n-        BloomFilter filter2 = createFilter(shape, from1);\n+        BloomFilter filter1 = createFilter(shape, TestingHashers.FROM1);\n+        BloomFilter filter2 = createFilter(shape, TestingHashers.FROM1);\n \n         // identical filters should have no distance.\n         double expected = 0;\n         assertSymmetricOperation(expected, SetOperations::cosineDistance, filter1, filter2);\n \n         final Shape shape2 = Shape.fromKM(2, 72);\n-        filter1 = createFilter(shape2, from1);\n+        filter1 = createFilter(shape2, TestingHashers.FROM1);\n         filter2 = createFilter(shape2, new IncrementingHasher(2, 1));\n \n         int dotProduct = /* [1,2] & [2,3] = [2] = */ 1;\n@@ -83,8 +77,8 @@ public final void testCosineDistance() {\n         expected = 1 - dotProduct / Math.sqrt(cardinalityA * cardinalityB);\n         assertSymmetricOperation(expected, SetOperations::cosineDistance, filter1, filter2);\n \n-        filter1 = createFilter(shape, from1);\n-        filter2 = createFilter(shape, from11);\n+        filter1 = createFilter(shape, TestingHashers.FROM1);\n+        filter2 = createFilter(shape, TestingHashers.FROM11);\n         dotProduct = /* [1..17] & [11..27] = [] = */ 7;\n         cardinalityA = 17;\n         cardinalityB = 17;\n@@ -92,7 +86,7 @@ public final void testCosineDistance() {\n         assertSymmetricOperation(expected, SetOperations::cosineDistance, filter1, filter2);\n \n         // test with no values\n-        filter1 = createFilter(shape, from1);\n+        filter1 = createFilter(shape, TestingHashers.FROM1);\n         filter2 = new SimpleBloomFilter(shape);\n \n         dotProduct = /* [1,2] & [] = [] = */ 0;\n@@ -113,8 +107,8 @@ public final void testCosineDistance() {\n      */\n     @Test\n     public final void testCosineSimilarity() {\n-        BloomFilter filter1 = createFilter(shape, from1);\n-        BloomFilter filter2 = createFilter(shape, from1);\n+        BloomFilter filter1 = createFilter(shape, TestingHashers.FROM1);\n+        BloomFilter filter2 = createFilter(shape, TestingHashers.FROM1);\n \n         int dotProduct = /* [1..17] & [1..17] = [1..17] = */ 17;\n         int cardinalityA = 17;\n@@ -126,14 +120,14 @@ public final void testCosineSimilarity() {\n         cardinalityA = 17;\n         cardinalityB = 17;\n         expected = dotProduct / Math.sqrt(cardinalityA * cardinalityB);\n-        filter2 = createFilter(shape, from11);\n+        filter2 = createFilter(shape, TestingHashers.FROM11);\n         assertSymmetricOperation(expected, SetOperations::cosineSimilarity, filter1, filter2);\n \n         // test no values\n         filter1 = new SimpleBloomFilter(shape);\n         filter2 = new SimpleBloomFilter(shape);\n         // build a filter\n-        final BloomFilter filter3 = createFilter(shape, from1);\n+        final BloomFilter filter3 = createFilter(shape, TestingHashers.FROM1);\n         assertSymmetricOperation(0.0, SetOperations::cosineSimilarity, filter1, filter2);\n         assertSymmetricOperation(0.0, SetOperations::cosineSimilarity, filter1, filter3);\n     }\n@@ -143,13 +137,13 @@ public final void testCosineSimilarity() {\n      */\n     @Test\n     public final void testHammingDistance() {\n-        final BloomFilter filter1 = createFilter(shape, from1);\n-        BloomFilter filter2 = createFilter(shape, from1);\n+        final BloomFilter filter1 = createFilter(shape, TestingHashers.FROM1);\n+        BloomFilter filter2 = createFilter(shape, TestingHashers.FROM1);\n \n         int hammingDistance = /* [1..17] ^ [1..17] = [] = */ 0;\n         assertSymmetricOperation(hammingDistance, SetOperations::hammingDistance, filter1, filter2);\n \n-        filter2 = createFilter(shape, from11);\n+        filter2 = createFilter(shape, TestingHashers.FROM11);\n         hammingDistance = /* [1..17] ^ [11..27] = [1..10][17-27] = */ 20;\n         assertSymmetricOperation(hammingDistance, SetOperations::hammingDistance, filter1, filter2);\n     }\n@@ -159,13 +153,13 @@ public final void testHammingDistance() {\n      */\n     @Test\n     public final void testJaccardDistance() {\n-        BloomFilter filter1 = createFilter(shape, from1);\n-        BloomFilter filter2 = createFilter(shape, from1);\n+        BloomFilter filter1 = createFilter(shape, TestingHashers.FROM1);\n+        BloomFilter filter2 = createFilter(shape, TestingHashers.FROM1);\n \n         // 1 - jaccardSimilarity -- see jaccardSimilarityTest\n         assertSymmetricOperation(0.0, SetOperations::jaccardDistance, filter1, filter2);\n \n-        filter2 = createFilter(shape, from11);\n+        filter2 = createFilter(shape, TestingHashers.FROM11);\n         final double intersection = /* [1..17] & [11..27] = [11..17] = */ 7.0;\n         final int union = /* [1..17] | [11..27] = [1..27] = */ 27;\n         final double expected = 1 - intersection / union;\n@@ -174,7 +168,7 @@ public final void testJaccardDistance() {\n         // test no values\n         filter1 = new SimpleBloomFilter(shape);\n         filter2 = new SimpleBloomFilter(shape);\n-        final BloomFilter filter3 = createFilter(shape, from1);\n+        final BloomFilter filter3 = createFilter(shape, TestingHashers.FROM1);\n \n         // 1 - jaccardSimilarity -- see jaccardSimilarityTest\n         assertSymmetricOperation(1.0, SetOperations::jaccardDistance, filter1, filter2);\n@@ -186,15 +180,15 @@ public final void testJaccardDistance() {\n      */\n     @Test\n     public final void testJaccardSimilarity() {\n-        BloomFilter filter1 = createFilter(shape, from1);\n-        BloomFilter filter2 = createFilter(shape, from1);\n+        BloomFilter filter1 = createFilter(shape, TestingHashers.FROM1);\n+        BloomFilter filter2 = createFilter(shape, TestingHashers.FROM1);\n \n         double intersection = /* [1..17] & [1..17] = [1..17] = */ 17.0;\n         int union = /* [1..17] | [1..17] = [1..17] = */ 17;\n         double expected = intersection / union;\n         assertSymmetricOperation(expected, SetOperations::jaccardSimilarity, filter1, filter2);\n \n-        filter2 = createFilter(shape, from11);\n+        filter2 = createFilter(shape, TestingHashers.FROM11);\n         intersection = /* [1..17] & [11..27] = [11..17] = */ 7.0;\n         union = /* [1..17] | [11..27] = [1..27] = */ 27;\n         expected = intersection / union;\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/SparseBloomFilterTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/SparseBloomFilterTest.java\nindex ba018134a3..aa9a4cd6db 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/SparseBloomFilterTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/SparseBloomFilterTest.java\n@@ -85,7 +85,7 @@ public void testBitMapProducerEdgeCases() {\n     public void testBloomFilterBasedMergeEdgeCases() {\n         final BloomFilter bf1 = createEmptyFilter(getTestShape());\n         final BloomFilter bf2 = new SimpleBloomFilter(getTestShape());\n-        bf2.merge(from1);\n+        bf2.merge(TestingHashers.FROM1);\n         bf1.merge(bf2);\n         assertTrue(bf2.forEachBitMapPair(bf1, (x, y) -> x == y));\n     }\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/TestingHashers.java b/src/test/java/org/apache/commons/collections4/bloomfilter/TestingHashers.java\nnew file mode 100644\nindex 0000000000..8589000fbb\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/TestingHashers.java\n@@ -0,0 +1,75 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.bloomfilter;\n+/**\n+ * A collection of methods and statics that represent standard hashers in testing.\n+ */\n+class TestingHashers {\n+    /**\n+     * Hasher that increments from 1.\n+     */\n+    static final Hasher FROM1 = new IncrementingHasher(1, 1);\n+\n+    /**\n+     * Hasher that increments from 11.\n+     */\n+    static final Hasher FROM11 = new IncrementingHasher(11, 1);\n+\n+    /**\n+     * Do not instantiate.\n+     */\n+    private TestingHashers() {}\n+\n+    /**\n+     * Merge several Hashers together into a single Bloom filter.\n+     * @param <T> The type of bloom filter.\n+     * @param filter The Bloom filter to populate\n+     * @param hashers The hashers to merge\n+     * @return {@code filter} for chaining\n+     */\n+    static <T extends BloomFilter> T mergeHashers(T filter, Hasher...hashers) {\n+        for (Hasher h : hashers) {\n+            filter.merge(h);\n+        }\n+        return filter;\n+    }\n+\n+    /**\n+     * Merge {@code from1} and {@code from11} into a single Bloom filter.\n+     * @param <T> The type of bloom filter.\n+     * @param filter The Bloom filter to populate\n+     * @return {@code filter} for chaining\n+     */\n+    static <T extends BloomFilter> T populateFromHashersFrom1AndFrom11(T filter) {\n+        return mergeHashers(filter, FROM1, FROM11);\n+    }\n+\n+    /**\n+     * Create a hasher that fills the entire range.\n+     * @param <T> the Bloom filter type.\n+     * @param filter the Bloom filter to populate\n+     * @return {@code filter} for chaining\n+     */\n+    static <T extends BloomFilter> T populateEntireFilter(T filter) {\n+        int n = filter.getShape().getNumberOfBits();\n+        int k = filter.getShape().getNumberOfHashFunctions();\n+        for (int i = 0; i < n; i += k) {\n+            filter.merge(new IncrementingHasher(i, 1));\n+        }\n+        return filter;\n+    }\n+}\n",
  "problem_statement" : "Removed HasherCollection\n\nFix for COLLECTIONS-836\r\n\r\nRemoved HasherCollection\r\n\r\nMoved multiple hashing functions into TestingHashers.",
  "hints_text" : null,
  "created_at" : "Fri Nov 11 15:40:18 CET 2022",
  "version" : null,
  "FAIL_TO_PASS" : [ "BitCountProducerFromHasherCollectionTest", "SparseBloomFilterTest", "HasherCollectionTest", "SetOperationsTest", "AbstractBloomFilterTest", "AbstractCountingBloomFilterTest", "BitCountProducerFromAbsoluteUniqueHasherCollectionTest", "TestingHashers", "BitCountProducerFromUniqueHasherCollectionTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=BitCountProducerFromHasherCollectionTest,SparseBloomFilterTest,HasherCollectionTest,SetOperationsTest,AbstractBloomFilterTest,AbstractCountingBloomFilterTest,BitCountProducerFromAbsoluteUniqueHasherCollectionTest,TestingHashers,BitCountProducerFromUniqueHasherCollectionTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 361,
  "metadata" : null
}, {
  "instance_id" : "apache-commons-collections-PR-335",
  "repo" : "apache/commons-collections",
  "base_commit" : "dca05e593e4fe6c5546f37994f818ab8a15d1380",
  "patch" : "diff --git a/src/main/java/org/apache/commons/collections4/bloomfilter/BitCountProducer.java b/src/main/java/org/apache/commons/collections4/bloomfilter/BitCountProducer.java\nindex aea07b36e7..e32313c7c2 100644\n--- a/src/main/java/org/apache/commons/collections4/bloomfilter/BitCountProducer.java\n+++ b/src/main/java/org/apache/commons/collections4/bloomfilter/BitCountProducer.java\n@@ -18,8 +18,32 @@\n \n import java.util.function.IntPredicate;\n \n-/**\n- * Produces bit counts for counting type Bloom filters.\n+/*\n+ * Defines a mapping of index to counts.\n+ *\n+ * <p>Note that a BitCountProducer may return duplicate indices and may be unordered.\n+ *\n+ * <p>Implementations must guarantee that:\n+ *\n+ * <ul>\n+ * <li>The mapping of index to counts is the combined sum of counts at each index.\n+ * <li>For every unique value produced by the IndexProducer there will be at least one matching\n+ * index and count produced by the BitCountProducer.\n+ * <li>The BitCountProducer will not generate indices that are not output by the IndexProducer.\n+ * </ul>\n+ *\n+ * <p>Note that implementations that do not output duplicate indices for BitCountProducer and\n+ * do for IndexProducer, or vice versa, are consistent if the distinct indices from each are\n+ * the same.\n+ *\n+ * <p>For example the mapping [(1,2),(2,3),(3,1)] can be output with many combinations including:\n+ * <pre>\n+ * [(1,2),(2,3),(3,1)]\n+ * [(1,1),(1,1),(2,1),(2,1),(2,1),(3,1)]\n+ * [(1,1),(3,1),(1,1),(2,1),(2,1),(2,1)]\n+ * [(3,1),(1,1),(2,2),(1,1),(2,1)]\n+ * ...\n+ * </pre>\n  *\n  * @since 4.5\n  */\n@@ -32,14 +56,18 @@ public interface BitCountProducer extends IndexProducer {\n      * index-count pair, if the consumer returns {@code false} the execution is stopped, {@code false}\n      * is returned, and no further pairs are processed.\n      *\n-     * <p>Must only process each index once, and must process indexes in order.</p>\n+     * Duplicate indices are not required to be aggregated. Duplicates may be output by the producer as\n+     * noted in the class javadoc.\n      *\n      * @param consumer the action to be performed for each non-zero bit count\n      * @return {@code true} if all count pairs return true from consumer, {@code false} otherwise.\n-     * @throws NullPointerException if the specified action is null\n+     * @throws NullPointerException if the specified consumer is null\n      */\n     boolean forEachCount(BitCountConsumer consumer);\n \n+    /**\n+     * The default implementation returns indices with ordering and uniqueness of {@code forEachCount()}.\n+     */\n     @Override\n     default boolean forEachIndex(IntPredicate predicate) {\n         return forEachCount((i, v) -> predicate.test(i));\n@@ -47,7 +75,13 @@ default boolean forEachIndex(IntPredicate predicate) {\n \n     /**\n      * Creates a BitCountProducer from an IndexProducer.  The resulting\n-     * producer will count each enabled bit once.\n+     * producer will return every index from the IndexProducer with a count of 1.\n+     *\n+     * <p>Note that the BitCountProducer does not remove duplicates. Any use of the\n+     * BitCountProducer to create an aggregate mapping of index to counts, such as a\n+     * CountingBloomFilter, should use the same BitCountProducer in both add and\n+     * subtract operations to maintain consistency.\n+     * </p>\n      * @param idx An index producer.\n      * @return A BitCountProducer with the same indices as the IndexProducer.\n      */\n@@ -57,12 +91,22 @@ static BitCountProducer from(IndexProducer idx) {\n             public boolean forEachCount(BitCountConsumer consumer) {\n                 return idx.forEachIndex(i -> consumer.test(i, 1));\n             }\n+\n+            @Override\n+            public int[] asIndexArray() {\n+                return idx.asIndexArray();\n+            }\n+\n+            @Override\n+            public boolean forEachIndex(IntPredicate predicate) {\n+                return idx.forEachIndex(predicate);\n+            }\n         };\n     }\n \n     /**\n      * Represents an operation that accepts an {@code <index, count>} pair representing\n-     * the count for a bit index in a Bit Count Producer Bloom filter and returns {@code true}\n+     * the count for a bit index. Returns {@code true}\n      * if processing should continue, {@code false} otherwise.\n      *\n      * <p>Note: This is a functional interface as a specialization of\n@@ -71,7 +115,7 @@ public boolean forEachCount(BitCountConsumer consumer) {\n     @FunctionalInterface\n     interface BitCountConsumer {\n         /**\n-         * Performs this operation on the given {@code <index, count>} pair.\n+         * Performs an operation on the given {@code <index, count>} pair.\n          *\n          * @param index the bit index.\n          * @param count the count at the specified bit index.\ndiff --git a/src/main/java/org/apache/commons/collections4/bloomfilter/Hasher.java b/src/main/java/org/apache/commons/collections4/bloomfilter/Hasher.java\nindex 82445a623d..573532e12e 100644\n--- a/src/main/java/org/apache/commons/collections4/bloomfilter/Hasher.java\n+++ b/src/main/java/org/apache/commons/collections4/bloomfilter/Hasher.java\n@@ -49,7 +49,8 @@ public interface Hasher {\n      * Creates an IndexProducer of unique indices for this hasher based on the Shape.\n      *\n      * <p>This is like the `indices(Shape)` method except that it adds the guarantee that no\n-     * duplicate values will be returned</p>\n+     * duplicate values will be returned.  The indices produced are equivalent to those returned\n+     * from by a Bloom filter created from this hasher.</p>\n      *\n      * @param shape the shape of the desired Bloom filter.\n      * @return the iterator of integers\ndiff --git a/src/main/java/org/apache/commons/collections4/bloomfilter/HasherCollection.java b/src/main/java/org/apache/commons/collections4/bloomfilter/HasherCollection.java\nindex 8483dfc300..56652ecbf7 100644\n--- a/src/main/java/org/apache/commons/collections4/bloomfilter/HasherCollection.java\n+++ b/src/main/java/org/apache/commons/collections4/bloomfilter/HasherCollection.java\n@@ -90,6 +90,20 @@ public IndexProducer indices(final Shape shape) {\n         return new HasherCollectionIndexProducer(shape);\n     }\n \n+    /**\n+     * Creates an IndexProducer comprising the unique indices from each of the contained\n+     * hashers.\n+     *\n+     * <p>This method may return duplicates if the collection of unique values from each of the contained\n+     * hashers contain duplicates.  This is equivalent to creating Bloom filters for each contained hasher\n+     * and returning an IndexProducer with the concatenated output indices from each filter.</p>\n+     *\n+     * <p>A BitCountProducer generated from this IndexProducer is equivalent to a BitCountProducer from a\n+     * counting Bloom filter that was constructed from the contained hashers unique indices.<p>\n+     *\n+     * @param shape the shape of the desired Bloom filter.\n+     * @return the iterator of integers\n+     */\n     @Override\n     public IndexProducer uniqueIndices(final Shape shape) {\n         Objects.requireNonNull(shape, \"shape\");\n@@ -106,6 +120,27 @@ public boolean forEachIndex(IntPredicate consumer) {\n         };\n     }\n \n+    /**\n+     * Creates an IndexProducer comprising the unique indices across all the contained\n+     * hashers.\n+     *\n+     * <p>This is equivalent to an IndexProducer created from a Bloom filter that comprises all\n+     * the contained hashers.</p>\n+     *\n+     * @param shape the shape of the desired Bloom filter.\n+     * @return the iterator of integers\n+     */\n+    public IndexProducer absoluteUniqueIndices(final Shape shape) {\n+        int kCount = hashers.size() > 0 ? hashers.size() : 1;\n+        return consumer -> {\n+            Objects.requireNonNull(consumer, \"consumer\");\n+            // shape must handle maximum unique indices\n+            return uniqueIndices(shape).forEachIndex(IndexFilter.create(\n+                    Shape.fromKM(shape.getNumberOfHashFunctions() * kCount,\n+                                 shape.getNumberOfBits()), consumer));\n+        };\n+    }\n+\n     /**\n      * Allow child classes access to the hashers.\n      * @return hashers\n@@ -141,29 +176,16 @@ public boolean forEachIndex(IntPredicate consumer) {\n \n         @Override\n         public int[] asIndexArray() {\n-            List<int[]> lst = new ArrayList<>();\n-            int[] count = new int[1];\n-            /*\n-             * This method needs to return duplicate indices\n-             */\n-            for (Hasher hasher : hashers) {\n-                int[] ary = hasher.indices(shape).asIndexArray();\n-                lst.add(ary);\n-                count[0] += ary.length;\n-            }\n-            if (lst.isEmpty()) {\n-                return new int[0];\n-            }\n-            if (lst.size() == 1) {\n-                return lst.get(0);\n-            }\n-            int[] result = new int[count[0]];\n-            int offset = 0;\n-            for (int[] ary : lst) {\n-                System.arraycopy(ary, 0, result, offset, ary.length);\n-                offset += ary.length;\n-            }\n-            return result;\n+            int[] result = new int[shape.getNumberOfHashFunctions() * hashers.size()];\n+            int[] idx = new int[1];\n+\n+            // This method needs to return duplicate indices\n+\n+            forEachIndex(i -> {\n+                result[idx[0]++] = i;\n+                return true;\n+            });\n+            return Arrays.copyOf(result, idx[0]);\n         }\n     }\n }\ndiff --git a/src/main/java/org/apache/commons/collections4/bloomfilter/IndexFilter.java b/src/main/java/org/apache/commons/collections4/bloomfilter/IndexFilter.java\nindex 991d4d98f3..82e1103452 100644\n--- a/src/main/java/org/apache/commons/collections4/bloomfilter/IndexFilter.java\n+++ b/src/main/java/org/apache/commons/collections4/bloomfilter/IndexFilter.java\n@@ -23,7 +23,7 @@\n  *\n  * <p><em>If the index is negative the behavior is not defined.</em></p>\n  *\n- * <p>This is conceptually a unique filter implemented as a {@code IntPredicate}.</p>\n+ * <p>This is conceptually a unique filter implemented as an {@code IntPredicate}.</p>\n  * @since 4.5\n  */\n public final class IndexFilter {\ndiff --git a/src/main/java/org/apache/commons/collections4/bloomfilter/IndexProducer.java b/src/main/java/org/apache/commons/collections4/bloomfilter/IndexProducer.java\nindex 5789285bf8..11cb3dd8d3 100644\n--- a/src/main/java/org/apache/commons/collections4/bloomfilter/IndexProducer.java\n+++ b/src/main/java/org/apache/commons/collections4/bloomfilter/IndexProducer.java\n@@ -64,6 +64,11 @@ public boolean forEachIndex(IntPredicate predicate) {\n                 }\n                 return true;\n             }\n+\n+            @Override\n+            public int[] asIndexArray() {\n+                return values.clone();\n+            }\n         };\n     }\n \n@@ -110,6 +115,10 @@ public boolean test(long word) {\n      * The default implementation of this method is slow.  It is recommended\n      * that implementing classes reimplement this method.\n      * </em></p>\n+     *\n+     * <p><em>\n+     * The default implementation of this method returns unique values in order.\n+     * </em></p>\n      * @return An int array of the data.\n      */\n     default int[] asIndexArray() {\n",
  "test_patch" : "diff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBitCountProducerTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBitCountProducerTest.java\nindex e51f90105e..9499b301a6 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBitCountProducerTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBitCountProducerTest.java\n@@ -16,35 +16,41 @@\n  */\n package org.apache.commons.collections4.bloomfilter;\n \n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n import static org.junit.jupiter.api.Assertions.assertFalse;\n import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assumptions.assumeTrue;\n \n+import java.util.Arrays;\n+import java.util.BitSet;\n+\n+import org.apache.commons.collections4.bag.TreeBag;\n import org.apache.commons.collections4.bloomfilter.BitCountProducer.BitCountConsumer;\n+import org.junit.jupiter.api.Assertions;\n import org.junit.jupiter.api.Test;\n \n public abstract class AbstractBitCountProducerTest extends AbstractIndexProducerTest {\n \n+    /**\n+     * A testing BitCountConsumer that always returns true.\n+     */\n+    private static final BitCountConsumer TRUE_CONSUMER = (i, j) -> true;\n     /**\n      * A testing BitCountConsumer that always returns false.\n      */\n-    public static BitCountConsumer FALSE_CONSUMER = new BitCountConsumer() {\n-\n-        @Override\n-        public boolean test(int index, int count) {\n-            return false;\n-        }\n-    };\n+    private static final BitCountConsumer FALSE_CONSUMER = (i, j) -> false;\n \n     /**\n-     * A testing BitCountConsumer that always returns true.\n+     * Creates an array of integer pairs comprising the index and the expected count for the index.\n+     * The order and count for each index is dependent upon the producer created by the {@code createProducer()}\n+     * method.\n+     * By default returns the each {@code getExpectedIndices()} value paired with 1 (one).\n+     * @return an array of integer pairs comprising the index and the expected count for the index.\n      */\n-    public static BitCountConsumer TRUE_CONSUMER = new BitCountConsumer() {\n-\n-        @Override\n-        public boolean test(int index, int count) {\n-            return true;\n-        }\n-    };\n+    protected int[][] getExpectedBitCount() {\n+        return Arrays.stream(getExpectedIndices()).mapToObj(x -> new int[] {x, 1}).toArray(int[][]::new);\n+    }\n \n     /**\n      * Creates a producer with some data.\n@@ -54,29 +60,109 @@ public boolean test(int index, int count) {\n     protected abstract BitCountProducer createProducer();\n \n     /**\n-     * Creates an producer without data.\n+     * Creates a producer without data.\n      * @return a producer that has no data.\n      */\n     @Override\n     protected abstract BitCountProducer createEmptyProducer();\n \n     /**\n-     * Determines if empty tests should be run.  Some producers do not implement an empty\n-     * version.  Tests for those classes should return false.\n-     * @return true if the empty tests are supported\n+     * Gets the behaviour of the {@link BitCountProducer#forEachCount(BitCountConsumer)} method.\n+     * By default returns the value of {@code getAsIndexArrayBehaviour()} method.\n+     * @return the behaviour.\n      */\n-    protected boolean supportsEmpty() {\n-        return true;\n+    protected int getForEachCountBehaviour() {\n+        return getAsIndexArrayBehaviour();\n+    }\n+\n+    @Test\n+    public final void testForEachCountPredicates() {\n+        BitCountProducer populated = createProducer();\n+        BitCountProducer empty = createEmptyProducer();\n+\n+        assertFalse(populated.forEachCount(FALSE_CONSUMER), \"non-empty should be false\");\n+        assertTrue(empty.forEachCount(FALSE_CONSUMER), \"empty should be true\");\n+\n+        assertTrue(populated.forEachCount(TRUE_CONSUMER), \"non-empty should be true\");\n+        assertTrue(empty.forEachCount(TRUE_CONSUMER), \"empty should be true\");\n+    }\n+\n+    @Test\n+    public final void testEmptyBitCountProducer() {\n+        BitCountProducer empty = createEmptyProducer();\n+        int ary[] = empty.asIndexArray();\n+        assertEquals(0, ary.length);\n+        assertTrue(empty.forEachCount((i, j) -> {\n+            Assertions.fail(\"forEachCount consumer should not be called\");\n+            return false;\n+        }));\n+    }\n+\n+    @Test\n+    public final void testIndexConsistency() {\n+        BitCountProducer producer = createProducer();\n+        BitSet bs1 = new BitSet();\n+        BitSet bs2 = new BitSet();\n+        producer.forEachIndex(i -> {\n+            bs1.set(i);\n+            return true;\n+        });\n+        producer.forEachCount((i, j) -> {\n+            bs2.set(i);\n+            return true;\n+        });\n+        Assertions.assertEquals(bs1, bs2);\n     }\n \n     @Test\n-    public final void testForEachCount() {\n+    public void testForEachCountValues() {\n+        // Assumes the collections bag works. Could be replaced with Map<Integer,Integer> with more work.\n+        final TreeBag<Integer> expected = new TreeBag<>();\n+        Arrays.stream(getExpectedBitCount()).forEach(c -> expected.add(c[0], c[1]));\n+        final TreeBag<Integer> actual = new TreeBag<>();\n+        // can not return actual.add as it returns false on duplicate 'i'\n+        createProducer().forEachCount((i, j) -> {\n+            actual.add(i, j);\n+            return true;\n+        });\n+        assertEquals(expected, actual);\n+    }\n \n-        assertFalse(createProducer().forEachCount(FALSE_CONSUMER), \"non-empty should be false\");\n-        assertTrue(createProducer().forEachCount(TRUE_CONSUMER), \"non-empty should be true\");\n-        if (supportsEmpty()) {\n-            assertTrue(createEmptyProducer().forEachCount(FALSE_CONSUMER), \"empty should be true\");\n-            assertTrue(createEmptyProducer().forEachCount(TRUE_CONSUMER), \"empty should be true\");\n+    /**\n+     * Test the behaviour of {@link BitCountProducer#forEachCount(BitCountConsumer)} with respect\n+     * to ordered and distinct indices. Currently the behaviour is assumed to be the same as\n+     * {@link IndexProducer#forEachIndex(java.util.function.IntPredicate)}.\n+     */\n+    @Test\n+    public final void testBehaviourForEachCount() {\n+        int flags = getForEachCountBehaviour();\n+        assumeTrue((flags & (ORDERED | DISTINCT)) != 0);\n+        IntList list = new IntList();\n+        createProducer().forEachCount((i, j) -> list.add(i));\n+        int[] actual = list.toArray();\n+        if ((flags & ORDERED) != 0) {\n+            int[] expected = Arrays.stream(actual).sorted().toArray();\n+            assertArrayEquals(expected, actual);\n+        }\n+        if ((flags & DISTINCT) != 0) {\n+            long count = Arrays.stream(actual).distinct().count();\n+            assertEquals(count, actual.length);\n         }\n     }\n+\n+    @Test\n+    public void testForEachCountEarlyExit() {\n+        int[] passes = new int[1];\n+        assertTrue(createEmptyProducer().forEachCount((i, j) -> {\n+            passes[0]++;\n+            return false;\n+        }));\n+        assertEquals(0, passes[0]);\n+\n+        assertFalse(createProducer().forEachCount((i, j) -> {\n+            passes[0]++;\n+            return false;\n+        }));\n+        assertEquals(1, passes[0]);\n+    }\n }\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractHasherTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractHasherTest.java\nindex 0e9fae4109..9b3d4a5774 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractHasherTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractHasherTest.java\n@@ -19,13 +19,6 @@\n import static org.junit.jupiter.api.Assertions.assertEquals;\n import static org.junit.jupiter.api.Assertions.assertTrue;\n \n-import java.util.Arrays;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-\n-import org.junit.jupiter.api.Test;\n import org.junit.jupiter.params.ParameterizedTest;\n import org.junit.jupiter.params.provider.CsvSource;\n \n@@ -87,18 +80,4 @@ public void testHashing(int k, int m) {\n         });\n         assertEquals(1, count[0], \"did not exit early\");\n     }\n-\n-    @Test\n-    public void testUniqueIndex() {\n-        // generating 11 numbers in the range of [0,9] will yield at least on collision.\n-        Shape shape = Shape.fromKM(11, 10);\n-        Hasher hasher = createHasher();\n-        IndexProducer producer = hasher.indices(shape);\n-        List<Integer> full = Arrays.stream(producer.asIndexArray()).boxed().collect(Collectors.toList());\n-        producer = hasher.uniqueIndices(shape);\n-        List<Integer> unique = Arrays.stream(producer.asIndexArray()).boxed().collect(Collectors.toList());\n-        assertTrue(full.size() > unique.size());\n-        Set<Integer> set = new HashSet<>(unique);\n-        assertEquals(set.size(), unique.size());\n-    }\n }\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractIndexProducerTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractIndexProducerTest.java\nindex ac5a6fc230..5a4b4498b1 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractIndexProducerTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractIndexProducerTest.java\n@@ -23,27 +23,25 @@\n import java.util.BitSet;\n import java.util.function.IntPredicate;\n import org.junit.jupiter.api.Assertions;\n-import org.junit.jupiter.api.Assumptions;\n import org.junit.jupiter.api.Test;\n \n+/**\n+ * Test for IndexProducer.\n+ */\n public abstract class AbstractIndexProducerTest {\n \n     private static final IntPredicate TRUE_PREDICATE = i -> true;\n     private static final IntPredicate FALSE_PREDICATE = i -> false;\n \n     /** Flag to indicate the {@link IndexProducer#forEachIndex(IntPredicate)} is ordered. */\n-    protected static final int FOR_EACH_ORDERED = 0x1;\n+    protected static final int ORDERED = 0x1;\n     /** Flag to indicate the {@link IndexProducer#forEachIndex(IntPredicate)} is distinct. */\n-    protected static final int FOR_EACH_DISTINCT = 0x2;\n-    /** Flag to indicate the {@link IndexProducer#asIndexArray()} is ordered. */\n-    protected static final int AS_ARRAY_ORDERED = 0x4;\n-    /** Flag to indicate the {@link IndexProducer#asIndexArray()} is distinct. */\n-    protected static final int AS_ARRAY_DISTINCT = 0x8;\n+    protected static final int DISTINCT = 0x2;\n \n     /**\n      * An expandable list of int values.\n      */\n-    private static class IntList {\n+    protected static class IntList {\n         private int size;\n         private int[] data = {0};\n \n@@ -84,17 +82,56 @@ int[] toArray() {\n     protected abstract IndexProducer createEmptyProducer();\n \n     /**\n-     * Gets the behaviour flags.\n-     *\n-     * <p>The flags indicate if the methods {@link IndexProducer#forEachIndex(IntPredicate)}\n-     * and {@link IndexProducer#asIndexArray()} output sorted or distinct indices.\n-     *\n+     * Gets the behaviour of the {@link IndexProducer#asIndexArray()} method.\n+     * @return the behaviour.\n+     */\n+    protected abstract int getAsIndexArrayBehaviour();\n+\n+    /**\n+     * Gets the behaviour of the {@link IndexProducer#forEachIndex(IntPredicate)} method.\n+     * By default returns the value of {@code getAsIndexArrayBehaviour()} method.\n      * @return the behaviour.\n      */\n-    protected abstract int getBehaviour();\n+    protected int getForEachIndexBehaviour() {\n+        return getAsIndexArrayBehaviour();\n+    }\n+\n+    /**\n+     * Creates an array of expected indices.\n+     * The expected indices are dependent upon the producer created in the {@code createProducer()} method.\n+     * @return an array of expected indices.\n+     */\n+    protected abstract int[] getExpectedIndices();\n+\n+    /**\n+     * Test to ensure that all expected values are generated at least once.\n+     */\n+    @Test\n+    public final void testAsIndexArrayValues() {\n+        BitSet bs = new BitSet();\n+        Arrays.stream(createProducer().asIndexArray()).forEach(bs::set);\n+        for (int i : getExpectedIndices()) {\n+            assertTrue(bs.get(i), () -> \"Missing \" + i);\n+        }\n+    }\n \n+    /**\n+     * Test to ensure that for each index returns each expected index at least once.\n+     */\n     @Test\n     public final void testForEachIndex() {\n+        BitSet bs1 = new BitSet();\n+        BitSet bs2 = new BitSet();\n+        Arrays.stream(getExpectedIndices()).forEach(bs1::set);\n+        createProducer().forEachIndex(i -> {\n+            bs2.set(i);\n+            return true;\n+        });\n+        Assertions.assertEquals(bs1, bs2);\n+    }\n+\n+    @Test\n+    public final void testForEachIndexPredicates() {\n         IndexProducer populated = createProducer();\n         IndexProducer empty = createEmptyProducer();\n \n@@ -131,35 +168,58 @@ public final void testConsistency() {\n         Assertions.assertEquals(bs1, bs2);\n     }\n \n+    /**\n+     * Tests the behaviour of {@code IndexProducer.asIndexArray()}.\n+     * The expected behaviour is defined by the {@code getBehaviour()} method.\n+     * The index array may be Ordered, Distinct or both.\n+     * If the index array is not distinct then all elements returned by the {@code getExpectedIndices()}\n+     * method, including duplicates, are expected to be returned by the {@code asIndexArray()} method.\n+     */\n     @Test\n     public final void testBehaviourAsIndexArray() {\n-        int flags = getBehaviour();\n-        Assumptions.assumeTrue((flags & (AS_ARRAY_ORDERED | AS_ARRAY_DISTINCT)) != 0);\n+        int flags = getAsIndexArrayBehaviour();\n         int[] actual = createProducer().asIndexArray();\n-        if ((flags & AS_ARRAY_ORDERED) != 0) {\n+        if ((flags & ORDERED) != 0) {\n             int[] expected = Arrays.stream(actual).sorted().toArray();\n             Assertions.assertArrayEquals(expected, actual);\n         }\n-        if ((flags & AS_ARRAY_DISTINCT) != 0) {\n+        if ((flags & DISTINCT) != 0) {\n             long count = Arrays.stream(actual).distinct().count();\n             Assertions.assertEquals(count, actual.length);\n+        } else {\n+            // if the array is not distinct all expected elements must be generated\n+            // This is modified so use a copy\n+            int[] expected = getExpectedIndices().clone();\n+            Arrays.sort(expected);\n+            Arrays.sort(actual);\n+            Assertions.assertArrayEquals(expected, actual);\n         }\n     }\n \n+    /**\n+     * Tests the behaviour of {@code IndexProducer.forEachIndex()}.\n+     * The expected behaviour is defined by the {@code getBehaviour()} method.\n+     * The order is assumed to follow the order produced by {@code IndexProducer.asIndexArray()}.\n+     */\n     @Test\n-    public final void testBehaviourForEach() {\n-        int flags = getBehaviour();\n-        Assumptions.assumeTrue((flags & (FOR_EACH_ORDERED | FOR_EACH_DISTINCT)) != 0);\n+    public final void testBehaviourForEachIndex() {\n+        int flags = getForEachIndexBehaviour();\n         IntList list = new IntList();\n         createProducer().forEachIndex(list::add);\n         int[] actual = list.toArray();\n-        if ((flags & FOR_EACH_ORDERED) != 0) {\n+        if ((flags & ORDERED) != 0) {\n             int[] expected = Arrays.stream(actual).sorted().toArray();\n             Assertions.assertArrayEquals(expected, actual);\n         }\n-        if ((flags & FOR_EACH_DISTINCT) != 0) {\n+        if ((flags & DISTINCT) != 0) {\n             long count = Arrays.stream(actual).distinct().count();\n             Assertions.assertEquals(count, actual.length);\n+        } else {\n+            // if forEach is not distinct all expected elements must be generated\n+            int[] expected = getExpectedIndices().clone();\n+            Arrays.sort(expected);\n+            Arrays.sort(actual);\n+            Assertions.assertArrayEquals(expected, actual);\n         }\n     }\n \ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/BitCountProducerFromAbsoluteUniqueHasherCollectionTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/BitCountProducerFromAbsoluteUniqueHasherCollectionTest.java\nnew file mode 100644\nindex 0000000000..a61c80aefc\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/BitCountProducerFromAbsoluteUniqueHasherCollectionTest.java\n@@ -0,0 +1,44 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.bloomfilter;\n+\n+\n+public class BitCountProducerFromAbsoluteUniqueHasherCollectionTest extends AbstractBitCountProducerTest {\n+\n+    @Override\n+    protected BitCountProducer createProducer() {\n+        // hasher has collisions and wraps\n+        return BitCountProducer.from(new HasherCollection(\n+                new IncrementingHasher(1, 1),\n+                new IncrementingHasher(7, 2)).absoluteUniqueIndices(Shape.fromKM(5, 10)));\n+    }\n+\n+    @Override\n+    protected BitCountProducer createEmptyProducer() {\n+        return BitCountProducer.from(new HasherCollection().absoluteUniqueIndices(Shape.fromKM(11, 10)));\n+    }\n+\n+    @Override\n+    protected int getAsIndexArrayBehaviour() {\n+        return DISTINCT;\n+    }\n+\n+    @Override\n+    protected int[] getExpectedIndices() {\n+        return new int[]{1, 2, 3, 4, 5, 7, 9};\n+    }\n+}\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/BitCountProducerFromArrayCountingBloomFilterTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/BitCountProducerFromArrayCountingBloomFilterTest.java\nindex 331411436a..340e8146ca 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/BitCountProducerFromArrayCountingBloomFilterTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/BitCountProducerFromArrayCountingBloomFilterTest.java\n@@ -23,8 +23,8 @@ public class BitCountProducerFromArrayCountingBloomFilterTest extends AbstractBi\n     @Override\n     protected BitCountProducer createProducer() {\n         ArrayCountingBloomFilter filter = new ArrayCountingBloomFilter(shape);\n-        Hasher hasher = new IncrementingHasher(0, 1);\n-        filter.merge(hasher);\n+        filter.merge(new IncrementingHasher(0, 1));\n+        filter.merge(new IncrementingHasher(5, 1));\n         return filter;\n     }\n \n@@ -34,8 +34,20 @@ protected BitCountProducer createEmptyProducer() {\n     }\n \n     @Override\n-    protected int getBehaviour() {\n+    protected int getAsIndexArrayBehaviour() {\n         // CountingBloomFilter based on an array will be distinct and ordered\n-        return FOR_EACH_DISTINCT | FOR_EACH_ORDERED | AS_ARRAY_DISTINCT | AS_ARRAY_ORDERED;\n+        return DISTINCT | ORDERED;\n+    }\n+\n+    @Override\n+    protected int[][] getExpectedBitCount() {\n+        return new int[][]{{0, 1}, {1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 2}, {6, 2}, {7, 2},\n+            {8, 2}, {9, 2}, {10, 2}, {11, 2}, {12, 2}, {13, 2}, {14, 2}, {15, 2}, {16, 2},\n+            {17, 1}, {18, 1}, {19, 1}, {20, 1}, {21, 1}};\n+    }\n+\n+    @Override\n+    protected int[] getExpectedIndices() {\n+        return new int[]{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21};\n     }\n }\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromHasherTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/BitCountProducerFromDefaultIndexProducerTest.java\nsimilarity index 63%\nrename from src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromHasherTest.java\nrename to src/test/java/org/apache/commons/collections4/bloomfilter/BitCountProducerFromDefaultIndexProducerTest.java\nindex 0e7368dee8..56a5c792a6 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromHasherTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/BitCountProducerFromDefaultIndexProducerTest.java\n@@ -16,21 +16,27 @@\n  */\n package org.apache.commons.collections4.bloomfilter;\n \n-public class IndexProducerFromHasherTest extends AbstractIndexProducerTest {\n+public class BitCountProducerFromDefaultIndexProducerTest extends AbstractBitCountProducerTest {\n+\n+    int[] data = {0, 63, 1, 1, 64, 127, 128};\n \n     @Override\n-    protected IndexProducer createProducer() {\n-        return new IncrementingHasher(0, 1).indices(Shape.fromKM(17, 72));\n+    protected BitCountProducer createProducer() {\n+        return BitCountProducer.from(IndexProducer.fromIndexArray(data));\n     }\n \n     @Override\n-    protected IndexProducer createEmptyProducer() {\n-        return NullHasher.INSTANCE.indices(Shape.fromKM(17, 72));\n+    protected BitCountProducer createEmptyProducer() {\n+        return BitCountProducer.from(IndexProducer.fromIndexArray(new int[0]));\n     }\n \n     @Override\n-    protected int getBehaviour() {\n-        // Hasher allows duplicates and may be unordered\n+    protected int getAsIndexArrayBehaviour() {\n         return 0;\n     }\n+\n+    @Override\n+    protected int[] getExpectedIndices() {\n+        return data;\n+    }\n }\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/BitCountProducerFromHasherCollectionTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/BitCountProducerFromHasherCollectionTest.java\nnew file mode 100644\nindex 0000000000..a8c84492cd\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/BitCountProducerFromHasherCollectionTest.java\n@@ -0,0 +1,51 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.bloomfilter;\n+\n+public class BitCountProducerFromHasherCollectionTest extends AbstractBitCountProducerTest {\n+\n+    @Override\n+    protected BitCountProducer createProducer() {\n+        // hasher has collisions and wraps\n+        return BitCountProducer.from(new HasherCollection(\n+                new IncrementingHasher(0, 1),\n+                new IncrementingHasher(2, 7)).indices(Shape.fromKM(17, 72)));\n+    }\n+\n+    @Override\n+    protected BitCountProducer createEmptyProducer() {\n+        return BitCountProducer.from(NullHasher.INSTANCE.indices(Shape.fromKM(17, 72)));\n+    }\n+\n+    @Override\n+    protected int getAsIndexArrayBehaviour() {\n+        return 0;\n+    }\n+\n+    @Override\n+    protected int[] getExpectedIndices() {\n+        return new int[]{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,\n+            2, 9, 16, 23, 30, 37, 44, 51, 58, 65, 0, 7, 14, 21, 28, 35, 42};\n+    }\n+\n+    @Override\n+    protected int[][] getExpectedBitCount() {\n+        return new int[][]{{0, 2}, {1, 1}, {2, 2}, {3, 1}, {4, 1}, {5, 1}, {6, 1}, {7, 2}, {8, 1},\n+            {9, 2}, {10, 1}, {11, 1}, {12, 1}, {13, 1}, {14, 2}, {15, 1}, {16, 2}, {21, 1}, {23, 1},\n+            {28, 1}, {30, 1}, {35, 1}, {37, 1}, {42, 1}, {44, 1}, {51, 1}, {58, 1}, {65, 1} };\n+    }\n+}\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/UniqueIndexProducerFromHasherCollectionTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/BitCountProducerFromHasherTest.java\nsimilarity index 52%\nrename from src/test/java/org/apache/commons/collections4/bloomfilter/UniqueIndexProducerFromHasherCollectionTest.java\nrename to src/test/java/org/apache/commons/collections4/bloomfilter/BitCountProducerFromHasherTest.java\nindex 54eeec90db..6c382ea254 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/UniqueIndexProducerFromHasherCollectionTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/BitCountProducerFromHasherTest.java\n@@ -16,24 +16,32 @@\n  */\n package org.apache.commons.collections4.bloomfilter;\n \n-public class UniqueIndexProducerFromHasherCollectionTest extends AbstractIndexProducerTest {\n+public class BitCountProducerFromHasherTest extends AbstractBitCountProducerTest {\n \n     @Override\n-    protected IndexProducer createProducer() {\n-        return new HasherCollection(new IncrementingHasher(0, 1), new IncrementingHasher(0, 2)).uniqueIndices(Shape.fromKM(17, 72));\n+    protected BitCountProducer createProducer() {\n+        // hasher has collisions and wraps\n+        return BitCountProducer.from(new IncrementingHasher(4, 8).indices(Shape.fromKM(17, 72)));\n     }\n \n     @Override\n-    protected IndexProducer createEmptyProducer() {\n-        return new HasherCollection().uniqueIndices(Shape.fromKM(17, 72));\n+    protected BitCountProducer createEmptyProducer() {\n+        return BitCountProducer.from(NullHasher.INSTANCE.indices(Shape.fromKM(17, 72)));\n     }\n \n     @Override\n-    protected int getBehaviour() {\n-        // Note:\n-        // Do not return FOR_EACH_DISTINCT | AS_ARRAY_DISTINCT.\n-        // Despite this being a unique index test, the HasherCollection will return a unique\n-        // index from each hasher. The result is there may still be duplicates.\n+    protected int getAsIndexArrayBehaviour() {\n+        // Hasher allows duplicates and may be unordered\n         return 0;\n     }\n+\n+    @Override\n+    protected int[] getExpectedIndices() {\n+        return new int[]{4, 12, 20, 28, 36, 44, 52, 60, 68, 4, 12, 20, 28, 36, 44, 52, 60};\n+    }\n+\n+    @Override\n+    protected int[][] getExpectedBitCount() {\n+        return new int[][]{{4, 2}, {12, 2}, {20, 2}, {28, 2}, {36, 2}, {44, 2}, {52, 2}, {60, 2}, {68, 1}};\n+    }\n }\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/BitCountProducerFromIndexProducerTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/BitCountProducerFromIndexProducerTest.java\ndeleted file mode 100644\nindex 8458dddfa3..0000000000\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/BitCountProducerFromIndexProducerTest.java\n+++ /dev/null\n@@ -1,64 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.commons.collections4.bloomfilter;\n-\n-import static org.junit.Assert.assertEquals;\n-\n-import java.util.HashMap;\n-import java.util.Map;\n-import org.junit.jupiter.api.Disabled;\n-import org.junit.jupiter.api.Test;\n-\n-public class BitCountProducerFromIndexProducerTest extends AbstractBitCountProducerTest {\n-\n-    @Override\n-    protected BitCountProducer createProducer() {\n-        return BitCountProducer.from(IndexProducer.fromIndexArray(new int[] { 0, 63, 1, 1, 64, 127, 128 }));\n-    }\n-\n-    @Override\n-    protected BitCountProducer createEmptyProducer() {\n-        return BitCountProducer.from(IndexProducer.fromIndexArray(new int[0]));\n-    }\n-\n-    @Override\n-    protected int getBehaviour() {\n-        // The default method streams a BitSet so is distinct and ordered.\n-        return AS_ARRAY_DISTINCT | AS_ARRAY_ORDERED;\n-    }\n-\n-    @Test\n-    @Disabled(\"Current behaviour will return the same index twice, each with a count of 1\")\n-    public final void testFromIndexProducer() {\n-\n-        BitCountProducer producer = createProducer();\n-        Map<Integer, Integer> m = new HashMap<>();\n-\n-        producer.forEachCount((i, v) -> {\n-            m.put(i, v);\n-            return true;\n-        });\n-\n-        assertEquals(6, m.size());\n-        assertEquals(Integer.valueOf(1), m.get(0));\n-        assertEquals(Integer.valueOf(2), m.get(1));\n-        assertEquals(Integer.valueOf(1), m.get(63));\n-        assertEquals(Integer.valueOf(1), m.get(64));\n-        assertEquals(Integer.valueOf(1), m.get(127));\n-        assertEquals(Integer.valueOf(1), m.get(128));\n-    }\n-}\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromHasherCollectionTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/BitCountProducerFromIntArrayTest.java\nsimilarity index 64%\nrename from src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromHasherCollectionTest.java\nrename to src/test/java/org/apache/commons/collections4/bloomfilter/BitCountProducerFromIntArrayTest.java\nindex 044e727b24..d0a598a17d 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromHasherCollectionTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/BitCountProducerFromIntArrayTest.java\n@@ -16,21 +16,27 @@\n  */\n package org.apache.commons.collections4.bloomfilter;\n \n-public class IndexProducerFromHasherCollectionTest extends AbstractIndexProducerTest {\n+public class BitCountProducerFromIntArrayTest extends AbstractBitCountProducerTest {\n+\n+    int[] data = {6, 8, 1, 2, 4, 4, 5};\n \n     @Override\n-    protected IndexProducer createProducer() {\n-        return new HasherCollection(new IncrementingHasher(0, 1), new IncrementingHasher(0, 2)).indices(Shape.fromKM(17, 72));\n+    protected BitCountProducer createEmptyProducer() {\n+        return BitCountProducer.from(IndexProducer.fromIndexArray(new int[0]));\n     }\n \n     @Override\n-    protected IndexProducer createEmptyProducer() {\n-        return new HasherCollection().indices(Shape.fromKM(17, 72));\n+    protected BitCountProducer createProducer() {\n+        return BitCountProducer.from(IndexProducer.fromIndexArray(data));\n     }\n \n     @Override\n-    protected int getBehaviour() {\n-        // HasherCollection allows duplicates and may be unordered\n+    protected int getAsIndexArrayBehaviour() {\n         return 0;\n     }\n+\n+    @Override\n+    protected int[] getExpectedIndices() {\n+        return data;\n+    }\n }\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromSimpleBloomFilterTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/BitCountProducerFromSimpleBloomFilterTest.java\nsimilarity index 65%\nrename from src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromSimpleBloomFilterTest.java\nrename to src/test/java/org/apache/commons/collections4/bloomfilter/BitCountProducerFromSimpleBloomFilterTest.java\nindex e8da24a8da..f4bc102cb5 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromSimpleBloomFilterTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/BitCountProducerFromSimpleBloomFilterTest.java\n@@ -16,26 +16,31 @@\n  */\n package org.apache.commons.collections4.bloomfilter;\n \n-public class IndexProducerFromSimpleBloomFilterTest extends AbstractIndexProducerTest {\n+public class BitCountProducerFromSimpleBloomFilterTest extends AbstractBitCountProducerTest {\n \n     protected Shape shape = Shape.fromKM(17, 72);\n \n     @Override\n-    protected IndexProducer createProducer() {\n-        Hasher hasher = new IncrementingHasher(0, 1);\n+    protected BitCountProducer createProducer() {\n+        Hasher hasher = new IncrementingHasher(3, 2);\n         BloomFilter bf = new SimpleBloomFilter(shape);\n         bf.merge(hasher);\n-        return bf;\n+        return BitCountProducer.from(bf);\n     }\n \n     @Override\n-    protected IndexProducer createEmptyProducer() {\n-        return new SimpleBloomFilter(shape);\n+    protected BitCountProducer createEmptyProducer() {\n+        return BitCountProducer.from(new SimpleBloomFilter(shape));\n     }\n \n     @Override\n-    protected int getBehaviour() {\n+    protected int getAsIndexArrayBehaviour() {\n         // BloomFilter based on a bit map array will be distinct and ordered\n-        return FOR_EACH_DISTINCT | FOR_EACH_ORDERED | AS_ARRAY_DISTINCT | AS_ARRAY_ORDERED;\n+        return DISTINCT | ORDERED;\n+    }\n+\n+    @Override\n+    protected int[] getExpectedIndices() {\n+        return new int[]{3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35};\n     }\n }\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromSparseBloomFilterTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/BitCountProducerFromSparseBloomFilterTest.java\nsimilarity index 63%\nrename from src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromSparseBloomFilterTest.java\nrename to src/test/java/org/apache/commons/collections4/bloomfilter/BitCountProducerFromSparseBloomFilterTest.java\nindex 59823f329e..2e26cbc042 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromSparseBloomFilterTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/BitCountProducerFromSparseBloomFilterTest.java\n@@ -16,29 +16,33 @@\n  */\n package org.apache.commons.collections4.bloomfilter;\n \n-public class IndexProducerFromSparseBloomFilterTest extends AbstractIndexProducerTest {\n+public class BitCountProducerFromSparseBloomFilterTest extends AbstractBitCountProducerTest {\n \n     protected Shape shape = Shape.fromKM(17, 72);\n \n     @Override\n-    protected IndexProducer createProducer() {\n-        Hasher hasher = new IncrementingHasher(0, 1);\n+    protected BitCountProducer createProducer() {\n+        Hasher hasher = new IncrementingHasher(4, 7);\n         BloomFilter bf = new SparseBloomFilter(shape);\n         bf.merge(hasher);\n-        return bf;\n-\n+        return BitCountProducer.from(bf);\n     }\n \n     @Override\n-    protected IndexProducer createEmptyProducer() {\n-        return new SparseBloomFilter(shape);\n+    protected BitCountProducer createEmptyProducer() {\n+        return BitCountProducer.from(new SparseBloomFilter(shape));\n     }\n \n     @Override\n-    protected int getBehaviour() {\n+    protected int getAsIndexArrayBehaviour() {\n         // A sparse BloomFilter will be distinct but it may not be ordered.\n-        // Currently the ordered behaviour is asserted as the implementation uses\n+        // Currently the ordered behavior is asserted as the implementation uses\n         // an ordered TreeSet. This may change in the future.\n-        return FOR_EACH_DISTINCT | FOR_EACH_ORDERED | AS_ARRAY_DISTINCT | AS_ARRAY_ORDERED;\n+        return DISTINCT | ORDERED;\n+    }\n+\n+    @Override\n+    protected int[] getExpectedIndices() {\n+        return new int[]{2, 4, 9, 11, 16, 18, 23, 25, 30, 32, 37, 39, 44, 46, 53, 60, 67};\n     }\n }\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/BitCountProducerFromUniqueHasherCollectionTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/BitCountProducerFromUniqueHasherCollectionTest.java\nnew file mode 100644\nindex 0000000000..9602e33240\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/BitCountProducerFromUniqueHasherCollectionTest.java\n@@ -0,0 +1,49 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.bloomfilter;\n+\n+public class BitCountProducerFromUniqueHasherCollectionTest extends AbstractBitCountProducerTest {\n+\n+    @Override\n+    protected BitCountProducer createProducer() {\n+        // hasher has collisions and wraps\n+        return BitCountProducer.from(new HasherCollection(\n+                new IncrementingHasher(1, 1),\n+                new IncrementingHasher(7, 12)).uniqueIndices(Shape.fromKM(5, 10)));\n+    }\n+\n+    @Override\n+    protected BitCountProducer createEmptyProducer() {\n+        return BitCountProducer.from(NullHasher.INSTANCE.uniqueIndices(Shape.fromKM(5, 10)));\n+    }\n+\n+    @Override\n+    protected int getAsIndexArrayBehaviour() {\n+        // HasherCollection uniqueIndices() allows duplicates and may be unordered\n+        return 0;\n+    }\n+\n+    @Override\n+    protected int[] getExpectedIndices() {\n+        return new int[]{1, 2, 3, 4, 5, 7, 9, 1, 3, 5};\n+    }\n+\n+    @Override\n+    protected int[][] getExpectedBitCount() {\n+        return new int[][]{{1, 2}, {2, 1}, {3, 2}, {4, 1}, {5, 2}, {7, 1}, {9, 1}};\n+    }\n+}\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromArrayCountingBloomFilterTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/BitCountProducerFromUniqueHasherTest.java\nsimilarity index 58%\nrename from src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromArrayCountingBloomFilterTest.java\nrename to src/test/java/org/apache/commons/collections4/bloomfilter/BitCountProducerFromUniqueHasherTest.java\nindex 4b7cbb8c84..0910249b67 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromArrayCountingBloomFilterTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/BitCountProducerFromUniqueHasherTest.java\n@@ -16,25 +16,27 @@\n  */\n package org.apache.commons.collections4.bloomfilter;\n \n-public class IndexProducerFromArrayCountingBloomFilterTest extends AbstractIndexProducerTest {\n+public class BitCountProducerFromUniqueHasherTest extends AbstractBitCountProducerTest {\n \n-    protected Shape shape = Shape.fromKM(17, 72);\n+    @Override\n+    protected BitCountProducer createProducer() {\n+        // hasher has collisions and wraps\n+        return BitCountProducer.from(new IncrementingHasher(4, 8).uniqueIndices(Shape.fromKM(17, 72)));\n+    }\n \n     @Override\n-    protected IndexProducer createProducer() {\n-        ArrayCountingBloomFilter filter = new ArrayCountingBloomFilter(shape);\n-        Hasher hasher = new IncrementingHasher(0, 1);\n-        filter.merge(hasher);\n-        return filter;\n+    protected BitCountProducer createEmptyProducer() {\n+        return BitCountProducer.from(NullHasher.INSTANCE.indices(Shape.fromKM(17, 72)));\n     }\n \n     @Override\n-    protected IndexProducer createEmptyProducer() {\n-        return new ArrayCountingBloomFilter(shape);\n+    protected int getAsIndexArrayBehaviour() {\n+        // Hasher may be unordered\n+        return DISTINCT;\n     }\n \n     @Override\n-    protected int getBehaviour() {\n-        return FOR_EACH_DISTINCT | FOR_EACH_ORDERED | AS_ARRAY_DISTINCT | AS_ARRAY_ORDERED;\n+    protected int[] getExpectedIndices() {\n+        return new int[]{4, 12, 20, 28, 36, 44, 52, 60, 68};\n     }\n }\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/DefaultBitCountProducerTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/DefaultBitCountProducerTest.java\nnew file mode 100644\nindex 0000000000..0dac74e038\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/DefaultBitCountProducerTest.java\n@@ -0,0 +1,71 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.bloomfilter;\n+\n+public class DefaultBitCountProducerTest extends AbstractBitCountProducerTest {\n+\n+    /** Make forEachIndex unordered and contain duplicates. */\n+    private int[] values = {10, 1, 10, 1};\n+\n+    @Override\n+    protected int[] getExpectedIndices() {\n+        return values;\n+    }\n+\n+    @Override\n+    protected BitCountProducer createProducer() {\n+        return new BitCountProducer() {\n+            @Override\n+            public boolean forEachCount(BitCountConsumer consumer) {\n+                for (int i : values) {\n+                    if (!consumer.test(i, 1)) {\n+                        return false;\n+                    }\n+                }\n+                return true;\n+            }\n+        };\n+    }\n+\n+    @Override\n+    protected BitCountProducer createEmptyProducer() {\n+        return new BitCountProducer() {\n+            @Override\n+            public boolean forEachCount(BitCountConsumer consumer) {\n+                return true;\n+            }\n+        };\n+    }\n+\n+    @Override\n+    protected int getAsIndexArrayBehaviour() {\n+        // The default method streams a BitSet so is distinct and ordered.\n+        return ORDERED | DISTINCT;\n+    }\n+\n+    @Override\n+    protected int getForEachIndexBehaviour() {\n+        // the default method has the same behaviour as the forEachCount() method.\n+        return 0;\n+    }\n+\n+    @Override\n+    protected int getForEachCountBehaviour() {\n+     // the implemented mehtod returns unordered duplicates.\n+        return 0;\n+    }\n+}\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/DefaultIndexProducerTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/DefaultIndexProducerTest.java\nindex dc0ca7f84d..ceac5bebdb 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/DefaultIndexProducerTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/DefaultIndexProducerTest.java\n@@ -20,6 +20,7 @@\n \n import java.util.Arrays;\n import java.util.BitSet;\n+import java.util.Objects;\n import java.util.concurrent.ThreadLocalRandom;\n import java.util.function.IntPredicate;\n \n@@ -27,28 +28,51 @@\n \n public class DefaultIndexProducerTest extends AbstractIndexProducerTest {\n \n-    private int[] values = generateIntArray(10, 512);\n+    /** Make forEachIndex unordered and contain duplicates. */\n+    private int[] values = {10, 1, 10, 1};\n+\n+    @Override\n+    protected int[] getExpectedIndices() {\n+        return values;\n+    }\n \n     @Override\n     protected IndexProducer createProducer() {\n-        return IndexProducer.fromIndexArray(values);\n+        return new IndexProducer() {\n+            @Override\n+            public boolean forEachIndex(IntPredicate predicate) {\n+                Objects.requireNonNull(predicate);\n+                for (int i : values) {\n+                    if (!predicate.test(i)) {\n+                        return false;\n+                    }\n+                }\n+                return true;\n+            }\n+        };\n     }\n \n     @Override\n     protected IndexProducer createEmptyProducer() {\n         return new IndexProducer() {\n-\n             @Override\n             public boolean forEachIndex(IntPredicate predicate) {\n+                Objects.requireNonNull(predicate);\n                 return true;\n             }\n         };\n     }\n \n     @Override\n-    protected int getBehaviour() {\n+    protected int getAsIndexArrayBehaviour() {\n         // The default method streams a BitSet so is distinct and ordered.\n-        return AS_ARRAY_DISTINCT | AS_ARRAY_ORDERED;\n+        return DISTINCT | ORDERED;\n+    }\n+\n+    @Override\n+    protected int getForEachIndexBehaviour() {\n+        // the forEachIndex implementation returns unordered duplicates.\n+        return 0;\n     }\n \n     /**\n@@ -99,7 +123,7 @@ public void testFromIndexArray() {\n         for (int i = 0; i < 5; i++) {\n             int[] expected = generateIntArray(10, 256);\n             IndexProducer ip = IndexProducer.fromIndexArray(expected);\n-            assertArrayEquals(unique(expected), ip.asIndexArray());\n+            assertArrayEquals(expected, ip.asIndexArray());\n         }\n     }\n }\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/EnhancedDoubleHasherTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/EnhancedDoubleHasherTest.java\nindex 49afb7b280..b3f7069f49 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/EnhancedDoubleHasherTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/EnhancedDoubleHasherTest.java\n@@ -24,6 +24,7 @@\n  * Tests the {@link EnhancedDoubleHasher}.\n  */\n public class EnhancedDoubleHasherTest extends AbstractHasherTest {\n+    int[] expected = {1, 0, 71, 71, 1, 6, 15, 29, 49, 4, 39, 11, 65, 58, 63, 9, 41};\n \n     @Override\n     protected Hasher createHasher() {\n@@ -36,7 +37,12 @@ protected Hasher createEmptyHasher() {\n     }\n \n     @Override\n-    protected int getBehaviour() {\n+    protected int[] getExpectedIndices() {\n+        return expected;\n+    }\n+\n+    @Override\n+    protected int getAsIndexArrayBehaviour() {\n         // Allows duplicates and may be unordered\n         return 0;\n     }\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/HasherCollectionTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/HasherCollectionTest.java\nindex 894115c596..70e82446a6 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/HasherCollectionTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/HasherCollectionTest.java\n@@ -17,11 +17,9 @@\n package org.apache.commons.collections4.bloomfilter;\n \n import static org.junit.jupiter.api.Assertions.assertEquals;\n-import static org.junit.jupiter.api.Assertions.assertTrue;\n \n-import java.util.ArrayList;\n import java.util.Arrays;\n-import java.util.List;\n+import java.util.stream.IntStream;\n \n import org.junit.jupiter.api.Assertions;\n import org.junit.jupiter.api.Test;\n@@ -29,11 +27,18 @@\n /**\n  * Tests the {@link HasherCollection}.\n  */\n-public class HasherCollectionTest extends AbstractHasherTest {\n \n+public class HasherCollectionTest extends AbstractHasherTest {\n     @Override\n     protected HasherCollection createHasher() {\n-        return new HasherCollection(new IncrementingHasher(1, 1), new IncrementingHasher(2, 2));\n+        return new HasherCollection(new IncrementingHasher(1, 1),\n+                new IncrementingHasher(2, 2));\n+    }\n+\n+    @Override\n+    protected int[] getExpectedIndices() {\n+        return new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 2, 4, 6, 8, 10, 12, 14, 16, 18,\n+            20, 22, 24, 26, 28, 30, 32, 34 };\n     }\n \n     @Override\n@@ -42,7 +47,7 @@ protected HasherCollection createEmptyHasher() {\n     }\n \n     @Override\n-    protected int getBehaviour() {\n+    protected int getAsIndexArrayBehaviour() {\n         // Allows duplicates and may be unordered\n         return 0;\n     }\n@@ -52,46 +57,6 @@ protected int getHasherSize(Hasher hasher) {\n         return ((HasherCollection) hasher).getHashers().size();\n     }\n \n-    protected void nestedTest(HasherCollectionTest nestedTest) {\n-        nestedTest.testForEachIndex();\n-        nestedTest.testEmptyProducer();\n-        nestedTest.testConsistency();\n-        nestedTest.testBehaviourAsIndexArray();\n-        nestedTest.testBehaviourForEach();\n-        nestedTest.testForEachIndexEarlyExit();\n-        nestedTest.testAdd();\n-    }\n-\n-    @Test\n-    public void testCollectionConstructor() {\n-        List<Hasher> lst = Arrays.asList(new IncrementingHasher(3, 2), new IncrementingHasher(4, 2));\n-        HasherCollectionTest nestedTest = new HasherCollectionTest() {\n-            @Override\n-            protected HasherCollection createHasher() {\n-                return new HasherCollection(lst);\n-            }\n-\n-            @Override\n-            protected HasherCollection createEmptyHasher() {\n-                return new HasherCollection();\n-            }\n-        };\n-        nestedTest(nestedTest);\n-\n-        nestedTest = new HasherCollectionTest() {\n-            @Override\n-            protected HasherCollection createHasher() {\n-                return new HasherCollection(new IncrementingHasher(3, 2), new IncrementingHasher(4, 2));\n-            }\n-\n-            @Override\n-            protected HasherCollection createEmptyHasher() {\n-                return new HasherCollection();\n-            }\n-        };\n-        nestedTest(nestedTest);\n-    }\n-\n     @Test\n     public void testAdd() {\n         HasherCollection hasher = createHasher();\n@@ -102,27 +67,6 @@ public void testAdd() {\n         assertEquals(5, hasher.getHashers().size());\n     }\n \n-    @Override\n-    public void testUniqueIndex() {\n-        // create a hasher that produces duplicates with the specified shape.\n-        // this setup produces 5, 17, 29, 41, 53, 65 two times\n-        Shape shape = Shape.fromKM(12, 72);\n-        Hasher h1 = new IncrementingHasher(5, 12);\n-        HasherCollection hasher = createEmptyHasher();\n-        hasher.add(h1);\n-        hasher.add(h1);\n-        List<Integer> lst = new ArrayList<>();\n-        for (int i : new int[] { 5, 17, 29, 41, 53, 65 }) {\n-            lst.add(i);\n-            lst.add(i);\n-        }\n-\n-        assertTrue(hasher.uniqueIndices(shape).forEachIndex(i -> {\n-            return lst.remove(Integer.valueOf(i));\n-        }), \"unable to remove value\");\n-        assertEquals(0, lst.size());\n-    }\n-\n     @Test\n     void testHasherCollection() {\n         Hasher h1 = new IncrementingHasher(13, 4678);\n@@ -143,4 +87,17 @@ void testHasherCollection() {\n         Assertions.assertTrue(bf.remove(hc2));\n         Assertions.assertEquals(0, bf.cardinality());\n     }\n+\n+    @Test\n+    public void testAbsoluteUniqueIndices() {\n+        int[] actual = new HasherCollection(\n+            new IncrementingHasher(1, 1),\n+            new IncrementingHasher(10, 1)\n+        ).absoluteUniqueIndices(Shape.fromKM(5, 1000)).asIndexArray();\n+        int[] expected = IntStream.concat(\n+                IntStream.range(1, 1 + 5),\n+                IntStream.range(10, 10 + 5)\n+            ).toArray();\n+        Assertions.assertArrayEquals(expected, actual);\n+    }\n }\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromBitmapProducerTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromBitmapProducerTest.java\nindex e844183efa..5eeaaf76b4 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromBitmapProducerTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromBitmapProducerTest.java\n@@ -50,9 +50,14 @@ protected IndexProducer createProducer() {\n     }\n \n     @Override\n-    protected int getBehaviour() {\n+    protected int[] getExpectedIndices() {\n+        return new int[]{0, 65, 128, 129};\n+    }\n+\n+    @Override\n+    protected int getAsIndexArrayBehaviour() {\n         // Bit maps will be distinct. Conversion to indices should be ordered.\n-        return FOR_EACH_DISTINCT | FOR_EACH_ORDERED | AS_ARRAY_DISTINCT | AS_ARRAY_ORDERED;\n+        return DISTINCT | ORDERED;\n     }\n \n     @Test\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromIntArrayTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromIntArrayTest.java\ndeleted file mode 100644\nindex 2ad9ee5c1e..0000000000\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromIntArrayTest.java\n+++ /dev/null\n@@ -1,36 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.commons.collections4.bloomfilter;\n-\n-public class IndexProducerFromIntArrayTest extends AbstractIndexProducerTest {\n-\n-    @Override\n-    protected IndexProducer createEmptyProducer() {\n-        return IndexProducer.fromIndexArray(new int[0]);\n-    }\n-\n-    @Override\n-    protected IndexProducer createProducer() {\n-        return IndexProducer.fromIndexArray(new int[] { 6, 8, 1, 2, 4, 4, 5 });\n-    }\n-\n-    @Override\n-    protected int getBehaviour() {\n-        // Delegates to the default asIndexArray which is distinct and ordered\n-        return AS_ARRAY_DISTINCT | AS_ARRAY_ORDERED;\n-    }\n-}\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/UniqueIndexProducerFromHasherTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/UniqueIndexProducerFromHasherTest.java\ndeleted file mode 100644\nindex 94d13e4d92..0000000000\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/UniqueIndexProducerFromHasherTest.java\n+++ /dev/null\n@@ -1,36 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.commons.collections4.bloomfilter;\n-\n-public class UniqueIndexProducerFromHasherTest extends AbstractIndexProducerTest {\n-\n-    @Override\n-    protected IndexProducer createProducer() {\n-        return new IncrementingHasher(0, 1).uniqueIndices(Shape.fromKM(17, 72));\n-    }\n-\n-    @Override\n-    protected IndexProducer createEmptyProducer() {\n-        return NullHasher.INSTANCE.indices(Shape.fromKM(17, 72));\n-    }\n-\n-    @Override\n-    protected int getBehaviour() {\n-        // Should be unique but may be unordered\n-        return FOR_EACH_DISTINCT | AS_ARRAY_DISTINCT;\n-    }\n-}\n",
  "problem_statement" : "[Collections-834][bloom filters] bit count producer operation is not clearly defined\n\nfix for COLLECTIONS-384\r\n\r\nDocument bit count producer operation in the BitCountProducer.java file.\r\n\r\nAdd unit tests for all BitCountProducers.",
  "hints_text" : null,
  "created_at" : "Sun Sep 11 00:06:16 CEST 2022",
  "version" : null,
  "FAIL_TO_PASS" : [ "BitCountProducerFromArrayCountingBloomFilterTest", "AbstractHasherTest", "AbstractIndexProducerTest", "IndexProducerFromSimpleBloomFilterTest", "IndexProducerFromBitmapProducerTest", "DefaultIndexProducerTest", "BitCountProducerFromAbsoluteUniqueHasherCollectionTest", "BitCountProducerFromSimpleBloomFilterTest", "IndexProducerFromHasherTest", "IndexProducerFromSparseBloomFilterTest", "UniqueIndexProducerFromHasherTest", "BitCountProducerFromSparseBloomFilterTest", "BitCountProducerFromUniqueHasherTest", "DefaultBitCountProducerTest", "IndexProducerFromHasherCollectionTest", "IndexProducerFromArrayCountingBloomFilterTest", "HasherCollectionTest", "UniqueIndexProducerFromHasherCollectionTest", "IndexProducerFromIntArrayTest", "AbstractBitCountProducerTest", "BitCountProducerFromUniqueHasherCollectionTest", "EnhancedDoubleHasherTest", "BitCountProducerFromDefaultIndexProducerTest", "BitCountProducerFromHasherCollectionTest", "BitCountProducerFromHasherTest", "BitCountProducerFromIndexProducerTest", "BitCountProducerFromIntArrayTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=BitCountProducerFromArrayCountingBloomFilterTest,AbstractHasherTest,AbstractIndexProducerTest,IndexProducerFromSimpleBloomFilterTest,IndexProducerFromBitmapProducerTest,DefaultIndexProducerTest,BitCountProducerFromAbsoluteUniqueHasherCollectionTest,BitCountProducerFromSimpleBloomFilterTest,IndexProducerFromHasherTest,IndexProducerFromSparseBloomFilterTest,UniqueIndexProducerFromHasherTest,BitCountProducerFromSparseBloomFilterTest,BitCountProducerFromUniqueHasherTest,DefaultBitCountProducerTest,IndexProducerFromHasherCollectionTest,IndexProducerFromArrayCountingBloomFilterTest,HasherCollectionTest,UniqueIndexProducerFromHasherCollectionTest,IndexProducerFromIntArrayTest,AbstractBitCountProducerTest,BitCountProducerFromUniqueHasherCollectionTest,EnhancedDoubleHasherTest,BitCountProducerFromDefaultIndexProducerTest,BitCountProducerFromHasherCollectionTest,BitCountProducerFromHasherTest,BitCountProducerFromIndexProducerTest,BitCountProducerFromIntArrayTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 335,
  "metadata" : null
}, {
  "instance_id" : "apache-commons-collections-PR-329",
  "repo" : "apache/commons-collections",
  "base_commit" : "df091173cdfabd5ecc852f47c978ee9bcb2b7059",
  "patch" : "diff --git a/src/main/java/org/apache/commons/collections4/bloomfilter/ArrayCountingBloomFilter.java b/src/main/java/org/apache/commons/collections4/bloomfilter/ArrayCountingBloomFilter.java\nindex a46d7665f7..4202f6d860 100644\n--- a/src/main/java/org/apache/commons/collections4/bloomfilter/ArrayCountingBloomFilter.java\n+++ b/src/main/java/org/apache/commons/collections4/bloomfilter/ArrayCountingBloomFilter.java\n@@ -110,8 +110,8 @@ public ArrayCountingBloomFilter copy() {\n     }\n \n     @Override\n-    public boolean isSparse() {\n-        return true;\n+    public int characteristics() {\n+        return SPARSE;\n     }\n \n     @Override\ndiff --git a/src/main/java/org/apache/commons/collections4/bloomfilter/BloomFilter.java b/src/main/java/org/apache/commons/collections4/bloomfilter/BloomFilter.java\nindex e13260b996..58ed6bcb5c 100644\n--- a/src/main/java/org/apache/commons/collections4/bloomfilter/BloomFilter.java\n+++ b/src/main/java/org/apache/commons/collections4/bloomfilter/BloomFilter.java\n@@ -29,6 +29,15 @@\n  */\n public interface BloomFilter extends IndexProducer, BitMapProducer {\n \n+    /**\n+     * The sparse characteristic used to determine the best method for matching.\n+     * <p>For `sparse` implementations\n+     * the {@code forEachIndex(IntConsumer consumer)} method is more efficient.  For non `sparse` implementations\n+     * the {@code forEachBitMap(LongConsumer consumer)} is more efficient.  Implementers should determine if it is easier\n+     * for the implementation to produce indexes of bit map blocks.</p>\n+     */\n+    int SPARSE = 0x1;\n+\n     /**\n      * Creates a new instance of the BloomFilter with the same properties as the current one.\n      * @return a copy of this BloomFilter\n@@ -38,17 +47,12 @@ public interface BloomFilter extends IndexProducer, BitMapProducer {\n     // Query Operations\n \n     /**\n-     * This method is used to determine the best method for matching.\n-     *\n-     * <p>For `sparse` implementations\n-     * the {@code forEachIndex(IntConsumer consumer)} method is more efficient.  For non `sparse` implementations\n-     * the {@code forEachBitMap(LongConsumer consumer)} is more efficient.  Implementers should determine if it is easier\n-     * for the implementation to produce indexes of bit map blocks.</p>\n-     *\n-     * @return {@code true} if the implementation is sparse {@code false} otherwise.\n-     * @see BitMap\n+     * Returns the characteristics of the filter.\n+     * <p>\n+     * Characteristics are defined as bits within the characteristics integer.\n+     * @return the characteristics for this bloom filter.\n      */\n-    boolean isSparse();\n+    int characteristics();\n \n     /**\n      * Gets the shape that was used when the filter was built.\n@@ -69,7 +73,7 @@ public interface BloomFilter extends IndexProducer, BitMapProducer {\n      */\n     default boolean contains(BloomFilter other) {\n         Objects.requireNonNull(other, \"other\");\n-        return isSparse() ? contains((IndexProducer) other) : contains((BitMapProducer) other);\n+        return (characteristics() & SPARSE) != 0 ? contains((IndexProducer) other) : contains((BitMapProducer) other);\n     }\n \n     /**\n@@ -143,8 +147,8 @@ default boolean contains(BitMapProducer bitMapProducer) {\n     default boolean merge(Hasher hasher) {\n         Objects.requireNonNull(hasher, \"hasher\");\n         Shape shape = getShape();\n-        // create the bloomfilter that is most likely to merge quickly with this one\n-        BloomFilter result = isSparse() ? new SparseBloomFilter(shape, hasher) : new SimpleBloomFilter(shape, hasher);\n+        // create the Bloom filter that is most likely to merge quickly with this one\n+        BloomFilter result = (characteristics() & SPARSE) != 0 ? new SparseBloomFilter(shape, hasher) : new SimpleBloomFilter(shape, hasher);\n         return merge(result);\n     }\n \ndiff --git a/src/main/java/org/apache/commons/collections4/bloomfilter/SimpleBloomFilter.java b/src/main/java/org/apache/commons/collections4/bloomfilter/SimpleBloomFilter.java\nindex b78ca999af..c351f40c19 100644\n--- a/src/main/java/org/apache/commons/collections4/bloomfilter/SimpleBloomFilter.java\n+++ b/src/main/java/org/apache/commons/collections4/bloomfilter/SimpleBloomFilter.java\n@@ -65,7 +65,7 @@ public SimpleBloomFilter(BloomFilter other) {\n         this.shape = other.getShape();\n         this.bitMap = new long[BitMap.numberOfBitMaps(shape.getNumberOfBits())];\n         this.cardinality = 0;\n-        if (other.isSparse()) {\n+        if ((other.characteristics() & SPARSE) != 0) {\n             merge((IndexProducer) other);\n         } else {\n             merge((BitMapProducer) other);\n@@ -194,7 +194,7 @@ public boolean merge(Hasher hasher) {\n     @Override\n     public boolean merge(BloomFilter other) {\n         Objects.requireNonNull(other, \"other\");\n-        if (other.isSparse()) {\n+        if ((other.characteristics() & SPARSE) != 0) {\n             merge((IndexProducer) other);\n         } else {\n             merge((BitMapProducer) other);\n@@ -208,8 +208,8 @@ public Shape getShape() {\n     }\n \n     @Override\n-    public boolean isSparse() {\n-        return false;\n+    public int characteristics() {\n+        return 0;\n     }\n \n     @Override\ndiff --git a/src/main/java/org/apache/commons/collections4/bloomfilter/SparseBloomFilter.java b/src/main/java/org/apache/commons/collections4/bloomfilter/SparseBloomFilter.java\nindex 794e3bcdaa..9cfa034eb2 100644\n--- a/src/main/java/org/apache/commons/collections4/bloomfilter/SparseBloomFilter.java\n+++ b/src/main/java/org/apache/commons/collections4/bloomfilter/SparseBloomFilter.java\n@@ -58,7 +58,7 @@ public SparseBloomFilter(BloomFilter other) {\n         Objects.requireNonNull(other, \"other\");\n         this.shape = other.getShape();\n         this.indices = new TreeSet<>();\n-        if (other.isSparse()) {\n+        if ((other.characteristics() & SPARSE) != 0) {\n             merge((IndexProducer) other);\n         } else {\n             merge(IndexProducer.fromBitMapProducer(other));\n@@ -169,7 +169,7 @@ public boolean merge(Hasher hasher) {\n     @Override\n     public boolean merge(BloomFilter other) {\n         Objects.requireNonNull(other, \"other\");\n-        IndexProducer producer = other.isSparse() ? (IndexProducer) other : IndexProducer.fromBitMapProducer(other);\n+        IndexProducer producer = (other.characteristics() & SPARSE) != 0 ? (IndexProducer) other : IndexProducer.fromBitMapProducer(other);\n         merge(producer);\n         return true;\n     }\n@@ -180,8 +180,8 @@ public Shape getShape() {\n     }\n \n     @Override\n-    public boolean isSparse() {\n-        return true;\n+    public int characteristics() {\n+        return SPARSE;\n     }\n \n     @Override\n",
  "test_patch" : "diff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/DefaultBloomFilterTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/DefaultBloomFilterTest.java\nindex 26862bb194..ff258ae806 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/DefaultBloomFilterTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/DefaultBloomFilterTest.java\n@@ -186,8 +186,8 @@ static class SparseDefaultBloomFilter extends AbstractDefaultBloomFilter {\n         }\n \n         @Override\n-        public boolean isSparse() {\n-            return true;\n+        public int characteristics() {\n+            return SPARSE;\n         }\n \n         @Override\n@@ -217,8 +217,8 @@ static class NonSparseDefaultBloomFilter extends AbstractDefaultBloomFilter {\n         }\n \n         @Override\n-        public boolean isSparse() {\n-            return false;\n+        public int characteristics() {\n+            return 0;\n         }\n \n         @Override\n",
  "problem_statement" : "Collections-818: convert to characteristics flag\n\nconverted BloomFilter.isSparse() to BloomFilter.characteristics() and defiend SPARSE constant.\r\n\r\nfixes Collections-818",
  "hints_text" : null,
  "created_at" : "Tue Aug 09 09:45:38 CEST 2022",
  "version" : null,
  "FAIL_TO_PASS" : [ "DefaultBloomFilterTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=DefaultBloomFilterTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 329,
  "metadata" : null
}, {
  "instance_id" : "apache-commons-collections-PR-323",
  "repo" : "apache/commons-collections",
  "base_commit" : "304a1bf3f37abb1740e5a1a378b69aa8bd70acfe",
  "patch" : "diff --git a/RELEASE-NOTES.txt b/RELEASE-NOTES.txt\nindex 129d96fcfd..bc2f8efb5a 100644\n--- a/RELEASE-NOTES.txt\n+++ b/RELEASE-NOTES.txt\n@@ -90,7 +90,7 @@ o COLLECTIONS-660:  Uncomment test in AbstractMapTest regarding LRUMap equals.\n o COLLECTIONS-656:  Fix site build on Java 8. \n o COLLECTIONS-653:  Update Javadoc to Build on Java 1.8. \n o COLLECTIONS-606:  Build status, Coverage status and Maven central weren't in README.md Thanks to Vamsi Kavuri. \n-o COLLECTIONS-594:  Web site spelling error: MultiValuedMapeList. Thanks to Javen O'Neal. \n+o COLLECTIONS-594:  Website spelling error: MultiValuedMapList. Thanks to Javen O'Neal.\n o COLLECTIONS-597:  Correction of Javadoc for org.apache.commons.collections4.functors.CatchAndRethrowClosure. Thanks to Enrique. \n o COLLECTIONS-678:  The verification of unsupported iterator methods is not complete. Thanks to Oscar Luis Vera Pérez. \n o COLLECTIONS-673:  ListUtils.partition potential integer overflow. Thanks to John Mark, Stephan Fuhrmann. \n@@ -128,7 +128,7 @@ mechanism. Serialization support for unsafe classes in the functor package has b\n completely removed (classes do not implement the Serializable interface anymore).\n For more details, please refer to COLLECTIONS-580.\n \n-All users are strongly encouraged to updated to this release.\n+All users are strongly encouraged to update to this release.\n \n \n Compatibility\n@@ -295,7 +295,7 @@ By default, serialization support for unsafe classes in the functor package is\n disabled and will result in an exception when either trying to serialize or de-serialize\n an instance of these classes. For more details, please refer to COLLECTIONS-580.\n \n-All users are strongly encouraged to updated to this release.\n+All users are strongly encouraged to update to this release.\n \n \n Changes in this version include:\ndiff --git a/pom.xml b/pom.xml\nindex 6b11f3568a..f04b24ebb4 100644\n--- a/pom.xml\n+++ b/pom.xml\n@@ -581,7 +581,7 @@\n     <commons.release.4.name>commons-collections-${commons.release.4.version}</commons.release.4.name>\n     <!-- Older release has sha256 only -->\n     <commons.release.4.hash>sha256</commons.release.4.hash>\n-    <!-- This is needed uptil CP49 is released -->\n+    <!-- This is needed until CP49 is released -->\n     <commons.release.4.binary.suffix>-bin</commons.release.4.binary.suffix>\n \n     <commons.jira.id>COLLECTIONS</commons.jira.id>\ndiff --git a/src/changes/changes.xml b/src/changes/changes.xml\nindex f30cdb9e6f..170c358186 100644\n--- a/src/changes/changes.xml\n+++ b/src/changes/changes.xml\n@@ -806,7 +806,7 @@ features, this release includes numerous bug fixes.\n       Added method \"CollectionUtils#isEqualCollection(Collection, Collection, Equator)\".\n     </action>\n     <action issue=\"COLLECTIONS-445\" dev=\"tn\" type=\"fix\">\n-      Adapt and/or ignore several unit tests when run on a IBM J9 VM (specification version 1.6.0)\n+      Adapt and/or ignore several unit tests when run on an IBM J9 VM (specification version 1.6.0)\n       due to a faulty \"java.util.TreeMap\" implementation.\n     </action>\n     <action issue=\"COLLECTIONS-444\" dev=\"tn\" type=\"fix\" due-to=\"Thomas Vahrst, John Vasileff\">\n@@ -1023,7 +1023,7 @@ features, this release includes numerous bug fixes.\n     </action>\n     <action issue=\"COLLECTIONS-322\" dev=\"tn\" type=\"add\" due-to=\"Thomas Vahrst\">\n       Added NodeListIterator and convenience methods in IteratorUtils to iterate over\n-      a org.w3c.dom.NodeList.\n+      an org.w3c.dom.NodeList.\n     </action>\n     <action issue=\"COLLECTIONS-320\" dev=\"bayard\" type=\"fix\" due-to=\"sebb\">\n       Improved performance of \"StaticBucketMap#putAll(Map)\" by iterating over the entry set.\n@@ -1060,7 +1060,7 @@ features, this release includes numerous bug fixes.\n       \"SetUniqueList#set(int, Object)\" will now correctly enforce the uniqueness constraint.\n     </action>\n     <action issue=\"COLLECTIONS-303\" dev=\"bayard\" type=\"fix\" due-to=\"Emmanuel Bourg\">\n-      Improved javadoc for \"Unmodifiable*\" classes wrt behavior when the users tries\n+      Improved javadoc for \"Unmodifiable*\" classes wrt behavior when the user tries\n       to modify the collection.\n     </action>\n     <action issue=\"COLLECTIONS-298\" dev=\"bayard\" type=\"update\" due-to=\"Benjamin Bentmann\">\ndiff --git a/src/main/java/org/apache/commons/collections4/ArrayStack.java b/src/main/java/org/apache/commons/collections4/ArrayStack.java\nindex f4b693eaca..4b5dd3069c 100644\n--- a/src/main/java/org/apache/commons/collections4/ArrayStack.java\n+++ b/src/main/java/org/apache/commons/collections4/ArrayStack.java\n@@ -22,7 +22,7 @@\n /**\n  * An implementation of the {@link java.util.Stack} API that is based on an\n  * {@code ArrayList} instead of a {@code Vector}, so it is not\n- * synchronized to protect against multi-threaded access.  The implementation\n+ * synchronized to protect against multithreaded access.  The implementation\n  * is therefore operates faster in environments where you do not need to\n  * worry about multiple thread contention.\n  * <p>\ndiff --git a/src/main/java/org/apache/commons/collections4/Bag.java b/src/main/java/org/apache/commons/collections4/Bag.java\nindex 9495d23c17..24958751e9 100644\n--- a/src/main/java/org/apache/commons/collections4/Bag.java\n+++ b/src/main/java/org/apache/commons/collections4/Bag.java\n@@ -32,7 +32,7 @@\n  * <i>NOTE: This interface violates the {@link Collection} contract.</i>\n  * The behavior specified in many of these methods is <i>not</i> the same\n  * as the behavior specified by {@code Collection}.\n- * The noncompliant methods are clearly marked with \"(Violation)\".\n+ * The non-compliant methods are clearly marked with \"(Violation)\".\n  * Exercise caution when using a bag as a {@code Collection}.\n  * </p>\n  * <p>\ndiff --git a/src/main/java/org/apache/commons/collections4/ClosureUtils.java b/src/main/java/org/apache/commons/collections4/ClosureUtils.java\nindex 86ce902adc..59f7203eef 100644\n--- a/src/main/java/org/apache/commons/collections4/ClosureUtils.java\n+++ b/src/main/java/org/apache/commons/collections4/ClosureUtils.java\n@@ -278,7 +278,7 @@ public static <E> Closure<E> ifClosure(final Predicate<? super E> predicate,\n      * @param predicates  an array of predicates to check, not null\n      * @param closures  an array of closures to call, not null\n      * @return the {@code switch} closure\n-     * @throws NullPointerException if the either array is null\n+     * @throws NullPointerException if either array is null\n      * @throws NullPointerException if any element in the arrays is null\n      * @throws IllegalArgumentException if the arrays have different sizes\n      */\n@@ -303,7 +303,7 @@ public static <E> Closure<E> switchClosure(final Predicate<? super E>[] predicat\n      * @param closures  an array of closures to call, not null\n      * @param defaultClosure  the default to call if no predicate matches\n      * @return the {@code switch} closure\n-     * @throws NullPointerException if the either array is null\n+     * @throws NullPointerException if either array is null\n      * @throws NullPointerException if any element in the arrays is null\n      * @throws IllegalArgumentException if the arrays are different sizes\n      */\ndiff --git a/src/main/java/org/apache/commons/collections4/ComparatorUtils.java b/src/main/java/org/apache/commons/collections4/ComparatorUtils.java\nindex 0fac39bb77..ed89a16bbc 100644\n--- a/src/main/java/org/apache/commons/collections4/ComparatorUtils.java\n+++ b/src/main/java/org/apache/commons/collections4/ComparatorUtils.java\n@@ -202,7 +202,7 @@ public static <I, O> Comparator<I> transformedComparator(Comparator<O> comparato\n     }\n \n     /**\n-     * Returns the smaller of the given objects according to the given\n+     * Returns the smallest of the given objects according to the given\n      * comparator, returning the second object if the comparator\n      * returns equal.\n      *\n@@ -222,7 +222,7 @@ public static <E> E min(final E o1, final E o2, Comparator<E> comparator) {\n     }\n \n     /**\n-     * Returns the larger of the given objects according to the given\n+     * Returns the largest of the given objects according to the given\n      * comparator, returning the second object if the comparator\n      * returns equal.\n      *\ndiff --git a/src/main/java/org/apache/commons/collections4/FluentIterable.java b/src/main/java/org/apache/commons/collections4/FluentIterable.java\nindex 36cbbc464f..0b6d28b81d 100644\n--- a/src/main/java/org/apache/commons/collections4/FluentIterable.java\n+++ b/src/main/java/org/apache/commons/collections4/FluentIterable.java\n@@ -192,7 +192,7 @@ public FluentIterable<E> collate(final Iterable<? extends E> other) {\n     /**\n      * Returns a new FluentIterable whose iterator will traverse the\n      * elements of the current and provided iterable according to the\n-     * ordering defined by an comparator.\n+     * ordering defined by a comparator.\n      * <p>\n      * Example: descending order\n      * <ul>\ndiff --git a/src/main/java/org/apache/commons/collections4/MapUtils.java b/src/main/java/org/apache/commons/collections4/MapUtils.java\nindex 1f45540454..dd9280c017 100644\n--- a/src/main/java/org/apache/commons/collections4/MapUtils.java\n+++ b/src/main/java/org/apache/commons/collections4/MapUtils.java\n@@ -648,7 +648,7 @@ public static <K> float getFloatValue(final Map<? super K, ?> map, final K key,\n     }\n \n     /**\n-     * Gets a Integer from a Map in a null-safe manner.\n+     * Gets an Integer from a Map in a null-safe manner.\n      * <p>\n      * The Integer is obtained from the results of {@link #getNumber(Map,Object)}.\n      * </p>\n@@ -656,7 +656,7 @@ public static <K> float getFloatValue(final Map<? super K, ?> map, final K key,\n      * @param <K> the key type\n      * @param map the map to use\n      * @param key the key to look up\n-     * @return the value in the Map as a Integer, {@code null} if null map input\n+     * @return the value in the Map as an Integer, {@code null} if null map input\n      */\n     public static <K> Integer getInteger(final Map<? super K, ?> map, final K key) {\n         final Number answer = getNumber(map, key);\n@@ -1409,7 +1409,7 @@ public static <K, V> SortedMap<K, V> lazySortedMap(final SortedMap<K, V> map,\n     }\n \n     /**\n-     * Creates a mult-value map backed by the given map which returns collections of type ArrayList.\n+     * Creates a multi-value map backed by the given map which returns collections of type ArrayList.\n      *\n      * @param <K> the key type\n      * @param <V> the value type\n@@ -1953,7 +1953,7 @@ public static void verbosePrint(final PrintStream out, final Object label, final\n      * Implementation providing functionality for {@link #debugPrint} and for {@link #verbosePrint}. This prints the\n      * given map with nice line breaks. If the debug flag is true, it additionally prints the type of the object value.\n      * If the contents of a map include the map itself, then the text <em>(this Map)</em> is printed out. If the\n-     * contents include a parent container of the map, the text <em>(ancestor[i] Map)</em> is printed, where i actually\n+     * contents include a parent container of the map, the text <em>(ancestor[i] Map)</em> is printed, where it actually\n      * indicates the number of levels which must be traversed in the sequential list of ancestors (e.g. father,\n      * grandfather, great-grandfather, etc).\n      *\ndiff --git a/src/main/java/org/apache/commons/collections4/MultiSet.java b/src/main/java/org/apache/commons/collections4/MultiSet.java\nindex 51dd135d71..eef64f0eeb 100644\n--- a/src/main/java/org/apache/commons/collections4/MultiSet.java\n+++ b/src/main/java/org/apache/commons/collections4/MultiSet.java\n@@ -92,7 +92,7 @@ public interface MultiSet<E> extends Collection<E> {\n     /**\n      * Removes one occurrence of the given object from the MultiSet.\n      * <p>\n-     * If the number of occurrences after this operations is reduced\n+     * If the number of occurrences after this operation is reduced\n      * to zero, the object will be removed from the {@link #uniqueSet()}.\n      *\n      * @param object  the object to remove\n@@ -215,7 +215,7 @@ public interface MultiSet<E> extends Collection<E> {\n      * An unmodifiable entry for an element and its occurrence as contained in a MultiSet.\n      * <p>\n      * The {@link MultiSet#entrySet()} method returns a view of the multiset whose elements\n-     * implements this interface.\n+     * implement this interface.\n      *\n      * @param <E>  the element type\n      */\ndiff --git a/src/main/java/org/apache/commons/collections4/MultiValuedMap.java b/src/main/java/org/apache/commons/collections4/MultiValuedMap.java\nindex 61b5dec16a..e26a6d5ae2 100644\n--- a/src/main/java/org/apache/commons/collections4/MultiValuedMap.java\n+++ b/src/main/java/org/apache/commons/collections4/MultiValuedMap.java\n@@ -117,14 +117,14 @@ public interface MultiValuedMap<K, V> {\n     // Modification operations\n \n     /**\n-     * Adds a key-value mapping to this multi-valued map.\n+     * Adds a key-value mapping to this multivalued map.\n      * <p>\n      * Unlike a normal {@code Map} the previous value is not replaced.\n      * Instead the new value is added to the collection stored against the key.\n      * Depending on the collection type used, duplicate key-value mappings may\n      * be allowed.\n      * <p>\n-     * The method will return {@code true} if the size of the multi-valued map\n+     * The method will return {@code true} if the size of the multivalued map\n      * has been increased because of this operation.\n      *\n      * @param key  the key to store against\n@@ -133,10 +133,10 @@ public interface MultiValuedMap<K, V> {\n      *   if the map already contained the key-value mapping and the collection\n      *   type does not allow duplicate values, e.g. when using a Set\n      * @throws UnsupportedOperationException if the put operation is not supported by\n-     *   this multi-valued map, e.g. if it is unmodifiable\n+     *   this multivalued map, e.g. if it is unmodifiable\n      * @throws NullPointerException if the key or value is null and null is invalid (optional)\n      * @throws IllegalArgumentException if some aspect of the specified key or value prevents\n-     *   it from being stored in this multi-valued map\n+     *   it from being stored in this multivalued map\n      */\n     boolean put(K key, V value);\n \n@@ -153,7 +153,7 @@ public interface MultiValuedMap<K, V> {\n     boolean putAll(K key, Iterable<? extends V> values);\n \n     /**\n-     * Copies all mappings from the specified map to this multi-valued map\n+     * Copies all mappings from the specified map to this multivalued map\n      * (optional operation).\n      * <p>\n      * The effect of this call is equivalent to that of calling\n@@ -176,7 +176,7 @@ public interface MultiValuedMap<K, V> {\n     boolean putAll(Map<? extends K, ? extends V> map);\n \n     /**\n-     * Copies all mappings from the specified map to this multi-valued map\n+     * Copies all mappings from the specified map to this multivalued map\n      * (optional operation).\n      * <p>\n      * The effect of this call is equivalent to that of calling\n@@ -202,7 +202,7 @@ public interface MultiValuedMap<K, V> {\n      * Removes all values associated with the specified key.\n      * <p>\n      * The returned collection <i>may</i> be modifiable, but updates will not be propagated\n-     * to this multi-valued map. In case no mapping was stored for the specified\n+     * to this multivalued map. In case no mapping was stored for the specified\n      * key, an empty, unmodifiable collection will be returned.\n      *\n      * @param key  the key to remove values from\n@@ -241,7 +241,7 @@ public interface MultiValuedMap<K, V> {\n     // Views\n \n     /**\n-     * Returns a {@link Collection} view of the mappings contained in this multi-valued map.\n+     * Returns a {@link Collection} view of the mappings contained in this multivalued map.\n      * <p>\n      * The collection is backed by the map, so changes to the map are reflected\n      * in the collection, and vice-versa.\n@@ -251,7 +251,7 @@ public interface MultiValuedMap<K, V> {\n     Collection<Entry<K, V>> entries();\n \n     /**\n-     * Returns a {@link MultiSet} view of the keys contained in this multi-valued map.\n+     * Returns a {@link MultiSet} view of the keys contained in this multivalued map.\n      * <p>\n      * The {@link MultiSet#getCount(Object)} method of the returned multiset will give\n      * the same result a calling {@code get(Object).size()} for the same key.\n@@ -264,7 +264,7 @@ public interface MultiValuedMap<K, V> {\n     MultiSet<K> keys();\n \n     /**\n-     * Returns a {@link Set} view of the keys contained in this multi-valued map.\n+     * Returns a {@link Set} view of the keys contained in this multivalued map.\n      * <p>\n      * The set is backed by the map, so changes to the map are reflected\n      * in the set, and vice-versa.\n@@ -282,36 +282,36 @@ public interface MultiValuedMap<K, V> {\n     Set<K> keySet();\n \n     /**\n-     * Gets a {@link Collection} view of all values contained in this multi-valued map.\n+     * Gets a {@link Collection} view of all values contained in this multivalued map.\n      * <p>\n      * Implementations typically return a collection containing the combination\n      * of values from all keys.\n      *\n-     * @return a collection view of the values contained in this multi-valued map\n+     * @return a collection view of the values contained in this multivalued map\n      */\n     Collection<V> values();\n \n     /**\n-     * Returns a view of this multi-valued map as a {@code Map} from each distinct\n+     * Returns a view of this multivalued map as a {@code Map} from each distinct\n      * key to the non-empty collection of that key's associated values.\n      * <p>\n      * Note that {@code this.asMap().get(k)} is equivalent to {@code this.get(k)}\n-     * only when {@code k} is a key contained in the multi-valued map; otherwise it\n+     * only when {@code k} is a key contained in the multivalued map; otherwise it\n      * returns {@code null} as opposed to an empty collection.\n      * <p>\n      * Changes to the returned map or the collections that serve as its values\n-     * will update the underlying multi-valued map, and vice versa. The map does\n+     * will update the underlying multivalued map, and vice versa. The map does\n      * not support {@code put} or {@code putAll}, nor do its entries support\n      * {@link java.util.Map.Entry#setValue(Object) setValue}.\n      *\n-     * @return a map view of the mappings in this multi-valued map\n+     * @return a map view of the mappings in this multivalued map\n      */\n     Map<K, Collection<V>> asMap();\n \n     // Iterators\n \n     /**\n-     * Obtains a {@code MapIterator} over this multi-valued map.\n+     * Obtains a {@code MapIterator} over this multivalued map.\n      * <p>\n      * A map iterator is an efficient way of iterating over maps. There is no\n      * need to access the entries collection or use {@code Map.Entry} objects.\ndiff --git a/src/main/java/org/apache/commons/collections4/OrderedMap.java b/src/main/java/org/apache/commons/collections4/OrderedMap.java\nindex 324710f06b..94688b539c 100644\n--- a/src/main/java/org/apache/commons/collections4/OrderedMap.java\n+++ b/src/main/java/org/apache/commons/collections4/OrderedMap.java\n@@ -30,7 +30,7 @@ public interface OrderedMap<K, V> extends IterableMap<K, V> {\n     /**\n      * Obtains an {@code OrderedMapIterator} over the map.\n      * <p>\n-     * A ordered map iterator is an efficient way of iterating over maps\n+     * An ordered map iterator is an efficient way of iterating over maps\n      * in both directions.\n      *\n      * @return a map iterator\ndiff --git a/src/main/java/org/apache/commons/collections4/SetUtils.java b/src/main/java/org/apache/commons/collections4/SetUtils.java\nindex 58fd6d78eb..42d09adcfb 100644\n--- a/src/main/java/org/apache/commons/collections4/SetUtils.java\n+++ b/src/main/java/org/apache/commons/collections4/SetUtils.java\n@@ -108,7 +108,7 @@ public Set<E> toSet() {\n             UnmodifiableSortedSet.unmodifiableSortedSet(new TreeSet<>());\n \n     /**\n-     * Returns a unmodifiable <b>view</b> containing the difference of the given\n+     * Returns an unmodifiable <b>view</b> containing the difference of the given\n      * {@link Set}s, denoted by {@code a \\ b} (or {@code a - b}).\n      * <p>\n      * The returned view contains all elements of {@code a} that are not a member\n@@ -118,7 +118,7 @@ public Set<E> toSet() {\n      *   in both input sets.\n      * @param setA  the set to subtract from, must not be null\n      * @param setB  the set to subtract, must not be null\n-     * @return a view of the relative complement of  of the two sets\n+     * @return a view of the relative complement of the two sets\n      * @since 4.1\n      */\n     public static <E> SetView<E> difference(final Set<? extends E> setA, final Set<? extends E> setB) {\n@@ -141,7 +141,7 @@ public Iterator<E> createIterator() {\n     }\n \n     /**\n-     * Returns a unmodifiable <b>view</b> of the symmetric difference of the given\n+     * Returns an unmodifiable <b>view</b> of the symmetric difference of the given\n      * {@link Set}s.\n      * <p>\n      * The returned view contains all elements of {@code a} and {@code b} that are\n@@ -261,7 +261,7 @@ public static <E> HashSet<E> hashSet(final E... items) {\n     }\n \n     /**\n-     * Returns a unmodifiable <b>view</b> of the intersection of the given {@link Set}s.\n+     * Returns an unmodifiable <b>view</b> of the intersection of the given {@link Set}s.\n      * <p>\n      * The returned view contains all elements that are members of both input sets\n      * ({@code a} and {@code b}).\n@@ -550,7 +550,7 @@ public static <E> SortedSet<E> transformedSortedSet(final SortedSet<E> set,\n     // Set operations\n \n     /**\n-     * Returns a unmodifiable <b>view</b> of the union of the given {@link Set}s.\n+     * Returns an unmodifiable <b>view</b> of the union of the given {@link Set}s.\n      * <p>\n      * The returned view contains all elements of {@code a} and {@code b}.\n      *\ndiff --git a/src/main/java/org/apache/commons/collections4/bag/SynchronizedBag.java b/src/main/java/org/apache/commons/collections4/bag/SynchronizedBag.java\nindex ed6e66a4a8..ba469ccaad 100644\n--- a/src/main/java/org/apache/commons/collections4/bag/SynchronizedBag.java\n+++ b/src/main/java/org/apache/commons/collections4/bag/SynchronizedBag.java\n@@ -23,7 +23,7 @@\n \n /**\n  * Decorates another {@link Bag} to synchronize its behavior\n- * for a multi-threaded environment.\n+ * for a multithreaded environment.\n  * <p>\n  * Methods are synchronized, then forwarded to the decorated bag.\n  * Iterators must be separately synchronized around the loop.\ndiff --git a/src/main/java/org/apache/commons/collections4/bag/SynchronizedSortedBag.java b/src/main/java/org/apache/commons/collections4/bag/SynchronizedSortedBag.java\nindex 3c8ec10505..3c226ebfdf 100644\n--- a/src/main/java/org/apache/commons/collections4/bag/SynchronizedSortedBag.java\n+++ b/src/main/java/org/apache/commons/collections4/bag/SynchronizedSortedBag.java\n@@ -23,7 +23,7 @@\n \n /**\n  * Decorates another {@link SortedBag} to synchronize its behavior\n- * for a multi-threaded environment.\n+ * for a multithreaded environment.\n  * <p>\n  * Methods are synchronized, then forwarded to the decorated bag.\n  * Iterators must be separately synchronized around the loop.\ndiff --git a/src/main/java/org/apache/commons/collections4/bag/package-info.java b/src/main/java/org/apache/commons/collections4/bag/package-info.java\nindex 169ed3d606..971dd026f3 100644\n--- a/src/main/java/org/apache/commons/collections4/bag/package-info.java\n+++ b/src/main/java/org/apache/commons/collections4/bag/package-info.java\n@@ -27,7 +27,7 @@\n  * <p>\n  * The following decorators are provided in the package:\n  * <ul>\n- *   <li>Synchronized - synchronizes method access for multi-threaded environments\n+ *   <li>Synchronized - synchronizes method access for multithreaded environments\n  *   <li>Unmodifiable - ensures the bag cannot be altered\n  *   <li>Predicated - ensures that only elements that are valid according to a predicate can be added\n  *   <li>Transformed - transforms each element added to the bag\ndiff --git a/src/main/java/org/apache/commons/collections4/bidimap/AbstractDualBidiMap.java b/src/main/java/org/apache/commons/collections4/bidimap/AbstractDualBidiMap.java\nindex e0d400b46d..55cc57b073 100644\n--- a/src/main/java/org/apache/commons/collections4/bidimap/AbstractDualBidiMap.java\n+++ b/src/main/java/org/apache/commons/collections4/bidimap/AbstractDualBidiMap.java\n@@ -673,7 +673,7 @@ public void remove() {\n             if (!canRemove) {\n                 throw new IllegalStateException(\"Iterator remove() can only be called once after next()\");\n             }\n-            // store value as remove may change the entry in the decorator (eg.TreeMap)\n+            // store value as remove may change the entry in the decorator (e.g. TreeMap)\n             final Object value = last.getValue();\n             super.remove();\n             parent.reverseMap.remove(value);\n@@ -756,7 +756,7 @@ public void remove() {\n             if (!canRemove) {\n                 throw new IllegalStateException(\"Iterator remove() can only be called once after next()\");\n             }\n-            // store value as remove may change the entry in the decorator (eg.TreeMap)\n+            // store value as remove may change the entry in the decorator (e.g. TreeMap)\n             final V value = last.getValue();\n             iterator.remove();\n             parent.reverseMap.remove(value);\ndiff --git a/src/main/java/org/apache/commons/collections4/bidimap/TreeBidiMap.java b/src/main/java/org/apache/commons/collections4/bidimap/TreeBidiMap.java\nindex 7b5aa39fc3..3c91ee8e06 100644\n--- a/src/main/java/org/apache/commons/collections4/bidimap/TreeBidiMap.java\n+++ b/src/main/java/org/apache/commons/collections4/bidimap/TreeBidiMap.java\n@@ -158,7 +158,7 @@ public boolean isEmpty() {\n     }\n \n     /**\n-     * Checks whether this map contains the a mapping for the specified key.\n+     * Checks whether this map contains a mapping for the specified key.\n      * <p>\n      * The key must implement {@code Comparable}.\n      *\n@@ -174,7 +174,7 @@ public boolean containsKey(final Object key) {\n     }\n \n     /**\n-     * Checks whether this map contains the a mapping for the specified value.\n+     * Checks whether this map contains a mapping for the specified value.\n      * <p>\n      * The value must implement {@code Comparable}.\n      *\n@@ -572,7 +572,7 @@ private K doRemoveValue(final Object value) {\n      * Does the actual lookup of a piece of data.\n      *\n      * @param data the key or value to be looked up\n-     * @param dataElement  either {@link DataElement#KEY} key}\n+     * @param dataElement  either the {@link DataElement#KEY key}\n      *                     or the {@link DataElement#VALUE value}.\n      * @return the desired Node, or null if there is no mapping of the\n      *         specified data\n@@ -606,7 +606,7 @@ private Node<K, V> lookupValue(final Object value) {\n      * Gets the next larger node from the specified node.\n      *\n      * @param node the node to be searched from\n-     * @param dataElement  either {@link DataElement#KEY} key}\n+     * @param dataElement  either the {@link DataElement#KEY key}\n      *                     or the {@link DataElement#VALUE value}.\n      * @return the specified node\n      */\n@@ -641,7 +641,7 @@ private Node<K, V> nextGreater(final Node<K, V> node, final DataElement dataElem\n      * Gets the next smaller node from the specified node.\n      *\n      * @param node the node to be searched from\n-     * @param dataElement  either {@link DataElement#KEY} key}\n+     * @param dataElement  either the {@link DataElement#KEY key}\n      *                     or the {@link DataElement#VALUE value}.\n      * @return the specified node\n      */\n@@ -690,7 +690,7 @@ private static <T extends Comparable<T>> int compare(final T o1, final T o2) {\n      * Finds the least node from a given node.\n      *\n      * @param node  the node from which we will start searching\n-     * @param dataElement  either {@link DataElement#KEY} key}\n+     * @param dataElement  either the {@link DataElement#KEY key}\n      *                     or the {@link DataElement#VALUE value}.\n      * @return the smallest node, from the specified node, in the\n      *         specified mapping\n@@ -709,7 +709,7 @@ private Node<K, V> leastNode(final Node<K, V> node, final DataElement dataElemen\n      * Finds the greatest node from a given node.\n      *\n      * @param node  the node from which we will start searching\n-     * @param dataElement  either {@link DataElement#KEY} key}\n+     * @param dataElement  either the {@link DataElement#KEY key}\n      *                     or the {@link DataElement#VALUE value}.\n      * @return the greatest node, from the specified node\n      */\n@@ -729,7 +729,7 @@ private Node<K, V> greatestNode(final Node<K, V> node, final DataElement dataEle\n      *\n      * @param from the node whose color we're copying; may be null\n      * @param to the node whose color we're changing; may be null\n-     * @param dataElement  either {@link DataElement#KEY} key}\n+     * @param dataElement  either the {@link DataElement#KEY key}\n      *                     or the {@link DataElement#VALUE value}.\n      */\n     private void copyColor(final Node<K, V> from, final Node<K, V> to, final DataElement dataElement) {\n@@ -748,7 +748,7 @@ private void copyColor(final Node<K, V> from, final Node<K, V> to, final DataEle\n      * black, thank you.\n      *\n      * @param node the node (may be null) in question\n-     * @param dataElement  either {@link DataElement#KEY} key}\n+     * @param dataElement  either the {@link DataElement#KEY key}\n      *                     or the {@link DataElement#VALUE value}.\n      */\n     private static boolean isRed(final Node<?, ?> node, final DataElement dataElement) {\n@@ -760,7 +760,7 @@ private static boolean isRed(final Node<?, ?> node, final DataElement dataElemen\n      * it's black, thank you.\n      *\n      * @param node the node (may be null) in question\n-     * @param dataElement  either {@link DataElement#KEY} key}\n+     * @param dataElement  either the {@link DataElement#KEY key}\n      *                     or the {@link DataElement#VALUE value}.\n      */\n     private static boolean isBlack(final Node<?, ?> node, final DataElement dataElement) {\n@@ -771,7 +771,7 @@ private static boolean isBlack(final Node<?, ?> node, final DataElement dataElem\n      * Forces a node (if it exists) red.\n      *\n      * @param node the node (may be null) in question\n-     * @param dataElement  either {@link DataElement#KEY} key}\n+     * @param dataElement  either the {@link DataElement#KEY key}\n      *                     or the {@link DataElement#VALUE value}.\n      */\n     private static void makeRed(final Node<?, ?> node, final DataElement dataElement) {\n@@ -784,7 +784,7 @@ private static void makeRed(final Node<?, ?> node, final DataElement dataElement\n      * Forces a node (if it exists) black.\n      *\n      * @param node the node (may be null) in question\n-     * @param dataElement  either {@link DataElement#KEY} key}\n+     * @param dataElement  either the {@link DataElement#KEY key}\n      *                     or the {@link DataElement#VALUE value}.\n      */\n     private static void makeBlack(final Node<?, ?> node, final DataElement dataElement) {\n@@ -798,7 +798,7 @@ private static void makeBlack(final Node<?, ?> node, final DataElement dataEleme\n      * its grandparent may not exist. No problem.\n      *\n      * @param node the node (may be null) in question\n-     * @param dataElement  either {@link DataElement#KEY} key}\n+     * @param dataElement  either the {@link DataElement#KEY key}\n      *                     or the {@link DataElement#VALUE value}.\n      */\n     private Node<K, V> getGrandParent(final Node<K, V> node, final DataElement dataElement) {\n@@ -810,7 +810,7 @@ private Node<K, V> getGrandParent(final Node<K, V> node, final DataElement dataE\n      * exist. no problem.\n      *\n      * @param node the node (may be null) in question\n-     * @param dataElement  either {@link DataElement#KEY} key}\n+     * @param dataElement  either the {@link DataElement#KEY key}\n      *                     or the {@link DataElement#VALUE value}.\n      */\n     private Node<K, V> getParent(final Node<K, V> node, final DataElement dataElement) {\n@@ -822,7 +822,7 @@ private Node<K, V> getParent(final Node<K, V> node, final DataElement dataElemen\n      * problem.\n      *\n      * @param node the node (may be null) in question\n-     * @param dataElement  either {@link DataElement#KEY} key}\n+     * @param dataElement  either the {@link DataElement#KEY key}\n      *                     or the {@link DataElement#VALUE value}.\n      */\n     private Node<K, V> getRightChild(final Node<K, V> node, final DataElement dataElement) {\n@@ -834,7 +834,7 @@ private Node<K, V> getRightChild(final Node<K, V> node, final DataElement dataEl\n      * problem.\n      *\n      * @param node the node (may be null) in question\n-     * @param dataElement  either {@link DataElement#KEY} key}\n+     * @param dataElement  either the {@link DataElement#KEY key}\n      *                     or the {@link DataElement#VALUE value}.\n      */\n     private Node<K, V> getLeftChild(final Node<K, V> node, final DataElement dataElement) {\n@@ -845,7 +845,7 @@ private Node<K, V> getLeftChild(final Node<K, V> node, final DataElement dataEle\n      * Does a rotate left. standard fare in the world of balanced trees.\n      *\n      * @param node the node to be rotated\n-     * @param dataElement  either {@link DataElement#KEY} key}\n+     * @param dataElement  either the {@link DataElement#KEY key}\n      *                     or the {@link DataElement#VALUE value}.\n      */\n     private void rotateLeft(final Node<K, V> node, final DataElement dataElement) {\n@@ -874,7 +874,7 @@ private void rotateLeft(final Node<K, V> node, final DataElement dataElement) {\n      * Does a rotate right. standard fare in the world of balanced trees.\n      *\n      * @param node the node to be rotated\n-     * @param dataElement  either {@link DataElement#KEY} key}\n+     * @param dataElement  either the {@link DataElement#KEY key}\n      *                     or the {@link DataElement#VALUE value}.\n      */\n     private void rotateRight(final Node<K, V> node, final DataElement dataElement) {\n@@ -900,7 +900,7 @@ private void rotateRight(final Node<K, V> node, final DataElement dataElement) {\n \n     /**\n      * Complicated red-black insert stuff. Based on Sun's TreeMap\n-     * implementation, though it's barely recognizable any more.\n+     * implementation, though it's barely recognizable anymore.\n      *\n      * @param insertedNode the node to be inserted\n      * @param dataElement  the KEY or VALUE int\n@@ -970,7 +970,7 @@ && isRed(currentNode.getParent(dataElement), dataElement)) {\n \n     /**\n      * Complicated red-black delete stuff. Based on Sun's TreeMap\n-     * implementation, though it's barely recognizable any more.\n+     * implementation, though it's barely recognizable anymore.\n      *\n      * @param deletedNode the node to be deleted\n      */\n@@ -1034,7 +1034,7 @@ private void doRedBlackDelete(final Node<K, V> deletedNode) {\n \n     /**\n      * Complicated red-black delete stuff. Based on Sun's TreeMap\n-     * implementation, though it's barely recognizable any more. This\n+     * implementation, though it's barely recognizable anymore. This\n      * rebalances the tree (somewhat, as red-black trees are not\n      * perfectly balanced -- perfect balancing takes longer)\n      *\n@@ -1220,7 +1220,7 @@ private void swapPosition(final Node<K, V> x, final Node<K, V> y, final DataElem\n      * Comparable and non-null.\n      *\n      * @param obj the object being checked\n-     * @param dataElement  either {@link DataElement#KEY} key}\n+     * @param dataElement  either the {@link DataElement#KEY key}\n      *                     or the {@link DataElement#VALUE value}.\n      *\n      * @throws NullPointerException if o is null\n@@ -1341,7 +1341,7 @@ private void insertValue(final Node<K, V> newNode) throws IllegalArgumentExcepti\n      * Compares for equals as per the API.\n      *\n      * @param obj  the object to compare to\n-     * @param dataElement  either {@link DataElement#KEY} key}\n+     * @param dataElement  either the {@link DataElement#KEY key}\n      *                     or the {@link DataElement#VALUE value}.\n      * @return true if equal\n      */\n@@ -1376,7 +1376,7 @@ private boolean doEquals(final Object obj, final DataElement dataElement) {\n     /**\n      * Gets the hash code value for this map as per the API.\n      *\n-     * @param dataElement  either {@link DataElement#KEY} key}\n+     * @param dataElement  either the {@link DataElement#KEY key}\n      *                     or the {@link DataElement#VALUE value}.\n      * @return the hash code value for this map\n      */\n@@ -1395,7 +1395,7 @@ private int doHashCode(final DataElement dataElement) {\n     /**\n      * Gets the string form of this map as per AbstractMap.\n      *\n-     * @param dataElement  either {@link DataElement#KEY} key}\n+     * @param dataElement  either the {@link DataElement#KEY key}\n      *                     or the {@link DataElement#VALUE value}.\n      * @return the string form of this map\n      */\n@@ -1920,7 +1920,7 @@ private Node<K, V> getRight(final DataElement dataElement) {\n          * Sets this node's parent node.\n          *\n          * @param node  the new parent node\n-         * @param dataElement  either {@link DataElement#KEY} key}\n+         * @param dataElement  either the {@link DataElement#KEY key}\n          *                     or the {@link DataElement#VALUE value}.\n          */\n         private void setParent(final Node<K, V> node, final DataElement dataElement) {\n@@ -1930,7 +1930,7 @@ private void setParent(final Node<K, V> node, final DataElement dataElement) {\n         /**\n          * Gets the parent node.\n          *\n-         * @param dataElement  either {@link DataElement#KEY} key}\n+         * @param dataElement  either the {@link DataElement#KEY key}\n          *                     or the {@link DataElement#VALUE value}.\n          * @return the parent node, may be null\n          */\n@@ -1942,7 +1942,7 @@ private Node<K, V> getParent(final DataElement dataElement) {\n          * Exchanges colors with another node.\n          *\n          * @param node  the node to swap with\n-         * @param dataElement  either {@link DataElement#KEY} key}\n+         * @param dataElement  either the {@link DataElement#KEY key}\n          *                     or the {@link DataElement#VALUE value}.\n          */\n         private void swapColors(final Node<K, V> node, final DataElement dataElement) {\n@@ -1955,7 +1955,7 @@ private void swapColors(final Node<K, V> node, final DataElement dataElement) {\n         /**\n          * Is this node black?\n          *\n-         * @param dataElement  either {@link DataElement#KEY} key}\n+         * @param dataElement  either the {@link DataElement#KEY key}\n          *                     or the {@link DataElement#VALUE value}.\n          * @return true if black (which is represented as a true boolean)\n          */\n@@ -1966,7 +1966,7 @@ private boolean isBlack(final DataElement dataElement) {\n         /**\n          * Is this node red?\n          *\n-         * @param dataElement  either {@link DataElement#KEY} key}\n+         * @param dataElement  either the {@link DataElement#KEY key}\n          *                     or the {@link DataElement#VALUE value}.\n          * @return true if non-black\n          */\n@@ -1977,7 +1977,7 @@ private boolean isRed(final DataElement dataElement) {\n         /**\n          * Makes this node black.\n          *\n-         * @param dataElement  either {@link DataElement#KEY} key}\n+         * @param dataElement  either the {@link DataElement#KEY key}\n          *                     or the {@link DataElement#VALUE value}.\n          */\n         private void setBlack(final DataElement dataElement) {\n@@ -1987,7 +1987,7 @@ private void setBlack(final DataElement dataElement) {\n         /**\n          * Makes this node red.\n          *\n-         * @param dataElement  either {@link DataElement#KEY} key}\n+         * @param dataElement  either the {@link DataElement#KEY key}\n          *                     or the {@link DataElement#VALUE value}.\n          */\n         private void setRed(final DataElement dataElement) {\n@@ -1998,7 +1998,7 @@ private void setRed(final DataElement dataElement) {\n          * Makes this node the same color as another.\n          *\n          * @param node  the node whose color we're adopting\n-         * @param dataElement  either {@link DataElement#KEY} key}\n+         * @param dataElement  either the {@link DataElement#KEY key}\n          *                     or the {@link DataElement#VALUE value}.\n          */\n         private void copyColor(final Node<K, V> node, final DataElement dataElement) {\ndiff --git a/src/main/java/org/apache/commons/collections4/collection/PredicatedCollection.java b/src/main/java/org/apache/commons/collections4/collection/PredicatedCollection.java\nindex a877005e48..369e3c44c9 100644\n--- a/src/main/java/org/apache/commons/collections4/collection/PredicatedCollection.java\n+++ b/src/main/java/org/apache/commons/collections4/collection/PredicatedCollection.java\n@@ -160,7 +160,7 @@ public boolean add(final E object) {\n \n     /**\n      * Override to validate the objects being added to ensure they match\n-     * the predicate. If any one fails, no update is made to the underlying\n+     * the predicate. If anyone fails, no update is made to the underlying\n      * collection.\n      *\n      * @param coll  the collection being added\ndiff --git a/src/main/java/org/apache/commons/collections4/collection/SynchronizedCollection.java b/src/main/java/org/apache/commons/collections4/collection/SynchronizedCollection.java\nindex 190766fc1e..399221690f 100644\n--- a/src/main/java/org/apache/commons/collections4/collection/SynchronizedCollection.java\n+++ b/src/main/java/org/apache/commons/collections4/collection/SynchronizedCollection.java\n@@ -24,7 +24,7 @@\n \n /**\n  * Decorates another {@link Collection} to synchronize its behavior\n- * for a multi-threaded environment.\n+ * for a multithreaded environment.\n  * <p>\n  * Iterators must be manually synchronized:\n  * </p>\ndiff --git a/src/main/java/org/apache/commons/collections4/collection/package-info.java b/src/main/java/org/apache/commons/collections4/collection/package-info.java\nindex fa5e59b545..f2ca8fd1f0 100644\n--- a/src/main/java/org/apache/commons/collections4/collection/package-info.java\n+++ b/src/main/java/org/apache/commons/collections4/collection/package-info.java\n@@ -24,7 +24,7 @@\n  * </ul>\n  * The following decorators are provided in the package:\n  * <ul>\n- *   <li>Synchronized - synchronizes method access for multi-threaded environments\n+ *   <li>Synchronized - synchronizes method access for multithreaded environments\n  *   <li>Unmodifiable - ensures the collection cannot be altered\n  *   <li>Predicated - ensures that only elements that are valid according to a predicate can be added\n  *   <li>Transformed - transforms elements as they are added\ndiff --git a/src/main/java/org/apache/commons/collections4/comparators/BooleanComparator.java b/src/main/java/org/apache/commons/collections4/comparators/BooleanComparator.java\nindex 544d978b0d..b391f08866 100644\n--- a/src/main/java/org/apache/commons/collections4/comparators/BooleanComparator.java\n+++ b/src/main/java/org/apache/commons/collections4/comparators/BooleanComparator.java\n@@ -155,7 +155,7 @@ public int hashCode() {\n \n     /**\n      * Returns {@code true} iff <i>that</i> Object is\n-     * is a {@link Comparator} whose ordering is known to be\n+     * a {@link Comparator} whose ordering is known to be\n      * equivalent to mine.\n      * <p>\n      * This implementation returns {@code true}\ndiff --git a/src/main/java/org/apache/commons/collections4/comparators/ComparableComparator.java b/src/main/java/org/apache/commons/collections4/comparators/ComparableComparator.java\nindex 063ffd59e1..45c20a5e89 100644\n--- a/src/main/java/org/apache/commons/collections4/comparators/ComparableComparator.java\n+++ b/src/main/java/org/apache/commons/collections4/comparators/ComparableComparator.java\n@@ -105,7 +105,7 @@ public int hashCode() {\n     }\n \n     /**\n-     * Returns {@code true} iff <i>that</i> Object is is a {@link Comparator Comparator}\n+     * Returns {@code true} iff <i>that</i> Object is a {@link Comparator Comparator}\n      * whose ordering is known to be equivalent to mine.\n      * <p>\n      * This implementation returns {@code true} iff\ndiff --git a/src/main/java/org/apache/commons/collections4/comparators/ComparatorChain.java b/src/main/java/org/apache/commons/collections4/comparators/ComparatorChain.java\nindex 4653092172..549b406a72 100644\n--- a/src/main/java/org/apache/commons/collections4/comparators/ComparatorChain.java\n+++ b/src/main/java/org/apache/commons/collections4/comparators/ComparatorChain.java\n@@ -315,7 +315,7 @@ public int hashCode() {\n \n     /**\n      * Returns {@code true} iff <i>that</i> Object is\n-     * is a {@link Comparator} whose ordering is known to be\n+     * a {@link Comparator} whose ordering is known to be\n      * equivalent to mine.\n      * <p>\n      * This implementation returns {@code true}\ndiff --git a/src/main/java/org/apache/commons/collections4/comparators/FixedOrderComparator.java b/src/main/java/org/apache/commons/collections4/comparators/FixedOrderComparator.java\nindex 4067c8e2f7..f6f58313ac 100644\n--- a/src/main/java/org/apache/commons/collections4/comparators/FixedOrderComparator.java\n+++ b/src/main/java/org/apache/commons/collections4/comparators/FixedOrderComparator.java\n@@ -253,7 +253,7 @@ public int hashCode() {\n \n     /**\n      * Returns {@code true} iff <i>that</i> Object is\n-     * is a {@link Comparator} whose ordering is known to be\n+     * a {@link Comparator} whose ordering is known to be\n      * equivalent to mine.\n      * <p>\n      * This implementation returns {@code true}\ndiff --git a/src/main/java/org/apache/commons/collections4/comparators/ReverseComparator.java b/src/main/java/org/apache/commons/collections4/comparators/ReverseComparator.java\nindex 4c2e010587..627277bfb2 100644\n--- a/src/main/java/org/apache/commons/collections4/comparators/ReverseComparator.java\n+++ b/src/main/java/org/apache/commons/collections4/comparators/ReverseComparator.java\n@@ -88,7 +88,7 @@ public int hashCode() {\n \n     /**\n      * Returns {@code true} iff <i>that</i> Object is\n-     * is a {@link Comparator} whose ordering is known to be\n+     * a {@link Comparator} whose ordering is known to be\n      * equivalent to mine.\n      * <p>\n      * This implementation returns {@code true}\ndiff --git a/src/main/java/org/apache/commons/collections4/comparators/TransformingComparator.java b/src/main/java/org/apache/commons/collections4/comparators/TransformingComparator.java\nindex a582a6f21c..28f044eef5 100644\n--- a/src/main/java/org/apache/commons/collections4/comparators/TransformingComparator.java\n+++ b/src/main/java/org/apache/commons/collections4/comparators/TransformingComparator.java\n@@ -101,7 +101,7 @@ public int hashCode() {\n \n     /**\n      * Returns {@code true} iff <i>that</i> Object is\n-     * is a {@link Comparator} whose ordering is known to be\n+     * a {@link Comparator} whose ordering is known to be\n      * equivalent to mine.\n      * <p>\n      * This implementation returns {@code true}\ndiff --git a/src/main/java/org/apache/commons/collections4/iterators/ArrayListIterator.java b/src/main/java/org/apache/commons/collections4/iterators/ArrayListIterator.java\nindex eedb4fd6eb..d605934812 100644\n--- a/src/main/java/org/apache/commons/collections4/iterators/ArrayListIterator.java\n+++ b/src/main/java/org/apache/commons/collections4/iterators/ArrayListIterator.java\n@@ -45,7 +45,7 @@ public class ArrayListIterator<E> extends ArrayIterator<E>\n     /**\n      * Holds the index of the last item returned by a call to {@code next()}\n      * or {@code previous()}. This is set to {@code -1} if neither method\n-     * has yet been invoked. {@code lastItemIndex} is used to to implement\n+     * has yet been invoked. {@code lastItemIndex} is used to implement\n      * the {@link #set} method.\n      */\n     private int lastItemIndex = -1;\ndiff --git a/src/main/java/org/apache/commons/collections4/iterators/CollatingIterator.java b/src/main/java/org/apache/commons/collections4/iterators/CollatingIterator.java\nindex 5dda409800..7bf975a274 100644\n--- a/src/main/java/org/apache/commons/collections4/iterators/CollatingIterator.java\n+++ b/src/main/java/org/apache/commons/collections4/iterators/CollatingIterator.java\n@@ -71,7 +71,7 @@ public CollatingIterator() {\n     }\n \n     /**\n-     * Constructs a new {@code CollatingIterator} that will used the\n+     * Constructs a new {@code CollatingIterator} that will use the\n      * specified comparator for ordering. Child iterators will have to be\n      * manually added using the {@link #addIterator(Iterator)} method.\n      *\n@@ -83,7 +83,7 @@ public CollatingIterator(final Comparator<? super E> comp) {\n     }\n \n     /**\n-     * Constructs a new {@code CollatingIterator} that will used the\n+     * Constructs a new {@code CollatingIterator} that will use the\n      * specified comparator for ordering and have the specified initial\n      * capacity. Child iterators will have to be manually added using the\n      * {@link #addIterator(Iterator)} method.\ndiff --git a/src/main/java/org/apache/commons/collections4/iterators/FilterIterator.java b/src/main/java/org/apache/commons/collections4/iterators/FilterIterator.java\nindex a7aed100ff..7f86848c2d 100644\n--- a/src/main/java/org/apache/commons/collections4/iterators/FilterIterator.java\n+++ b/src/main/java/org/apache/commons/collections4/iterators/FilterIterator.java\n@@ -161,7 +161,7 @@ public void setPredicate(final Predicate<? super E> predicate) {\n \n     /**\n      * Set nextObject to the next object. If there are no more\n-     * objects then return false. Otherwise, return true.\n+     * objects, then return false. Otherwise, return true.\n      */\n     private boolean setNextObject() {\n         while (iterator.hasNext()) {\ndiff --git a/src/main/java/org/apache/commons/collections4/iterators/LazyIteratorChain.java b/src/main/java/org/apache/commons/collections4/iterators/LazyIteratorChain.java\nindex dc9dd28181..de658845ef 100644\n--- a/src/main/java/org/apache/commons/collections4/iterators/LazyIteratorChain.java\n+++ b/src/main/java/org/apache/commons/collections4/iterators/LazyIteratorChain.java\n@@ -27,7 +27,7 @@\n  * in sequence until all Iterators are exhausted.\n  * <p>\n  * The Iterators are provided by {@link #nextIterator(int)} which has to be overridden by\n- * sub-classes and allows to lazily create the Iterators as they are accessed:\n+ * subclasses and allows to lazily create the Iterators as they are accessed:\n  * <pre>\n  * return new LazyIteratorChain&lt;String&gt;() {\n  *     protected Iterator&lt;String&gt; nextIterator(int count) {\ndiff --git a/src/main/java/org/apache/commons/collections4/iterators/LoopingListIterator.java b/src/main/java/org/apache/commons/collections4/iterators/LoopingListIterator.java\nindex 0719a44598..5d29e24a41 100644\n--- a/src/main/java/org/apache/commons/collections4/iterators/LoopingListIterator.java\n+++ b/src/main/java/org/apache/commons/collections4/iterators/LoopingListIterator.java\n@@ -53,7 +53,7 @@ public class LoopingListIterator<E> implements ResettableListIterator<E> {\n      * passed in and a reference to it held.\n      *\n      * @param list the list to wrap\n-     * @throws NullPointerException if the list it null\n+     * @throws NullPointerException if the list is null\n      */\n     public LoopingListIterator(final List<E> list) {\n         this.list = Objects.requireNonNull(list, \"collection\");\ndiff --git a/src/main/java/org/apache/commons/collections4/iterators/ObjectArrayListIterator.java b/src/main/java/org/apache/commons/collections4/iterators/ObjectArrayListIterator.java\nindex 772dc20d36..816d563638 100644\n--- a/src/main/java/org/apache/commons/collections4/iterators/ObjectArrayListIterator.java\n+++ b/src/main/java/org/apache/commons/collections4/iterators/ObjectArrayListIterator.java\n@@ -42,7 +42,7 @@ public class ObjectArrayListIterator<E> extends ObjectArrayIterator<E>\n     /**\n      * Holds the index of the last item returned by a call to {@code next()}\n      * or {@code previous()}. This is set to {@code -1} if neither method\n-     * has yet been invoked. {@code lastItemIndex} is used to to implement the\n+     * has yet been invoked. {@code lastItemIndex} is used to implement the\n      * {@link #set} method.\n      */\n     private int lastItemIndex = -1;\ndiff --git a/src/main/java/org/apache/commons/collections4/iterators/PermutationIterator.java b/src/main/java/org/apache/commons/collections4/iterators/PermutationIterator.java\nindex 4382e2bc05..cebb6a4e2c 100644\n--- a/src/main/java/org/apache/commons/collections4/iterators/PermutationIterator.java\n+++ b/src/main/java/org/apache/commons/collections4/iterators/PermutationIterator.java\n@@ -44,7 +44,7 @@\n public class PermutationIterator<E> implements Iterator<List<E>> {\n \n     /**\n-     * Permutation is done on theses keys to handle equal objects.\n+     * Permutation is done on these keys to handle equal objects.\n      */\n     private final int[] keys;\n \ndiff --git a/src/main/java/org/apache/commons/collections4/keyvalue/MultiKey.java b/src/main/java/org/apache/commons/collections4/keyvalue/MultiKey.java\nindex 0286ea2645..b25cd89234 100644\n--- a/src/main/java/org/apache/commons/collections4/keyvalue/MultiKey.java\n+++ b/src/main/java/org/apache/commons/collections4/keyvalue/MultiKey.java\n@@ -47,7 +47,7 @@\n  * @since 3.0\n  */\n public class MultiKey<K> implements Serializable {\n-    // This class could implement List, but that would confuse it's purpose\n+    // This class could implement List, but that would confuse its purpose\n \n     /** Serialisation version */\n     private static final long serialVersionUID = 4465448607415788805L;\n@@ -290,7 +290,7 @@ public K[] getKeys() {\n      * This value is computed once and then cached, so elements should not\n      * change their hash codes once created (note that this is the same\n      * constraint that would be used if the individual keys elements were\n-     * themselves {@link java.util.Map Map} keys.\n+     * themselves {@link java.util.Map Map} keys).\n      *\n      * @return the hash code\n      */\ndiff --git a/src/main/java/org/apache/commons/collections4/list/AbstractLinkedList.java b/src/main/java/org/apache/commons/collections4/list/AbstractLinkedList.java\nindex 75039993e5..f27650335c 100644\n--- a/src/main/java/org/apache/commons/collections4/list/AbstractLinkedList.java\n+++ b/src/main/java/org/apache/commons/collections4/list/AbstractLinkedList.java\n@@ -59,7 +59,7 @@ public abstract class AbstractLinkedList<E> implements List<E> {\n     /**\n      * A {@link Node} which indicates the start and end of the list and does not\n      * hold a value. The value of {@code next} is the first item in the\n-     * list. The value of of {@code previous} is the last item in the list.\n+     * list. The value of {@code previous} is the last item in the list.\n      */\n     transient Node<E> header;\n \n@@ -70,7 +70,7 @@ public abstract class AbstractLinkedList<E> implements List<E> {\n     transient int modCount;\n \n     /**\n-     * Constructor that does nothing intended for deserialization.\n+     * Constructor that does nothing (intended for deserialization).\n      * <p>\n      * If this constructor is used by a serializable subclass then the init()\n      * method must be called.\ndiff --git a/src/main/java/org/apache/commons/collections4/list/CursorableLinkedList.java b/src/main/java/org/apache/commons/collections4/list/CursorableLinkedList.java\nindex 25b9ff6f13..32bc30afa7 100644\n--- a/src/main/java/org/apache/commons/collections4/list/CursorableLinkedList.java\n+++ b/src/main/java/org/apache/commons/collections4/list/CursorableLinkedList.java\n@@ -430,7 +430,7 @@ public void remove() {\n             if (current == null && currentRemovedByAnother) { // NOPMD\n                 // quietly ignore, as the last returned node was removed\n                 // by the list or some other iterator\n-                // by ignoring it, we keep this iterator independent from\n+                // by ignoring it, we keep this iterator independent of\n                 // other changes as much as possible\n             } else {\n                 checkModCount();\ndiff --git a/src/main/java/org/apache/commons/collections4/list/LazyList.java b/src/main/java/org/apache/commons/collections4/list/LazyList.java\nindex 7321b322d6..928fc68c36 100644\n--- a/src/main/java/org/apache/commons/collections4/list/LazyList.java\n+++ b/src/main/java/org/apache/commons/collections4/list/LazyList.java\n@@ -148,7 +148,7 @@ public E get(final int index) {\n             // within bounds, get the object\n             E object = decorated().get(index);\n             if (object == null) {\n-                // item is a place holder, create new one, set and return\n+                // item is a placeholder, create new one, set and return\n                 object = element(index);\n                 decorated().set(index, object);\n             }\ndiff --git a/src/main/java/org/apache/commons/collections4/list/NodeCachingLinkedList.java b/src/main/java/org/apache/commons/collections4/list/NodeCachingLinkedList.java\nindex e7d7742de3..9a62f497cf 100644\n--- a/src/main/java/org/apache/commons/collections4/list/NodeCachingLinkedList.java\n+++ b/src/main/java/org/apache/commons/collections4/list/NodeCachingLinkedList.java\n@@ -154,7 +154,7 @@ protected boolean isCacheFull() {\n \n     /**\n      * Adds a node to the cache, if the cache isn't full.\n-     * The node's contents are cleared to so they can be garbage collected.\n+     * The node's contents are cleared so they can be garbage collected.\n      *\n      * @param node  the node to add to the cache\n      */\ndiff --git a/src/main/java/org/apache/commons/collections4/list/TreeList.java b/src/main/java/org/apache/commons/collections4/list/TreeList.java\nindex 5544aa017e..65ec38995f 100644\n--- a/src/main/java/org/apache/commons/collections4/list/TreeList.java\n+++ b/src/main/java/org/apache/commons/collections4/list/TreeList.java\n@@ -528,14 +528,14 @@ private AVLNode<E> insertOnRight(final int indexRelativeToMe, final E obj) {\n         }\n \n         /**\n-         * Gets the left node, returning null if its a faedelung.\n+         * Gets the left node, returning null if it's a faedelung.\n          */\n         private AVLNode<E> getLeftSubTree() {\n             return leftIsPrevious ? null : left;\n         }\n \n         /**\n-         * Gets the right node, returning null if its a faedelung.\n+         * Gets the right node, returning null if it's a faedelung.\n          */\n         private AVLNode<E> getRightSubTree() {\n             return rightIsNext ? null : right;\ndiff --git a/src/main/java/org/apache/commons/collections4/map/AbstractInputCheckedMapDecorator.java b/src/main/java/org/apache/commons/collections4/map/AbstractInputCheckedMapDecorator.java\nindex 41bc142877..e568535545 100644\n--- a/src/main/java/org/apache/commons/collections4/map/AbstractInputCheckedMapDecorator.java\n+++ b/src/main/java/org/apache/commons/collections4/map/AbstractInputCheckedMapDecorator.java\n@@ -140,7 +140,7 @@ public Object[] toArray() {\n         public <T> T[] toArray(final T[] array) {\n             Object[] result = array;\n             if (array.length > 0) {\n-                // we must create a new array to handle multi-threaded situations\n+                // we must create a new array to handle multithreaded situations\n                 // where another thread could access data before we decorate it\n                 result = (Object[]) Array.newInstance(array.getClass().getComponentType(), 0);\n             }\ndiff --git a/src/main/java/org/apache/commons/collections4/map/AbstractReferenceMap.java b/src/main/java/org/apache/commons/collections4/map/AbstractReferenceMap.java\nindex 81e9ce534f..ac59468f78 100644\n--- a/src/main/java/org/apache/commons/collections4/map/AbstractReferenceMap.java\n+++ b/src/main/java/org/apache/commons/collections4/map/AbstractReferenceMap.java\n@@ -487,7 +487,7 @@ protected Iterator<Map.Entry<K, V>> createEntrySetIterator() {\n     }\n \n     /**\n-     * Creates an key set iterator.\n+     * Creates a key set iterator.\n      *\n      * @return the keySet iterator\n      */\n@@ -497,7 +497,7 @@ protected Iterator<K> createKeySetIterator() {\n     }\n \n     /**\n-     * Creates an values iterator.\n+     * Creates a values iterator.\n      *\n      * @return the values iterator\n      */\n@@ -948,7 +948,7 @@ public V setValue(final V value) {\n     }\n \n     // These two classes store the hashCode of the key of\n-    // of the mapping, so that after they're dequeued a quick\n+    // the mapping, so that after they're dequeued a quick\n     // lookup of the bucket in the table can occur.\n \n     /**\ndiff --git a/src/main/java/org/apache/commons/collections4/map/CompositeMap.java b/src/main/java/org/apache/commons/collections4/map/CompositeMap.java\nindex 118c3e3842..bf44c25a22 100644\n--- a/src/main/java/org/apache/commons/collections4/map/CompositeMap.java\n+++ b/src/main/java/org/apache/commons/collections4/map/CompositeMap.java\n@@ -199,7 +199,7 @@ public void clear() {\n      * @throws ClassCastException if the key is of an inappropriate type for\n      *         this map (optional).\n      * @throws NullPointerException if the key is {@code null} and this map\n-     *            does not not permit {@code null} keys (optional).\n+     *            does not permit {@code null} keys (optional).\n      */\n     @Override\n     public boolean containsKey(final Object key) {\n@@ -225,7 +225,7 @@ public boolean containsKey(final Object key) {\n      * @throws ClassCastException if the value is of an inappropriate type for\n      *         this map (optional).\n      * @throws NullPointerException if the value is {@code null} and this map\n-     *            does not not permit {@code null} values (optional).\n+     *            does not permit {@code null} values (optional).\n      */\n     @Override\n     public boolean containsValue(final Object value) {\n@@ -282,7 +282,7 @@ public Set<Map.Entry<K, V>> entrySet() {\n      *\n      * @throws ClassCastException if the key is of an inappropriate type for\n      *         this map (optional).\n-     * @throws NullPointerException key is {@code null} and this map does not\n+     * @throws NullPointerException key is {@code null} and this map does\n      *         not permit {@code null} keys (optional).\n      *\n      * @see #containsKey(Object)\n@@ -420,7 +420,7 @@ public void putAll(final Map<? extends K, ? extends V> map) {\n      * @throws ClassCastException if the key is of an inappropriate type for\n      *         the composited map (optional).\n      * @throws NullPointerException if the key is {@code null} and the composited map\n-     *            does not not permit {@code null} keys (optional).\n+     *            does not permit {@code null} keys (optional).\n      * @throws UnsupportedOperationException if the {@code remove} method is\n      *         not supported by the composited map containing the key\n      */\ndiff --git a/src/main/java/org/apache/commons/collections4/map/PassiveExpiringMap.java b/src/main/java/org/apache/commons/collections4/map/PassiveExpiringMap.java\nindex 4b3e657205..b922e51859 100644\n--- a/src/main/java/org/apache/commons/collections4/map/PassiveExpiringMap.java\n+++ b/src/main/java/org/apache/commons/collections4/map/PassiveExpiringMap.java\n@@ -66,7 +66,7 @@ public class PassiveExpiringMap<K, V>\n \n     /**\n      * A {@link org.apache.commons.collections4.map.PassiveExpiringMap.ExpirationPolicy ExpirationPolicy}\n-     * that returns a expiration time that is a\n+     * that returns an expiration time that is a\n      * constant about of time in the future from the current time.\n      *\n      * @param <K> the type of the keys in the map\ndiff --git a/src/main/java/org/apache/commons/collections4/map/StaticBucketMap.java b/src/main/java/org/apache/commons/collections4/map/StaticBucketMap.java\nindex d8ccb31a7a..1662dc6341 100644\n--- a/src/main/java/org/apache/commons/collections4/map/StaticBucketMap.java\n+++ b/src/main/java/org/apache/commons/collections4/map/StaticBucketMap.java\n@@ -30,7 +30,7 @@\n \n /**\n  * A StaticBucketMap is an efficient, thread-safe implementation of\n- * {@code java.util.Map} that performs well in in a highly\n+ * {@code java.util.Map} that performs well in a highly\n  * thread-contentious environment.  The map supports very efficient\n  * {@link #get(Object) get}, {@link #put(Object,Object) put},\n  * {@link #remove(Object) remove} and {@link #containsKey(Object) containsKey}\ndiff --git a/src/main/java/org/apache/commons/collections4/map/UnmodifiableEntrySet.java b/src/main/java/org/apache/commons/collections4/map/UnmodifiableEntrySet.java\nindex f919597c62..89a52dd67f 100644\n--- a/src/main/java/org/apache/commons/collections4/map/UnmodifiableEntrySet.java\n+++ b/src/main/java/org/apache/commons/collections4/map/UnmodifiableEntrySet.java\n@@ -130,7 +130,7 @@ public Object[] toArray() {\n     public <T> T[] toArray(final T[] array) {\n         Object[] result = array;\n         if (array.length > 0) {\n-            // we must create a new array to handle multi-threaded situations\n+            // we must create a new array to handle multithreaded situations\n             // where another thread could access data before we decorate it\n             result = (Object[]) Array.newInstance(array.getClass().getComponentType(), 0);\n         }\ndiff --git a/src/main/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMap.java b/src/main/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMap.java\nindex 84fe5d5c73..c02fb2f806 100644\n--- a/src/main/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMap.java\n+++ b/src/main/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMap.java\n@@ -166,7 +166,7 @@ public Collection<V> remove(final Object key) {\n     }\n \n     /**\n-     * Removes a specific key/value mapping from the multi-valued map.\n+     * Removes a specific key/value mapping from the multivalued map.\n      * <p>\n      * The value is removed from the collection mapped to the specified key.\n      * Other values attached to that key are unaffected.\n@@ -205,7 +205,7 @@ public Set<K> keySet() {\n      * {@inheritDoc}\n      * <p>\n      * This implementation does <b>not</b> cache the total size\n-     * of the multi-valued map, but rather calculates it by iterating\n+     * of the multivalued map, but rather calculates it by iterating\n      * over the entries of the underlying map.\n      */\n     @Override\ndiff --git a/src/main/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMapDecorator.java b/src/main/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMapDecorator.java\nindex 11ac195c39..a86a06d93a 100644\n--- a/src/main/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMapDecorator.java\n+++ b/src/main/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMapDecorator.java\n@@ -60,7 +60,7 @@ protected AbstractMultiValuedMapDecorator(final MultiValuedMap<K, V> map) {\n     }\n \n     /**\n-     * The decorated multi-valued map.\n+     * The decorated multivalued map.\n      *\n      * @return the map to decorate\n      */\ndiff --git a/src/main/java/org/apache/commons/collections4/multiset/AbstractMultiSetDecorator.java b/src/main/java/org/apache/commons/collections4/multiset/AbstractMultiSetDecorator.java\nindex d0a5af8625..c060985444 100644\n--- a/src/main/java/org/apache/commons/collections4/multiset/AbstractMultiSetDecorator.java\n+++ b/src/main/java/org/apache/commons/collections4/multiset/AbstractMultiSetDecorator.java\n@@ -22,7 +22,7 @@\n import org.apache.commons.collections4.collection.AbstractCollectionDecorator;\n \n /**\n- * Decorates another {@code MultSet} to provide additional behavior.\n+ * Decorates another {@code MultiSet} to provide additional behavior.\n  * <p>\n  * Methods are forwarded directly to the decorated multiset.\n  * </p>\ndiff --git a/src/main/java/org/apache/commons/collections4/multiset/SynchronizedMultiSet.java b/src/main/java/org/apache/commons/collections4/multiset/SynchronizedMultiSet.java\nindex 8002a2a6b9..f522897ca0 100644\n--- a/src/main/java/org/apache/commons/collections4/multiset/SynchronizedMultiSet.java\n+++ b/src/main/java/org/apache/commons/collections4/multiset/SynchronizedMultiSet.java\n@@ -23,7 +23,7 @@\n \n /**\n  * Decorates another {@link MultiSet} to synchronize its behavior\n- * for a multi-threaded environment.\n+ * for a multithreaded environment.\n  * <p>\n  * Methods are synchronized, then forwarded to the decorated multiset.\n  * Iterators must be separately synchronized around the loop.\ndiff --git a/src/main/java/org/apache/commons/collections4/multiset/package-info.java b/src/main/java/org/apache/commons/collections4/multiset/package-info.java\nindex 014a00330b..f409489967 100644\n--- a/src/main/java/org/apache/commons/collections4/multiset/package-info.java\n+++ b/src/main/java/org/apache/commons/collections4/multiset/package-info.java\n@@ -27,7 +27,7 @@\n  * The following decorators are provided in the package:\n  * <ul>\n  *   <li>Predicated   - ensures that only elements that are valid according to a predicate can be added\n- *   <li>Synchronized - synchronizes method access for multi-threaded environments\n+ *   <li>Synchronized - synchronizes method access for multithreaded environments\n  *   <li>Unmodifiable - ensures the multiset cannot be altered\n  * </ul>\n  *\ndiff --git a/src/main/java/org/apache/commons/collections4/properties/AbstractPropertiesFactory.java b/src/main/java/org/apache/commons/collections4/properties/AbstractPropertiesFactory.java\nindex d278f30172..1788280675 100644\n--- a/src/main/java/org/apache/commons/collections4/properties/AbstractPropertiesFactory.java\n+++ b/src/main/java/org/apache/commons/collections4/properties/AbstractPropertiesFactory.java\n@@ -41,7 +41,7 @@\n public abstract class AbstractPropertiesFactory<T extends Properties> {\n \n     /**\n-     * Enumerat5es property formats.\n+     * Enumerates property formats.\n      *\n      * @since 4.5\n      */\ndiff --git a/src/main/java/org/apache/commons/collections4/queue/SynchronizedQueue.java b/src/main/java/org/apache/commons/collections4/queue/SynchronizedQueue.java\nindex 0517dbf164..d77b7cc050 100644\n--- a/src/main/java/org/apache/commons/collections4/queue/SynchronizedQueue.java\n+++ b/src/main/java/org/apache/commons/collections4/queue/SynchronizedQueue.java\n@@ -21,7 +21,7 @@\n import org.apache.commons.collections4.collection.SynchronizedCollection;\n \n /**\n- * Decorates another {@link Queue} to synchronize its behavior for a multi-threaded environment.\n+ * Decorates another {@link Queue} to synchronize its behavior for a multithreaded environment.\n  * <p>\n  * Methods are synchronized, then forwarded to the decorated queue. Iterators must be separately synchronized around the\n  * loop.\ndiff --git a/src/main/java/org/apache/commons/collections4/sequence/EditCommand.java b/src/main/java/org/apache/commons/collections4/sequence/EditCommand.java\nindex 22f63c837c..2ee1f5cc51 100644\n--- a/src/main/java/org/apache/commons/collections4/sequence/EditCommand.java\n+++ b/src/main/java/org/apache/commons/collections4/sequence/EditCommand.java\n@@ -73,7 +73,7 @@ protected T getObject() {\n     /**\n      * Accept a visitor.\n      * <p>\n-     * This method is invoked for each commands belonging to\n+     * This method is invoked for each command belonging to\n      * an {@link EditScript EditScript}, in order to implement the visitor design pattern\n      *\n      * @param visitor  the visitor to be accepted\ndiff --git a/src/main/java/org/apache/commons/collections4/sequence/SequencesComparator.java b/src/main/java/org/apache/commons/collections4/sequence/SequencesComparator.java\nindex 0e279edc77..813c1d1324 100644\n--- a/src/main/java/org/apache/commons/collections4/sequence/SequencesComparator.java\n+++ b/src/main/java/org/apache/commons/collections4/sequence/SequencesComparator.java\n@@ -156,7 +156,7 @@ private Snake buildSnake(final int start, final int diag, final int end1, final\n      * Get the middle snake corresponding to two subsequences of the\n      * main sequences.\n      * <p>\n-     * The snake is found using the MYERS Algorithm (this algorithms has\n+     * The snake is found using the MYERS Algorithm (this algorithm has\n      * also been implemented in the GNU diff program). This algorithm is\n      * explained in Eugene Myers article:\n      * <a href=\"https://web.archive.org/web/20040719035900/http%3A//www.cs.arizona.edu/people/gene/PAPERS/diff.ps\">\ndiff --git a/src/main/java/org/apache/commons/collections4/sequence/package-info.java b/src/main/java/org/apache/commons/collections4/sequence/package-info.java\nindex 43e91cd14f..552944130f 100644\n--- a/src/main/java/org/apache/commons/collections4/sequence/package-info.java\n+++ b/src/main/java/org/apache/commons/collections4/sequence/package-info.java\n@@ -56,7 +56,7 @@\n  * to perform the transformation, of course, or to retrieve the longest\n  * common subsequence for example.\n  * <p>\n- * If the user needs a very fine grained access to the comparison result,\n+ * If the user needs a very fine-grained access to the comparison result,\n  * he needs to go through this script by providing a visitor implementing\n  * the {@link org.apache.commons.collections4.sequence.CommandVisitor} interface.\n  * <p>\ndiff --git a/src/main/java/org/apache/commons/collections4/splitmap/package-info.java b/src/main/java/org/apache/commons/collections4/splitmap/package-info.java\nindex f407f6f082..edd56e0f95 100644\n--- a/src/main/java/org/apache/commons/collections4/splitmap/package-info.java\n+++ b/src/main/java/org/apache/commons/collections4/splitmap/package-info.java\n@@ -20,7 +20,7 @@\n  * {@link org.apache.commons.collections4.Get Get} interfaces,\n  * with <i>differing</i> generic types. This is like a pre-generics\n  * {@link java.util.Map Map} whose input key/value constraints are\n- * different than its output key/value constraints.  While it would\n+ * different from its output key/value constraints.  While it would\n  * be possible to declare a \"split map\" with matching input/output\n  * key/value constraints, this would be a {@link java.util.Map Map}\n  * and would therefore make little sense (any Commons Collections\ndiff --git a/src/main/java/org/apache/commons/collections4/trie/AbstractBitwiseTrie.java b/src/main/java/org/apache/commons/collections4/trie/AbstractBitwiseTrie.java\nindex 714b395c00..999cfa5078 100644\n--- a/src/main/java/org/apache/commons/collections4/trie/AbstractBitwiseTrie.java\n+++ b/src/main/java/org/apache/commons/collections4/trie/AbstractBitwiseTrie.java\n@@ -120,7 +120,7 @@ final int bitIndex(final K key, final K foundKey) {\n     }\n \n     /**\n-     * An utility method for calling {@link KeyAnalyzer#compare(Object, Object)}\n+     * A utility method for calling {@link KeyAnalyzer#compare(Object, Object)}\n      */\n     final boolean compareKeys(final K key, final K other) {\n         if (key == null) {\ndiff --git a/src/main/java/org/apache/commons/collections4/trie/AbstractPatriciaTrie.java b/src/main/java/org/apache/commons/collections4/trie/AbstractPatriciaTrie.java\nindex 9479d7406b..eebb6a427c 100644\n--- a/src/main/java/org/apache/commons/collections4/trie/AbstractPatriciaTrie.java\n+++ b/src/main/java/org/apache/commons/collections4/trie/AbstractPatriciaTrie.java\n@@ -537,8 +537,8 @@ private void removeInternalEntry(final TrieEntry<K, V> h) {\n             final TrieEntry<K, V> child = p.left == h ? p.right : p.left;\n \n             // if it was looping to itself previously,\n-            // it will now be pointed from it's parent\n-            // (if we aren't removing it's parent --\n+            // it will now be pointed from its parent\n+            // (if we aren't removing its parent --\n             //  in that case, it remains looping to itself).\n             // otherwise, it will continue to have the same\n             // predecessor.\n@@ -1381,7 +1381,7 @@ public String toString() {\n \n \n     /**\n-     * This is a entry set view of the {@link org.apache.commons.collections4.Trie} as returned by {@link Map#entrySet()}.\n+     * This is an entry set view of the {@link org.apache.commons.collections4.Trie} as returned by {@link Map#entrySet()}.\n      */\n     private class EntrySet extends AbstractSet<Map.Entry<K, V>> {\n \ndiff --git a/src/main/java/org/apache/commons/collections4/trie/UnmodifiableTrie.java b/src/main/java/org/apache/commons/collections4/trie/UnmodifiableTrie.java\nindex be5774e2ec..6ea3af0f60 100644\n--- a/src/main/java/org/apache/commons/collections4/trie/UnmodifiableTrie.java\n+++ b/src/main/java/org/apache/commons/collections4/trie/UnmodifiableTrie.java\n@@ -45,7 +45,7 @@ public class UnmodifiableTrie<K, V> implements Trie<K, V>, Serializable, Unmodif\n     private final Trie<K, V> delegate;\n \n     /**\n-     * Factory method to create a unmodifiable trie.\n+     * Factory method to create an unmodifiable trie.\n      *\n      * @param <K>  the key type\n      * @param <V>  the value type\ndiff --git a/src/site/xdoc/compatibility.xml b/src/site/xdoc/compatibility.xml\nindex 5a9fc62051..3be2690412 100644\n--- a/src/site/xdoc/compatibility.xml\n+++ b/src/site/xdoc/compatibility.xml\n@@ -68,7 +68,7 @@ changes were deliberate and have not caused any known issues.)\n \n <p>\n It is not possible to make v2.1 and v3.0 compatible without further binary incompatibility.\n-The chosen solution is to provide a work around by releasing v2.1.1 and v3.1.\n+The chosen solution is to provide a workaround by releasing v2.1.1 and v3.1.\n The following deprecations must be resolved in v2.1.1 to allow compatibility with v3.1.\n </p>\n <ul>\ndiff --git a/src/site/xdoc/history.xml b/src/site/xdoc/history.xml\nindex fb19a53f3a..a9335a90c5 100644\n--- a/src/site/xdoc/history.xml\n+++ b/src/site/xdoc/history.xml\n@@ -60,7 +60,7 @@ Thus there were now three packages, main, comparator and iterator.\n </p>\n \n <p>\n-<b>Collections 3.0</b> represented a re-birth of collections after an 18 month absence.\n+<b>Collections 3.0</b> represented a re-birth of collections after an 18-month absence.\n Many, many classes were added to CVS but not released including primitive and\n event-generating classes. In order to control the size of the collections distribution,\n these became two new projects - primitives and events.\n@@ -90,7 +90,7 @@ This patch was created as a work around, enabling 2.1.1 to be compatible with 3.\n \n <p>\n <b>Collections 3.1</b> fixed some bugs in 3.0 and adds a few new enhancements.\n-The most notable change is a new list implementation, TreeList, that is well balanced for insertions and removals at any index.\n+The most notable change is a new list implementation, TreeList, that is well-balanced for insertions and removals at any index.\n Other changes included more classes implementing Serializable and a ReferenceIdentityMap.\n </p>\n \ndiff --git a/src/site/xdoc/mail-lists.xml b/src/site/xdoc/mail-lists.xml\nindex 45704c9984..2385faad88 100644\n--- a/src/site/xdoc/mail-lists.xml\n+++ b/src/site/xdoc/mail-lists.xml\n@@ -152,7 +152,7 @@ limitations under the License.\n           <td>\n             <strong>Commons Commits List</strong>\n             <br /><br />\n-            Only for e-mails automatically generated by the <a href=\"scm.html\">source control</a> sytem.\n+            Only for e-mails automatically generated by the <a href=\"scm.html\">source control</a> system.\n             <br /><br />\n           </td>\n           <td><a href=\"mailto:commits-subscribe@commons.apache.org\">Subscribe</a></td>\ndiff --git a/src/site/xdoc/pick.xml b/src/site/xdoc/pick.xml\nindex 736af561e5..e53e656f2d 100644\n--- a/src/site/xdoc/pick.xml\n+++ b/src/site/xdoc/pick.xml\n@@ -168,7 +168,7 @@ The <a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/Map.html\">Map</\n </tr>\n <tr>\n <td><a href=\"https://commons.apache.org/proper/commons-collections/javadocs/api-4.4/org/apache/commons/collections4/map/StaticBucketMap.html\">StaticBucketMap</a></td>\n-<td>This map is optimised to work well in a heavily loaded multi-threaded environment. It provides synchronization internally, locking on a per 'bucket' basis, where the buckets are fixed at construction time. You should use this class if you can predict the size of the map and you are working in a very intensive multi-threaded environment.</td>\n+<td>This map is optimised to work well in a heavily loaded multithreaded environment. It provides synchronization internally, locking on a per 'bucket' basis, where the buckets are fixed at construction time. You should use this class if you can predict the size of the map and you are working in a very intensive multithreaded environment.</td>\n </tr>\n </table>\n </p>\ndiff --git a/src/site/xdoc/release_3_2.xml b/src/site/xdoc/release_3_2.xml\nindex 3ba50548e2..3c1d106739 100644\n--- a/src/site/xdoc/release_3_2.xml\n+++ b/src/site/xdoc/release_3_2.xml\n@@ -48,7 +48,7 @@ Please check the bug fixes to ensure you weren't relying on the behavior of a bu\n There are two new <i>deprecations</i>:<br />\n BeanMap is now deprecated and will be removed in 4.0.\n The class is now available in commons-beanutils (full jar version).\n-This change was made to ensure that all bean related collections were in one place (ie. beanutils).\n+This change was made to ensure that all bean related collections were in one place (i.e. beanutils).\n If this causes major headaches to anyone please contact commons-dev at jakarta.apache.org.\n </p>\n <p>\n@@ -73,13 +73,13 @@ If this causes major headaches to anyone please contact commons-dev at jakarta.a\n <ul>\n <li>CollectionUtils.addIgnoreNull - Adds to the collection if the value being added is not null [30020]</li>\n <li>MapUtils.putAll - Puts an array of key/value pairs into a map [30882]</li>\n-<li>CollectionUtils/MapUtils.isEmpty/isNotEmpty - Null-safe checks of collection emptyness [35890]</li>\n+<li>CollectionUtils/MapUtils.isEmpty/isNotEmpty - Null-safe checks of collection emptiness [35890]</li>\n <li>CollectionUtils.sizeIsEmpty - Checks if a collection, array, map, iterator or enumeration is empty</li>\n-<li>CollectionUtils/ListUtils - retainAll/removeAll that don't change original colllection</li>\n+<li>CollectionUtils/ListUtils - retainAll/removeAll that don't change original collection</li>\n <li>ExtendedProperties - Accepts List elements (does not enforce Vector) as values [36812]</li>\n <li>ExtendedProperties - new Methods getList(String key) and getList(String key, List defaults) [36812]</li>\n <li>ExtendedProperties - No longer uses an exception in normal processing [30497]</li>\n-<li>BlockingBuffer - now includes stack trace if InterupttedException occurs [33700]</li>\n+<li>BlockingBuffer - now includes stack trace if InterruptedException occurs [33700]</li>\n <li>BlockingBuffer - new methods that allow get and remove with a timeout, updated BufferUtils to match [27691]</li>\n <li>BlockingBuffer - now allows you to specify a default timeout value for get/remove operations [37607]</li>\n <li>TransformedMap/TransformedSortedMap - new factory decorateTransform() that transforms any existing entries in the map [30959]</li>\n@@ -88,7 +88,7 @@ If this causes major headaches to anyone please contact commons-dev at jakarta.a\n <li>ListOrderedMap - additional method, put(int,Object,Object)</li>\n <li>PriorityBuffer - now Serializable [36163]</li>\n <li>ListIteratorWrapper - now implements ResettableListIterator [39449]</li>\n-<li>IfClosure - add single argument constructor, updated CllosureUtils to match [38495]</li>\n+<li>IfClosure - add single argument constructor, updated ClosureUtils to match [38495]</li>\n <li>All/Any/One/None Predicate - allow construction with zero or one predicates [37979]</li>\n </ul>\n \n@@ -102,8 +102,8 @@ If this causes major headaches to anyone please contact commons-dev at jakarta.a\n <li>SetUniqueList.set(int,Object) - Destroyed set status in certain circumstances [33294]</li>\n <li>AbstractLinkedMap.init() - Now calls createEntry() to create the map entry object [33706]</li>\n <li>AbstractHashedMap deserialization - Fix to prevent doubling of internal data array [34265]</li>\n-<li>AbstractHashedMap initialization - Fix to setup threshold correctly, improving performance [35012]</li>\n-<li>BeanMap.initialize() - Internal variable now correctly initialised with only write methods that actually exist [15895]</li>\n+<li>AbstractHashedMap initialization - Fix to set up threshold correctly, improving performance [35012]</li>\n+<li>BeanMap.initialize() - Internal variable now correctly initialized with only write methods that actually exist [15895]</li>\n <li>MultiHashMap.remove(key, item) - Was returning the item even when nothing was removed [32366]</li>\n <li>MultiHashMap.putAll(multimap) - Was adding the collection as a single item rather than individually [35631]</li>\n <li>MultiHashMap - Enable compilation using J#</li>\n@@ -114,7 +114,7 @@ If this causes major headaches to anyone please contact commons-dev at jakarta.a\n <li>BoundedFifoBuffer/CircularFifoBuffer - Fix serialization to work in case where buffer serialized when full [31433]</li>\n <li>BoundedFifoBuffer - Fix iterator remove bug causing ArrayIndexOutOfBounds error [33071]</li>\n <li>UnboundedFifoBuffer - Fix iterator remove bug causing ArrayIndexOutOfBounds error [35733]</li>\n-<li>UnboundedFifoBuffer - Fix deserialization to work with subsequant object manipulation [35763]</li>\n+<li>UnboundedFifoBuffer - Fix deserialization to work with subsequent object manipulation [35763]</li>\n <li>BlockingBuffer - Fix internal locking code (internal fix, no effect on users of BlockingBuffer) [37028]</li>\n <li>IteratorChain.remove() - Fix to avoid IllegalStateException when one of the underlying iterators is a FilterIterator [34267]</li>\n <li>FilterIterator - Correctly handle setting of iterator and predicate after object creation [38074]</li>\ndiff --git a/src/site/xdoc/release_3_2_1.xml b/src/site/xdoc/release_3_2_1.xml\nindex 394bf7e6c9..3cc2b2dcac 100644\n--- a/src/site/xdoc/release_3_2_1.xml\n+++ b/src/site/xdoc/release_3_2_1.xml\n@@ -34,7 +34,7 @@ This project is Java 1.2 compatible, and does not use Java 5 generics.\n </p>\n <p>\n This 3.2.1 release is simply a re-packaging of the 3.2 release, with appropriate\n-OSGi meta data added to the jar's manifest file.\n+OSGi metadata added to the jar's manifest file.\n </p>\n <hr />\n \ndiff --git a/src/site/xdoc/release_3_2_2.xml b/src/site/xdoc/release_3_2_2.xml\nindex f6e754800b..374eb9f707 100644\n--- a/src/site/xdoc/release_3_2_2.xml\n+++ b/src/site/xdoc/release_3_2_2.xml\n@@ -38,7 +38,7 @@ disabled and will result in an exception when either trying to serialize or de-s\n an instance of these classes. For more details, please refer to COLLECTIONS-580.\n </p>\n <p>\n-All users are strongly encouraged to updated to this release.\n+All users are strongly encouraged to update to this release.\n </p>\n \n <h3>Compatibility</h3>\ndiff --git a/src/site/xdoc/release_4_0.xml b/src/site/xdoc/release_4_0.xml\nindex ba57040e9a..f5b0fc1c4a 100644\n--- a/src/site/xdoc/release_4_0.xml\n+++ b/src/site/xdoc/release_4_0.xml\n@@ -106,7 +106,7 @@ have changed.\n <li>PermutationIterator - generates unordered permutations of a collection. Thanks to Benoit Corne.</li>\n <li>SequencesComparator - an implementation of Eugene Myers difference algorithm in package o.a.c.c.sequence. Thanks to Jordane Sarda.</li>\n <li>LazyIteratorChain - a variant of IteratorChain which supports lazy initialization. Thanks to Jeff Rodriguez.</li>\n-<li>NodeListIterator - supports iteration over a org.w3c.dom.NodeList. Thanks to Thomas Vahrst.</li>\n+<li>NodeListIterator - supports iteration over an org.w3c.dom.NodeList. Thanks to Thomas Vahrst.</li>\n <li>CatchAndRethrowClosure - re-throws any checked exception as unchecked \"FunctorException\". Thanks to David J. M. Karlsen.</li>\n <li>IndexedCollection - collection decorator which provides a map-like view on an existing collection. Thanks to Stephen Kestle.</li>\n <li>DualLinkedHashBidiMap - bidi map implementation using LinkedHashMap instances. Thanks to Nathan Blomquist.</li>\n@@ -211,7 +211,7 @@ have changed.\n <li>Improved performance of \"AbstractMapBag#containsAll(Collection)\" by returning immediately after a difference has been found. Thanks to Adrian Nistor.</li>\n <li>Added additional clarification to javadoc of interface \"Put\" wrt return type of \"put(Object, Object)\" method. Thanks to Matt Benson, sebb.</li>\n <li>Tree traversal with a TreeListIterator will not be affected anymore by the removal of an element directly after a call to previous(). Thanks to Jeffrey Barnes.</li>\n-<li>Adapt and/or ignore several unit tests when run on a IBM J9 VM (specification version 1.6.0) due to a faulty \"java.util.TreeMap\" implementation.</li>\n+<li>Adapt and/or ignore several unit tests when run on an IBM J9 VM (specification version 1.6.0) due to a faulty \"java.util.TreeMap\" implementation.</li>\n <li>SetUniqueList.set(int, E) now works correctly if the object to be inserted is already placed at the given position. Thanks to Thomas Vahrst, John Vasileff.</li>\n <li>MultiKeyMap.clone() now correctly calls super.clone(). Thanks to Thomas Vahrst.</li>\n <li>Improve performance of \"TreeList#addAll\" and \"TreeList(Collection)\" by converting the input collection into an AVL tree and efficiently merge it into the existing tree. Thanks to Jeffrey Barnes.</li>\n@@ -262,7 +262,7 @@ have changed.\n <li>Use of final keyword where applicable, minor performance improvements by properly initializing the capacity of newly created collections when known in advance. Thanks to Peter Lawrey, Gary Gregory.</li>\n <li>\"SetUniqueList#subList()#contains(Object)\" will now correctly check the subList rather than the parent list. Thanks to Christian Semrau.</li>\n <li>\"SetUniqueList#set(int, Object)\" will now correctly enforce the uniqueness constraint. Thanks to Rafał Figas,Bjorn Townsend.</li>\n-<li>Improved javadoc for \"Unmodifiable*\" classes wrt behavior when the users tries to modify the collection. Thanks to Emmanuel Bourg.</li>\n+<li>Improved javadoc for \"Unmodifiable*\" classes wrt behavior when the user tries to modify the collection. Thanks to Emmanuel Bourg.</li>\n <li>\"CaseInsensitiveMap\" will now convert input strings to lower-case in a locale-independent manner. Thanks to Benjamin Bentmann.</li>\n <li>Fixed javadoc for \"ListUtils#transformedList(List)\" to clarify that existing objects in the list are not transformed. Thanks to Paul Benedict.</li>\n <li>\"MultiKey\" will now be correctly serialized/de-serialized. Thanks to Joerg Schaible.</li>\ndiff --git a/src/site/xdoc/release_4_1.xml b/src/site/xdoc/release_4_1.xml\nindex 8a16f20267..4d5e886e55 100644\n--- a/src/site/xdoc/release_4_1.xml\n+++ b/src/site/xdoc/release_4_1.xml\n@@ -37,7 +37,7 @@ completely removed (classes do not implement the Serializable interface anymore)\n For more details, please refer to COLLECTIONS-580.\n </p>\n <p>\n-All users are strongly encouraged to updated to this release.\n+All users are strongly encouraged to update to this release.\n </p>\n \n <h3>Compatibility</h3>\ndiff --git a/src/site/xdoc/release_4_2.xml b/src/site/xdoc/release_4_2.xml\nindex 6b04cd9322..2990411e52 100644\n--- a/src/site/xdoc/release_4_2.xml\n+++ b/src/site/xdoc/release_4_2.xml\n@@ -33,7 +33,7 @@ This 4.2 release is a minor and updates the platform requirement from Java 6 to\n This release fixes several bugs present in previous releases of the 4.X branch.\n </p>\n <p>\n-All users are strongly encouraged to updated to this release.\n+All users are strongly encouraged to update to this release.\n </p>\n \n <h3>Compatibility</h3>\ndiff --git a/src/site/xdoc/release_4_3.xml b/src/site/xdoc/release_4_3.xml\nindex a147dba4ec..3bfd094708 100644\n--- a/src/site/xdoc/release_4_3.xml\n+++ b/src/site/xdoc/release_4_3.xml\n@@ -33,7 +33,7 @@ This 4.3 release is a minor and updates the platform requirement from Java 7 to\n This release fixes several bugs present in previous releases of the 4.X branch.\n </p>\n <p>\n-All users are strongly encouraged to updated to this release.\n+All users are strongly encouraged to update to this release.\n </p>\n \n <h3>Compatibility</h3>\ndiff --git a/src/site/xdoc/release_4_4.xml b/src/site/xdoc/release_4_4.xml\nindex a5e8d09fe2..0e418c04f8 100644\n--- a/src/site/xdoc/release_4_4.xml\n+++ b/src/site/xdoc/release_4_4.xml\n@@ -33,7 +33,7 @@ This 4.4 release is a minor and requires Java 8.\n This release fixes several bugs present in previous releases of the 4.x branch.\n </p>\n <p>\n-All users are strongly encouraged to updated to this release.\n+All users are strongly encouraged to update to this release.\n </p>\n \n <h3>Compatibility</h3>\ndiff --git a/src/site/xdoc/security-reports.xml b/src/site/xdoc/security-reports.xml\nindex 2e2e8322bb..ab3a746b5f 100644\n--- a/src/site/xdoc/security-reports.xml\n+++ b/src/site/xdoc/security-reports.xml\n@@ -106,7 +106,7 @@\n         </subsection>\n       </section>\n \n-      <section name=\"Errors and Ommissions\">\n+      <section name=\"Errors and Omissions\">\n         <p>Please report any errors or omissions to <a\n         href=\"mail-lists.html\">the dev mailing list</a>.</p>\n       </section>\ndiff --git a/src/site/xdoc/userguide.xml b/src/site/xdoc/userguide.xml\nindex 77d2161438..1deff1ce42 100644\n--- a/src/site/xdoc/userguide.xml\n+++ b/src/site/xdoc/userguide.xml\n@@ -53,7 +53,7 @@ multithreaded application.\n   <p>\n The class level javadocs should indicate whether a particular\n implementation is safe for multithreaded access without additional\n-synchronization. Where there is no expicit indication that the implementation\n+synchronization. Where there is no explicit indication that the implementation\n is thread safe then it should be assumed that synchronization is required.\n Please report the missing documentation to the commons development team.\n </p>\n@@ -122,7 +122,7 @@ map.nextKey(\"SIX\");  // returns \"SEVEN\"\n \n <p>\n A new interface hierarchy has been added to support bidirectional maps - <code>BidiMap.</code>\n-These represent maps where the key can lookup the value and the value can lookup the key with equal ease.\n+These represent maps where the key can lookup the value and the value can look up the key with equal ease.\n </p>\n <source>\n BidiMap bidi = new TreeBidiMap();\n",
  "test_patch" : "diff --git a/src/test/java/org/apache/commons/collections4/AbstractObjectTest.java b/src/test/java/org/apache/commons/collections4/AbstractObjectTest.java\nindex 9c63cd9e74..eebd01345f 100644\n--- a/src/test/java/org/apache/commons/collections4/AbstractObjectTest.java\n+++ b/src/test/java/org/apache/commons/collections4/AbstractObjectTest.java\n@@ -170,8 +170,8 @@ public void testSerializeDeserializeThenCompare() throws Exception {\n     public void testSimpleSerialization() throws Exception {\n         final Object o = makeObject();\n         if (o instanceof Serializable && isTestSerialization()) {\n-            final byte[] objekt = writeExternalFormToBytes((Serializable) o);\n-            readExternalFormFromBytes(objekt);\n+            final byte[] object = writeExternalFormToBytes((Serializable) o);\n+            readExternalFormFromBytes(object);\n         }\n     }\n \ndiff --git a/src/test/java/org/apache/commons/collections4/BulkTest.java b/src/test/java/org/apache/commons/collections4/BulkTest.java\nindex 34a747aa5b..bc3ddb44ed 100644\n--- a/src/test/java/org/apache/commons/collections4/BulkTest.java\n+++ b/src/test/java/org/apache/commons/collections4/BulkTest.java\n@@ -31,8 +31,8 @@\n  * A {@link TestCase} that can define both simple and bulk test methods.\n  * <p>\n  * A <I>simple test method</I> is the type of test traditionally\n- * supplied by by {@link TestCase}.  To define a simple test, create a public\n- * no-argument method whose name starts with \"test\".  You can specify the\n+ * supplied by {@link TestCase}.  To define a simple test, create a public\n+ * no-argument method whose name starts with \"test\".  You can specify\n  * the name of simple test in the constructor of {@code BulkTest};\n  * a subsequent call to {@link TestCase#run} will run that simple test.\n  * <p>\ndiff --git a/src/test/java/org/apache/commons/collections4/ListUtilsTest.java b/src/test/java/org/apache/commons/collections4/ListUtilsTest.java\nindex 12d552584b..04b9a190ed 100644\n--- a/src/test/java/org/apache/commons/collections4/ListUtilsTest.java\n+++ b/src/test/java/org/apache/commons/collections4/ListUtilsTest.java\n@@ -123,7 +123,7 @@ public void testHashCode() {\n     }\n \n     /**\n-     * Tests the {@code indexOf} method in {@code ListUtils} class..\n+     * Tests the {@code indexOf} method in {@code ListUtils} class.\n      */\n     @Test\n     public void testIndexOf() {\n@@ -165,7 +165,7 @@ public void testIntersectionOrderInsensitivity() {\n     }\n \n     /**\n-     * Tests intersecting a non-empty list with an subset of itself.\n+     * Tests intersecting a non-empty list with a subset of itself.\n      */\n     @Test\n     public void testIntersectListWithNoOverlapAndDifferentTypes() {\n@@ -183,7 +183,7 @@ public void testIntersectListWithSelf() {\n     }\n \n     /**\n-     * Tests intersecting a non-empty list with an subset of itself.\n+     * Tests intersecting a non-empty list with a subset of itself.\n      */\n     @Test\n     public void testIntersectNonEmptySubset() {\ndiff --git a/src/test/java/org/apache/commons/collections4/SplitMapUtilsTest.java b/src/test/java/org/apache/commons/collections4/SplitMapUtilsTest.java\nindex d5d6e080ba..0085ae5c23 100644\n--- a/src/test/java/org/apache/commons/collections4/SplitMapUtilsTest.java\n+++ b/src/test/java/org/apache/commons/collections4/SplitMapUtilsTest.java\n@@ -135,7 +135,7 @@ public void testWritableMap() {\n         map.put(\"new\", \"66\");\n         assertEquals(++sz, backingMap.size());\n \n-        // putall\n+        // putAll\n         final Map<String, String> more = new HashMap<>();\n         more.put(\"foo\", \"77\");\n         more.put(\"bar\", \"88\");\ndiff --git a/src/test/java/org/apache/commons/collections4/bag/AbstractSortedBagTest.java b/src/test/java/org/apache/commons/collections4/bag/AbstractSortedBagTest.java\nindex f1fa526f61..fc2040ed47 100644\n--- a/src/test/java/org/apache/commons/collections4/bag/AbstractSortedBagTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bag/AbstractSortedBagTest.java\n@@ -43,18 +43,18 @@ public void verify() {\n \n         // Check that iterator returns elements in order and first() and last()\n         // are consistent\n-        final Iterator<T> colliter = getCollection().iterator();\n-        final Iterator<T> confiter = getConfirmed().iterator();\n+        final Iterator<T> collIter = getCollection().iterator();\n+        final Iterator<T> confIter = getConfirmed().iterator();\n         T first = null;\n         T last = null;\n-        while (colliter.hasNext()) {\n+        while (collIter.hasNext()) {\n             if (first == null) {\n-                first = colliter.next();\n+                first = collIter.next();\n                 last = first;\n             } else {\n-                last = colliter.next();\n+                last = collIter.next();\n             }\n-            assertEquals(\"Element appears to be out of order.\", last, confiter.next());\n+            assertEquals(\"Element appears to be out of order.\", last, confIter.next());\n         }\n         if (!getCollection().isEmpty()) {\n             assertEquals(\"Incorrect element returned by first().\", first,\ndiff --git a/src/test/java/org/apache/commons/collections4/bag/PredicatedBagTest.java b/src/test/java/org/apache/commons/collections4/bag/PredicatedBagTest.java\nindex 82a165720c..908bb42de6 100644\n--- a/src/test/java/org/apache/commons/collections4/bag/PredicatedBagTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bag/PredicatedBagTest.java\n@@ -68,7 +68,7 @@ protected int getIterationBehaviour() {\n \n     @Test\n     @SuppressWarnings(\"unchecked\")\n-    public void testlegalAddRemove() {\n+    public void testLegalAddRemove() {\n         final Bag<T> bag = makeTestBag();\n         assertEquals(0, bag.size());\n         final T[] els = (T[]) new Object[] { \"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"1\" };\ndiff --git a/src/test/java/org/apache/commons/collections4/collection/AbstractCollectionTest.java b/src/test/java/org/apache/commons/collections4/collection/AbstractCollectionTest.java\nindex 7add046530..9cb9172c9d 100644\n--- a/src/test/java/org/apache/commons/collections4/collection/AbstractCollectionTest.java\n+++ b/src/test/java/org/apache/commons/collections4/collection/AbstractCollectionTest.java\n@@ -395,7 +395,7 @@ public Map.Entry<E, E> cloneMapEntry(final Map.Entry<E, E> entry) {\n      *  Returns an array of objects that are contained in a collection\n      *  produced by {@link #makeFullCollection()}.  Every element in the\n      *  returned array <I>must</I> be an element in a full collection.<P>\n-     *  The default implementation returns a heterogenous array of\n+     *  The default implementation returns a heterogeneous array of\n      *  objects with some duplicates. null is added if allowed.\n      *  Override if you require specific testing elements.  Note that if you\n      *  override {@link #makeFullCollection()}, you <I>must</I> override\n@@ -415,7 +415,7 @@ public E[] getFullElements() {\n      *  Returns an array of elements that are <I>not</I> contained in a\n      *  full collection.  Every element in the returned array must\n      *  not exist in a collection returned by {@link #makeFullCollection()}.\n-     *  The default implementation returns a heterogenous array of elements\n+     *  The default implementation returns a heterogeneous array of elements\n      *  without null.  Note that some of the tests add these elements\n      *  to an empty or full collection, so if your collection restricts\n      *  certain kinds of elements, you should override this method.\n@@ -480,7 +480,7 @@ public E[] getOtherNonNullElements() {\n      *  Returns a list of string elements suitable for return by\n      *  {@link #getFullElements()}.  Override getFullElements to return\n      *  the results of this method if your collection does not support\n-     *  heterogenous elements or the null element.\n+     *  heterogeneous elements or the null element.\n      */\n     public Object[] getFullNonNullStringElements() {\n         return new Object[] {\n@@ -493,7 +493,7 @@ public Object[] getFullNonNullStringElements() {\n      *  Returns a list of string elements suitable for return by\n      *  {@link #getOtherElements()}.  Override getOtherElements to return\n      *  the results of this method if your collection does not support\n-     *  heterogenous elements or the null element.\n+     *  heterogeneous elements or the null element.\n      */\n     public Object[] getOtherNonNullStringElements() {\n         return new Object[] {\ndiff --git a/src/test/java/org/apache/commons/collections4/comparators/ComparatorChainTest.java b/src/test/java/org/apache/commons/collections4/comparators/ComparatorChainTest.java\nindex 75988486d4..0b87e516b4 100644\n--- a/src/test/java/org/apache/commons/collections4/comparators/ComparatorChainTest.java\n+++ b/src/test/java/org/apache/commons/collections4/comparators/ComparatorChainTest.java\n@@ -95,7 +95,7 @@ public void testBadListComparatorChain() {\n     }\n \n     @Test\n-    public void testComparatorChainOnMinvaluedCompatator() {\n+    public void testComparatorChainOnMinValuedComparator() {\n         // -1 * Integer.MIN_VALUE is less than 0,\n         // test that ComparatorChain handles this edge case correctly\n         final ComparatorChain<Integer> chain = new ComparatorChain<>();\ndiff --git a/src/test/java/org/apache/commons/collections4/comparators/ReverseComparatorTest.java b/src/test/java/org/apache/commons/collections4/comparators/ReverseComparatorTest.java\nindex 8be79d2275..7c6a99bf9f 100644\n--- a/src/test/java/org/apache/commons/collections4/comparators/ReverseComparatorTest.java\n+++ b/src/test/java/org/apache/commons/collections4/comparators/ReverseComparatorTest.java\n@@ -43,7 +43,7 @@ public ReverseComparatorTest() {\n      * Comparator.  The resulting comparator should\n      * sort according to natural Order.  (Note: we wrap\n      * a Comparator taken from the JDK so that we can\n-     * save a \"canonical\" form in SCM.\n+     * save a \"canonical\" form in SCM).\n      *\n      * @return Comparator that returns \"natural\" order\n      */\ndiff --git a/src/test/java/org/apache/commons/collections4/iterators/FilterIteratorTest.java b/src/test/java/org/apache/commons/collections4/iterators/FilterIteratorTest.java\nindex b2c03ffa7a..b0172f2183 100644\n--- a/src/test/java/org/apache/commons/collections4/iterators/FilterIteratorTest.java\n+++ b/src/test/java/org/apache/commons/collections4/iterators/FilterIteratorTest.java\n@@ -63,7 +63,7 @@ public void tearDown() throws Exception {\n     }\n \n     /**\n-     * Returns an full iterator wrapped in a\n+     * Returns a full iterator wrapped in a\n      * FilterIterator that blocks all the elements\n      *\n      * @return \"empty\" FilterIterator\ndiff --git a/src/test/java/org/apache/commons/collections4/iterators/ListIteratorWrapper2Test.java b/src/test/java/org/apache/commons/collections4/iterators/ListIteratorWrapper2Test.java\nindex 610ae52d2e..191d34b569 100644\n--- a/src/test/java/org/apache/commons/collections4/iterators/ListIteratorWrapper2Test.java\n+++ b/src/test/java/org/apache/commons/collections4/iterators/ListIteratorWrapper2Test.java\n@@ -28,7 +28,7 @@\n import static org.junit.jupiter.api.Assertions.assertThrows;\n \n /**\n- * Tests the ListIteratorWrapper to insure that it behaves as expected when wrapping a ListIterator.\n+ * Tests the ListIteratorWrapper to ensure that it behaves as expected when wrapping a ListIterator.\n  */\n public class ListIteratorWrapper2Test<E> extends AbstractIteratorTest<E> {\n \n@@ -190,7 +190,7 @@ public void testReset() {\n         assertEquals(\"First element should be the same\", first, iter.next());\n         assertEquals(\"Second element should be the same\", second, iter.next());\n \n-        // after passing the point, where we resetted, continuation should work as expected\n+        // after passing the point, where we reset, continuation should work as expected\n         for (int i = 2; i < testArray.length; i++) {\n             final Object testValue = testArray[i];\n             final E iterValue = iter.next();\ndiff --git a/src/test/java/org/apache/commons/collections4/iterators/ListIteratorWrapperTest.java b/src/test/java/org/apache/commons/collections4/iterators/ListIteratorWrapperTest.java\nindex b986d22f05..20cbebe0a8 100644\n--- a/src/test/java/org/apache/commons/collections4/iterators/ListIteratorWrapperTest.java\n+++ b/src/test/java/org/apache/commons/collections4/iterators/ListIteratorWrapperTest.java\n@@ -28,7 +28,7 @@\n import org.junit.jupiter.api.Test;\n \n /**\n- * Tests the ListIteratorWrapper to insure that it simulates\n+ * Tests the ListIteratorWrapper to ensure that it simulates\n  * a ListIterator correctly.\n  */\n public class ListIteratorWrapperTest<E> extends AbstractIteratorTest<E> {\n@@ -212,7 +212,7 @@ public void testReset() {\n         assertEquals(\"First element should be the same\", first, iter.next());\n         assertEquals(\"Second element should be the same\", second, iter.next());\n \n-        // after passing the point, where we resetted, continuation should work as expected\n+        // after passing the point, where we reset, continuation should work as expected\n         for (int i = 2; i < testArray.length; i++) {\n             final Object testValue = testArray[i];\n             final E iterValue = iter.next();\ndiff --git a/src/test/java/org/apache/commons/collections4/list/AbstractListTest.java b/src/test/java/org/apache/commons/collections4/list/AbstractListTest.java\nindex 607dc10600..cfc85fe3e6 100644\n--- a/src/test/java/org/apache/commons/collections4/list/AbstractListTest.java\n+++ b/src/test/java/org/apache/commons/collections4/list/AbstractListTest.java\n@@ -285,7 +285,7 @@ public void testListEquals() {\n \n         list2 = Arrays.asList(getFullElements());\n         if (list2.size() < 2 && isAddSupported()) {\n-            // main list is only size 1, so lets add other elements to get a better list\n+            // main list is only size 1, so let's add other elements to get a better list\n             list.addAll(Arrays.asList(getOtherElements()));\n             getConfirmed().addAll(Arrays.asList(getOtherElements()));\n             list2 = new ArrayList<>(list2);\ndiff --git a/src/test/java/org/apache/commons/collections4/list/CursorableLinkedListTest.java b/src/test/java/org/apache/commons/collections4/list/CursorableLinkedListTest.java\nindex bf94a1a1f5..3e906bab02 100644\n--- a/src/test/java/org/apache/commons/collections4/list/CursorableLinkedListTest.java\n+++ b/src/test/java/org/apache/commons/collections4/list/CursorableLinkedListTest.java\n@@ -1432,8 +1432,8 @@ public void testSerialization() throws Exception {\n         out.flush();\n         out.close();\n \n-        final java.io.ByteArrayInputStream bufin = new java.io.ByteArrayInputStream(buf.toByteArray());\n-        final java.io.ObjectInputStream in = new java.io.ObjectInputStream(bufin);\n+        final java.io.ByteArrayInputStream bufIn = new java.io.ByteArrayInputStream(buf.toByteArray());\n+        final java.io.ObjectInputStream in = new java.io.ObjectInputStream(bufIn);\n         final Object list2 = in.readObject();\n \n         assertNotSame(list, list2);\ndiff --git a/src/test/java/org/apache/commons/collections4/list/TreeListTest.java b/src/test/java/org/apache/commons/collections4/list/TreeListTest.java\nindex 88f59a616d..a18ebcbc44 100644\n--- a/src/test/java/org/apache/commons/collections4/list/TreeListTest.java\n+++ b/src/test/java/org/apache/commons/collections4/list/TreeListTest.java\n@@ -228,7 +228,7 @@ public void testBug35258() {\n         treelist.add(Integer.valueOf(3));\n         treelist.add(Integer.valueOf(4));\n \n-        // this cause inconsistence of ListIterator()\n+        // this cause inconsistency in ListIterator()\n         treelist.remove(objectToRemove);\n \n         final ListIterator<Integer> li = treelist.listIterator();\ndiff --git a/src/test/java/org/apache/commons/collections4/map/AbstractMapTest.java b/src/test/java/org/apache/commons/collections4/map/AbstractMapTest.java\nindex ea28f3d403..0fbf5a573c 100644\n--- a/src/test/java/org/apache/commons/collections4/map/AbstractMapTest.java\n+++ b/src/test/java/org/apache/commons/collections4/map/AbstractMapTest.java\n@@ -342,7 +342,7 @@ protected <E> List<E> getAsList(final Object[] o) {\n      * {@link #getOtherKeys()} or {@link #getOtherValues}.\n      *\n      * <p>Override getOtherElements to return the results of this method if your\n-     * collection does not support heterogenous elements or the null element.\n+     * collection does not support heterogeneous elements or the null element.\n      * </p>\n      */\n     public Object[] getOtherNonNullStringElements() {\n@@ -374,7 +374,7 @@ public V[] getSampleValues() {\n     }\n \n     /**\n-     * Returns a the set of values that can be used to replace the values\n+     * Returns a set of values that can be used to replace the values\n      * returned from {@link #getSampleValues()}.  This method must return an\n      * array with the same length as {@link #getSampleValues()}.  The values\n      * returned from this method should not be the same as those returned from\n@@ -604,7 +604,7 @@ public void testMapSize() {\n     }\n \n     /**\n-     * Tests {@link Map#clear()}.  If the map {@link #isRemoveSupported()}\n+     * Tests {@link Map#clear()}.  If the map {@link #isRemoveSupported()\n      * can add and remove elements}, then {@link Map#size()} and\n      * {@link Map#isEmpty()} are used to ensure that map has no elements after\n      * a call to clear.  If the map does not support adding and removing\ndiff --git a/src/test/java/org/apache/commons/collections4/map/MultiValueMapTest.java b/src/test/java/org/apache/commons/collections4/map/MultiValueMapTest.java\nindex 6c38128804..2d23384a61 100644\n--- a/src/test/java/org/apache/commons/collections4/map/MultiValueMapTest.java\n+++ b/src/test/java/org/apache/commons/collections4/map/MultiValueMapTest.java\n@@ -487,7 +487,7 @@ public void testFullMapCompatibility() throws Exception {\n         final Map<?, ?> map2 = (Map<?, ?>) readExternalFormFromDisk(getCanonicalFullCollectionName(map));\n         assertEquals(\"Map is the right size\", map.size(), map2.size());\n         for (final Object key : map.keySet()) {\n-            assertEquals( \"Map had inequal elements\", map.get(key), map2.get(key) );\n+            assertEquals( \"Map had unequal elements\", map.get(key), map2.get(key) );\n             map2.remove(key);\n         }\n         assertEquals(\"Map had extra values\", 0, map2.size());\ndiff --git a/src/test/java/org/apache/commons/collections4/map/SingletonMapTest.java b/src/test/java/org/apache/commons/collections4/map/SingletonMapTest.java\nindex acb508324f..2420255ed1 100644\n--- a/src/test/java/org/apache/commons/collections4/map/SingletonMapTest.java\n+++ b/src/test/java/org/apache/commons/collections4/map/SingletonMapTest.java\n@@ -44,7 +44,7 @@ public static junit.framework.Test suite() {\n \n     @Override\n     public OrderedMap<K, V> makeObject() {\n-        // need an empty singleton map, but thats not possible\n+        // need an empty singleton map, but that's not possible\n         // use a ridiculous fake instead to make the tests pass\n         return UnmodifiableOrderedMap.unmodifiableOrderedMap(ListOrderedMap.listOrderedMap(new HashMap<K, V>()));\n     }\n@@ -52,7 +52,7 @@ public OrderedMap<K, V> makeObject() {\n     @Override\n     public String[] ignoredTests() {\n         // the ridiculous map above still doesn't pass these tests\n-        // but its not relevant, so we ignore them\n+        // but it's not relevant, so we ignore them\n         return new String[] {\n             \"SingletonMapTest.bulkTestMapIterator.testEmptyMapIterator\",\n             \"SingletonMapTest.bulkTestOrderedMapIterator.testEmptyMapIterator\",\ndiff --git a/src/test/java/org/apache/commons/collections4/set/AbstractNavigableSetTest.java b/src/test/java/org/apache/commons/collections4/set/AbstractNavigableSetTest.java\nindex 765d5c72b5..1cfb5c1e8e 100644\n--- a/src/test/java/org/apache/commons/collections4/set/AbstractNavigableSetTest.java\n+++ b/src/test/java/org/apache/commons/collections4/set/AbstractNavigableSetTest.java\n@@ -78,12 +78,12 @@ public void verify() {\n \n         // Check that descending iterator returns elements in order and higher(), lower(),\n         // floor() and ceiling() are consistent\n-        final Iterator<E> colliter = getCollection().descendingIterator();\n-        final Iterator<E> confiter = getConfirmed().descendingIterator();\n-        while (colliter.hasNext()) {\n-            final E element = colliter.next();\n-            final E confelement = confiter.next();\n-            assertEquals(\"Element appears to be out of order.\", confelement, element);\n+        final Iterator<E> collIter = getCollection().descendingIterator();\n+        final Iterator<E> confIter = getConfirmed().descendingIterator();\n+        while (collIter.hasNext()) {\n+            final E element = collIter.next();\n+            final E confElement = confIter.next();\n+            assertEquals(\"Element appears to be out of order.\", confElement, element);\n \n             assertEquals(\"Incorrect element returned by higher().\", getConfirmed().higher(element),\n                                                                     getCollection().higher(element));\n@@ -137,9 +137,9 @@ public E[] getOtherNonNullElements() {\n     public BulkTest bulkTestNavigableSetSubSet() {\n         final int length = getFullElements().length;\n \n-        final int lobound = length / 3;\n-        final int hibound = lobound * 2;\n-        return new TestNavigableSetSubSet(lobound, hibound, false);\n+        final int loBound = length / 3;\n+        final int hiBound = loBound * 2;\n+        return new TestNavigableSetSubSet(loBound, hiBound, false);\n     }\n \n     /**\n@@ -153,9 +153,9 @@ public BulkTest bulkTestNavigableSetSubSet() {\n     public BulkTest bulkTestNavigableSetHeadSet() {\n         final int length = getFullElements().length;\n \n-        final int lobound = length / 3;\n-        final int hibound = lobound * 2;\n-        return new TestNavigableSetSubSet(hibound, true, true);\n+        final int loBound = length / 3;\n+        final int hiBound = loBound * 2;\n+        return new TestNavigableSetSubSet(hiBound, true, true);\n     }\n \n     /**\n@@ -168,8 +168,8 @@ public BulkTest bulkTestNavigableSetHeadSet() {\n      */\n     public BulkTest bulkTestNavigableSetTailSet() {\n         final int length = getFullElements().length;\n-        final int lobound = length / 3;\n-        return new TestNavigableSetSubSet(lobound, false, false);\n+        final int loBound = length / 3;\n+        return new TestNavigableSetSubSet(loBound, false, false);\n     }\n \n     public class TestNavigableSetSubSet extends AbstractNavigableSetTest<E> {\n@@ -199,33 +199,33 @@ public TestNavigableSetSubSet(final int bound, final boolean head, final boolean\n                 type = TYPE_TAILSET;\n                 m_Inclusive = inclusive;\n                 lowBound = bound;\n-                final Object[] allelements = AbstractNavigableSetTest.this.getFullElements();\n+                final Object[] allElements = AbstractNavigableSetTest.this.getFullElements();\n                 final int realBound = inclusive ? bound : bound + 1;\n-                fullElements = (E[]) new Object[allelements.length - realBound];\n-                System.arraycopy(allelements, realBound, fullElements, 0, allelements.length - realBound);\n-                otherElements = (E[]) new Object[allelements.length - bound - 1];\n+                fullElements = (E[]) new Object[allElements.length - realBound];\n+                System.arraycopy(allElements, realBound, fullElements, 0, allElements.length - realBound);\n+                otherElements = (E[]) new Object[allElements.length - bound - 1];\n                 System.arraycopy(//src src_pos dst dst_pos length\n-                    AbstractNavigableSetTest.this.getOtherElements(), bound, otherElements, 0, allelements.length - bound - 1);\n+                    AbstractNavigableSetTest.this.getOtherElements(), bound, otherElements, 0, allElements.length - bound - 1);\n             }\n \n         } //type\n \n         @SuppressWarnings(\"unchecked\")\n-        public TestNavigableSetSubSet(final int lobound, final int hibound, final boolean inclusive) {\n+        public TestNavigableSetSubSet(final int loBound, final int hiBound, final boolean inclusive) {\n             super(\"TestNavigableSetSubSet\");\n             type = TYPE_SUBSET;\n-            lowBound = lobound;\n-            highBound = hibound;\n+            lowBound = loBound;\n+            highBound = hiBound;\n             m_Inclusive = inclusive;\n \n-            final int fullLoBound = inclusive ? lobound : lobound + 1;\n-            final int length = hibound - lobound + 1 - (inclusive ? 0 : 2);\n+            final int fullLoBound = inclusive ? loBound : loBound + 1;\n+            final int length = hiBound - loBound + 1 - (inclusive ? 0 : 2);\n             fullElements = (E[]) new Object[length];\n             System.arraycopy(AbstractNavigableSetTest.this.getFullElements(), fullLoBound, fullElements, 0, length);\n-            final int otherLength = hibound - lobound;\n+            final int otherLength = hiBound - loBound;\n             otherElements = (E[]) new Object[otherLength - 1];\n             System.arraycopy(//src src_pos dst dst_pos length\n-                AbstractNavigableSetTest.this.getOtherElements(), lobound, otherElements, 0, otherLength - 1);\n+                AbstractNavigableSetTest.this.getOtherElements(), loBound, otherElements, 0, otherLength - 1);\n         }\n \n         @Override\ndiff --git a/src/test/java/org/apache/commons/collections4/set/AbstractSortedSetTest.java b/src/test/java/org/apache/commons/collections4/set/AbstractSortedSetTest.java\nindex 1f8fd4cfb1..b8ed7af145 100644\n--- a/src/test/java/org/apache/commons/collections4/set/AbstractSortedSetTest.java\n+++ b/src/test/java/org/apache/commons/collections4/set/AbstractSortedSetTest.java\n@@ -53,18 +53,18 @@ public void verify() {\n \n         // Check that iterator returns elements in order and first() and last()\n         // are consistent\n-        final Iterator<E> colliter = getCollection().iterator();\n-        final Iterator<E> confiter = getConfirmed().iterator();\n+        final Iterator<E> collIter = getCollection().iterator();\n+        final Iterator<E> confIter = getConfirmed().iterator();\n         E first = null;\n         E last = null;\n-        while (colliter.hasNext()) {\n+        while (collIter.hasNext()) {\n             if (first == null) {\n-                first = colliter.next();\n+                first = collIter.next();\n                 last = first;\n             } else {\n-                last = colliter.next();\n+                last = collIter.next();\n             }\n-            assertEquals(\"Element appears to be out of order.\", last, confiter.next());\n+            assertEquals(\"Element appears to be out of order.\", last, confIter.next());\n         }\n         if (!getCollection().isEmpty()) {\n             assertEquals(\"Incorrect element returned by first().\", first,\n@@ -145,9 +145,9 @@ public E[] getOtherNonNullElements() {\n     public BulkTest bulkTestSortedSetSubSet() {\n         final int length = getFullElements().length;\n \n-        final int lobound = length / 3;\n-        final int hibound = lobound * 2;\n-        return new TestSortedSetSubSet(lobound, hibound);\n+        final int loBound = length / 3;\n+        final int hiBound = loBound * 2;\n+        return new TestSortedSetSubSet(loBound, hiBound);\n \n     }\n \n@@ -162,9 +162,9 @@ public BulkTest bulkTestSortedSetSubSet() {\n     public BulkTest bulkTestSortedSetHeadSet() {\n         final int length = getFullElements().length;\n \n-        final int lobound = length / 3;\n-        final int hibound = lobound * 2;\n-        return new TestSortedSetSubSet(hibound, true);\n+        final int loBound = length / 3;\n+        final int hiBound = loBound * 2;\n+        return new TestSortedSetSubSet(hiBound, true);\n     }\n \n     /**\n@@ -177,8 +177,8 @@ public BulkTest bulkTestSortedSetHeadSet() {\n      */\n     public BulkTest bulkTestSortedSetTailSet() {\n         final int length = getFullElements().length;\n-        final int lobound = length / 3;\n-        return new TestSortedSetSubSet(lobound, false);\n+        final int loBound = length / 3;\n+        return new TestSortedSetSubSet(loBound, false);\n     }\n \n     public class TestSortedSetSubSet extends AbstractSortedSetTest<E> {\n@@ -207,13 +207,13 @@ public TestSortedSetSubSet(final int bound, final boolean head) {\n                 //System.out.println(\"TAILSET\");\n                 m_Type = TYPE_TAILSET;\n                 m_LowBound = bound;\n-                final Object[] allelements = AbstractSortedSetTest.this.getFullElements();\n-                //System.out.println(\"bound = \"+bound +\"::length=\"+allelements.length);\n-                m_FullElements = (E[]) new Object[allelements.length - bound];\n-                System.arraycopy(allelements, bound, m_FullElements, 0, allelements.length - bound);\n-                m_OtherElements = (E[]) new Object[allelements.length - bound - 1];\n+                final Object[] allElements = AbstractSortedSetTest.this.getFullElements();\n+                //System.out.println(\"bound = \"+bound +\"::length=\"+allElements.length);\n+                m_FullElements = (E[]) new Object[allElements.length - bound];\n+                System.arraycopy(allElements, bound, m_FullElements, 0, allElements.length - bound);\n+                m_OtherElements = (E[]) new Object[allElements.length - bound - 1];\n                 System.arraycopy(//src src_pos dst dst_pos length\n-                    AbstractSortedSetTest.this.getOtherElements(), bound, m_OtherElements, 0, allelements.length - bound - 1);\n+                    AbstractSortedSetTest.this.getOtherElements(), bound, m_OtherElements, 0, allElements.length - bound - 1);\n                 //System.out.println(new TreeSet(Arrays.asList(m_FullElements)));\n                 //System.out.println(new TreeSet(Arrays.asList(m_OtherElements)));\n                 //resetFull();\n@@ -225,19 +225,19 @@ public TestSortedSetSubSet(final int bound, final boolean head) {\n         } //type\n \n         @SuppressWarnings(\"unchecked\")\n-        public TestSortedSetSubSet(final int lobound, final int hibound) {\n+        public TestSortedSetSubSet(final int loBound, final int hiBound) {\n             super(\"TestSortedSetSubSet\");\n             //System.out.println(\"SUBSET\");\n             m_Type = TYPE_SUBSET;\n-            m_LowBound = lobound;\n-            m_HighBound = hibound;\n-            final int length = hibound - lobound;\n-            //System.out.println(\"Low=\" + lobound + \"::High=\" + hibound + \"::Length=\" + length);\n+            m_LowBound = loBound;\n+            m_HighBound = hiBound;\n+            final int length = hiBound - loBound;\n+            //System.out.println(\"Low=\" + loBound + \"::High=\" + hiBound + \"::Length=\" + length);\n             m_FullElements = (E[]) new Object[length];\n-            System.arraycopy(AbstractSortedSetTest.this.getFullElements(), lobound, m_FullElements, 0, length);\n+            System.arraycopy(AbstractSortedSetTest.this.getFullElements(), loBound, m_FullElements, 0, length);\n             m_OtherElements = (E[]) new Object[length - 1];\n             System.arraycopy(//src src_pos dst dst_pos length\n-                AbstractSortedSetTest.this.getOtherElements(), lobound, m_OtherElements, 0, length - 1);\n+                AbstractSortedSetTest.this.getOtherElements(), loBound, m_OtherElements, 0, length - 1);\n \n             //System.out.println(new TreeSet(Arrays.asList(m_FullElements)));\n             //System.out.println(new TreeSet(Arrays.asList(m_OtherElements)));\n",
  "problem_statement" : "Fix minor typos\n\nFix various minor typos in :\r\n\r\n- project documentations,\r\n- javadoc and comments,\r\n- method attribute and variable names,\r\n- test method names.",
  "hints_text" : null,
  "created_at" : "Sat Jul 16 10:22:35 CEST 2022",
  "version" : null,
  "FAIL_TO_PASS" : [ "FilterIteratorTest", "MultiValueMapTest", "TreeListTest", "AbstractSortedSetTest", "SingletonMapTest", "AbstractSortedBagTest", "ReverseComparatorTest", "CursorableLinkedListTest", "AbstractNavigableSetTest", "PredicatedBagTest", "ListIteratorWrapper2Test", "ListIteratorWrapperTest", "AbstractCollectionTest", "ComparatorChainTest", "AbstractListTest", "AbstractMapTest", "ListUtilsTest", "BulkTest", "AbstractObjectTest", "SplitMapUtilsTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=FilterIteratorTest,MultiValueMapTest,TreeListTest,AbstractSortedSetTest,SingletonMapTest,AbstractSortedBagTest,ReverseComparatorTest,CursorableLinkedListTest,AbstractNavigableSetTest,PredicatedBagTest,ListIteratorWrapper2Test,ListIteratorWrapperTest,AbstractCollectionTest,ComparatorChainTest,AbstractListTest,AbstractMapTest,ListUtilsTest,BulkTest,AbstractObjectTest,SplitMapUtilsTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 323,
  "metadata" : null
}, {
  "instance_id" : "apache-commons-collections-PR-320",
  "repo" : "apache/commons-collections",
  "base_commit" : "a43e0245ba6f3f39f51aaac41df4a4e547f4372f",
  "patch" : "diff --git a/src/main/java/org/apache/commons/collections4/bloomfilter/EnhancedDoubleHasher.java b/src/main/java/org/apache/commons/collections4/bloomfilter/EnhancedDoubleHasher.java\nnew file mode 100644\nindex 0000000000..347a951a3c\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/bloomfilter/EnhancedDoubleHasher.java\n@@ -0,0 +1,227 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.bloomfilter;\n+\n+import java.util.Objects;\n+import java.util.function.IntPredicate;\n+\n+/**\n+ * A Hasher that implements combinatorial hashing as as described by\n+ * <a href=\"https://www.eecs.harvard.edu/~michaelm/postscripts/tr-02-05.pdf\">Krisch and Mitzenmacher</a> using the enhanced double hashing technique\n+ * described in the wikipedia article  <a href=\"https://en.wikipedia.org/wiki/Double_hashing#Enhanced_double_hashing\">Double Hashing</a>.\n+ * <p>\n+ * Common use for this hasher is to generate bit indices from a byte array output of a hashing\n+ * or MessageDigest algorithm.</p>\n+ *\n+ * <h2>Thoughts on the hasher input</h2>\n+ *\n+ *<p>Note that it is worse to create smaller numbers for the {@code initial} and {@code increment}. If the {@code initial} is smaller than\n+ * the number of bits in a filter then hashing will start at the same point when the size increases; likewise the {@code increment} will be\n+ * the same if it remains smaller than the number of bits in the filter and so the first few indices will be the same if the number of bits\n+ * changes (but is still larger than the {@code increment}). In a worse case scenario with small {@code initial} and {@code increment} for\n+ * all items, hashing may not create indices that fill the full region within a much larger filter. Imagine hashers created with {@code initial}\n+ * and {@code increment} values less than 255 with a filter size of 30000 and number of hash functions as 5. Ignoring the\n+ * tetrahedral addition (a maximum of 20 for k=5) the max index is 255 * 4 + 255 = 1275, this covers 4.25% of the filter. This also\n+ * ignores the negative wrapping but the behaviour is the same, some bits cannot be reached.\n+ * </p><p>\n+ * So this needs to be avoided as the filter probability assumptions will be void. If the {@code initial} and {@code increment} are larger\n+ * than the number of bits then the modulus will create a 'random' position and increment within the size.\n+ * </p>\n+ *\n+ * @since 4.5\n+ */\n+public class EnhancedDoubleHasher implements Hasher {\n+\n+    /**\n+     * The initial hash value.\n+     */\n+    private final long initial;\n+\n+    /**\n+     * The value to increment the hash value by.\n+     */\n+    private final long increment;\n+\n+    /**\n+     * Convert bytes to big-endian long filling with zero bytes as necessary..\n+     * @param byteArray the byte array to extract the values from.\n+     * @param offset the offset to start extraction from.\n+     * @param len the length of the extraction, may be longer than 8.\n+     * @return\n+     */\n+    private static long toLong(byte[] byteArray, int offset, int len) {\n+        long val = 0;\n+        int shift = Long.SIZE;\n+        final int end = offset + Math.min(len, Long.BYTES);\n+        for (int i = offset; i < end; i++) {\n+            shift -=  Byte.SIZE;\n+            val |= ((long) (byteArray[i] & 0xFF) << shift);\n+        }\n+        return val;\n+    }\n+\n+    /**\n+     * Constructs the EnhancedDoubleHasher from a byte array.\n+     * <p>\n+     * This method simplifies the conversion from a Digest or hasher algorithm output\n+     * to the two values used by the EnhancedDoubleHasher.</p>\n+     * <p>The byte array is split in 2 and the first 8 bytes of each half are interpreted as a big-endian long value.\n+     * Excess bytes are ignored.\n+     * If there are fewer than 16 bytes the following conversions are made.\n+     *</p>\n+     * <ol>\n+     * <li>If there is an odd number of bytes the excess byte is assigned to the increment value</li>\n+     * <li>The bytes alloted are read in big-endian order any byte not populated is set to zero.</li>\n+     * </ol>\n+     * <p>\n+     * This ensures that small arrays generate the largest possible increment and initial values.\n+     * </p>\n+     * @param buffer the buffer to extract the longs from.\n+     * @throws IllegalArgumentException is buffer length is zero.\n+     */\n+    public EnhancedDoubleHasher(byte[] buffer) {\n+        if (buffer.length == 0) {\n+            throw new IllegalArgumentException(\"buffer length must be greater than 0\");\n+        }\n+        // divide by 2\n+        int segment = buffer.length / 2;\n+        this.initial = toLong(buffer, 0, segment);\n+        this.increment = toLong(buffer, segment, buffer.length - segment);\n+    }\n+\n+    /**\n+     * Constructs the EnhancedDoubleHasher from 2 longs.  The long values will be interpreted as unsigned values.\n+     * @param initial The initial value for the hasher.\n+     * @param increment The value to increment the hash by on each iteration.\n+     */\n+    public EnhancedDoubleHasher(long initial, long increment) {\n+        this.initial = initial;\n+        this.increment = increment;\n+    }\n+\n+    /**\n+     * Gets the initial value for the hash calculation.\n+     * @return the initial value for the hash calculation.\n+     */\n+    long getInitial() {\n+        return initial;\n+    }\n+\n+    /**\n+     * Gets the increment value for the hash calculation.\n+     * @return the increment value for the hash calculation.\n+     */\n+    long getIncrement() {\n+        return increment;\n+    }\n+\n+    /**\n+     * Performs a modulus calculation on an unsigned long and an integer divisor.\n+     * @param dividend a unsigned long value to calculate the modulus of.\n+     * @param divisor the divisor for the modulus calculation.\n+     * @return the remainder or modulus value.\n+     */\n+    static int mod(long dividend, int divisor) {\n+        // See Hacker's Delight (2nd ed), section 9.3.\n+        // Assume divisor is positive.\n+        // Divide half the unsigned number and then double the quotient result.\n+        final long quotient = ((dividend >>> 1) / divisor) << 1;\n+        final long remainder = dividend - quotient * divisor;\n+        // remainder in [0, 2 * divisor)\n+        return (int) (remainder >= divisor ? remainder - divisor : remainder);\n+    }\n+\n+    @Override\n+    public IndexProducer indices(final Shape shape) {\n+        Objects.requireNonNull(shape, \"shape\");\n+\n+        return new IndexProducer() {\n+\n+            @Override\n+            public boolean forEachIndex(IntPredicate consumer) {\n+                Objects.requireNonNull(consumer, \"consumer\");\n+                final int bits = shape.getNumberOfBits();\n+                // Enhanced double hashing:\n+                // hash[i] = ( h1(x) + i*h2(x) + (i*i*i - i)/6 ) mod bits\n+                // See: https://en.wikipedia.org/wiki/Double_hashing#Enhanced_double_hashing\n+                //\n+                // Essentially this is computing a wrapped modulus from a start point and an\n+                // increment and an additional term as a tetrahedral number.\n+                // You only need two modulus operations before the loop. Within the loop\n+                // the modulus is handled using the sign bit to detect wrapping to ensure:\n+                // 0 <= index < bits\n+                // 0 <= inc < bits\n+                // The final hash is:\n+                // hash[i] = ( h1(x) - i*h2(x) - (i*i*i - i)/6 ) wrapped in [0, bits)\n+\n+                int index = mod(initial, bits);\n+                int inc = mod(increment, bits);\n+\n+                final int k = shape.getNumberOfHashFunctions();\n+                if (k > bits) {\n+                    for (int j = k; j > 0;) {\n+                        // handle k > bits\n+                        final int block = Math.min(j, bits);\n+                        j -= block;\n+                        for (int i = 0; i < block; i++) {\n+                            if (!consumer.test(index)) {\n+                                return false;\n+                            }\n+                            // Update index and handle wrapping\n+                            index -= inc;\n+                            index = index < 0 ? index + bits : index;\n+\n+                            // Incorporate the counter into the increment to create a\n+                            // tetrahedral number additional term, and handle wrapping.\n+                            inc -= i;\n+                            inc = inc < 0 ? inc + bits : inc;\n+                        }\n+                    }\n+                } else {\n+                    for (int i = 0; i < k; i++) {\n+                        if (!consumer.test(index)) {\n+                            return false;\n+                        }\n+                        // Update index and handle wrapping\n+                        index -= inc;\n+                        index = index < 0 ? index + bits : index;\n+\n+                        // Incorporate the counter into the increment to create a\n+                        // tetrahedral number additional term, and handle wrapping.\n+                        inc -= i;\n+                        inc = inc < 0 ? inc + bits : inc;\n+                    }\n+                }\n+                return true;\n+            }\n+\n+            @Override\n+            public int[] asIndexArray() {\n+                int[] result = new int[shape.getNumberOfHashFunctions()];\n+                int[] idx = new int[1];\n+\n+                // This method needs to return duplicate indices\n+\n+                forEachIndex(i -> {\n+                    result[idx[0]++] = i;\n+                    return true;\n+                });\n+                return result;\n+            }\n+        };\n+    }\n+}\ndiff --git a/src/main/java/org/apache/commons/collections4/bloomfilter/Hasher.java b/src/main/java/org/apache/commons/collections4/bloomfilter/Hasher.java\nindex 6f2b5aab8e..82445a623d 100644\n--- a/src/main/java/org/apache/commons/collections4/bloomfilter/Hasher.java\n+++ b/src/main/java/org/apache/commons/collections4/bloomfilter/Hasher.java\n@@ -16,6 +16,8 @@\n  */\n package org.apache.commons.collections4.bloomfilter;\n \n+import java.util.Objects;\n+\n /**\n  * A Hasher creates IndexProducer based on the hash implementation and the\n  * provided Shape.\n@@ -52,5 +54,10 @@ public interface Hasher {\n      * @param shape the shape of the desired Bloom filter.\n      * @return the iterator of integers\n      */\n-    IndexProducer uniqueIndices(Shape shape);\n+    default IndexProducer uniqueIndices(Shape shape) {\n+        return consumer -> {\n+            Objects.requireNonNull(consumer, \"consumer\");\n+            return Hasher.this.indices(shape).forEachIndex(IndexFilter.create(shape, consumer));\n+        };\n+    }\n }\ndiff --git a/src/main/java/org/apache/commons/collections4/bloomfilter/Shape.java b/src/main/java/org/apache/commons/collections4/bloomfilter/Shape.java\nindex 40db56516a..d39df255ef 100644\n--- a/src/main/java/org/apache/commons/collections4/bloomfilter/Shape.java\n+++ b/src/main/java/org/apache/commons/collections4/bloomfilter/Shape.java\n@@ -186,20 +186,6 @@ public double estimateN(int cardinality) {\n         return -(m / k) * Math.log1p(-c / m);\n     }\n \n-    /**\n-     * The factory to assist in the creation of proper Shapes.\n-     *\n-     * In the methods of this factory the `from` names are appended with the standard variable\n-     * names in the order expected:\n-     *\n-     * <dl>\n-     * <dt>{@code N})</dt><dd>The number of items to be placed in the Bloom filter</dd>\n-     * <dt>{@code M})</dt><dd>The number of bits in the Bloom filter</dd>\n-     * <dt>{@code K})</dt><dd>The number of hash functions for each item placed in the Bloom filter</dd>\n-     * <dt>{@code P})</dt><dd>The probability of a collision once N items have been placed in the Bloom filter</dd>\n-     * </dl>\n-     */\n-\n     /**\n      * Constructs a filter configuration with a desired false-positive probability ({@code p}) and the\n      * specified number of bits ({@code m}) and hash functions ({@code k}).\ndiff --git a/src/main/java/org/apache/commons/collections4/bloomfilter/SimpleHasher.java b/src/main/java/org/apache/commons/collections4/bloomfilter/SimpleHasher.java\ndeleted file mode 100644\nindex 6c5056dc49..0000000000\n--- a/src/main/java/org/apache/commons/collections4/bloomfilter/SimpleHasher.java\n+++ /dev/null\n@@ -1,196 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.commons.collections4.bloomfilter;\n-\n-import java.util.Objects;\n-import java.util.function.IntPredicate;\n-\n-/**\n- * A Hasher that implements combinatorial hashing as as described by\n- * <a href=\"https://www.eecs.harvard.edu/~michaelm/postscripts/tr-02-05.pdf\">Krisch and Mitzenmacher</a>.\n- * <p>\n- * Common use for this hasher is to generate a byte array as the output of a hashing\n- * or MessageDigest algorithm.</p>\n- *\n- * @since 4.5\n- */\n-public class SimpleHasher implements Hasher {\n-\n-    /**\n-     * The initial hash value.\n-     */\n-    private final long initial;\n-\n-    /**\n-     * The value to increment the hash value by.\n-     */\n-    private final long increment;\n-\n-    /**\n-     * Convert bytes to long.\n-     * @param byteArray the byte array to extract the values from.\n-     * @param offset the offset to start extraction from.\n-     * @param len the length of the extraction, may be longer than 8.\n-     * @return\n-     */\n-    private static long toLong(byte[] byteArray, int offset, int len) {\n-        long val = 0;\n-        len = Math.min(len, Long.BYTES);\n-        for (int i = 0; i < len; i++) {\n-            val <<= 8;\n-            val |= (byteArray[offset + i] & 0x00FF);\n-        }\n-        return val;\n-    }\n-\n-    /**\n-     * Constructs the SimpleHasher from a byte array.\n-     * <p>The byte array is split in 2 and each half is interpreted as a long value.\n-     * Excess bytes are ignored.  This simplifies the conversion from a Digest or hasher algorithm output\n-     * to the two values used by the SimpleHasher.</p>\n-     * <p><em>If the second long is zero the default increment is used instead.</em></p>\n-     * @param buffer the buffer to extract the longs from.\n-     * @throws IllegalArgumentException is buffer length is zero.\n-     * @see #getDefaultIncrement()\n-     */\n-    public SimpleHasher(byte[] buffer) {\n-        if (buffer.length == 0) {\n-            throw new IllegalArgumentException(\"buffer length must be greater than 0\");\n-        }\n-        int segment = buffer.length / 2;\n-        this.initial = toLong(buffer, 0, segment);\n-        long possibleIncrement = toLong(buffer, segment, buffer.length - segment);\n-        this.increment = possibleIncrement == 0 ? getDefaultIncrement() : possibleIncrement;\n-    }\n-\n-    /**\n-     * Constructs the SimpleHasher from 2 longs.  The long values will be interpreted as unsigned values.\n-     * <p><em>If the increment is zero the default increment is used instead.</em></p>\n-     * @param initial The initial value for the hasher.\n-     * @param increment The value to increment the hash by on each iteration.\n-     * @see #getDefaultIncrement()\n-     */\n-    public SimpleHasher(long initial, long increment) {\n-        this.initial = initial;\n-        this.increment = increment == 0 ? getDefaultIncrement() : increment;\n-    }\n-\n-    /**\n-     * Get the default increment used when the requested increment is zero.\n-     * <p>\n-     * By default this is the same\n-     * default increment used in Java's SplittableRandom random number generator.  It is the\n-     * fractional representation of the golden ratio (0.618...) with a base of 2^64.\n-     * </p><p>\n-     * Implementations may want to override this value to match defaults in legacy implementations.\n-     * </p>\n-     * @return The default increment to use when the requested increment is zero.\n-     */\n-    public long getDefaultIncrement() {\n-        return 0x9e3779b97f4a7c15L;\n-    }\n-\n-    /**\n-     * Performs a modulus calculation on an unsigned long and an integer divisor.\n-     * @param dividend a unsigned long value to calculate the modulus of.\n-     * @param divisor the divisor for the modulus calculation.\n-     * @return the remainder or modulus value.\n-     */\n-    static int mod(long dividend, int divisor) {\n-        // See Hacker's Delight (2nd ed), section 9.3.\n-        // Assume divisor is positive.\n-        // Divide half the unsigned number and then double the quotient result.\n-        final long quotient = ((dividend >>> 1) / divisor) << 1;\n-        final long remainder = dividend - quotient * divisor;\n-        // remainder in [0, 2 * divisor)\n-        return (int) (remainder >= divisor ? remainder - divisor : remainder);\n-    }\n-\n-    @Override\n-    public IndexProducer indices(final Shape shape) {\n-        Objects.requireNonNull(shape, \"shape\");\n-\n-        return new IndexProducer() {\n-\n-            @Override\n-            public boolean forEachIndex(IntPredicate consumer) {\n-                Objects.requireNonNull(consumer, \"consumer\");\n-                int bits = shape.getNumberOfBits();\n-                /*\n-                 * Essentially this is computing a wrapped modulus from a start point and an\n-                 * increment. So actually you only need two modulus operations before the loop.\n-                 * This avoids any modulus operation inside the while loop. It uses a long index\n-                 * to avoid overflow.\n-                 */\n-                long index = mod(initial, bits);\n-                int inc = mod(increment, bits);\n-\n-                for (int functionalCount = 0; functionalCount < shape.getNumberOfHashFunctions(); functionalCount++) {\n-\n-                    if (!consumer.test((int) index)) {\n-                        return false;\n-                    }\n-                    index += inc;\n-                    index = index >= bits ? index - bits : index;\n-                }\n-                return true;\n-            }\n-\n-            @Override\n-            public int[] asIndexArray() {\n-                int[] result = new int[shape.getNumberOfHashFunctions()];\n-                int[] idx = new int[1];\n-                /*\n-                 * This method needs to return duplicate indices\n-                 */\n-                forEachIndex(i -> {\n-                    result[idx[0]++] = i;\n-                    return true;\n-                });\n-                return result;\n-            }\n-        };\n-    }\n-\n-    @Override\n-    public IndexProducer uniqueIndices(final Shape shape) {\n-        return new IndexProducer() {\n-\n-            @Override\n-            public boolean forEachIndex(IntPredicate consumer) {\n-                Objects.requireNonNull(consumer, \"consumer\");\n-                IntPredicate filter = IndexFilter.create(shape, consumer);\n-\n-                int bits = shape.getNumberOfBits();\n-\n-                // Set up for the modulus. Use a long index to avoid overflow.\n-                long index = mod(initial, bits);\n-                int inc = mod(increment, bits);\n-\n-                for (int functionalCount = 0; functionalCount < shape.getNumberOfHashFunctions(); functionalCount++) {\n-\n-                    if (!filter.test((int) index)) {\n-                        return false;\n-                    }\n-                    index += inc;\n-                    index = index >= bits ? index - bits : index;\n-                }\n-                return true;\n-            }\n-        };\n-    }\n-}\n",
  "test_patch" : "diff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBloomFilterTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBloomFilterTest.java\nindex 74b140c44e..d8ceea079d 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBloomFilterTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBloomFilterTest.java\n@@ -30,15 +30,15 @@\n  */\n public abstract class AbstractBloomFilterTest<T extends BloomFilter> {\n \n-    protected final SimpleHasher from1 = new SimpleHasher(1, 1);\n+    protected final Hasher from1 = new IncrementingHasher(1, 1);\n     protected final long from1Value = 0x3fffeL;\n-    protected final SimpleHasher from11 = new SimpleHasher(11, 1);\n+    protected final Hasher from11 = new IncrementingHasher(11, 1);\n     protected final long from11Value = 0xffff800L;\n     protected final HasherCollection bigHasher = new HasherCollection(from1, from11);\n     protected final long bigHashValue = 0xffffffeL;\n-    protected final HasherCollection fullHasher = new HasherCollection(new SimpleHasher(0, 1)/* 0-16 */,\n-            new SimpleHasher(17, 1)/* 17-33 */, new SimpleHasher(33, 1)/* 33-49 */, new SimpleHasher(50, 1)/* 50-66 */,\n-            new SimpleHasher(67, 1)/* 67-83 */\n+    protected final HasherCollection fullHasher = new HasherCollection(new IncrementingHasher(0, 1)/* 0-16 */,\n+            new IncrementingHasher(17, 1)/* 17-33 */, new IncrementingHasher(33, 1)/* 33-49 */, new IncrementingHasher(50, 1)/* 50-66 */,\n+            new IncrementingHasher(67, 1)/* 67-83 */\n     );\n     protected final long[] fullHashValue = { 0xffffffffffffffffL, 0xfffffL };\n \n@@ -150,18 +150,18 @@ public final void testContains() {\n         assertFalse(bf1.contains(bf2), \"BF should not contain BF2\");\n         assertTrue(bf2.contains(bf1), \"BF2 should contain BF\");\n \n-        assertTrue(bf2.contains(new SimpleHasher(1, 1)), \"BF2 Should contain this hasher\");\n-        assertFalse(bf2.contains(new SimpleHasher(1, 3)), \"BF2 Should not contain this hasher\");\n+        assertTrue(bf2.contains(new IncrementingHasher(1, 1)), \"BF2 Should contain this hasher\");\n+        assertFalse(bf2.contains(new IncrementingHasher(1, 3)), \"BF2 Should not contain this hasher\");\n \n-        IndexProducer indexProducer = new SimpleHasher(1, 1).indices(getTestShape());\n+        IndexProducer indexProducer = new IncrementingHasher(1, 1).indices(getTestShape());\n         assertTrue(bf2.contains(indexProducer), \"BF2 Should contain this hasher\");\n-        indexProducer = new SimpleHasher(1, 3).indices(getTestShape());\n+        indexProducer = new IncrementingHasher(1, 3).indices(getTestShape());\n         assertFalse(bf2.contains(indexProducer), \"BF2 Should not contain this hasher\");\n \n-        BitMapProducer bitMapProducer = BitMapProducer.fromIndexProducer(new SimpleHasher(1, 1).indices(getTestShape()),\n+        BitMapProducer bitMapProducer = BitMapProducer.fromIndexProducer(new IncrementingHasher(1, 1).indices(getTestShape()),\n                 getTestShape().getNumberOfBits());\n         assertTrue(bf2.contains(bitMapProducer), \"BF2 Should contain this hasher\");\n-        bitMapProducer = BitMapProducer.fromIndexProducer(new SimpleHasher(1, 3).indices(getTestShape()),\n+        bitMapProducer = BitMapProducer.fromIndexProducer(new IncrementingHasher(1, 3).indices(getTestShape()),\n                 getTestShape().getNumberOfBits());\n         assertFalse(bf2.contains(bitMapProducer), \"BF2 Should not contain this hasher\");\n \n@@ -228,11 +228,11 @@ public final void testEstimateN() {\n \n         // the data provided above do not generate an estimate that is equivalent to the\n         // actual.\n-        filter1.merge(new SimpleHasher(4, 1));\n+        filter1.merge(new IncrementingHasher(4, 1));\n \n         assertEquals(1, filter1.estimateN());\n \n-        filter1.merge(new SimpleHasher(17, 1));\n+        filter1.merge(new IncrementingHasher(17, 1));\n \n         assertEquals(3, filter1.estimateN());\n     }\n@@ -244,7 +244,7 @@ public final void testEstimateN() {\n     public final void testAsBitMapArray() {\n \n         // test when multiple long values are returned.\n-        final SimpleHasher hasher = new SimpleHasher(63, 1);\n+        final IncrementingHasher hasher = new IncrementingHasher(63, 1);\n         final BloomFilter bf = createFilter(Shape.fromKM(2, 72), hasher);\n         final long[] lb = bf.asBitMapArray();\n         assertEquals(2, lb.length);\n@@ -265,7 +265,7 @@ public final void testIsFull() {\n         filter = createFilter(getTestShape(), fullHasher);\n         assertTrue(filter.isFull(), \"Should be full\");\n \n-        filter = createFilter(getTestShape(), new SimpleHasher(1, 3));\n+        filter = createFilter(getTestShape(), new IncrementingHasher(1, 3));\n         assertFalse(filter.isFull(), \"Should not be full\");\n     }\n \n@@ -313,12 +313,12 @@ public final void testMerge() {\n         // test error when bloom filter returns values out of range\n         final BloomFilter bf5 = new SimpleBloomFilter(\n                 Shape.fromKM(getTestShape().getNumberOfHashFunctions(), 3 * Long.SIZE),\n-                new SimpleHasher(Long.SIZE * 2, 1));\n+                new IncrementingHasher(Long.SIZE * 2, 1));\n         assertThrows(IllegalArgumentException.class, () -> bf1.merge(bf5));\n \n         final BloomFilter bf6 = new SparseBloomFilter(\n                 Shape.fromKM(getTestShape().getNumberOfHashFunctions(), 3 * Long.SIZE),\n-                new SimpleHasher(Long.SIZE * 2, 1));\n+                new IncrementingHasher(Long.SIZE * 2, 1));\n         assertThrows(IllegalArgumentException.class, () -> bf1.merge(bf6));\n     }\n \ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractCountingBloomFilterTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractCountingBloomFilterTest.java\nindex 02839df9b9..b7ca7dd37f 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractCountingBloomFilterTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractCountingBloomFilterTest.java\n@@ -234,7 +234,7 @@ public void testExcludesDuplicates() {\n         // create a hasher that produces duplicates with the specified shape.\n         // this setup produces 5, 17, 29, 41, 53, 65 two times\n         Shape shape = Shape.fromKM(12, 72);\n-        SimpleHasher hasher = new SimpleHasher(5, 12);\n+        Hasher hasher = new IncrementingHasher(5, 12);\n \n         CountingBloomFilter bf1 = createFilter(shape, hasher);\n         assertEquals(6, bf1.cardinality());\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractHasherTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractHasherTest.java\nindex 95b2e59fbf..cd5eda18c4 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractHasherTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/AbstractHasherTest.java\n@@ -19,10 +19,13 @@\n import static org.junit.jupiter.api.Assertions.assertEquals;\n import static org.junit.jupiter.api.Assertions.assertTrue;\n \n+import java.util.Arrays;\n import java.util.HashSet;\n+import java.util.List;\n import java.util.Set;\n+import java.util.stream.Collectors;\n \n-import org.junit.Test;\n+import org.junit.jupiter.api.Test;\n import org.junit.jupiter.params.ParameterizedTest;\n import org.junit.jupiter.params.provider.CsvSource;\n \n@@ -63,7 +66,7 @@ protected IndexProducer createEmptyProducer() {\n     }\n \n     @ParameterizedTest\n-    @CsvSource({ \"17, 72\", \"3, 14\", \"5, 67868\", })\n+    @CsvSource({ \"17, 72\", \"3, 14\", \"5, 67868\", \"75, 10\"})\n     public void testHashing(int k, int m) {\n         int[] count = { 0 };\n         Hasher hasher = createHasher();\n@@ -74,16 +77,28 @@ public void testHashing(int k, int m) {\n         });\n         assertEquals(k * getHasherSize(hasher), count[0],\n                 () -> String.format(\"Did not produce k=%d * m=%d indices\", k, getHasherSize(hasher)));\n+\n+        // test early exit\n+        count[0] = 0;\n+        hasher.indices(Shape.fromKM(k, m)).forEachIndex(i -> {\n+            assertTrue(i >= 0 && i < m, () -> \"Out of range: \" + i + \", m=\" + m);\n+            count[0]++;\n+            return false;\n+        });\n+        assertEquals(1, count[0], \"did not exit early\" );\n     }\n \n     @Test\n     public void testUniqueIndex() {\n-        // create a hasher that produces duplicates with the specified shape.\n-        // this setup produces 5, 17, 29, 41, 53, 65 two times\n-        Shape shape = Shape.fromKM(12, 72);\n-        Hasher hasher = new SimpleHasher(5, 12);\n-        Set<Integer> set = new HashSet<>();\n-        assertTrue(hasher.uniqueIndices(shape).forEachIndex(set::add), \"Duplicate detected\");\n-        assertEquals(6, set.size());\n+        // generating 11 numbers in the range of [0,9] will yield at least on collision.\n+        Shape shape = Shape.fromKM(11, 10);\n+        Hasher hasher = createHasher();\n+        IndexProducer producer = hasher.indices(shape);\n+        List<Integer> full = Arrays.stream(producer.asIndexArray()).boxed().collect(Collectors.toList());\n+        producer = hasher.uniqueIndices(shape);\n+        List<Integer> unique = Arrays.stream(producer.asIndexArray()).boxed().collect(Collectors.toList());\n+        assertTrue( full.size() > unique.size() );\n+        Set<Integer> set = new HashSet<Integer>( unique );\n+        assertEquals( set.size(), unique.size() );\n     }\n }\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/BitCountProducerFromArrayCountingBloomFilterTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/BitCountProducerFromArrayCountingBloomFilterTest.java\nindex 3329bc4b5c..7961b6d53d 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/BitCountProducerFromArrayCountingBloomFilterTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/BitCountProducerFromArrayCountingBloomFilterTest.java\n@@ -23,7 +23,7 @@ public class BitCountProducerFromArrayCountingBloomFilterTest extends AbstractBi\n     @Override\n     protected BitCountProducer createProducer() {\n         ArrayCountingBloomFilter filter = new ArrayCountingBloomFilter(shape);\n-        Hasher hasher = new SimpleHasher(0, 1);\n+        Hasher hasher = new IncrementingHasher(0, 1);\n         filter.merge(hasher);\n         return filter;\n     }\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/BitMapProducerFromArrayCountingBloomFilterTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/BitMapProducerFromArrayCountingBloomFilterTest.java\nindex 48f5fb411a..38c24af732 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/BitMapProducerFromArrayCountingBloomFilterTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/BitMapProducerFromArrayCountingBloomFilterTest.java\n@@ -23,7 +23,7 @@ public class BitMapProducerFromArrayCountingBloomFilterTest extends AbstractBitM\n     @Override\n     protected BitMapProducer createProducer() {\n         ArrayCountingBloomFilter filter = new ArrayCountingBloomFilter(shape);\n-        Hasher hasher = new SimpleHasher(0, 1);\n+        Hasher hasher = new IncrementingHasher(0, 1);\n         filter.merge(hasher);\n         return filter;\n     }\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/BitMapProducerFromSimpleBloomFilterTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/BitMapProducerFromSimpleBloomFilterTest.java\nindex f73b4807bc..aa000797e5 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/BitMapProducerFromSimpleBloomFilterTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/BitMapProducerFromSimpleBloomFilterTest.java\n@@ -22,7 +22,7 @@ public class BitMapProducerFromSimpleBloomFilterTest extends AbstractBitMapProdu\n \n     @Override\n     protected BitMapProducer createProducer() {\n-        Hasher hasher = new SimpleHasher(0, 1);\n+        Hasher hasher = new IncrementingHasher(0, 1);\n         return new SimpleBloomFilter(shape, hasher);\n     }\n \ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/BitMapProducerFromSparseBloomFilterTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/BitMapProducerFromSparseBloomFilterTest.java\nindex 0a6331ce78..0c80b6d0d3 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/BitMapProducerFromSparseBloomFilterTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/BitMapProducerFromSparseBloomFilterTest.java\n@@ -22,7 +22,7 @@ public class BitMapProducerFromSparseBloomFilterTest extends AbstractBitMapProdu\n \n     @Override\n     protected BitMapProducer createProducer() {\n-        Hasher hasher = new SimpleHasher(0, 1);\n+        Hasher hasher = new IncrementingHasher(0, 1);\n         return new SparseBloomFilter(shape, hasher);\n     }\n \ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/DefaultBloomFilterTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/DefaultBloomFilterTest.java\nindex 2c107fb01e..26862bb194 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/DefaultBloomFilterTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/DefaultBloomFilterTest.java\n@@ -52,7 +52,7 @@ protected AbstractDefaultBloomFilter createFilter(final Shape shape, final Index\n     @Test\n     public void testDefaultBloomFilterSimpleSpecificMerge() {\n         AbstractDefaultBloomFilter filter = new SparseDefaultBloomFilter(Shape.fromKM(3, 150));\n-        Hasher hasher = new SimpleHasher(0, 1);\n+        Hasher hasher = new IncrementingHasher(0, 1);\n         assertTrue(filter.merge(hasher));\n         assertEquals(3, filter.cardinality());\n     }\n@@ -62,7 +62,7 @@ public void testDefaultBloomFilterSimpleSpecificMerge() {\n     public void testDefaultBloomFilterSparseSpecificMerge() {\n         Shape shape = Shape.fromKM(3, 150);\n         AbstractDefaultBloomFilter filter = new SparseDefaultBloomFilter(shape);\n-        AbstractDefaultBloomFilter filter2 = new SparseDefaultBloomFilter(shape, new SimpleHasher(0, 1));\n+        AbstractDefaultBloomFilter filter2 = new SparseDefaultBloomFilter(shape, new IncrementingHasher(0, 1));\n         BloomFilter newFilter = filter.copy();\n         newFilter.merge(filter2);\n         assertEquals(3, newFilter.cardinality());\n@@ -70,7 +70,7 @@ public void testDefaultBloomFilterSparseSpecificMerge() {\n \n     @Test\n     public void testHasherBasedMergeInPlaceWithDifferingSparseness() {\n-        Hasher hasher = new SimpleHasher(1, 1);\n+        Hasher hasher = new IncrementingHasher(1, 1);\n \n         BloomFilter bf1 = new NonSparseDefaultBloomFilter(getTestShape());\n         bf1.merge(hasher);\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/EnhancedDoubleHasherTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/EnhancedDoubleHasherTest.java\nnew file mode 100644\nindex 0000000000..2c028bf02f\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/EnhancedDoubleHasherTest.java\n@@ -0,0 +1,94 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.bloomfilter;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import org.junit.jupiter.api.Test;\n+\n+/**\n+ * Tests the {@link EnhancedDoubleHasher}.\n+ */\n+public class EnhancedDoubleHasherTest extends AbstractHasherTest {\n+\n+    @Override\n+    protected Hasher createHasher() {\n+        return new EnhancedDoubleHasher(1, 1);\n+    }\n+\n+    @Override\n+    protected Hasher createEmptyHasher() {\n+        return NullHasher.INSTANCE;\n+    }\n+\n+    @Override\n+    protected int getHasherSize(Hasher hasher) {\n+        return 1;\n+    }\n+\n+    @Test\n+    public void testByteConstructor() {\n+        // single value become increment.\n+        EnhancedDoubleHasher hasher = new EnhancedDoubleHasher( new byte[] { 1 } );\n+        assertEquals( 0, hasher.getInitial() );\n+        assertEquals( 0x01_00_00_00_00_00_00_00L, hasher.getIncrement() );\n+\n+        // 2 bytes become initial and increment.\n+        hasher = new EnhancedDoubleHasher( new byte[] { 1, 2 } );\n+        assertEquals( 0x01_00_00_00_00_00_00_00L, hasher.getInitial() );\n+        assertEquals( 0x200000000000000L, hasher.getIncrement() );\n+\n+        // odd values place extra byte in increment.\n+        hasher = new EnhancedDoubleHasher( new byte[] { 1, 2, 3 } );\n+        assertEquals( 0x01_00_00_00_00_00_00_00L, hasher.getInitial() );\n+        assertEquals( 0x203000000000000L, hasher.getIncrement() );\n+\n+        // even short split\n+        hasher = new EnhancedDoubleHasher( new byte[] {0, 1, 0, 2 } );\n+        assertEquals( 0x01_00_00_00_00_00_00L, hasher.getInitial() );\n+        assertEquals( 0x02_00_00_00_00_00_00L, hasher.getIncrement() );\n+\n+        // longs are parse correctly\n+        hasher = new EnhancedDoubleHasher( new byte[] { 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2 } );\n+        assertEquals( 1, hasher.getInitial() );\n+        assertEquals( 2, hasher.getIncrement() );\n+\n+        // excess bytes are ignored before mid point and at end\n+        hasher = new EnhancedDoubleHasher( new byte[] { 0, 0, 0, 0, 0, 0, 0, 1, 5, 5, 0, 0, 0, 0, 0, 0, 0, 2, 5, 5 } );\n+        assertEquals( 1, hasher.getInitial() );\n+        assertEquals( 2, hasher.getIncrement() );\n+\n+        // odd extra bytes are accounted for correctly\n+        hasher = new EnhancedDoubleHasher( new byte[] { 0, 0, 0, 0, 0, 0, 0, 1, 5, 1, 0, 0, 0, 0, 0, 0, 2, 5, 5 } );\n+        assertEquals( 1, hasher.getInitial() );\n+        assertEquals( 0x01_00_00_00_00_00_00_02L, hasher.getIncrement() );\n+\n+        // test empty buffer\n+        assertThrows(IllegalArgumentException.class, () -> new EnhancedDoubleHasher(new byte[0]));\n+    }\n+\n+    @Test\n+    void testModEdgeCases() {\n+        for (long dividend : new long[] { -1, -2, -3, -6378683, -23567468136887892L, Long.MIN_VALUE, 345, 678686,\n+            67868768686878924L, Long.MAX_VALUE }) {\n+            for (int divisor : new int[] { 1, 2, 3, 5, 13, Integer.MAX_VALUE }) {\n+                assertEquals((int) Long.remainderUnsigned(dividend, divisor), EnhancedDoubleHasher.mod(dividend, divisor),\n+                        () -> String.format(\"failure with dividend=%s and divisor=%s.\", dividend, divisor));\n+            }\n+        }\n+    }\n+}\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/HasherCollectionTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/HasherCollectionTest.java\nindex 29d3c55206..997ee01a21 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/HasherCollectionTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/HasherCollectionTest.java\n@@ -33,7 +33,7 @@ public class HasherCollectionTest extends AbstractHasherTest {\n \n     @Override\n     protected HasherCollection createHasher() {\n-        return new HasherCollection(new SimpleHasher(1, 1), new SimpleHasher(2, 2));\n+        return new HasherCollection(new IncrementingHasher(1, 1), new IncrementingHasher(2, 2));\n     }\n \n     @Override\n@@ -54,7 +54,7 @@ protected void nestedTest(HasherCollectionTest nestedTest) {\n \n     @Test\n     public void testCollectionConstructor() {\n-        List<Hasher> lst = Arrays.asList(new SimpleHasher(3, 2), new SimpleHasher(4, 2));\n+        List<Hasher> lst = Arrays.asList(new IncrementingHasher(3, 2), new IncrementingHasher(4, 2));\n         HasherCollectionTest nestedTest = new HasherCollectionTest() {\n             @Override\n             protected HasherCollection createHasher() {\n@@ -71,7 +71,7 @@ protected HasherCollection createEmptyHasher() {\n         nestedTest = new HasherCollectionTest() {\n             @Override\n             protected HasherCollection createHasher() {\n-                return new HasherCollection(new SimpleHasher(3, 2), new SimpleHasher(4, 2));\n+                return new HasherCollection(new IncrementingHasher(3, 2), new IncrementingHasher(4, 2));\n             }\n \n             @Override\n@@ -85,10 +85,10 @@ protected HasherCollection createEmptyHasher() {\n     @Test\n     public void testAdd() {\n         HasherCollection hasher = createHasher();\n-        hasher.add(new SimpleHasher(2, 2));\n+        hasher.add(new IncrementingHasher(2, 2));\n         assertEquals(3, hasher.getHashers().size());\n \n-        hasher.add(Arrays.asList(new SimpleHasher(3, 2), new SimpleHasher(4, 2)));\n+        hasher.add(Arrays.asList(new IncrementingHasher(3, 2), new IncrementingHasher(4, 2)));\n         assertEquals(5, hasher.getHashers().size());\n     }\n \n@@ -97,7 +97,7 @@ public void testUniqueIndex() {\n         // create a hasher that produces duplicates with the specified shape.\n         // this setup produces 5, 17, 29, 41, 53, 65 two times\n         Shape shape = Shape.fromKM(12, 72);\n-        Hasher h1 = new SimpleHasher(5, 12);\n+        Hasher h1 = new IncrementingHasher(5, 12);\n         HasherCollection hasher = createEmptyHasher();\n         hasher.add(h1);\n         hasher.add(h1);\n@@ -115,9 +115,9 @@ public void testUniqueIndex() {\n \n     @Test\n     void testHasherCollection() {\n-        Hasher h1 = new SimpleHasher(13, 4678);\n-        Hasher h2 = new SimpleHasher(42, 987);\n-        Hasher h3 = new SimpleHasher(454, 2342);\n+        Hasher h1 = new IncrementingHasher(13, 4678);\n+        Hasher h2 = new IncrementingHasher(42, 987);\n+        Hasher h3 = new IncrementingHasher(454, 2342);\n \n         HasherCollection hc1 = new HasherCollection(Arrays.asList(h1, h1));\n         HasherCollection hc2 = new HasherCollection(Arrays.asList(h2, h3));\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/IncrementingHasher.java b/src/test/java/org/apache/commons/collections4/bloomfilter/IncrementingHasher.java\nnew file mode 100644\nindex 0000000000..bc4003f18d\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/IncrementingHasher.java\n@@ -0,0 +1,100 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.bloomfilter;\n+\n+import java.util.Objects;\n+import java.util.function.IntPredicate;\n+\n+/**\n+ * A Hasher that implements simple combinatorial hashing as as described by\n+ * <a href=\"https://www.eecs.harvard.edu/~michaelm/postscripts/tr-02-05.pdf\">Krisch and Mitzenmacher</a>.\n+ *\n+ * <p>To be used for testing only.</p>\n+ *\n+ * @since 4.5\n+ */\n+class IncrementingHasher implements Hasher {\n+\n+    /**\n+     * The initial hash value.\n+     */\n+    private final long initial;\n+\n+    /**\n+     * The value to increment the hash value by.\n+     */\n+    private final long increment;\n+\n+    /**\n+     * Constructs the IncrementingHasher from 2 longs.  The long values will be interpreted as unsigned values.\n+     * <p>\n+     * The initial hash value will be the modulus of the initial value.\n+     * Subsequent values will be calculated by repeatedly adding the increment to the last value and taking the modulus.\n+     * </p>\n+     * @param initial The initial value for the hasher.\n+     * @param increment The value to increment the hash by on each iteration.\n+     */\n+    IncrementingHasher(long initial, long increment) {\n+        this.initial = initial;\n+        this.increment = increment;\n+    }\n+\n+    @Override\n+    public IndexProducer indices(final Shape shape) {\n+        Objects.requireNonNull(shape, \"shape\");\n+\n+        return new IndexProducer() {\n+\n+            @Override\n+            public boolean forEachIndex(IntPredicate consumer) {\n+                Objects.requireNonNull(consumer, \"consumer\");\n+                int bits = shape.getNumberOfBits();\n+\n+                // Essentially this is computing a wrapped modulus from a start point and an\n+                // increment. So actually you only need two modulus operations before the loop.\n+                // This avoids any modulus operation inside the while loop. It uses a long index\n+                // to avoid overflow.\n+\n+                long index = EnhancedDoubleHasher.mod(initial, bits);\n+                int inc = EnhancedDoubleHasher.mod(increment, bits);\n+\n+                for (int functionalCount = 0; functionalCount < shape.getNumberOfHashFunctions(); functionalCount++) {\n+                    if (!consumer.test((int) index)) {\n+                        return false;\n+                    }\n+                    index += inc;\n+                    index = index >= bits ? index - bits : index;\n+                }\n+                return true;\n+            }\n+\n+            @Override\n+            public int[] asIndexArray() {\n+                int[] result = new int[shape.getNumberOfHashFunctions()];\n+                int[] idx = new int[1];\n+\n+                // This method needs to return duplicate indices\n+\n+                forEachIndex(i -> {\n+                    result[idx[0]++] = i;\n+                    return true;\n+                });\n+                return result;\n+            }\n+        };\n+    }\n+}\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromArrayCountingBloomFilterTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromArrayCountingBloomFilterTest.java\nindex 383cf38619..0ea2c60795 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromArrayCountingBloomFilterTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromArrayCountingBloomFilterTest.java\n@@ -23,7 +23,7 @@ public class IndexProducerFromArrayCountingBloomFilterTest extends AbstractIndex\n     @Override\n     protected IndexProducer createProducer() {\n         ArrayCountingBloomFilter filter = new ArrayCountingBloomFilter(shape);\n-        Hasher hasher = new SimpleHasher(0, 1);\n+        Hasher hasher = new IncrementingHasher(0, 1);\n         filter.merge(hasher);\n         return filter;\n     }\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromHasherCollectionTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromHasherCollectionTest.java\nindex d7e61d796d..1376a4bfc0 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromHasherCollectionTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromHasherCollectionTest.java\n@@ -20,7 +20,7 @@ public class IndexProducerFromHasherCollectionTest extends AbstractIndexProducer\n \n     @Override\n     protected IndexProducer createProducer() {\n-        return new HasherCollection(new SimpleHasher(0, 1), new SimpleHasher(0, 2)).indices(Shape.fromKM(17, 72));\n+        return new HasherCollection(new IncrementingHasher(0, 1), new IncrementingHasher(0, 2)).indices(Shape.fromKM(17, 72));\n     }\n \n     @Override\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromHasherTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromHasherTest.java\nindex c089b4b420..683b3705e2 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromHasherTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromHasherTest.java\n@@ -20,7 +20,7 @@ public class IndexProducerFromHasherTest extends AbstractIndexProducerTest {\n \n     @Override\n     protected IndexProducer createProducer() {\n-        return new SimpleHasher(0, 1).indices(Shape.fromKM(17, 72));\n+        return new IncrementingHasher(0, 1).indices(Shape.fromKM(17, 72));\n     }\n \n     @Override\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromSimpleBloomFilterTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromSimpleBloomFilterTest.java\nindex 8525428671..d62ac959e0 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromSimpleBloomFilterTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromSimpleBloomFilterTest.java\n@@ -22,7 +22,7 @@ public class IndexProducerFromSimpleBloomFilterTest extends AbstractIndexProduce\n \n     @Override\n     protected IndexProducer createProducer() {\n-        Hasher hasher = new SimpleHasher(0, 1);\n+        Hasher hasher = new IncrementingHasher(0, 1);\n         return new SparseBloomFilter(shape, hasher);\n     }\n \ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromSparseBloomFilterTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromSparseBloomFilterTest.java\nindex 4204c90fe7..b51e01b40b 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromSparseBloomFilterTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/IndexProducerFromSparseBloomFilterTest.java\n@@ -22,7 +22,7 @@ public class IndexProducerFromSparseBloomFilterTest extends AbstractIndexProduce\n \n     @Override\n     protected IndexProducer createProducer() {\n-        Hasher hasher = new SimpleHasher(0, 1);\n+        Hasher hasher = new IncrementingHasher(0, 1);\n         return new SimpleBloomFilter(shape, hasher);\n     }\n \ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/SetOperationsTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/SetOperationsTest.java\nindex 9d7659d1fa..f958cdcc96 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/SetOperationsTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/SetOperationsTest.java\n@@ -25,9 +25,9 @@\n  */\n public class SetOperationsTest {\n \n-    protected final SimpleHasher from1 = new SimpleHasher(1, 1);\n+    protected final Hasher from1 = new IncrementingHasher(1, 1);\n     protected final long from1Value = 0x3FFFEL;\n-    protected final SimpleHasher from11 = new SimpleHasher(11, 1);\n+    protected final Hasher from11 = new IncrementingHasher(11, 1);\n     protected final long from11Value = 0xFFFF800L;\n     protected final HasherCollection bigHasher = new HasherCollection(from1, from11);\n     protected final long bigHashValue = 0xFFFFFFEL;\n@@ -49,7 +49,7 @@ public final void testCosineDistance() {\n \n         Shape shape2 = Shape.fromKM(2, 72);\n         filter1 = new SimpleBloomFilter(shape2, from1);\n-        filter2 = new SimpleBloomFilter(shape2, new SimpleHasher(2, 1));\n+        filter2 = new SimpleBloomFilter(shape2, new IncrementingHasher(2, 1));\n \n         int dotProduct = /* [1,2] & [2,3] = [2] = */ 1;\n         int cardinalityA = 2;\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/SimpleHasherTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/SimpleHasherTest.java\ndeleted file mode 100644\nindex cb52bf80a8..0000000000\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/SimpleHasherTest.java\n+++ /dev/null\n@@ -1,117 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.commons.collections4.bloomfilter;\n-\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n-import static org.junit.jupiter.api.Assertions.assertThrows;\n-import java.util.ArrayList;\n-import java.util.List;\n-import org.junit.jupiter.api.Test;\n-\n-/**\n- * Tests the {@link SimpleHasher}.\n- */\n-public class SimpleHasherTest extends AbstractHasherTest {\n-\n-    @Override\n-    protected Hasher createHasher() {\n-        return new SimpleHasher(1, 1);\n-    }\n-\n-    @Override\n-    protected Hasher createEmptyHasher() {\n-        return NullHasher.INSTANCE;\n-    }\n-\n-    @Override\n-    protected int getHasherSize(Hasher hasher) {\n-        return 1;\n-    }\n-\n-    private void assertConstructorBuffer(Shape shape, byte[] buffer, Integer[] expected) {\n-        SimpleHasher hasher = new SimpleHasher(buffer);\n-        List<Integer> lst = new ArrayList<>();\n-        IndexProducer producer = hasher.indices(shape);\n-        producer.forEachIndex(lst::add);\n-        assertEquals(expected.length, lst.size());\n-        for (int i = 0; i < expected.length; i++) {\n-            assertEquals(expected[i], lst.get(i));\n-        }\n-    }\n-\n-    private void assertIncrement(SimpleHasher hasher, long defaultIncrement) {\n-        assertEquals(defaultIncrement, hasher.getDefaultIncrement());\n-        int[] values = hasher.indices(Shape.fromKM(2, Integer.MAX_VALUE)).asIndexArray();\n-        assertEquals(0, values[0]);\n-        assertEquals(Long.remainderUnsigned(defaultIncrement, Integer.MAX_VALUE), values[1]);\n-    }\n-\n-    @Test\n-    public void testConstructor() {\n-        Shape shape = Shape.fromKM(5, 10);\n-        assertConstructorBuffer(shape, new byte[] { 1, 1 }, new Integer[] { 1, 2, 3, 4, 5 });\n-        assertConstructorBuffer(shape, new byte[] { 1 }, new Integer[] { 0, 1, 2, 3, 4 });\n-        assertConstructorBuffer(shape, new byte[] { 1, 0, 1 }, new Integer[] { 1, 2, 3, 4, 5 });\n-        assertConstructorBuffer(shape, new byte[] { 0, 1, 0, 1 }, new Integer[] { 1, 2, 3, 4, 5 });\n-        assertConstructorBuffer(shape, new byte[] { 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1 },\n-                new Integer[] { 1, 2, 3, 4, 5 });\n-        assertConstructorBuffer(shape, new byte[] { 0, 0, 0, 0, 0, 0, 0, 1, 5, 5, 0, 0, 0, 0, 0, 0, 0, 1, 5, 5 },\n-                new Integer[] { 1, 2, 3, 4, 5 });\n-        assertConstructorBuffer(shape, new byte[] { 0, 0, 0, 0, 0, 0, 0, 1, 5, 0, 0, 0, 0, 0, 0, 0, 1, 5, 5 },\n-                new Integer[] { 1, 2, 3, 4, 5 });\n-\n-        // test empty buffer\n-        assertThrows(IllegalArgumentException.class, () -> new SimpleHasher(new byte[0]));\n-\n-        // test zero incrementer gets default\n-        // default increment from SimpleHasher.\n-        long defaultIncrement = 0x9e3779b97f4a7c15L;\n-        SimpleHasher hasher = new SimpleHasher(0, 0);\n-        assertIncrement(new SimpleHasher(0, 0), defaultIncrement);\n-        assertIncrement(new SimpleHasher(new byte[2]), defaultIncrement);\n-\n-        // test that changing default increment works\n-        defaultIncrement = 4;\n-        defaultIncrement = 4L;\n-        hasher = new SimpleHasher(0, 0) {\n-            @Override\n-            public long getDefaultIncrement() {\n-                return 4L;\n-            }\n-        };\n-        assertIncrement(hasher, defaultIncrement);\n-        hasher = new SimpleHasher(new byte[2]) {\n-            @Override\n-            public long getDefaultIncrement() {\n-                return 4L;\n-            }\n-        };\n-\n-        assertEquals(defaultIncrement, hasher.getDefaultIncrement());\n-    }\n-\n-    @Test\n-    void testModEdgeCases() {\n-        for (long dividend : new long[] { -1, -2, -3, -6378683, -23567468136887892L, Long.MIN_VALUE, 345, 678686,\n-            67868768686878924L, Long.MAX_VALUE }) {\n-            for (int divisor : new int[] { 1, 2, 3, 5, 13, Integer.MAX_VALUE }) {\n-                assertEquals((int) Long.remainderUnsigned(dividend, divisor), SimpleHasher.mod(dividend, divisor),\n-                        () -> String.format(\"failure with dividend=%s and divisor=%s.\", dividend, divisor));\n-            }\n-        }\n-    }\n-}\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/UniqueIndexProducerFromHasherCollectionTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/UniqueIndexProducerFromHasherCollectionTest.java\nindex 4aaf9141a0..99ef6f200a 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/UniqueIndexProducerFromHasherCollectionTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/UniqueIndexProducerFromHasherCollectionTest.java\n@@ -20,7 +20,7 @@ public class UniqueIndexProducerFromHasherCollectionTest extends AbstractIndexPr\n \n     @Override\n     protected IndexProducer createProducer() {\n-        return new HasherCollection(new SimpleHasher(0, 1), new SimpleHasher(0, 2)).uniqueIndices(Shape.fromKM(17, 72));\n+        return new HasherCollection(new IncrementingHasher(0, 1), new IncrementingHasher(0, 2)).uniqueIndices(Shape.fromKM(17, 72));\n     }\n \n     @Override\ndiff --git a/src/test/java/org/apache/commons/collections4/bloomfilter/UniqueIndexProducerFromHasherTest.java b/src/test/java/org/apache/commons/collections4/bloomfilter/UniqueIndexProducerFromHasherTest.java\nindex f711a57201..84c17b60f8 100644\n--- a/src/test/java/org/apache/commons/collections4/bloomfilter/UniqueIndexProducerFromHasherTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bloomfilter/UniqueIndexProducerFromHasherTest.java\n@@ -20,7 +20,7 @@ public class UniqueIndexProducerFromHasherTest extends AbstractIndexProducerTest\n \n     @Override\n     protected IndexProducer createProducer() {\n-        return new SimpleHasher(0, 1).uniqueIndices(Shape.fromKM(17, 72));\n+        return new IncrementingHasher(0, 1).uniqueIndices(Shape.fromKM(17, 72));\n     }\n \n     @Override\n",
  "problem_statement" : "Collections 824: Optimize SimpleHasher.forEachIndex and SimpleHasher name change\n\nFix for COLLECTIONS-824 and COLLECTIONS-825\r\n\r\nRenamed `SimpleHasher` to `EnhancedDoubleHasher` and modified the hashing accordingly.\r\n\r\nMost test changes are to switch to a testing Hasher.",
  "hints_text" : null,
  "created_at" : "Sat Jul 09 13:12:05 CEST 2022",
  "version" : null,
  "FAIL_TO_PASS" : [ "BitCountProducerFromArrayCountingBloomFilterTest", "AbstractHasherTest", "IndexProducerFromArrayCountingBloomFilterTest", "IndexProducerFromHasherCollectionTest", "HasherCollectionTest", "IndexProducerFromSimpleBloomFilterTest", "AbstractCountingBloomFilterTest", "BitMapProducerFromArrayCountingBloomFilterTest", "UniqueIndexProducerFromHasherCollectionTest", "BitMapProducerFromSimpleBloomFilterTest", "EnhancedDoubleHasherTest", "IncrementingHasher", "SetOperationsTest", "AbstractBloomFilterTest", "IndexProducerFromHasherTest", "BitMapProducerFromSparseBloomFilterTest", "SimpleHasherTest", "DefaultBloomFilterTest", "IndexProducerFromSparseBloomFilterTest", "UniqueIndexProducerFromHasherTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=BitCountProducerFromArrayCountingBloomFilterTest,AbstractHasherTest,IndexProducerFromArrayCountingBloomFilterTest,IndexProducerFromHasherCollectionTest,HasherCollectionTest,IndexProducerFromSimpleBloomFilterTest,AbstractCountingBloomFilterTest,BitMapProducerFromArrayCountingBloomFilterTest,UniqueIndexProducerFromHasherCollectionTest,BitMapProducerFromSimpleBloomFilterTest,EnhancedDoubleHasherTest,IncrementingHasher,SetOperationsTest,AbstractBloomFilterTest,IndexProducerFromHasherTest,BitMapProducerFromSparseBloomFilterTest,SimpleHasherTest,DefaultBloomFilterTest,IndexProducerFromSparseBloomFilterTest,UniqueIndexProducerFromHasherTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 320,
  "metadata" : null
} ]