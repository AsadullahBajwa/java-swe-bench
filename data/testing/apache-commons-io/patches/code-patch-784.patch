diff --git a/src/changes/changes.xml b/src/changes/changes.xml
index c28573c784e..0190734a841 100644
--- a/src/changes/changes.xml
+++ b/src/changes/changes.xml
@@ -63,9 +63,10 @@ The <action> type attribute can be add,update,fix,remove.
       <action dev="ggregory" type="add"                due-to="Gary Gregory">Add org.apache.commons.io.output.ProxyOutputStream.writeRepeat(int, long).</action>
       <action dev="pkarwasz" type="add"                due-to="Piotr P. Karwasz">Add length unit support in FileSystem limits.</action>
       <action dev="pkarwasz" type="add"                due-to="Piotr P. Karwasz">Add IOUtils.toByteArray(InputStream, int, int) for safer chunked reading with size validation.</action>
-      <action dev="pkarwasz" type="add"                due-to="Piotr P. Karwasz">Add org.apache.commons.io.file.PathUtils.getPath(String, String).</action>
+      <action dev="ggregory" type="add"                due-to="Gary Gregory">Add org.apache.commons.io.file.PathUtils.getPath(String, String).</action>
       <action dev="ggregory" type="add"                due-to="Gary Gregory">Add org.apache.commons.io.channels.ByteArraySeekableByteChannel.</action>
       <action dev="ggregory" type="add"                due-to="Gary Gregory">Add IOIterable.asIterable().</action>
+      <action dev="pkarwasz" type="add"                due-to="Piotr P. Karwasz">Add NIO channel support to `AbstractStreamBuilder`.</action>
       <action dev="pkarwasz" type="add"                due-to="Piotr P. Karwasz">Add CloseShieldChannel to close-shielded NIO Channels #786.</action>
       <!-- UPDATE -->
       <action type="update" dev="ggregory"             due-to="Gary Gregory, Dependabot">Bump org.apache.commons:commons-parent from 85 to 88 #774, #783.</action>
diff --git a/src/main/java/org/apache/commons/io/build/AbstractOrigin.java b/src/main/java/org/apache/commons/io/build/AbstractOrigin.java
index 3c81bfd38bf..1706076fbaf 100644
--- a/src/main/java/org/apache/commons/io/build/AbstractOrigin.java
+++ b/src/main/java/org/apache/commons/io/build/AbstractOrigin.java
@@ -19,6 +19,7 @@
 
 import java.io.ByteArrayInputStream;
 import java.io.File;
+import java.io.FileInputStream;
 import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.InputStream;
@@ -29,13 +30,17 @@
 import java.io.Reader;
 import java.io.Writer;
 import java.net.URI;
+import java.nio.channels.Channel;
+import java.nio.channels.Channels;
+import java.nio.channels.ReadableByteChannel;
+import java.nio.channels.SeekableByteChannel;
+import java.nio.channels.WritableByteChannel;
 import java.nio.charset.Charset;
 import java.nio.file.Files;
 import java.nio.file.OpenOption;
 import java.nio.file.Path;
 import java.nio.file.Paths;
 import java.nio.file.StandardOpenOption;
-import java.nio.file.spi.FileSystemProvider;
 import java.util.Arrays;
 import java.util.Objects;
 
@@ -44,7 +49,7 @@
 import org.apache.commons.io.IOUtils;
 import org.apache.commons.io.RandomAccessFileMode;
 import org.apache.commons.io.RandomAccessFiles;
-import org.apache.commons.io.file.spi.FileSystemProviders;
+import org.apache.commons.io.channels.ByteArraySeekableByteChannel;
 import org.apache.commons.io.input.BufferedFileChannelInputStream;
 import org.apache.commons.io.input.CharSequenceInputStream;
 import org.apache.commons.io.input.CharSequenceReader;
@@ -53,15 +58,270 @@
 import org.apache.commons.io.output.WriterOutputStream;
 
 /**
- * Abstracts the origin of data for builders like a {@link File}, {@link Path}, {@link Reader}, {@link Writer}, {@link InputStream}, {@link OutputStream}, and
- * {@link URI}.
+ * Abstract base class that encapsulates the <em>origin</em> of data used by Commons IO builders.
  * <p>
- * Some methods may throw {@link UnsupportedOperationException} if that method is not implemented in a concrete subclass, see {@link #getFile()} and
- * {@link #getPath()}.
+ * An origin represents where bytes/characters come from or go to, such as a {@link File}, {@link Path},
+ * {@link Reader}, {@link Writer}, {@link InputStream}, {@link OutputStream}, or {@link URI}. Concrete subclasses
+ * expose only the operations that make sense for the underlying source or sink; invoking an unsupported operation
+ * results in {@link UnsupportedOperationException} (see, for example, {@link #getFile()} and {@link #getPath()}).
  * </p>
  *
- * @param <T> the type of instances to build.
- * @param <B> the type of builder subclass.
+ * <p>
+ * The table below summarizes which views and conversions are supported for each origin type.
+ * Column headers show the target view; cells indicate whether that view is available from the origin in that row.
+ * </p>
+ *
+ * <table>
+ *   <caption>Origin support matrix</caption>
+ *   <thead>
+ *     <tr>
+ *       <th>Origin Type</th>
+ *       <th>byte[]</th>
+ *       <th>CS</th>
+ *       <th>File</th>
+ *       <th>Path</th>
+ *       <th>RAF</th>
+ *       <th>IS</th>
+ *       <th>Reader</th>
+ *       <th>RBC</th>
+ *       <th>OS</th>
+ *       <th>Writer</th>
+ *       <th>WBC</th>
+ *       <th>Channel type<sup>2</sup></th>
+ *     </tr>
+ *   </thead>
+ *   <tbody>
+ *     <tr>
+ *       <td>byte[]</td>
+ *       <td>✔</td>
+ *       <td>✔</td>
+ *       <td>✖</td>
+ *       <td>✖</td>
+ *       <td>✖</td>
+ *       <td>✔</td>
+ *       <td>✔</td>
+ *       <td>✔</td>
+ *       <td>✖</td>
+ *       <td>✖</td>
+ *       <td>✖</td>
+ *       <td>SBC</td>
+ *     </tr>
+ *     <tr>
+ *       <td>CharSequence (CS)</td>
+ *       <td>✔</td>
+ *       <td>✔</td>
+ *       <td>✖</td>
+ *       <td>✖</td>
+ *       <td>✖</td>
+ *       <td>✔<sup>1</sup></td>
+ *       <td>✔</td>
+ *       <td>✔<sup>1</sup></td>
+ *       <td>✖</td>
+ *       <td>✖</td>
+ *       <td>✖</td>
+ *       <td>SBC</td>
+ *     </tr>
+ *     <tr>
+ *       <td>File</td>
+ *       <td>✔</td>
+ *       <td>✔</td>
+ *       <td>✔</td>
+ *       <td>✔</td>
+ *       <td>✔</td>
+ *       <td>✔</td>
+ *       <td>✔</td>
+ *       <td>✔</td>
+ *       <td>✔</td>
+ *       <td>✔</td>
+ *       <td>✔</td>
+ *       <td>FC</td>
+ *     </tr>
+ *     <tr>
+ *       <td>Path</td>
+ *       <td>✔</td>
+ *       <td>✔</td>
+ *       <td>✔</td>
+ *       <td>✔</td>
+ *       <td>✔</td>
+ *       <td>✔</td>
+ *       <td>✔</td>
+ *       <td>✔</td>
+ *       <td>✔</td>
+ *       <td>✔</td>
+ *       <td>✔</td>
+ *       <td>FC</td>
+ *     </tr>
+ *     <tr>
+ *       <td>IORandomAccessFile</td>
+ *       <td>✔</td>
+ *       <td>✔</td>
+ *       <td>✔</td>
+ *       <td>✔</td>
+ *       <td>✔</td>
+ *       <td>✔</td>
+ *       <td>✔</td>
+ *       <td>✔</td>
+ *       <td>✔</td>
+ *       <td>✔</td>
+ *       <td>✔</td>
+ *       <td>FC</td>
+ *     </tr>
+ *     <tr>
+ *       <td>RandomAccessFile (RAF)</td>
+ *       <td>✔</td>
+ *       <td>✔</td>
+ *       <td>✖</td>
+ *       <td>✖</td>
+ *       <td>✔</td>
+ *       <td>✔</td>
+ *       <td>✔</td>
+ *       <td>✔</td>
+ *       <td>✔</td>
+ *       <td>✔</td>
+ *       <td>✔</td>
+ *       <td>FC</td>
+ *     </tr>
+ *     <tr>
+ *       <td>InputStream (IS)</td>
+ *       <td>✔</td>
+ *       <td>✔</td>
+ *       <td>✖</td>
+ *       <td>✖</td>
+ *       <td>✖</td>
+ *       <td>✔</td>
+ *       <td>✔</td>
+ *       <td>✔</td>
+ *       <td>✖</td>
+ *       <td>✖</td>
+ *       <td>✖</td>
+ *       <td>RBC</td>
+ *     </tr>
+ *     <tr>
+ *       <td>Reader</td>
+ *       <td>✔</td>
+ *       <td>✔</td>
+ *       <td>✖</td>
+ *       <td>✖</td>
+ *       <td>✖</td>
+ *       <td>✔<sup>1</sup></td>
+ *       <td>✔</td>
+ *       <td>✔<sup>1</sup></td>
+ *       <td>✖</td>
+ *       <td>✖</td>
+ *       <td>✖</td>
+ *       <td>RBC</td>
+ *     </tr>
+ *     <tr>
+ *       <td>ReadableByteChannel (RBC)</td>
+ *       <td>✔</td>
+ *       <td>✔</td>
+ *       <td>✖</td>
+ *       <td>✖</td>
+ *       <td>✖</td>
+ *       <td>✔</td>
+ *       <td>✔</td>
+ *       <td>✔</td>
+ *       <td>✖</td>
+ *       <td>✖</td>
+ *       <td>✖</td>
+ *       <td>RBC</td>
+ *     </tr>
+ *     <tr>
+ *       <td>OutputStream (OS)</td>
+ *       <td>✖</td>
+ *       <td>✖</td>
+ *       <td>✖</td>
+ *       <td>✖</td>
+ *       <td>✖</td>
+ *       <td>✖</td>
+ *       <td>✖</td>
+ *       <td>✖</td>
+ *       <td>✔</td>
+ *       <td>✔</td>
+ *       <td>✔</td>
+ *       <td>WBC</td>
+ *     </tr>
+ *     <tr>
+ *       <td>Writer</td>
+ *       <td>✖</td>
+ *       <td>✖</td>
+ *       <td>✖</td>
+ *       <td>✖</td>
+ *       <td>✖</td>
+ *       <td>✖</td>
+ *       <td>✖</td>
+ *       <td>✖</td>
+ *       <td>✔<sup>1</sup></td>
+ *       <td>✔</td>
+ *       <td>✔<sup>1</sup></td>
+ *       <td>WBC</td>
+ *     </tr>
+ *     <tr>
+ *       <td>WritableByteChannel (WBC)</td>
+ *       <td>✖</td>
+ *       <td>✖</td>
+ *       <td>✖</td>
+ *       <td>✖</td>
+ *       <td>✖</td>
+ *       <td>✖</td>
+ *       <td>✖</td>
+ *       <td>✖</td>
+ *       <td>✔</td>
+ *       <td>✔</td>
+ *       <td>✔</td>
+ *       <td>WBC</td>
+ *     </tr>
+ *     <tr>
+ *       <td>URI (FileSystem)</td>
+ *       <td>✔</td>
+ *       <td>✔</td>
+ *       <td>✔</td>
+ *       <td>✔</td>
+ *       <td>✔</td>
+ *       <td>✔</td>
+ *       <td>✔</td>
+ *       <td>✔</td>
+ *       <td>✔</td>
+ *       <td>✔</td>
+ *       <td>✔</td>
+ *       <td>FC</td>
+ *     </tr>
+ *     <tr>
+ *       <td>URI (http/https))</td>
+ *       <td>✔</td>
+ *       <td>✔</td>
+ *       <td>✖</td>
+ *       <td>✖</td>
+ *       <td>✖</td>
+ *       <td>✔</td>
+ *       <td>✔</td>
+ *       <td>✔</td>
+ *       <td>✖</td>
+ *       <td>✖</td>
+ *       <td>✖</td>
+ *       <td>RBC</td>
+ *     </tr>
+ *   </tbody>
+ * </table>
+ *
+ * <p><strong>Legend</strong></p>
+ * <ul>
+ *   <li>✔ = Supported</li>
+ *   <li>✖ = Not supported (throws {@link UnsupportedOperationException})</li>
+ *   <li><sup>1</sup> = Characters are converted to bytes using the default {@link Charset}.</li>
+ *   <li><sup>2</sup> Minimum channel type provided by the origin:
+ *     <ul>
+ *         <li>RBC = ReadableByteChannel</li>
+ *         <li>WBC = WritableByteChannel</li>
+ *         <li>SBC = SeekableByteChannel</li>
+ *         <li>FC = FileChannel</li>
+ *     </ul>
+ *     The exact channel type may be a subtype of the minimum shown.
+ *   </li>
+ * </ul>
+ *
+ * @param <T> the type produced by the builder.
+ * @param <B> the concrete builder subclass type.
  * @since 2.12.0
  */
 public abstract class AbstractOrigin<T, B extends AbstractOrigin<T, B>> extends AbstractSupplier<T, B> {
@@ -137,6 +397,11 @@ public Writer getWriter(final Charset charset, final OpenOption... options) thro
             return new OutputStreamWriter(getOutputStream(options), Charsets.toCharset(charset));
         }
 
+        @Override
+        protected Channel getChannel(OpenOption... options) throws IOException {
+            return getRandomAccessFile(options).getChannel();
+        }
+
         @Override
         public long size() throws IOException {
             return origin.length();
@@ -179,6 +444,17 @@ public Reader getReader(final Charset charset) throws IOException {
             return new InputStreamReader(getInputStream(), Charsets.toCharset(charset));
         }
 
+        @Override
+        protected Channel getChannel(OpenOption... options) throws IOException {
+            for (final OpenOption option : options) {
+                if (option == StandardOpenOption.WRITE) {
+                    throw new UnsupportedOperationException(
+                            "Only READ is supported for byte[] origins: " + Arrays.toString(options));
+                }
+            }
+            return ByteArraySeekableByteChannel.wrap(getByteArray());
+        }
+
         @Override
         public long size() throws IOException {
             return origin.length;
@@ -241,6 +517,17 @@ public Reader getReader(final Charset charset) throws IOException {
             return new CharSequenceReader(get());
         }
 
+        @Override
+        protected Channel getChannel(OpenOption... options) throws IOException {
+            for (final OpenOption option : options) {
+                if (option == StandardOpenOption.WRITE) {
+                    throw new UnsupportedOperationException(
+                            "Only READ is supported for CharSequence origins: " + Arrays.toString(options));
+                }
+            }
+            return ByteArraySeekableByteChannel.wrap(getByteArray());
+        }
+
         @Override
         public long size() throws IOException {
             return origin.length();
@@ -283,6 +570,10 @@ public Path getPath() {
             return get().toPath();
         }
 
+        @Override
+        protected Channel getChannel(OpenOption... options) throws IOException {
+            return Files.newByteChannel(getPath(), options);
+        }
     }
 
     /**
@@ -324,6 +615,19 @@ public Reader getReader(final Charset charset) throws IOException {
             return new InputStreamReader(getInputStream(), Charsets.toCharset(charset));
         }
 
+        @Override
+        protected Channel getChannel(OpenOption... options) throws IOException {
+            return Channels.newChannel(getInputStream(options));
+        }
+
+        @Override
+        public long size() throws IOException {
+            if (origin instanceof FileInputStream) {
+                final FileInputStream fileInputStream = (FileInputStream) origin;
+                return fileInputStream.getChannel().size();
+            }
+            throw unsupportedOperation("size");
+        }
     }
 
     /**
@@ -394,6 +698,11 @@ public OutputStream getOutputStream(final OpenOption... options) {
         public Writer getWriter(final Charset charset, final OpenOption... options) throws IOException {
             return new OutputStreamWriter(origin, Charsets.toCharset(charset));
         }
+
+        @Override
+        protected Channel getChannel(OpenOption... options) throws IOException {
+            return Channels.newChannel(getOutputStream(options));
+        }
     }
 
     /**
@@ -429,6 +738,10 @@ public Path getPath() {
             return get();
         }
 
+        @Override
+        protected Channel getChannel(OpenOption... options) throws IOException {
+            return Files.newByteChannel(getPath(), options);
+        }
     }
 
     /**
@@ -511,6 +824,11 @@ public Reader getReader(final Charset charset) throws IOException {
             // No conversion
             return get();
         }
+
+        @Override
+        protected Channel getChannel(OpenOption... options) throws IOException {
+            return Channels.newChannel(getInputStream());
+        }
     }
 
     /**
@@ -539,10 +857,6 @@ public File getFile() {
         public InputStream getInputStream(final OpenOption... options) throws IOException {
             final URI uri = get();
             final String scheme = uri.getScheme();
-            final FileSystemProvider fileSystemProvider = FileSystemProviders.installed().getFileSystemProvider(scheme);
-            if (fileSystemProvider != null) {
-                return Files.newInputStream(fileSystemProvider.getPath(uri), options);
-            }
             if (SCHEME_HTTP.equalsIgnoreCase(scheme) || SCHEME_HTTPS.equalsIgnoreCase(scheme)) {
                 return uri.toURL().openStream();
             }
@@ -553,6 +867,16 @@ public InputStream getInputStream(final OpenOption... options) throws IOExceptio
         public Path getPath() {
             return Paths.get(get());
         }
+
+        @Override
+        protected Channel getChannel(OpenOption... options) throws IOException {
+            final URI uri = get();
+            final String scheme = uri.getScheme();
+            if (SCHEME_HTTP.equalsIgnoreCase(scheme) || SCHEME_HTTPS.equalsIgnoreCase(scheme)) {
+                return Channels.newChannel(uri.toURL().openStream());
+            }
+            return Files.newByteChannel(getPath(), options);
+        }
     }
 
     /**
@@ -598,6 +922,73 @@ public Writer getWriter(final Charset charset, final OpenOption... options) thro
             // No conversion
             return get();
         }
+
+        @Override
+        protected Channel getChannel(OpenOption... options) throws IOException {
+            return Channels.newChannel(getOutputStream());
+        }
+    }
+
+    /**
+     * A {@link Channel} origin.
+     *
+     * @since 2.21.0
+     */
+    public static class ChannelOrigin extends AbstractOrigin<Channel, ChannelOrigin> {
+
+        /**
+         * Constructs a new instance for the given origin.
+         *
+         * @param origin The origin, not null.
+         */
+        public ChannelOrigin(final Channel origin) {
+            super(origin);
+        }
+
+        @Override
+        public byte[] getByteArray() throws IOException {
+            return IOUtils.toByteArray(getInputStream());
+        }
+
+        @Override
+        public InputStream getInputStream(final OpenOption... options) throws IOException {
+            return Channels.newInputStream(getChannel(ReadableByteChannel.class, options));
+        }
+
+        @Override
+        public Reader getReader(Charset charset) throws IOException {
+            return Channels.newReader(
+                    getChannel(ReadableByteChannel.class),
+                    Charsets.toCharset(charset).newDecoder(),
+                    -1);
+        }
+
+        @Override
+        public OutputStream getOutputStream(final OpenOption... options) throws IOException {
+            return Channels.newOutputStream(getChannel(WritableByteChannel.class, options));
+        }
+
+        @Override
+        public Writer getWriter(Charset charset, OpenOption... options) throws IOException {
+            return Channels.newWriter(
+                    getChannel(WritableByteChannel.class, options),
+                    Charsets.toCharset(charset).newEncoder(),
+                    -1);
+        }
+
+        @Override
+        protected Channel getChannel(OpenOption... options) throws IOException {
+            // No conversion
+            return get();
+        }
+
+        @Override
+        public long size() throws IOException {
+            if (origin instanceof SeekableByteChannel) {
+                return ((SeekableByteChannel) origin).size();
+            }
+            throw unsupportedOperation("size");
+        }
     }
 
     /**
@@ -675,8 +1066,7 @@ public CharSequence getCharSequence(final Charset charset) throws IOException {
      * @throws UnsupportedOperationException if this method is not implemented in a concrete subclass.
      */
     public File getFile() {
-        throw new UnsupportedOperationException(
-                String.format("%s#getFile() for %s origin %s", getSimpleClassName(), origin.getClass().getSimpleName(), origin));
+        throw unsupportedOperation("getFile");
     }
 
     /**
@@ -710,8 +1100,7 @@ public OutputStream getOutputStream(final OpenOption... options) throws IOExcept
      * @throws UnsupportedOperationException if this method is not implemented in a concrete subclass.
      */
     public Path getPath() {
-        throw new UnsupportedOperationException(
-                String.format("%s#getPath() for %s origin %s", getSimpleClassName(), origin.getClass().getSimpleName(), origin));
+        throw unsupportedOperation("getPath");
     }
 
     /**
@@ -755,6 +1144,39 @@ public Writer getWriter(final Charset charset, final OpenOption... options) thro
         return Files.newBufferedWriter(getPath(), Charsets.toCharset(charset), options);
     }
 
+    /**
+     * Gets this origin as a Channel of the given type, if possible.
+     *
+     * @param channelType The type of channel to return.
+     * @param options Options specifying how a file-based origin is opened, ignored otherwise.
+     * @return A new Channel on the origin of the given type.
+     * @param <C> The type of channel to return.
+     * @throws IOException                   If an I/O error occurs.
+     * @throws UnsupportedOperationException If this origin cannot be converted to a channel of the given type.
+     * @since 2.21.0
+     */
+    public final <C extends Channel> C getChannel(Class<C> channelType, OpenOption... options) throws IOException {
+        Objects.requireNonNull(channelType, "channelType");
+        final Channel channel = getChannel(options);
+        if (channelType.isInstance(channel)) {
+            return channelType.cast(channel);
+        }
+        throw unsupportedChannelType(channelType);
+    }
+
+    /**
+     * Gets this origin as a Channel, if possible.
+     *
+     * @param options Options specifying how a file-based origin is opened, ignored otherwise.
+     * @return A new Channel on the origin.
+     * @throws IOException                   If an I/O error occurs.
+     * @throws UnsupportedOperationException If this origin cannot be converted to a channel.
+     * @since 2.21.0
+     */
+    protected Channel getChannel(OpenOption... options) throws IOException {
+        throw unsupportedOperation("getChannel");
+    }
+
     /**
      * Gets the size of the origin, if possible.
      *
@@ -770,4 +1192,19 @@ public long size() throws IOException {
     public String toString() {
         return getSimpleClassName() + "[" + origin.toString() + "]";
     }
+
+    UnsupportedOperationException unsupportedOperation(String method) {
+        return new UnsupportedOperationException(String.format(
+                "%s#%s() for %s origin %s",
+                getSimpleClassName(), method, origin.getClass().getSimpleName(), origin));
+    }
+
+    UnsupportedOperationException unsupportedChannelType(Class<? extends Channel> channelType) {
+        return new UnsupportedOperationException(String.format(
+                "%s#getChannel(%s) for %s origin %s",
+                getSimpleClassName(),
+                channelType.getSimpleName(),
+                origin.getClass().getSimpleName(),
+                origin));
+    }
 }
diff --git a/src/main/java/org/apache/commons/io/build/AbstractOriginSupplier.java b/src/main/java/org/apache/commons/io/build/AbstractOriginSupplier.java
index 8f2354d95bf..6f14fac3bfc 100644
--- a/src/main/java/org/apache/commons/io/build/AbstractOriginSupplier.java
+++ b/src/main/java/org/apache/commons/io/build/AbstractOriginSupplier.java
@@ -24,11 +24,13 @@
 import java.io.Reader;
 import java.io.Writer;
 import java.net.URI;
+import java.nio.channels.Channel;
 import java.nio.file.Path;
 import java.nio.file.Paths;
 
 import org.apache.commons.io.IORandomAccessFile;
 import org.apache.commons.io.build.AbstractOrigin.ByteArrayOrigin;
+import org.apache.commons.io.build.AbstractOrigin.ChannelOrigin;
 import org.apache.commons.io.build.AbstractOrigin.CharSequenceOrigin;
 import org.apache.commons.io.build.AbstractOrigin.FileOrigin;
 import org.apache.commons.io.build.AbstractOrigin.IORandomAccessFileOrigin;
@@ -182,6 +184,17 @@ protected static WriterOrigin newWriterOrigin(final Writer origin) {
         return new WriterOrigin(origin);
     }
 
+    /**
+     * Constructs a new channel origin for a channel.
+     *
+     * @param origin the channel.
+     * @return a new channel origin.
+     * @since 2.21.0
+     */
+    protected static ChannelOrigin newChannelOrigin(final Channel origin) {
+        return new ChannelOrigin(origin);
+    }
+
     /**
      * The underlying origin.
      */
@@ -368,4 +381,15 @@ public B setURI(final URI origin) {
     public B setWriter(final Writer origin) {
         return setOrigin(newWriterOrigin(origin));
     }
+
+    /**
+     * Sets a new origin.
+     *
+     * @param origin the new origin.
+     * @return {@code this} instance.
+     * @since 2.21.0
+     */
+    public B setChannel(final Channel origin) {
+        return setOrigin(newChannelOrigin(origin));
+    }
 }
diff --git a/src/main/java/org/apache/commons/io/build/AbstractStreamBuilder.java b/src/main/java/org/apache/commons/io/build/AbstractStreamBuilder.java
index 3feac4a6533..fe37c5eedab 100644
--- a/src/main/java/org/apache/commons/io/build/AbstractStreamBuilder.java
+++ b/src/main/java/org/apache/commons/io/build/AbstractStreamBuilder.java
@@ -24,6 +24,8 @@
 import java.io.RandomAccessFile;
 import java.io.Reader;
 import java.io.Writer;
+import java.nio.channels.Channel;
+import java.nio.channels.ReadableByteChannel;
 import java.nio.charset.Charset;
 import java.nio.file.OpenOption;
 import java.nio.file.Path;
@@ -258,6 +260,23 @@ public Writer getWriter() throws IOException {
         return checkOrigin().getWriter(getCharset(), getOpenOptions());
     }
 
+    /**
+     * Gets a Channel from the origin with OpenOption[].
+     *
+     * @param channelType The channel type, not null.
+     * @return A channel of the specified type.
+     * @param <C>         The channel type.
+     * @throws IllegalStateException         if the {@code origin} is {@code null}.
+     * @throws UnsupportedOperationException if the origin cannot be converted to a {@link ReadableByteChannel}.
+     * @throws IOException                   if an I/O error occurs.
+     * @see AbstractOrigin#getChannel
+     * @see #getOpenOptions()
+     * @since 2.21.0
+     */
+    public <C extends Channel> C getChannel(Class<C> channelType) throws IOException {
+        return checkOrigin().getChannel(channelType, getOpenOptions());
+    }
+
     /**
      * Sets the buffer size. Invalid input (bufferSize &lt;= 0) resets the value to its default.
      * <p>
diff --git a/src/main/java/org/apache/commons/io/channels/ByteArraySeekableByteChannel.java b/src/main/java/org/apache/commons/io/channels/ByteArraySeekableByteChannel.java
index 51e8c182447..d1aff851500 100644
--- a/src/main/java/org/apache/commons/io/channels/ByteArraySeekableByteChannel.java
+++ b/src/main/java/org/apache/commons/io/channels/ByteArraySeekableByteChannel.java
@@ -19,12 +19,14 @@
 
 package org.apache.commons.io.channels;
 
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
 import java.io.IOException;
 import java.nio.ByteBuffer;
 import java.nio.channels.ClosedChannelException;
 import java.nio.channels.SeekableByteChannel;
 import java.util.Arrays;
-import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.Objects;
 import java.util.concurrent.locks.ReentrantLock;
 
 import org.apache.commons.io.IOUtils;
@@ -37,41 +39,73 @@
  * accessed via {@link ByteArraySeekableByteChannel#array()}.
  * </p>
  *
- * @since 2.19.0
+ * @since 2.21.0
  */
 public class ByteArraySeekableByteChannel implements SeekableByteChannel {
 
     private static final int RESIZE_LIMIT = Integer.MAX_VALUE >> 1;
+
+    /**
+     * Constructs a new channel backed directly by the given byte array.
+     *
+     * <p>The channel initially contains the full contents of the array, with its
+     * size set to {@code bytes.length} and its position set to {@code 0}.</p>
+     *
+     * <p>Reads and writes operate on the shared array.
+     * If a write operation extends beyond the current capacity, the channel will
+     * automatically allocate a larger backing array and copy the existing contents.</p>
+     *
+     * @param bytes The byte array to wrap, must not be {@code null}
+     * @return A new channel that uses the given array as its initial backing store
+     * @throws NullPointerException If {@code bytes} is {@code null}
+     * @see #array()
+     * @see ByteArrayInputStream#ByteArrayInputStream(byte[])
+     */
+    public static ByteArraySeekableByteChannel wrap(byte[] bytes) {
+        Objects.requireNonNull(bytes, "bytes");
+        return new ByteArraySeekableByteChannel(bytes);
+    }
+
     private byte[] data;
-    private final AtomicBoolean closed = new AtomicBoolean();
+    private volatile boolean closed;
     private int position;
     private int size;
     private final ReentrantLock lock = new ReentrantLock();
 
     /**
-     * Constructs a new instance using a default empty buffer.
+     * Constructs a new instance, with a default internal buffer capacity.
+     * <p>
+     * The initial size and position of the channel are 0.
+     * </p>
+     *
+     * @see ByteArrayOutputStream#ByteArrayOutputStream()
      */
     public ByteArraySeekableByteChannel() {
-        this(0);
+        this(IOUtils.DEFAULT_BUFFER_SIZE);
     }
 
     /**
-     * Constructs a new instance from a byte array.
+     * Constructs a new instance, with an internal buffer of the given capacity, in bytes.
+     * <p>
+     * The initial size and position of the channel are 0.
+     * </p>
      *
-     * @param data input data or pre-allocated array.
+     * @param size Capacity of the internal buffer to allocate, in bytes.
+     * @see ByteArrayOutputStream#ByteArrayOutputStream(int)
      */
-    public ByteArraySeekableByteChannel(final byte[] data) {
-        this.data = data;
-        this.size = data.length;
+    public ByteArraySeekableByteChannel(final int size) {
+        if (size < 0) {
+            throw new IllegalArgumentException("Size must be non-negative");
+        }
+        this.data = new byte[size];
+        this.position = 0;
+        this.size = 0;
     }
 
-    /**
-     * Constructs a new instance from a size of storage to be allocated.
-     *
-     * @param size size of internal buffer to allocate, in bytes.
-     */
-    public ByteArraySeekableByteChannel(final int size) {
-        this(new byte[size]);
+    private ByteArraySeekableByteChannel(byte[] data) {
+        this.data = data;
+        this.position = 0;
+        this.size = data.length;
     }
 
     /**
@@ -86,6 +120,18 @@ public byte[] array() {
         return data;
     }
 
+    /**
+     * Gets a copy of the data stored in this channel.
+     * <p>
+     * The returned array is a copy of the internal buffer, sized to the actual data stored in this channel.
+     * </p>
+     *
+     * @return a new byte array containing the data stored in this channel.
+     */
+    public byte[] toByteArray() {
+        return Arrays.copyOf(data, size);
+    }
+
     private void checkOpen() throws ClosedChannelException {
         if (!isOpen()) {
             throw new ClosedChannelException();
@@ -101,7 +147,7 @@ private int checkRange(final long newSize, final String method) {
 
     @Override
     public void close() {
-        closed.set(true);
+        closed = true;
     }
 
     /**
@@ -115,7 +161,7 @@ public long getSize() {
 
     @Override
     public boolean isOpen() {
-        return !closed.get();
+        return !closed;
     }
 
     @Override
@@ -165,7 +211,7 @@ public int read(final ByteBuffer buf) throws IOException {
 
     private void resize(final int newLength) {
         int len = data.length;
-        if (len <= 0) {
+        if (len == 0) {
             len = 1;
         }
         if (newLength < RESIZE_LIMIT) {
@@ -212,13 +258,12 @@ public int write(final ByteBuffer b) throws IOException {
         checkOpen();
         lock.lock();
         try {
-            int wanted = b.remaining();
-            final int possibleWithoutResize = size - position;
+            final int wanted = b.remaining();
+            final int possibleWithoutResize = Math.max(0, size - position);
             if (wanted > possibleWithoutResize) {
                 final int newSize = position + wanted;
-                if (newSize < 0) { // overflow
-                    resize(IOUtils.SOFT_MAX_ARRAY_LENGTH);
-                    wanted = IOUtils.SOFT_MAX_ARRAY_LENGTH - position;
+                if (newSize < 0 || newSize > IOUtils.SOFT_MAX_ARRAY_LENGTH) { // overflow
+                    throw new OutOfMemoryError("required array size " + Integer.toUnsignedString(newSize) + " too large");
                 } else {
                     resize(newSize);
                 }
