[ {
  "instance_id" : "apache-commons-io-PR-818",
  "repo" : "apache/commons-io",
  "base_commit" : "8f66b3212c3d35c74cc96e7d0b3258f0fb9305f1",
  "patch" : "diff --git a/src/main/java/org/apache/commons/io/FileUtils.java b/src/main/java/org/apache/commons/io/FileUtils.java\nindex 523c2c1fd26..a24ab813a73 100644\n--- a/src/main/java/org/apache/commons/io/FileUtils.java\n+++ b/src/main/java/org/apache/commons/io/FileUtils.java\n@@ -2290,7 +2290,7 @@ public static LineIterator lineIterator(final File file, final String charsetNam\n             inputStream = Files.newInputStream(file.toPath());\n             return IOUtils.lineIterator(inputStream, charsetName);\n         } catch (final IOException | RuntimeException ex) {\n-            IOUtils.closeQuietly(inputStream, ex::addSuppressed);\n+            IOUtils.closeQuietly(inputStream, ex);\n             throw ex;\n         }\n     }\ndiff --git a/src/main/java/org/apache/commons/io/IOUtils.java b/src/main/java/org/apache/commons/io/IOUtils.java\nindex 09a018b036d..8a4057ae514 100644\n--- a/src/main/java/org/apache/commons/io/IOUtils.java\n+++ b/src/main/java/org/apache/commons/io/IOUtils.java\n@@ -780,7 +780,7 @@ public static void close(final URLConnection conn) {\n      * @param closeable the object to close, may be null.\n      */\n     private static void closeQ(final Closeable closeable) {\n-        closeQuietly(closeable, null);\n+        closeQuietly(closeable, (Consumer<Exception>) null);\n     }\n \n     /**\n@@ -824,7 +824,40 @@ private static void closeQ(final Closeable closeable) {\n      * @see Throwable#addSuppressed(Throwable)\n      */\n     public static void closeQuietly(final Closeable closeable) {\n-        closeQuietly(closeable, null);\n+        closeQuietly(closeable, (Consumer<Exception>) null);\n+    }\n+\n+    /**\n+     * Closes a {@link Closeable} unconditionally and adds any exception thrown by the {@code close()} to the given Throwable.\n+     *\n+     * <p>\n+     * For example:\n+     * </p>\n+     *\n+     * <pre>\n+     * Closeable closeable = ...;\n+     * try {\n+     *     // process closeable\n+     *     closeable.close();\n+     * } catch (Exception e) {\n+     *     // error handling\n+     *     throw IOUtils.closeQuietly(closeable, e);\n+     * }\n+     * </pre>\n+     * <p>\n+     * Also consider using a try-with-resources statement where appropriate.\n+     * </p>\n+     *\n+     * @param <T> The Throwable type.\n+     * @param closeable The object to close, may be null or already closed.\n+     * @param throwable Add the exception throw by the closeable to the given Throwable.\n+     * @return The given Throwable.\n+     * @since 2.22.0\n+     * @see Throwable#addSuppressed(Throwable)\n+     */\n+    public static <T extends Throwable> T closeQuietly(final Closeable closeable, final T throwable) {\n+        closeQuietly(closeable, (Consumer<Exception>) throwable::addSuppressed);\n+        return throwable;\n     }\n \n     /**\ndiff --git a/src/main/java/org/apache/commons/io/LineIterator.java b/src/main/java/org/apache/commons/io/LineIterator.java\nindex 293847e7a72..2e1bf0169ab 100644\n--- a/src/main/java/org/apache/commons/io/LineIterator.java\n+++ b/src/main/java/org/apache/commons/io/LineIterator.java\n@@ -135,8 +135,7 @@ public boolean hasNext() {\n                 }\n             }\n         } catch (final IOException ioe) {\n-            IOUtils.closeQuietly(this, ioe::addSuppressed);\n-            throw new IllegalStateException(ioe);\n+            throw new IllegalStateException(IOUtils.closeQuietly(this, ioe));\n         }\n     }\n \ndiff --git a/src/main/java/org/apache/commons/io/output/FileWriterWithEncoding.java b/src/main/java/org/apache/commons/io/output/FileWriterWithEncoding.java\nindex 42d378cc0a5..1bb15a37a19 100644\n--- a/src/main/java/org/apache/commons/io/output/FileWriterWithEncoding.java\n+++ b/src/main/java/org/apache/commons/io/output/FileWriterWithEncoding.java\n@@ -188,11 +188,7 @@ private static OutputStreamWriter initWriter(final File file, final Object encod\n             }\n             return new OutputStreamWriter(outputStream, (String) encoding);\n         } catch (final IOException | RuntimeException ex) {\n-            try {\n-                IOUtils.close(outputStream);\n-            } catch (final IOException e) {\n-                ex.addSuppressed(e);\n-            }\n+            IOUtils.closeQuietly(outputStream, ex);\n             if (!fileExistedAlready) {\n                 FileUtils.deleteQuietly(file);\n             }\n",
  "test_patch" : "diff --git a/src/test/java/org/apache/commons/io/IOUtilsTest.java b/src/test/java/org/apache/commons/io/IOUtilsTest.java\nindex 033fdffdd76..df90ab66e11 100644\n--- a/src/test/java/org/apache/commons/io/IOUtilsTest.java\n+++ b/src/test/java/org/apache/commons/io/IOUtilsTest.java\n@@ -20,6 +20,7 @@\n import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n import static org.junit.jupiter.api.Assertions.assertEquals;\n import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertInstanceOf;\n import static org.junit.jupiter.api.Assertions.assertNotNull;\n import static org.junit.jupiter.api.Assertions.assertNotSame;\n import static org.junit.jupiter.api.Assertions.assertNull;\n@@ -539,6 +540,18 @@ void testCloseQuietly_AllCloseableIOException() {\n         assertDoesNotThrow(() -> IOUtils.closeQuietly((Iterable<Closeable>) null));\n     }\n \n+    @SuppressWarnings(\"resource\")\n+    @Test\n+    void testCloseQuietly_CloseableIOExceptionAddSuppressed() {\n+        final Throwable e = new Exception(\"test\").fillInStackTrace();\n+        assertEquals(0, e.getSuppressed().length);\n+        assertSame(e, IOUtils.closeQuietly(new BrokenInputStream(new EOFException(\"Suppressed\").fillInStackTrace()), e));\n+        assertEquals(1, e.getSuppressed().length);\n+        final Throwable suppressed0 = e.getSuppressed()[0];\n+        assertInstanceOf(EOFException.class, suppressed0);\n+        assertEquals(\"Suppressed\", suppressed0.getMessage());\n+    }\n+\n     @Test\n     void testCloseQuietly_CloseableException() {\n         // IOException\n",
  "problem_statement" : "Add and use IOUtils.closeQuietly(Closeable, Throwable)\n\nAdd and use IOUtils.closeQuietly(Closeable, Throwable)\r\n\r\n- [x] Read the [contribution guidelines](CONTRIBUTING.md) for this project.\r\n- [x] Read the [ASF Generative Tooling Guidance](https://www.apache.org/legal/generative-tooling.html) if you use Artificial Intelligence (AI).\r\n- [ ] I used AI to create any part of, or all of, this pull request. Which AI tool was used to create this pull request, and to what extent did it contribute?\r\n- [x] Run a successful build using the default [Maven](https://maven.apache.org/) goal with `mvn`; that's `mvn` on the command line by itself.\r\n- [x] Write unit tests that match behavioral changes, where the tests fail if the changes to the runtime are not applied. This may not always be possible, but it is a best practice.\r\n- [x] Write a pull request description that is detailed enough to understand what the pull request does, how, and why.\r\n- [x] Each commit in the pull request should have a meaningful subject line and body. Note that a maintainer may squash commits during the merge process.\r\n",
  "hints_text" : null,
  "created_at" : "Thu Dec 11 14:30:19 CET 2025",
  "version" : null,
  "FAIL_TO_PASS" : [ "IOUtilsTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=IOUtilsTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 818,
  "metadata" : null
}, {
  "instance_id" : "apache-commons-io-PR-817",
  "repo" : "apache/commons-io",
  "base_commit" : "3557766ab48bb876008b0a2cb9bd1933275a306a",
  "patch" : "diff --git a/src/main/java/org/apache/commons/io/channels/ByteArraySeekableByteChannel.java b/src/main/java/org/apache/commons/io/channels/ByteArraySeekableByteChannel.java\nindex 4135a815e83..2cd8009203f 100644\n--- a/src/main/java/org/apache/commons/io/channels/ByteArraySeekableByteChannel.java\n+++ b/src/main/java/org/apache/commons/io/channels/ByteArraySeekableByteChannel.java\n@@ -68,7 +68,7 @@ public static ByteArraySeekableByteChannel wrap(final byte[] bytes) {\n \n     private byte[] data;\n     private volatile boolean closed;\n-    private int position;\n+    private long position;\n     private int size;\n     private final ReentrantLock lock = new ReentrantLock();\n \n@@ -126,11 +126,10 @@ private void checkOpen() throws ClosedChannelException {\n         }\n     }\n \n-    private int checkRange(final long newSize, final String method) {\n-        if (newSize < 0L || newSize > IOUtils.SOFT_MAX_ARRAY_LENGTH) {\n-            throw new IllegalArgumentException(String.format(\"%s must be in range [0..%,d]: %,d\", method, IOUtils.SOFT_MAX_ARRAY_LENGTH, newSize));\n+    private void checkRange(final long newSize, final String method) {\n+        if (newSize < 0L) {\n+            throw new IllegalArgumentException(String.format(\"%s must be positive: %,d\", method, newSize));\n         }\n-        return (int) newSize;\n     }\n \n     @Override\n@@ -166,10 +165,10 @@ public long position() throws ClosedChannelException {\n     @Override\n     public SeekableByteChannel position(final long newPosition) throws IOException {\n         checkOpen();\n-        final int intPos = checkRange(newPosition, \"position()\");\n+        checkRange(newPosition, \"position()\");\n         lock.lock();\n         try {\n-            position = intPos;\n+            position = newPosition;\n         } finally {\n             lock.unlock();\n         }\n@@ -181,15 +180,18 @@ public int read(final ByteBuffer buf) throws IOException {\n         checkOpen();\n         lock.lock();\n         try {\n+            if (position > Integer.MAX_VALUE) {\n+                return IOUtils.EOF;\n+            }\n             int wanted = buf.remaining();\n-            final int possible = size - position;\n+            final int possible = size - (int) position;\n             if (possible <= 0) {\n                 return IOUtils.EOF;\n             }\n             if (wanted > possible) {\n                 wanted = possible;\n             }\n-            buf.put(data, position, wanted);\n+            buf.put(data, (int) position, wanted);\n             position += wanted;\n             return wanted;\n         } finally {\n@@ -238,14 +240,14 @@ public byte[] toByteArray() {\n     @Override\n     public SeekableByteChannel truncate(final long newSize) throws ClosedChannelException {\n         checkOpen();\n-        final int intSize = checkRange(newSize, \"truncate()\");\n+        checkRange(newSize, \"truncate()\");\n         lock.lock();\n         try {\n-            if (size > intSize) {\n-                size = intSize;\n+            if (size > newSize) {\n+                size = (int) newSize;\n             }\n-            if (position > intSize) {\n-                position = intSize;\n+            if (position > newSize) {\n+                position = newSize;\n             }\n         } finally {\n             lock.unlock();\n@@ -256,21 +258,28 @@ public SeekableByteChannel truncate(final long newSize) throws ClosedChannelExce\n     @Override\n     public int write(final ByteBuffer b) throws IOException {\n         checkOpen();\n+        if (position > Integer.MAX_VALUE) {\n+            throw new IOException(\"position > Integer.MAX_VALUE\");\n+        }\n         lock.lock();\n         try {\n             final int wanted = b.remaining();\n-            final int possibleWithoutResize = Math.max(0, size - position);\n-            if (wanted > possibleWithoutResize) {\n-                final int newSize = position + wanted;\n-                if (newSize < 0 || newSize > IOUtils.SOFT_MAX_ARRAY_LENGTH) { // overflow\n-                    throw new OutOfMemoryError(\"required array size \" + Integer.toUnsignedString(newSize) + \" too large\");\n-                }\n-                resize(newSize);\n+            // intPos <= Integer.MAX_VALUE\n+            final int intPos = (int) position;\n+            final long newPosition = position + wanted;\n+            if (newPosition > IOUtils.SOFT_MAX_ARRAY_LENGTH) {\n+                throw new IOException(String.format(\"Requested array size %,d is too large.\", newPosition));\n             }\n-            b.get(data, position, wanted);\n-            position += wanted;\n-            if (size < position) {\n-                size = position;\n+            if (newPosition > size) {\n+                final int newPositionInt = (int) newPosition;\n+                // Ensure that newPositionInt â‰¤ data.length\n+                resize(newPositionInt);\n+                size = newPositionInt;\n+            }\n+            b.get(data, intPos, wanted);\n+            position = newPosition;\n+            if (size < intPos) {\n+                size = intPos;\n             }\n             return wanted;\n         } finally {\n",
  "test_patch" : "diff --git a/src/test/java/org/apache/commons/io/channels/AbstractSeekableByteChannelTest.java b/src/test/java/org/apache/commons/io/channels/AbstractSeekableByteChannelTest.java\nindex abf96d8f47d..afb2245a49f 100644\n--- a/src/test/java/org/apache/commons/io/channels/AbstractSeekableByteChannelTest.java\n+++ b/src/test/java/org/apache/commons/io/channels/AbstractSeekableByteChannelTest.java\n@@ -47,7 +47,7 @@\n  */\n abstract class AbstractSeekableByteChannelTest {\n \n-    private SeekableByteChannel channel;\n+    protected SeekableByteChannel channel;\n \n     @TempDir\n     protected Path tempDir;\n@@ -87,6 +87,7 @@ void testCloseMultipleTimes() throws IOException {\n         assertFalse(channel.isOpen());\n     }\n \n+\n     @Test\n     void testConcurrentPositionAndSizeQueries() throws IOException {\n         final byte[] data = \"test data\".getBytes();\n@@ -136,6 +137,20 @@ void testPositionBeyondSize() throws IOException {\n         assertEquals(4, channel.size()); // Size should not change\n     }\n \n+    @Test\n+    void testPositionBeyondSizeRead() throws IOException {\n+        final ByteBuffer buffer = ByteBuffer.allocate(1);\n+        channel.position(channel.size() + 1);\n+        assertEquals(channel.size() + 1, channel.position());\n+        assertEquals(-1, channel.read(buffer));\n+        channel.position(Integer.MAX_VALUE + 1L);\n+        assertEquals(Integer.MAX_VALUE + 1L, channel.position());\n+        assertEquals(-1, channel.read(buffer));\n+        assertThrows(IllegalArgumentException.class, () -> channel.position(-1));\n+        assertThrows(IllegalArgumentException.class, () -> channel.position(Integer.MIN_VALUE));\n+        assertThrows(IllegalArgumentException.class, () -> channel.position(Long.MIN_VALUE));\n+    }\n+\n     @ParameterizedTest\n     @CsvSource({ \"0, 0\", \"5, 5\", \"10, 10\", \"100, 100\" })\n     void testPositionInBounds(final long newPosition, final long expectedPosition) throws IOException {\n@@ -149,6 +164,7 @@ void testPositionInBounds(final long newPosition, final long expectedPosition) t\n         assertEquals(expectedPosition, channel.position());\n     }\n \n+\n     @Test\n     void testPositionNegative() {\n         assertThrows(IllegalArgumentException.class, () -> channel.position(-1));\n@@ -292,6 +308,18 @@ void testSizeSameOnOverwrite() throws IOException {\n         assertEquals(11, channel.size()); // Size should not change\n     }\n \n+    @Test\n+    void testTrucateBeyondSizeReadWrite() throws IOException {\n+        final ByteBuffer buffer = ByteBuffer.allocate(1);\n+        channel.truncate(channel.size() + 1);\n+        assertEquals(-1, channel.read(buffer));\n+        channel.truncate(Integer.MAX_VALUE + 1L);\n+        assertEquals(-1, channel.read(buffer));\n+        assertThrows(IllegalArgumentException.class, () -> channel.truncate(-1));\n+        assertThrows(IllegalArgumentException.class, () -> channel.truncate(Integer.MIN_VALUE));\n+        assertThrows(IllegalArgumentException.class, () -> channel.truncate(Long.MIN_VALUE));\n+    }\n+\n     @Test\n     void testTruncateNegative() {\n         assertThrows(IllegalArgumentException.class, () -> channel.truncate(-1));\ndiff --git a/src/test/java/org/apache/commons/io/channels/ByteArraySeekableByteChannelCompressTest.java b/src/test/java/org/apache/commons/io/channels/ByteArraySeekableByteChannelCompressTest.java\nindex 66c8e60b91a..60c294f0d65 100644\n--- a/src/test/java/org/apache/commons/io/channels/ByteArraySeekableByteChannelCompressTest.java\n+++ b/src/test/java/org/apache/commons/io/channels/ByteArraySeekableByteChannelCompressTest.java\n@@ -162,16 +162,39 @@ void testShouldThrowExceptionOnWritingToClosedChannel() {\n     }\n \n     @Test\n-    void testShouldThrowExceptionWhenSettingIncorrectPosition() {\n+    void testThrowWhenSettingIncorrectPosition() throws IOException {\n         try (ByteArraySeekableByteChannel c = new ByteArraySeekableByteChannel()) {\n-            assertThrows(IllegalArgumentException.class, () -> c.position(Integer.MAX_VALUE + 1L));\n+            final ByteBuffer buffer = ByteBuffer.allocate(1);\n+            // write\n+            c.write(buffer);\n+            assertEquals(1, c.position());\n+            // bad pos A\n+            c.position(c.size() + 1);\n+            assertEquals(c.size() + 1, c.position());\n+            assertEquals(-1, c.read(buffer));\n+            // bad pos B\n+            c.position(Integer.MAX_VALUE + 1L);\n+            assertEquals(Integer.MAX_VALUE + 1L, c.position());\n+            assertEquals(-1, c.read(buffer));\n+            assertThrows(IOException.class, () -> c.write(buffer));\n+            // negative input is the only illegal input\n+            assertThrows(IllegalArgumentException.class, () -> c.position(-1));\n+            assertThrows(IllegalArgumentException.class, () -> c.position(Integer.MIN_VALUE));\n+            assertThrows(IllegalArgumentException.class, () -> c.position(Long.MIN_VALUE));\n         }\n     }\n \n     @Test\n-    void testShouldThrowExceptionWhenTruncatingToIncorrectSize() {\n+    void testThrowWhenTruncatingToIncorrectSize() throws IOException {\n         try (ByteArraySeekableByteChannel c = new ByteArraySeekableByteChannel()) {\n-            assertThrows(IllegalArgumentException.class, () -> c.truncate(Integer.MAX_VALUE + 1L));\n+            final ByteBuffer buffer = ByteBuffer.allocate(1);\n+            c.truncate(c.size() + 1);\n+            assertEquals(-1, c.read(buffer));\n+            c.truncate(Integer.MAX_VALUE + 1L);\n+            assertEquals(-1, c.read(buffer));\n+            assertThrows(IllegalArgumentException.class, () -> c.truncate(-1));\n+            assertThrows(IllegalArgumentException.class, () -> c.truncate(Integer.MIN_VALUE));\n+            assertThrows(IllegalArgumentException.class, () -> c.truncate(Long.MIN_VALUE));\n         }\n     }\n \ndiff --git a/src/test/java/org/apache/commons/io/channels/ByteArraySeekableByteChannelTest.java b/src/test/java/org/apache/commons/io/channels/ByteArraySeekableByteChannelTest.java\nindex 5b29b3f1be0..79f971e4a0c 100644\n--- a/src/test/java/org/apache/commons/io/channels/ByteArraySeekableByteChannelTest.java\n+++ b/src/test/java/org/apache/commons/io/channels/ByteArraySeekableByteChannelTest.java\n@@ -84,6 +84,22 @@ void testConstructorInvalid() {\n         assertThrows(NullPointerException.class, () -> ByteArraySeekableByteChannel.wrap(null));\n     }\n \n+    @Test\n+    void testPositionBeyondSizeReadWrite() throws IOException {\n+        final ByteBuffer buffer = ByteBuffer.allocate(1);\n+        channel.position(channel.size() + 1);\n+        assertEquals(channel.size() + 1, channel.position());\n+        assertEquals(-1, channel.read(buffer));\n+        channel.position(Integer.MAX_VALUE + 1L);\n+        assertEquals(Integer.MAX_VALUE + 1L, channel.position());\n+        assertEquals(-1, channel.read(buffer));\n+        // ByteArraySeekableByteChannel has a hard boundary at Integer.MAX_VALUE, files don't.\n+        assertThrows(IOException.class, () -> channel.write(buffer));\n+        assertThrows(IllegalArgumentException.class, () -> channel.position(-1));\n+        assertThrows(IllegalArgumentException.class, () -> channel.position(Integer.MIN_VALUE));\n+        assertThrows(IllegalArgumentException.class, () -> channel.position(Long.MIN_VALUE));\n+    }\n+\n     @ParameterizedTest\n     @MethodSource\n     void testShouldResizeWhenWritingMoreDataThanCapacity(final byte[] data, final int wanted) throws IOException {\n",
  "problem_statement" : "ByteArraySeekableByteChannel.position|truncate(long) shouldn't throw an IllegalArgumentException for a new positive position that's too large\n\n`ByteArraySeekableByteChannel`'s `position(long)` and `truncate(long)` shouldn't throw an\r\n`IllegalArgumentException` for a new positive position that's too large.\r\n\r\n\r\nBefore you push a pull request, review this list:\r\n\r\n- [x] Read the [contribution guidelines](CONTRIBUTING.md) for this project.\r\n- [x] Read the [ASF Generative Tooling Guidance](https://www.apache.org/legal/generative-tooling.html) if you use Artificial Intelligence (AI).\r\n- [ ] I used AI to create any part of, or all of, this pull request. Which AI tool was used to create this pull request, and to what extent did it contribute?\r\n- [x] Run a successful build using the default [Maven](https://maven.apache.org/) goal with `mvn`; that's `mvn` on the command line by itself.\r\n- [x] Write unit tests that match behavioral changes, where the tests fail if the changes to the runtime are not applied. This may not always be possible, but it is a best practice.\r\n- [x] Write a pull request description that is detailed enough to understand what the pull request does, how, and why.\r\n- [x] Each commit in the pull request should have a meaningful subject line and body. Note that a maintainer may squash commits during the merge process.\r\n",
  "hints_text" : null,
  "created_at" : "Mon Dec 08 20:21:30 CET 2025",
  "version" : null,
  "FAIL_TO_PASS" : [ "ByteArraySeekableByteChannelCompressTest", "AbstractSeekableByteChannelTest", "ByteArraySeekableByteChannelTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=ByteArraySeekableByteChannelCompressTest,AbstractSeekableByteChannelTest,ByteArraySeekableByteChannelTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 817,
  "metadata" : null
}, {
  "instance_id" : "apache-commons-io-PR-801",
  "repo" : "apache/commons-io",
  "base_commit" : "c28dc1bdc28cc3a47ca3a897ce31cac1fc9592c2",
  "patch" : "diff --git a/src/changes/changes.xml b/src/changes/changes.xml\nindex ecee3aeca01..3aa41940132 100644\n--- a/src/changes/changes.xml\n+++ b/src/changes/changes.xml\n@@ -56,6 +56,7 @@ The <action> type attribute can be add,update,fix,remove.\n       <action type=\"fix\" dev=\"pkarwasz\"                due-to=\"Piotr P. Karwasz\">IOUtils.toByteArray(InputStream) now throws IOException on byte array overflow.</action>\n       <action type=\"fix\" dev=\"ggregory\"                due-to=\"Gary Gregory, Piotr P. Karwasz\">Javadoc general improvements.</action>\n       <action type=\"fix\" dev=\"ggregory\"                due-to=\"Piotr P. Karwasz\">IOUtils.toByteArray() now throws EOFException when not enough data is available #796.</action>\n+      <action type=\"fix\" dev=\"pkarwasz\"                due-to=\"Piotr P. Karwasz\">Fix IOUtils.skip() usage in concurrent scenarios.</action>\n       <!-- ADD -->\n       <action dev=\"ggregory\" type=\"add\"                due-to=\"strangelookingnerd, Gary Gregory\">FileUtils#byteCountToDisplaySize() supports Zettabyte, Yottabyte, Ronnabyte and Quettabyte #763.</action>\n       <action dev=\"ggregory\" type=\"add\"                due-to=\"strangelookingnerd, Gary Gregory\">Add org.apache.commons.io.FileUtils.ONE_RB #763.</action>\ndiff --git a/src/main/java/org/apache/commons/io/CopyUtils.java b/src/main/java/org/apache/commons/io/CopyUtils.java\nindex e22adef83be..fdb137d2039 100644\n--- a/src/main/java/org/apache/commons/io/CopyUtils.java\n+++ b/src/main/java/org/apache/commons/io/CopyUtils.java\n@@ -278,14 +278,18 @@ public static int copy(\n             final Reader input,\n             final Writer output)\n                 throws IOException {\n-        final char[] buffer = IOUtils.getScratchCharArray();\n-        int count = 0;\n-        int n;\n-        while (EOF != (n = input.read(buffer))) {\n-            output.write(buffer, 0, n);\n-            count += n;\n+        final char[] buffer = IOUtils.ScratchBufferHolder.getScratchCharArray();\n+        try {\n+            int count = 0;\n+            int n;\n+            while (EOF != (n = input.read(buffer))) {\n+                output.write(buffer, 0, n);\n+                count += n;\n+            }\n+            return count;\n+        } finally {\n+            IOUtils.ScratchBufferHolder.releaseScratchCharArray(buffer);\n         }\n-        return count;\n     }\n \n     /**\ndiff --git a/src/main/java/org/apache/commons/io/IOUtils.java b/src/main/java/org/apache/commons/io/IOUtils.java\nindex a1f9b0709a2..717be4b49bf 100644\n--- a/src/main/java/org/apache/commons/io/IOUtils.java\n+++ b/src/main/java/org/apache/commons/io/IOUtils.java\n@@ -132,6 +132,94 @@ public class IOUtils {\n     // Writer. Each method should take at least one of these as a parameter,\n     // or return one of them.\n \n+    /**\n+     * Holder for per-thread internal scratch buffers.\n+     *\n+     * <p>Buffers are created lazily and reused within the same thread to reduce allocation overhead. In the rare case of reentrant access, a temporary buffer\n+     * is allocated to avoid data corruption.</p>\n+     *\n+     * <p>Typical usage:</p>\n+     *\n+     * <pre>{@code\n+     * final byte[] buffer = ScratchBufferHolder.getScratchByteArray();\n+     * try {\n+     *     // use the buffer\n+     * } finally {\n+     *     ScratchBufferHolder.releaseScratchByteArray(buffer);\n+     * }\n+     * }</pre>\n+     */\n+    static final class ScratchBufferHolder {\n+\n+        /**\n+         * Holder for internal byte array buffer.\n+         */\n+        private static final ThreadLocal<Object[]> SCRATCH_BYTE_BUFFER_HOLDER = ThreadLocal.withInitial(() -> new Object[] { false, byteArray() });\n+\n+        /**\n+         * Holder for internal char array buffer.\n+         */\n+        private static final ThreadLocal<Object[]> SCRATCH_CHAR_BUFFER_HOLDER = ThreadLocal.withInitial(() -> new Object[] { false, charArray() });\n+\n+\n+        /**\n+         * Gets the internal byte array buffer.\n+         *\n+         * @return the internal byte array buffer.\n+         */\n+        static byte[] getScratchByteArray() {\n+            final Object[] holder = SCRATCH_BYTE_BUFFER_HOLDER.get();\n+            // If already in use, return a new array\n+            if ((boolean) holder[0]) {\n+                return byteArray();\n+            }\n+            holder[0] = true;\n+            return (byte[]) holder[1];\n+        }\n+\n+        /**\n+         * Gets the char array buffer.\n+         *\n+         * @return the char array buffer.\n+         */\n+        static char[] getScratchCharArray() {\n+            final Object[] holder = SCRATCH_CHAR_BUFFER_HOLDER.get();\n+            // If already in use, return a new array\n+            if ((boolean) holder[0]) {\n+                return charArray();\n+            }\n+            holder[0] = true;\n+            return (char[]) holder[1];\n+        }\n+\n+\n+        /**\n+         * If the argument is the internal byte array, release it for reuse.\n+         *\n+         * @param array the byte array to release.\n+         */\n+        static void releaseScratchByteArray(byte[] array) {\n+            final Object[] holder = SCRATCH_BYTE_BUFFER_HOLDER.get();\n+            if (array == holder[1]) {\n+                Arrays.fill(array, (byte) 0);\n+                holder[0] = false;\n+            }\n+        }\n+\n+        /**\n+         * If the argument is the internal char array, release it for reuse.\n+         *\n+         * @param array the char array to release.\n+         */\n+        static void releaseScratchCharArray(char[] array) {\n+            final Object[] holder = SCRATCH_CHAR_BUFFER_HOLDER.get();\n+            if (array == holder[1]) {\n+                Arrays.fill(array, (char) 0);\n+                holder[0] = false;\n+            }\n+        }\n+    }\n+\n     /**\n      * CR char '{@value}'.\n      *\n@@ -201,26 +289,6 @@ public class IOUtils {\n      */\n     public static final String LINE_SEPARATOR_WINDOWS = StandardLineSeparator.CRLF.getString();\n \n-    /**\n-     * Internal byte array buffer, intended for both reading and writing.\n-     */\n-    private static final ThreadLocal<byte[]> SCRATCH_BYTE_BUFFER_RW = ThreadLocal.withInitial(IOUtils::byteArray);\n-\n-    /**\n-     * Internal byte array buffer, intended for write only operations.\n-     */\n-    private static final byte[] SCRATCH_BYTE_BUFFER_WO = byteArray();\n-\n-    /**\n-     * Internal char array buffer, intended for both reading and writing.\n-     */\n-    private static final ThreadLocal<char[]> SCRATCH_CHAR_BUFFER_RW = ThreadLocal.withInitial(IOUtils::charArray);\n-\n-    /**\n-     * Internal char array buffer, intended for write only operations.\n-     */\n-    private static final char[] SCRATCH_CHAR_BUFFER_WO = charArray();\n-\n     /**\n      * The maximum size of an array in many Java VMs.\n      * <p>\n@@ -592,10 +660,8 @@ static void checkFromToIndex(final int fromIndex, final int toIndex, final int l\n      * @see IO#clear()\n      */\n     static void clear() {\n-        SCRATCH_BYTE_BUFFER_RW.remove();\n-        SCRATCH_CHAR_BUFFER_RW.remove();\n-        Arrays.fill(SCRATCH_BYTE_BUFFER_WO, (byte) 0);\n-        Arrays.fill(SCRATCH_CHAR_BUFFER_WO, (char) 0);\n+        ScratchBufferHolder.SCRATCH_BYTE_BUFFER_HOLDER.remove();\n+        ScratchBufferHolder.SCRATCH_CHAR_BUFFER_HOLDER.remove();\n     }\n \n     /**\n@@ -1139,39 +1205,43 @@ public static boolean contentEquals(final Reader input1, final Reader input2) th\n         }\n \n         // reuse one\n-        final char[] array1 = getScratchCharArray();\n+        final char[] array1 = ScratchBufferHolder.getScratchCharArray();\n         // but allocate another\n         final char[] array2 = charArray();\n         int pos1;\n         int pos2;\n         int count1;\n         int count2;\n-        while (true) {\n-            pos1 = 0;\n-            pos2 = 0;\n-            for (int index = 0; index < DEFAULT_BUFFER_SIZE; index++) {\n-                if (pos1 == index) {\n-                    do {\n-                        count1 = input1.read(array1, pos1, DEFAULT_BUFFER_SIZE - pos1);\n-                    } while (count1 == 0);\n-                    if (count1 == EOF) {\n-                        return pos2 == index && input2.read() == EOF;\n+        try {\n+            while (true) {\n+                pos1 = 0;\n+                pos2 = 0;\n+                for (int index = 0; index < DEFAULT_BUFFER_SIZE; index++) {\n+                    if (pos1 == index) {\n+                        do {\n+                            count1 = input1.read(array1, pos1, DEFAULT_BUFFER_SIZE - pos1);\n+                        } while (count1 == 0);\n+                        if (count1 == EOF) {\n+                            return pos2 == index && input2.read() == EOF;\n+                        }\n+                        pos1 += count1;\n                     }\n-                    pos1 += count1;\n-                }\n-                if (pos2 == index) {\n-                    do {\n-                        count2 = input2.read(array2, pos2, DEFAULT_BUFFER_SIZE - pos2);\n-                    } while (count2 == 0);\n-                    if (count2 == EOF) {\n-                        return pos1 == index && input1.read() == EOF;\n+                    if (pos2 == index) {\n+                        do {\n+                            count2 = input2.read(array2, pos2, DEFAULT_BUFFER_SIZE - pos2);\n+                        } while (count2 == 0);\n+                        if (count2 == EOF) {\n+                            return pos1 == index && input1.read() == EOF;\n+                        }\n+                        pos2 += count2;\n+                    }\n+                    if (array1[index] != array2[index]) {\n+                        return false;\n                     }\n-                    pos2 += count2;\n-                }\n-                if (array1[index] != array2[index]) {\n-                    return false;\n                 }\n             }\n+        } finally {\n+            ScratchBufferHolder.releaseScratchCharArray(array1);\n         }\n     }\n \n@@ -1651,9 +1721,13 @@ public static long copyLarge(final InputStream inputStream, final OutputStream o\n      * @throws IOException          if an I/O error occurs.\n      * @since 2.2\n      */\n-    public static long copyLarge(final InputStream input, final OutputStream output, final long inputOffset,\n-                                 final long length) throws IOException {\n-        return copyLarge(input, output, inputOffset, length, getScratchByteArray());\n+    public static long copyLarge(final InputStream input, final OutputStream output, final long inputOffset, final long length) throws IOException {\n+        final byte[] buffer = ScratchBufferHolder.getScratchByteArray();\n+        try {\n+            return copyLarge(input, output, inputOffset, length, buffer);\n+        } finally {\n+            ScratchBufferHolder.releaseScratchByteArray(buffer);\n+        }\n     }\n \n     /**\n@@ -1723,7 +1797,12 @@ public static long copyLarge(final InputStream input, final OutputStream output,\n      * @since 1.3\n      */\n     public static long copyLarge(final Reader reader, final Writer writer) throws IOException {\n-        return copyLarge(reader, writer, getScratchCharArray());\n+        final char[] buffer = ScratchBufferHolder.getScratchCharArray();\n+        try {\n+            return copyLarge(reader, writer, buffer);\n+        } finally {\n+            ScratchBufferHolder.releaseScratchCharArray(buffer);\n+        }\n     }\n \n     /**\n@@ -1770,7 +1849,12 @@ public static long copyLarge(final Reader reader, final Writer writer, final cha\n      * @since 2.2\n      */\n     public static long copyLarge(final Reader reader, final Writer writer, final long inputOffset, final long length) throws IOException {\n-        return copyLarge(reader, writer, inputOffset, length, getScratchCharArray());\n+        final char[] buffer = ScratchBufferHolder.getScratchCharArray();\n+        try {\n+            return copyLarge(reader, writer, inputOffset, length, buffer);\n+        } finally {\n+            ScratchBufferHolder.releaseScratchCharArray(buffer);\n+        }\n     }\n \n     /**\n@@ -1837,64 +1921,6 @@ static UnsynchronizedByteArrayOutputStream copyToOutputStream(\n         }\n     }\n \n-    /**\n-     * Fills the given array with 0s.\n-     *\n-     * @param arr The non-null array to fill.\n-     * @return The given array.\n-     */\n-    private static byte[] fill0(final byte[] arr) {\n-        Arrays.fill(arr, (byte) 0);\n-        return arr;\n-    }\n-\n-    /**\n-     * Fills the given array with 0s.\n-     *\n-     * @param arr The non-null array to fill.\n-     * @return The given array.\n-     */\n-    private static char[] fill0(final char[] arr) {\n-        Arrays.fill(arr, (char) 0);\n-        return arr;\n-    }\n-\n-    /**\n-     * Gets the internal byte array buffer, intended for both reading and writing.\n-     *\n-     * @return the internal byte array buffer, intended for both reading and writing.\n-     */\n-    static byte[] getScratchByteArray() {\n-        return fill0(SCRATCH_BYTE_BUFFER_RW.get());\n-    }\n-\n-    /**\n-     * Gets the internal byte array intended for write only operations.\n-     *\n-     * @return the internal byte array intended for write only operations.\n-     */\n-    static byte[] getScratchByteArrayWriteOnly() {\n-        return fill0(SCRATCH_BYTE_BUFFER_WO);\n-    }\n-\n-    /**\n-     * Gets the char byte array buffer, intended for both reading and writing.\n-     *\n-     * @return the char byte array buffer, intended for both reading and writing.\n-     */\n-    static char[] getScratchCharArray() {\n-        return fill0(SCRATCH_CHAR_BUFFER_RW.get());\n-    }\n-\n-    /**\n-     * Gets the internal char array intended for write only operations.\n-     *\n-     * @return the internal char array intended for write only operations.\n-     */\n-    static char[] getScratchCharArrayWriteOnly() {\n-        return fill0(SCRATCH_CHAR_BUFFER_WO);\n-    }\n-\n     /**\n      * Returns the length of the given array in a null-safe manner.\n      *\n@@ -2527,7 +2553,12 @@ public static URL resourceToURL(final String name, final ClassLoader classLoader\n      * @since 2.0\n      */\n     public static long skip(final InputStream input, final long skip) throws IOException {\n-        return skip(input, skip, IOUtils::getScratchByteArrayWriteOnly);\n+        final byte[] buffer = ScratchBufferHolder.getScratchByteArray();\n+        try {\n+            return skip(input, skip, () -> buffer);\n+        } finally {\n+            ScratchBufferHolder.releaseScratchByteArray(buffer);\n+        }\n     }\n \n     /**\n@@ -2634,14 +2665,18 @@ public static long skip(final Reader reader, final long toSkip) throws IOExcepti\n             throw new IllegalArgumentException(\"Skip count must be non-negative, actual: \" + toSkip);\n         }\n         long remain = toSkip;\n-        while (remain > 0) {\n-            // See https://issues.apache.org/jira/browse/IO-203 for why we use read() rather than delegating to skip()\n-            final char[] charArray = getScratchCharArrayWriteOnly();\n-            final long n = reader.read(charArray, 0, (int) Math.min(remain, charArray.length));\n-            if (n < 0) { // EOF\n-                break;\n+        final char[] charArray = ScratchBufferHolder.getScratchCharArray();\n+        try {\n+            while (remain > 0) {\n+                // See https://issues.apache.org/jira/browse/IO-203 for why we use read() rather than delegating to skip()\n+                final long n = reader.read(charArray, 0, (int) Math.min(remain, charArray.length));\n+                if (n < 0) { // EOF\n+                    break;\n+                }\n+                remain -= n;\n             }\n-            remain -= n;\n+        } finally {\n+            ScratchBufferHolder.releaseScratchCharArray(charArray);\n         }\n         return toSkip - remain;\n     }\n@@ -2667,7 +2702,7 @@ public static long skip(final Reader reader, final long toSkip) throws IOExcepti\n      * @since 2.0\n      */\n     public static void skipFully(final InputStream input, final long toSkip) throws IOException {\n-        final long skipped = skip(input, toSkip, IOUtils::getScratchByteArrayWriteOnly);\n+        final long skipped = skip(input, toSkip);\n         if (skipped != toSkip) {\n             throw new EOFException(\"Bytes to skip: \" + toSkip + \" actual: \" + skipped);\n         }\n",
  "test_patch" : "diff --git a/src/test/java/org/apache/commons/io/IOCaseTest.java b/src/test/java/org/apache/commons/io/IOCaseTest.java\nindex 97a990f6369..1121b38eeeb 100644\n--- a/src/test/java/org/apache/commons/io/IOCaseTest.java\n+++ b/src/test/java/org/apache/commons/io/IOCaseTest.java\n@@ -18,6 +18,7 @@\n \n import static org.junit.jupiter.api.Assertions.assertEquals;\n import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotSame;\n import static org.junit.jupiter.api.Assertions.assertSame;\n import static org.junit.jupiter.api.Assertions.assertThrows;\n import static org.junit.jupiter.api.Assertions.assertTrue;\n@@ -296,34 +297,50 @@ void test_getName() {\n \n     @Test\n     void test_getScratchByteArray() {\n-        final byte[] array = IOUtils.getScratchByteArray();\n-        assert0(array);\n-        Arrays.fill(array, (byte) 1);\n-        assert0(IOUtils.getScratchCharArray());\n-    }\n-\n-    @Test\n-    void test_getScratchByteArrayWriteOnly() {\n-        final byte[] array = IOUtils.getScratchByteArrayWriteOnly();\n-        assert0(array);\n-        Arrays.fill(array, (byte) 1);\n-        assert0(IOUtils.getScratchCharArray());\n+        final byte[] array = IOUtils.ScratchBufferHolder.getScratchByteArray();\n+        try {\n+            assert0(array);\n+            Arrays.fill(array, (byte) 1);\n+            // Get another array, while the first is still in use\n+            final byte[] array2 = IOUtils.ScratchBufferHolder.getScratchByteArray();\n+            assert0(array2);\n+            assertNotSame(array, array2);\n+        } finally {\n+            // Release first array\n+            IOUtils.ScratchBufferHolder.releaseScratchByteArray(array);\n+        }\n+        // The first array should be reset and reusable\n+        final byte[] array3 = IOUtils.ScratchBufferHolder.getScratchByteArray();\n+        try {\n+            assert0(array3);\n+            assertSame(array, array3);\n+        } finally {\n+            IOUtils.ScratchBufferHolder.releaseScratchByteArray(array3);\n+        }\n     }\n \n     @Test\n     void test_getScratchCharArray() {\n-        final char[] array = IOUtils.getScratchCharArray();\n-        assert0(array);\n-        Arrays.fill(array, (char) 1);\n-        assert0(IOUtils.getScratchCharArray());\n-    }\n-\n-    @Test\n-    void test_getScratchCharArrayWriteOnly() {\n-        final char[] array = IOUtils.getScratchCharArrayWriteOnly();\n-        assert0(array);\n-        Arrays.fill(array, (char) 1);\n-        assert0(IOUtils.getScratchCharArray());\n+        final char[] array = IOUtils.ScratchBufferHolder.getScratchCharArray();\n+        try {\n+            assert0(array);\n+            Arrays.fill(array, (char) 1);\n+            // Get another array, while the first is still in use\n+            final char[] array2 = IOUtils.ScratchBufferHolder.getScratchCharArray();\n+            assert0(array2);\n+            assertNotSame(array, array2);\n+        } finally {\n+            // Release first array\n+            IOUtils.ScratchBufferHolder.releaseScratchCharArray(array);\n+        }\n+        // The first array should be reset and reusable\n+        final char[] array3 = IOUtils.ScratchBufferHolder.getScratchCharArray();\n+        try {\n+            assert0(array3);\n+            assertSame(array, array3);\n+        } finally {\n+            IOUtils.ScratchBufferHolder.releaseScratchCharArray(array3);\n+        }\n     }\n \n     @Test\ndiff --git a/src/test/java/org/apache/commons/io/IOUtilsConcurrentTest.java b/src/test/java/org/apache/commons/io/IOUtilsConcurrentTest.java\nnew file mode 100644\nindex 00000000000..0e1fb057175\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/io/IOUtilsConcurrentTest.java\n@@ -0,0 +1,212 @@\n+/*\n+ *  Licensed to the Apache Software Foundation (ASF) under one or more\n+ *  contributor license agreements.  See the NOTICE file distributed with\n+ *  this work for additional information regarding copyright ownership.\n+ *  The ASF licenses this file to You under the Apache License, Version 2.0\n+ *  (the \"License\"); you may not use this file except in compliance with\n+ *  the License.  You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.apache.commons.io;\n+\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.Reader;\n+import java.io.StringReader;\n+import java.nio.charset.Charset;\n+import java.util.List;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+import java.util.zip.CRC32;\n+import java.util.zip.Checksum;\n+\n+import org.apache.commons.io.function.IOConsumer;\n+import org.apache.commons.io.input.ChecksumInputStream;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+/**\n+ * Tests {@link IOUtils} methods in a concurrent environment.\n+ */\n+class IOUtilsConcurrentTest {\n+\n+    private static class ChecksumReader extends Reader {\n+        private final CRC32 checksum;\n+        private final long expectedChecksumValue;\n+        private final Reader reader;\n+\n+        ChecksumReader(Reader reader, long expectedChecksumValue) {\n+            this.reader = reader;\n+            this.checksum = new CRC32();\n+            this.expectedChecksumValue = expectedChecksumValue;\n+        }\n+\n+        @Override\n+        public void close() throws IOException {\n+            reader.close();\n+        }\n+\n+        public long getValue() {\n+            return checksum.getValue();\n+        }\n+\n+        @Override\n+        public int read() throws IOException {\n+            return super.read();\n+        }\n+\n+        @Override\n+        public int read(char[] cbuf, int off, int len) throws IOException {\n+            final int n = reader.read(cbuf, off, len);\n+            if (n > 0) {\n+                final byte[] bytes = new String(cbuf, off, n).getBytes(Charset.defaultCharset());\n+                checksum.update(bytes, 0, bytes.length);\n+            }\n+            if (n == -1) {\n+                final long actual = checksum.getValue();\n+                if (actual != expectedChecksumValue) {\n+                    throw new IOException(\"Checksum mismatch: expected \" + expectedChecksumValue + \" but got \" + actual);\n+                }\n+            }\n+            return n;\n+        }\n+    }\n+\n+    /**\n+     * Test data for InputStream tests.\n+     */\n+    private static final byte[][] BYTE_DATA;\n+    /**\n+     * Checksum values for {@link #BYTE_DATA}.\n+     */\n+    private static final long[] BYTE_DATA_CHECKSUM;\n+    /**\n+     * Number of runs per thread (to increase the chance of collisions).\n+     */\n+    private static final int RUNS_PER_THREAD = 16;\n+    /**\n+     * Size of test data.\n+     */\n+    private static final int SIZE = IOUtils.DEFAULT_BUFFER_SIZE;\n+    /**\n+     * Test data for Reader tests.\n+     */\n+    private static final String[] STRING_DATA;\n+    /**\n+     * Checksum values for {@link #STRING_DATA}.\n+     */\n+    private static final long[] STRING_DATA_CHECKSUM;\n+    /**\n+     * Number of threads to use.\n+     */\n+    private static final int THREAD_COUNT = 16;\n+    /**\n+     * Number of data variants (to increase the chance of collisions).\n+     */\n+    private static final int VARIANTS = 16;\n+\n+    static {\n+        final Checksum checksum = new CRC32();\n+        // Byte data\n+        BYTE_DATA = new byte[VARIANTS][];\n+        BYTE_DATA_CHECKSUM = new long[VARIANTS];\n+        for (int variant = 0; variant < VARIANTS; variant++) {\n+            final byte[] data = new byte[SIZE];\n+            for (int i = 0; i < SIZE; i++) {\n+                data[i] = (byte) ((i + variant) % 256);\n+            }\n+            BYTE_DATA[variant] = data;\n+            checksum.reset();\n+            checksum.update(data, 0 , data.length);\n+            BYTE_DATA_CHECKSUM[variant] = checksum.getValue();\n+        }\n+        // Char data\n+        final char[] cdata = new char[SIZE];\n+        STRING_DATA = new String[VARIANTS];\n+        STRING_DATA_CHECKSUM = new long[VARIANTS];\n+        for (int variant = 0; variant < VARIANTS; variant++) {\n+            for (int i = 0; i < SIZE; i++) {\n+                cdata[i] = (char) ((i + variant) % Character.MAX_VALUE);\n+            }\n+            STRING_DATA[variant] = new String(cdata);\n+            checksum.reset();\n+            final byte[] bytes = STRING_DATA[variant].getBytes(Charset.defaultCharset());\n+            checksum.update(bytes, 0, bytes.length);\n+            STRING_DATA_CHECKSUM[variant] = checksum.getValue();\n+        }\n+    }\n+\n+    static Stream<IOConsumer<InputStream>> testConcurrentInputStreamTasks() {\n+        return Stream.of(\n+                IOUtils::consume,\n+                in -> IOUtils.skip(in, Long.MAX_VALUE),\n+                in -> IOUtils.skipFully(in, SIZE),\n+                IOUtils::toByteArray,\n+                in -> IOUtils.toByteArray(in, SIZE),\n+                in -> IOUtils.toByteArray(in, SIZE, 512)\n+        );\n+    }\n+\n+    static Stream<IOConsumer<Reader>> testConcurrentReaderTasks() {\n+        return Stream.of(\n+                IOUtils::consume,\n+                reader -> IOUtils.skip(reader, Long.MAX_VALUE),\n+                reader -> IOUtils.skipFully(reader, SIZE),\n+                reader -> IOUtils.toByteArray(reader, Charset.defaultCharset())\n+        );\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    void testConcurrentInputStreamTasks(IOConsumer<InputStream> consumer) throws InterruptedException {\n+        final ExecutorService threadPool = Executors.newFixedThreadPool(THREAD_COUNT);\n+        try {\n+            final List<Future<Void>> futures = IntStream.range(0, THREAD_COUNT * RUNS_PER_THREAD)\n+                    .<Future<Void>>mapToObj(i -> threadPool.submit(() -> {\n+                        try (InputStream in = ChecksumInputStream\n+                                .builder()\n+                                .setByteArray(BYTE_DATA[i % VARIANTS])\n+                                .setChecksum(new CRC32())\n+                                .setExpectedChecksumValue(BYTE_DATA_CHECKSUM[i % VARIANTS])\n+                                .get()) {\n+                            consumer.accept(in);\n+                        }\n+                        return null;\n+                    })).collect(Collectors.toList());\n+            futures.forEach(f -> assertDoesNotThrow(() -> f.get()));\n+        } finally {\n+            threadPool.shutdownNow();\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    void testConcurrentReaderTasks(IOConsumer<Reader> consumer) throws InterruptedException {\n+        final ExecutorService threadPool = Executors.newFixedThreadPool(THREAD_COUNT);\n+        try {\n+            final List<Future<Void>> futures = IntStream.range(0, THREAD_COUNT * RUNS_PER_THREAD)\n+                    .<Future<Void>>mapToObj(i -> threadPool.submit(() -> {\n+                        try (Reader reader = new ChecksumReader(new StringReader(STRING_DATA[i % VARIANTS]), STRING_DATA_CHECKSUM[i % VARIANTS])) {\n+                            consumer.accept(reader);\n+                        }\n+                        return null;\n+                    })).collect(Collectors.toList());\n+            futures.forEach(f -> assertDoesNotThrow(() -> f.get()));\n+        } finally {\n+            threadPool.shutdownNow();\n+        }\n+    }\n+}\n",
  "problem_statement" : "Fix concurrency issue in `IOUtils.skip`\n\nThis patch addresses a concurrency problem in `IOUtils.skip`, as reported in [COMPRESS-666](https://issues.apache.org/jira/browse/COMPRESS-666) and [COMPRESS-697](https://issues.apache.org/jira/browse/COMPRESS-697).\r\n\r\nPreviously, `IOUtils.skip` relied on `InputStream#read` to skip bytes, using a buffer shared across **all** threads. Although `IOUtils.skip` itself does not consume the data read, certain `InputStream` implementations (e.g. `ChecksumInputStream`) may process that data internally.\r\n\r\nIn concurrent scenarios, this shared buffer could be overwritten by another thread between the `read` and the subsequent internal processing (such as checksum calculation), leading to incorrect behavior.\r\n\r\nThis change reverts commit c12eaff7f747353a7a9a97df735fd3301f42e313 and restores the use of a **per-thread buffer** in `IOUtils.skip`, ensuring thread safety and correct behavior in concurrent environments.\r\n",
  "hints_text" : null,
  "created_at" : "Thu Oct 16 22:46:17 CEST 2025",
  "version" : null,
  "FAIL_TO_PASS" : [ "IOCaseTest", "IOUtilsConcurrentTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=IOCaseTest,IOUtilsConcurrentTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 801,
  "metadata" : null
}, {
  "instance_id" : "apache-commons-io-PR-800",
  "repo" : "apache/commons-io",
  "base_commit" : "b95cbfa29df2928578a133b395a3e03dd05658fb",
  "patch" : "diff --git a/src/main/java/org/apache/commons/io/channels/CloseShieldChannel.java b/src/main/java/org/apache/commons/io/channels/CloseShieldChannel.java\nindex a9a462da73b..bde0feb25cc 100644\n--- a/src/main/java/org/apache/commons/io/channels/CloseShieldChannel.java\n+++ b/src/main/java/org/apache/commons/io/channels/CloseShieldChannel.java\n@@ -40,11 +40,15 @@ public final class CloseShieldChannel {\n     private static final Class<?>[] EMPTY = {};\n \n     private static Set<Class<?>> collectChannelInterfaces(final Class<?> type, final Set<Class<?>> out) {\n+        Class<?> currentType = type;\n         // Visit interfaces\n-        for (final Class<?> iface : type.getInterfaces()) {\n-            if (Channel.class.isAssignableFrom(iface) && out.add(iface)) {\n-                collectChannelInterfaces(iface, out);\n+        while (currentType != null) {\n+            for (final Class<?> iface : currentType.getInterfaces()) {\n+                if (Channel.class.isAssignableFrom(iface) && out.add(iface)) {\n+                    collectChannelInterfaces(iface, out);\n+                }\n             }\n+            currentType = currentType.getSuperclass();\n         }\n         return out;\n     }\n",
  "test_patch" : "diff --git a/src/test/java/org/apache/commons/io/channels/CloseShieldChannelTest.java b/src/test/java/org/apache/commons/io/channels/CloseShieldChannelTest.java\nindex ac7e85b7a89..42a23f0af1c 100644\n--- a/src/test/java/org/apache/commons/io/channels/CloseShieldChannelTest.java\n+++ b/src/test/java/org/apache/commons/io/channels/CloseShieldChannelTest.java\n@@ -20,6 +20,7 @@\n import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n import static org.junit.jupiter.api.Assertions.assertEquals;\n import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertInstanceOf;\n import static org.junit.jupiter.api.Assertions.assertNotSame;\n import static org.junit.jupiter.api.Assertions.assertSame;\n import static org.junit.jupiter.api.Assertions.assertThrows;\n@@ -32,11 +33,13 @@\n import static org.mockito.Mockito.verifyNoMoreInteractions;\n import static org.mockito.Mockito.when;\n \n+import java.io.IOException;\n import java.nio.channels.AsynchronousByteChannel;\n import java.nio.channels.AsynchronousChannel;\n import java.nio.channels.ByteChannel;\n import java.nio.channels.Channel;\n import java.nio.channels.ClosedChannelException;\n+import java.nio.channels.FileChannel;\n import java.nio.channels.GatheringByteChannel;\n import java.nio.channels.InterruptibleChannel;\n import java.nio.channels.MulticastChannel;\n@@ -45,9 +48,12 @@\n import java.nio.channels.ScatteringByteChannel;\n import java.nio.channels.SeekableByteChannel;\n import java.nio.channels.WritableByteChannel;\n+import java.nio.file.Path;\n import java.util.stream.Stream;\n \n+import org.apache.commons.io.FileUtils;\n import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.io.TempDir;\n import org.junit.jupiter.params.ParameterizedTest;\n import org.junit.jupiter.params.provider.MethodSource;\n \n@@ -280,4 +286,22 @@ void testWritableByteChannelMethods() throws Exception {\n         assertThrows(ClosedChannelException.class, () -> shield.write(null));\n         verifyNoMoreInteractions(channel);\n     }\n+\n+    @Test\n+    void testCorrectlyDetectsInterfaces(@TempDir Path tempDir) throws IOException {\n+        final Path testFile = tempDir.resolve(\"test.txt\");\n+        FileUtils.touch(testFile.toFile());\n+        try (FileChannel channel = FileChannel.open(testFile); Channel shield = CloseShieldChannel.wrap(channel)) {\n+            assertInstanceOf(SeekableByteChannel.class, shield);\n+            assertInstanceOf(GatheringByteChannel.class, shield);\n+            assertInstanceOf(WritableByteChannel.class, shield);\n+            assertInstanceOf(ScatteringByteChannel.class, shield);\n+            assertInstanceOf(ReadableByteChannel.class, shield);\n+            assertInstanceOf(InterruptibleChannel.class, shield);\n+            assertInstanceOf(ByteChannel.class, shield);\n+            assertInstanceOf(Channel.class, shield);\n+            // These are not interfaces, so can not be implemented\n+            assertFalse(shield instanceof FileChannel, \"not FileChannel\");\n+        }\n+    }\n }\n",
  "problem_statement" : "Fix interface discovery in `CloseShieldChannel`\n\nThis PR is split from #799.\r\n\r\nThe `CloseShieldChannel` implementation only inspects interfaces **directly** implemented by the given channelâ€™s class, ignoring those inherited from its superclasses. As a result, proxies for types such as `FileChannel` does not expose any of the interfaces declared on `FileChannel` itself.\r\n",
  "hints_text" : null,
  "created_at" : "Tue Oct 14 19:12:29 CEST 2025",
  "version" : null,
  "FAIL_TO_PASS" : [ "CloseShieldChannelTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=CloseShieldChannelTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 800,
  "metadata" : null
}, {
  "instance_id" : "apache-commons-io-PR-799",
  "repo" : "apache/commons-io",
  "base_commit" : "f51d19cabad7b8c67e2992a2ab22465658249485",
  "patch" : "diff --git a/src/main/java/org/apache/commons/io/channels/CloseShieldChannel.java b/src/main/java/org/apache/commons/io/channels/CloseShieldChannel.java\nindex bde0feb25cc..ba890d8a6a7 100644\n--- a/src/main/java/org/apache/commons/io/channels/CloseShieldChannel.java\n+++ b/src/main/java/org/apache/commons/io/channels/CloseShieldChannel.java\n@@ -19,7 +19,16 @@\n \n import java.io.Closeable;\n import java.lang.reflect.Proxy;\n+import java.nio.channels.AsynchronousChannel;\n+import java.nio.channels.ByteChannel;\n import java.nio.channels.Channel;\n+import java.nio.channels.GatheringByteChannel;\n+import java.nio.channels.InterruptibleChannel;\n+import java.nio.channels.NetworkChannel;\n+import java.nio.channels.ReadableByteChannel;\n+import java.nio.channels.ScatteringByteChannel;\n+import java.nio.channels.SeekableByteChannel;\n+import java.nio.channels.WritableByteChannel;\n import java.util.LinkedHashSet;\n import java.util.Objects;\n import java.util.Set;\n@@ -27,9 +36,23 @@\n /**\n  * Creates a close-shielding proxy for a {@link Channel}.\n  *\n- * <p>\n- * The returned proxy will implement all {@link Channel} sub-interfaces that the delegate implements.\n- * </p>\n+ * <p>The returned proxy implements all {@link Channel} sub-interfaces that are both supported by this implementation and actually implemented by the given\n+ * delegate.</p>\n+ *\n+ * <p>The following interfaces are supported:</p>\n+ *\n+ * <ul>\n+ * <li>{@link AsynchronousChannel}</li>\n+ * <li>{@link ByteChannel}</li>\n+ * <li>{@link Channel}</li>\n+ * <li>{@link GatheringByteChannel}</li>\n+ * <li>{@link InterruptibleChannel}</li>\n+ * <li>{@link NetworkChannel}</li>\n+ * <li>{@link ReadableByteChannel}</li>\n+ * <li>{@link ScatteringByteChannel}</li>\n+ * <li>{@link SeekableByteChannel}</li>\n+ * <li>{@link WritableByteChannel}</li>\n+ * </ul>\n  *\n  * @see Channel\n  * @see Closeable\n@@ -44,7 +67,7 @@ private static Set<Class<?>> collectChannelInterfaces(final Class<?> type, final\n         // Visit interfaces\n         while (currentType != null) {\n             for (final Class<?> iface : currentType.getInterfaces()) {\n-                if (Channel.class.isAssignableFrom(iface) && out.add(iface)) {\n+                if (CloseShieldChannelHandler.isSupported(iface) && out.add(iface)) {\n                     collectChannelInterfaces(iface, out);\n                 }\n             }\n@@ -57,8 +80,10 @@ private static Set<Class<?>> collectChannelInterfaces(final Class<?> type, final\n      * Wraps a channel to shield it from being closed.\n      *\n      * @param channel The underlying channel to shield, not {@code null}.\n-     * @param <T>     Any Channel type (interface or class).\n+     * @param <T>     A supported channel type.\n      * @return A proxy that shields {@code close()} and enforces closed semantics on other calls.\n+     * @throws ClassCastException if {@code T} is not a supported channel type.\n+     * @throws NullPointerException if {@code channel} is {@code null}.\n      */\n     @SuppressWarnings({ \"unchecked\", \"resource\" }) // caller closes\n     public static <T extends Channel> T wrap(final T channel) {\ndiff --git a/src/main/java/org/apache/commons/io/channels/CloseShieldChannelHandler.java b/src/main/java/org/apache/commons/io/channels/CloseShieldChannelHandler.java\nindex f13b101c197..a7f3d3694f1 100644\n--- a/src/main/java/org/apache/commons/io/channels/CloseShieldChannelHandler.java\n+++ b/src/main/java/org/apache/commons/io/channels/CloseShieldChannelHandler.java\n@@ -21,14 +21,45 @@\n import java.lang.reflect.InvocationTargetException;\n import java.lang.reflect.Method;\n import java.lang.reflect.Proxy;\n+import java.nio.channels.AsynchronousChannel;\n+import java.nio.channels.ByteChannel;\n import java.nio.channels.Channel;\n import java.nio.channels.ClosedChannelException;\n+import java.nio.channels.GatheringByteChannel;\n+import java.nio.channels.InterruptibleChannel;\n import java.nio.channels.NetworkChannel;\n+import java.nio.channels.ReadableByteChannel;\n+import java.nio.channels.ScatteringByteChannel;\n import java.nio.channels.SeekableByteChannel;\n+import java.nio.channels.WritableByteChannel;\n+import java.util.Collections;\n+import java.util.HashSet;\n import java.util.Objects;\n+import java.util.Set;\n \n final class CloseShieldChannelHandler implements InvocationHandler {\n \n+    private static final Set<Class<?>> SUPPORTED_INTERFACES;\n+\n+    static {\n+        final Set<Class<?>> interfaces = new HashSet<>();\n+        interfaces.add(AsynchronousChannel.class);\n+        interfaces.add(ByteChannel.class);\n+        interfaces.add(Channel.class);\n+        interfaces.add(GatheringByteChannel.class);\n+        interfaces.add(InterruptibleChannel.class);\n+        interfaces.add(NetworkChannel.class);\n+        interfaces.add(ReadableByteChannel.class);\n+        interfaces.add(ScatteringByteChannel.class);\n+        interfaces.add(SeekableByteChannel.class);\n+        interfaces.add(WritableByteChannel.class);\n+        SUPPORTED_INTERFACES = Collections.unmodifiableSet(interfaces);\n+    }\n+\n+    static boolean isSupported(final Class<?> interfaceClass) {\n+        return SUPPORTED_INTERFACES.contains(interfaceClass);\n+    }\n+\n     /**\n      * Tests whether the given method is allowed to be called after the shield is closed.\n      *\n",
  "test_patch" : "diff --git a/src/test/java/org/apache/commons/io/channels/CloseShieldChannelTest.java b/src/test/java/org/apache/commons/io/channels/CloseShieldChannelTest.java\nindex 47d04df95d6..1f448f42cc2 100644\n--- a/src/test/java/org/apache/commons/io/channels/CloseShieldChannelTest.java\n+++ b/src/test/java/org/apache/commons/io/channels/CloseShieldChannelTest.java\n@@ -34,7 +34,6 @@\n import static org.mockito.Mockito.when;\n \n import java.io.IOException;\n-import java.nio.channels.AsynchronousByteChannel;\n import java.nio.channels.AsynchronousChannel;\n import java.nio.channels.ByteChannel;\n import java.nio.channels.Channel;\n@@ -42,7 +41,6 @@\n import java.nio.channels.FileChannel;\n import java.nio.channels.GatheringByteChannel;\n import java.nio.channels.InterruptibleChannel;\n-import java.nio.channels.MulticastChannel;\n import java.nio.channels.NetworkChannel;\n import java.nio.channels.ReadableByteChannel;\n import java.nio.channels.ScatteringByteChannel;\n@@ -65,14 +63,11 @@ class CloseShieldChannelTest {\n     static Stream<Class<? extends Channel>> testedInterfaces() {\n         // @formatter:off\n         return Stream.of(\n-                AsynchronousByteChannel.class,\n                 AsynchronousChannel.class,\n                 ByteChannel.class,\n                 Channel.class,\n                 GatheringByteChannel.class,\n                 InterruptibleChannel.class,\n-                MulticastChannel.class,\n-                NetworkChannel.class,\n                 NetworkChannel.class,\n                 ReadableByteChannel.class,\n                 ScatteringByteChannel.class,\n",
  "problem_statement" : "Fixes issues in `CloseShieldChannel`\n\nTwo bugs in the `CloseShieldChannel` helper make it unreliable in practice:\r\n\r\n1. **Type-erasure bug in `T wrap(T)`** The method signature only works correctly when `T` is an **interface** extending `Channel`. Since Javaâ€™s type system doesnâ€™t allow constraining `T` to â€œinterface types only,â€ this could lead to unexpected runtime `ClassCastException`s even though the code compiles successfully.\r\n\r\n2. **Incomplete interface discovery** The implementation only inspected interfaces **directly** implemented by the given channelâ€™s class, ignoring those inherited from its superclasses. As a result, proxies for types such as `FileChannel` did not expose any of the interfaces declared on `FileChannel` itself.\r\n\r\n#### Fixes\r\n\r\nThis PR addresses both issues:\r\n\r\n* **Reworks the API signature**\r\n\r\n  * Replaces `T wrap(T)` with its erasure: `Channel wrap(Channel)`.\r\n  * Introduces a new overload: `T wrap(T, Class<T>)`, which allows callers to explicitly specify the interface type they expect. This version fails fast with a clear `IllegalArgumentException` if the provided type is not an interface, instead of allowing a `ClassCastException` later.\r\n\r\n* **Improves interface collection logic**\r\n\r\n  * Updates the implementation to include interfaces declared on superclasses, ensuring all relevant `Channel` interfaces are correctly proxied.\r\n",
  "hints_text" : null,
  "created_at" : "Mon Oct 13 15:59:57 CEST 2025",
  "version" : null,
  "FAIL_TO_PASS" : [ "CloseShieldChannelTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=CloseShieldChannelTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 799,
  "metadata" : null
}, {
  "instance_id" : "apache-commons-io-PR-796",
  "repo" : "apache/commons-io",
  "base_commit" : "07d2cd9c493baae1e82553b3da420d17a6093c05",
  "patch" : "diff --git a/src/main/java/org/apache/commons/io/IOUtils.java b/src/main/java/org/apache/commons/io/IOUtils.java\nindex a882d4d87cb..e157d51a5a9 100644\n--- a/src/main/java/org/apache/commons/io/IOUtils.java\n+++ b/src/main/java/org/apache/commons/io/IOUtils.java\n@@ -2957,6 +2957,7 @@ public static byte[] toByteArray(final InputStream input, final long size) throw\n      * @param input the input to read, not null.\n      * @param size the size of the input to read, where 0 &lt; {@code size} &lt;= length of input.\n      * @return byte [] of length {@code size}.\n+     * @throws EOFException if the end of the input is reached before reading {@code size} bytes.\n      * @throws IOException if an I/O error occurs or input length is smaller than parameter {@code size}.\n      * @throws IllegalArgumentException if {@code size} is less than zero.\n      */\n@@ -2974,7 +2975,7 @@ static byte[] toByteArray(final IOTriFunction<byte[], Integer, Integer, Integer>\n             offset += read;\n         }\n         if (offset != size) {\n-            throw new IOException(\"Unexpected read size, current: \" + offset + \", expected: \" + size);\n+            throw new EOFException(\"Unexpected read size, current: \" + offset + \", expected: \" + size);\n         }\n         return data;\n     }\n",
  "test_patch" : "diff --git a/src/test/java/org/apache/commons/io/IOUtilsTest.java b/src/test/java/org/apache/commons/io/IOUtilsTest.java\nindex 02574946bf8..df05c648f8d 100644\n--- a/src/test/java/org/apache/commons/io/IOUtilsTest.java\n+++ b/src/test/java/org/apache/commons/io/IOUtilsTest.java\n@@ -158,7 +158,9 @@ static Stream<Arguments> testToByteArray_InputStream_Size_BufferSize_Throws() {\n                 Arguments.of(-1, 128, IllegalArgumentException.class),\n                 // Invalid buffer size\n                 Arguments.of(0, 0, IllegalArgumentException.class),\n-                // Huge size: should not cause OutOfMemoryError\n+                // Truncation with requested size < chunk size\n+                Arguments.of(64, 128, EOFException.class),\n+                // Truncation with requested size > chunk size\n                 Arguments.of(Integer.MAX_VALUE, 128, EOFException.class));\n     }\n \n@@ -1757,6 +1759,13 @@ void testToByteArray_InputStream_Size() throws Exception {\n         }\n     }\n \n+    @Test\n+    void testToByteArray_InputStream_Size_Truncated() throws Exception {\n+        try (InputStream in = new NullInputStream(0)) {\n+            assertThrows(EOFException.class, () -> IOUtils.toByteArray(in, 1), \"Should have failed with EOFException\");\n+        }\n+    }\n+\n     @ParameterizedTest\n     @MethodSource\n     void testToByteArray_InputStream_Size_BufferSize_Succeeds(final byte[] data, final int size, final int bufferSize) throws IOException {\n",
  "problem_statement" : "`IOUtils.toByteArray` now throws `EOFException` when not enough data is available\n\nThe implementation of `IOUtils.toByteArray(InputStream, int, int)` added in #776 throws different exceptions depending on the requested size:\r\n\r\n* For request sizes larger than the internal chunk size, it correctly throws an `EOFException`.\r\n* For smaller requests, it incorrectly throws a generic `IOException`.\r\n\r\nThis PR makes the behavior consistent by always throwing an `EOFException` when the stream ends prematurely.\r\n\r\n> [!NOTE]\r\n> This also affects `RandomAccessFiles.read`. Its previous truncation behavior was undocumented and inconsistent with `RandomAccessFile.read` (which reads as much as possible). The new behavior is not explicitly documented here either, since it is unclear whether throwing on truncation is actually desirable.\r\n",
  "hints_text" : null,
  "created_at" : "Fri Oct 03 20:44:30 CEST 2025",
  "version" : null,
  "FAIL_TO_PASS" : [ "IOUtilsTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=IOUtilsTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 796,
  "metadata" : null
}, {
  "instance_id" : "apache-commons-io-PR-795",
  "repo" : "apache/commons-io",
  "base_commit" : "07d2cd9c493baae1e82553b3da420d17a6093c05",
  "patch" : "diff --git a/src/main/java/org/apache/commons/io/IOUtils.java b/src/main/java/org/apache/commons/io/IOUtils.java\nindex a882d4d87cb..66d785885ee 100644\n--- a/src/main/java/org/apache/commons/io/IOUtils.java\n+++ b/src/main/java/org/apache/commons/io/IOUtils.java\n@@ -2054,6 +2054,7 @@ public static LineIterator lineIterator(final Reader reader) {\n      * @param input where to read input from.\n      * @param buffer destination.\n      * @return actual length read; may be less than requested if EOF was reached.\n+     * @throws NullPointerException if {@code input} or {@code buffer} is null.\n      * @throws IOException if a read error occurs.\n      * @since 2.2\n      */\n@@ -2074,40 +2075,19 @@ public static int read(final InputStream input, final byte[] buffer) throws IOEx\n      * @param offset initial offset into buffer.\n      * @param length length to read, must be &gt;= 0.\n      * @return actual length read; may be less than requested if EOF was reached.\n-     * @throws IllegalArgumentException if length is negative.\n+     * @throws NullPointerException     if {@code input} or {@code buffer} is null.\n+     * @throws IndexOutOfBoundsException if {@code offset} or {@code length} is negative, or if\n+     *                                   {@code offset + length} is greater than {@code buffer.length}.\n      * @throws IOException              if a read error occurs.\n      * @since 2.2\n      */\n     public static int read(final InputStream input, final byte[] buffer, final int offset, final int length)\n             throws IOException {\n-        if (length == 0) {\n-            return 0;\n-        }\n-        return read(input::read, buffer, offset, length);\n-    }\n-\n-    /**\n-     * Reads bytes from an input. This implementation guarantees that it will read as many bytes as possible before giving up; this may not always be the case\n-     * for subclasses of {@link InputStream}.\n-     *\n-     * @param input  How to read input.\n-     * @param buffer destination.\n-     * @param offset initial offset into buffer.\n-     * @param length length to read, must be &gt;= 0.\n-     * @return actual length read; may be less than requested if EOF was reached.\n-     * @throws IllegalArgumentException if length is negative.\n-     * @throws IOException              if a read error occurs.\n-     * @since 2.2\n-     */\n-    static int read(final IOTriFunction<byte[], Integer, Integer, Integer> input, final byte[] buffer, final int offset, final int length)\n-            throws IOException {\n-        if (length < 0) {\n-            throw new IllegalArgumentException(\"Length must not be negative: \" + length);\n-        }\n+        checkFromIndexSize(buffer, offset, length);\n         int remaining = length;\n         while (remaining > 0) {\n             final int location = length - remaining;\n-            final int count = input.apply(buffer, offset + location, remaining);\n+            final int count = input.read(buffer, offset + location, remaining);\n             if (EOF == count) {\n                 break;\n             }\n@@ -2172,15 +2152,15 @@ public static int read(final Reader reader, final char[] buffer) throws IOExcept\n      * @param offset initial offset into buffer.\n      * @param length length to read, must be &gt;= 0.\n      * @return actual length read; may be less than requested if EOF was reached.\n-     * @throws IllegalArgumentException if length is negative.\n+     * @throws NullPointerException     if {@code reader} or {@code buffer} is null.\n+     * @throws IndexOutOfBoundsException if {@code offset} or {@code length} is negative, or if\n+     *                                   {@code offset + length} is greater than {@code buffer.length}.\n      * @throws IOException              if a read error occurs.\n      * @since 2.2\n      */\n     public static int read(final Reader reader, final char[] buffer, final int offset, final int length)\n             throws IOException {\n-        if (length < 0) {\n-            throw new IllegalArgumentException(\"Length must not be negative: \" + length);\n-        }\n+        checkFromIndexSize(buffer, offset, length);\n         int remaining = length;\n         while (remaining > 0) {\n             final int location = length - remaining;\n@@ -2202,9 +2182,9 @@ public static int read(final Reader reader, final char[] buffer, final int offse\n      *\n      * @param input where to read input from.\n      * @param buffer destination.\n-     * @throws IOException              if there is a problem reading the file.\n-     * @throws IllegalArgumentException if length is negative.\n+     * @throws NullPointerException     if {@code input} or {@code buffer} is null.\n      * @throws EOFException             if the number of bytes read was incorrect.\n+     * @throws IOException              if there is a problem reading the file.\n      * @since 2.2\n      */\n     public static void readFully(final InputStream input, final byte[] buffer) throws IOException {\n@@ -2222,9 +2202,11 @@ public static void readFully(final InputStream input, final byte[] buffer) throw\n      * @param buffer destination.\n      * @param offset initial offset into buffer.\n      * @param length length to read, must be &gt;= 0.\n-     * @throws IOException              if there is a problem reading the file.\n-     * @throws IllegalArgumentException if length is negative.\n+     * @throws NullPointerException     if {@code input} or {@code buffer} is null.\n+     * @throws IndexOutOfBoundsException if {@code offset} or {@code length} is negative, or if\n+     *                                   {@code offset + length} is greater than {@code buffer.length}.\n      * @throws EOFException             if the number of bytes read was incorrect.\n+     * @throws IOException              if there is a problem reading the file.\n      * @since 2.2\n      */\n     public static void readFully(final InputStream input, final byte[] buffer, final int offset, final int length)\n@@ -2286,9 +2268,9 @@ public static void readFully(final ReadableByteChannel input, final ByteBuffer b\n      *\n      * @param reader where to read input from.\n      * @param buffer destination.\n-     * @throws IOException              if there is a problem reading the file.\n-     * @throws IllegalArgumentException if length is negative.\n+     * @throws NullPointerException     if {@code reader} or {@code buffer} is null.\n      * @throws EOFException             if the number of characters read was incorrect.\n+     * @throws IOException              if there is a problem reading the file.\n      * @since 2.2\n      */\n     public static void readFully(final Reader reader, final char[] buffer) throws IOException {\n@@ -2306,9 +2288,11 @@ public static void readFully(final Reader reader, final char[] buffer) throws IO\n      * @param buffer destination.\n      * @param offset initial offset into buffer.\n      * @param length length to read, must be &gt;= 0.\n-     * @throws IOException              if there is a problem reading the file.\n-     * @throws IllegalArgumentException if length is negative.\n+     * @throws NullPointerException     if {@code reader} or {@code buffer} is null.\n+     * @throws IndexOutOfBoundsException if {@code offset} or {@code length} is negative, or if\n+     *                                   {@code offset + length} is greater than {@code buffer.length}.\n      * @throws EOFException             if the number of characters read was incorrect.\n+     * @throws IOException              if there is a problem reading the file.\n      * @since 2.2\n      */\n     public static void readFully(final Reader reader, final char[] buffer, final int offset, final int length)\n",
  "test_patch" : "diff --git a/src/test/java/org/apache/commons/io/IOUtilsTest.java b/src/test/java/org/apache/commons/io/IOUtilsTest.java\nindex 02574946bf8..a2164ce49d1 100644\n--- a/src/test/java/org/apache/commons/io/IOUtilsTest.java\n+++ b/src/test/java/org/apache/commons/io/IOUtilsTest.java\n@@ -1195,6 +1195,31 @@ void testRead_ReadableByteChannel() throws Exception {\n         }\n     }\n \n+    static Stream<Arguments> invalidRead_InputStream_Offset_ArgumentsProvider() {\n+        final InputStream input = new ByteArrayInputStream(new byte[10]);\n+        final byte[] b = new byte[10];\n+        return Stream.of(\n+            // input is null\n+            Arguments.of(null, b, 0, 1, NullPointerException.class),\n+            // b is null\n+            Arguments.of(input, null, 0, 1, NullPointerException.class),\n+            // off is negative\n+            Arguments.of(input, b, -1, 1, IndexOutOfBoundsException.class),\n+            // len is negative\n+            Arguments.of(input, b, 0, -1, IndexOutOfBoundsException.class),\n+            // off + len is too big\n+            Arguments.of(input, b, 1, 10, IndexOutOfBoundsException.class),\n+            // off + len is too big\n+            Arguments.of(input, b, 10, 1, IndexOutOfBoundsException.class)\n+        );\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"invalidRead_InputStream_Offset_ArgumentsProvider\")\n+    void testRead_InputStream_Offset_ArgumentsValidation(InputStream input, byte[] b, int off, int len, Class<? extends Throwable> expected) {\n+        assertThrows(expected, () -> IOUtils.read(input, b, off, len));\n+    }\n+\n     @Test\n     void testReadFully_InputStream__ReturnByteArray() throws Exception {\n         final byte[] bytes = \"abcd1234\".getBytes(StandardCharsets.UTF_8);\n@@ -1213,7 +1238,7 @@ void testReadFully_InputStream_ByteArray() throws Exception {\n         final byte[] buffer = new byte[size];\n         final InputStream input = new ByteArrayInputStream(new byte[size]);\n \n-        assertThrows(IllegalArgumentException.class, () -> IOUtils.readFully(input, buffer, 0, -1), \"Should have failed with IllegalArgumentException\");\n+        assertThrows(IndexOutOfBoundsException.class, () -> IOUtils.readFully(input, buffer, 0, -1), \"Should have failed with IndexOutOfBoundsException\");\n \n         IOUtils.readFully(input, buffer, 0, 0);\n         IOUtils.readFully(input, buffer, 0, size - 1);\n@@ -1260,7 +1285,7 @@ void testReadFully_Reader() throws Exception {\n \n         IOUtils.readFully(input, buffer, 0, 0);\n         IOUtils.readFully(input, buffer, 0, size - 3);\n-        assertThrows(IllegalArgumentException.class, () -> IOUtils.readFully(input, buffer, 0, -1), \"Should have failed with IllegalArgumentException\");\n+        assertThrows(IndexOutOfBoundsException.class, () -> IOUtils.readFully(input, buffer, 0, -1), \"Should have failed with IndexOutOfBoundsException\");\n         assertThrows(EOFException.class, () -> IOUtils.readFully(input, buffer, 0, 5), \"Should have failed with EOFException\");\n         IOUtils.closeQuietly(input);\n     }\n@@ -1274,6 +1299,12 @@ void testReadFully_Reader_Offset() throws Exception {\n         IOUtils.closeQuietly(reader);\n     }\n \n+    @ParameterizedTest\n+    @MethodSource(\"invalidRead_InputStream_Offset_ArgumentsProvider\")\n+    void testReadFully_InputStream_Offset_ArgumentsValidation(InputStream input, byte[] b, int off, int len, Class<? extends Throwable> expected) {\n+        assertThrows(expected, () -> IOUtils.read(input, b, off, len));\n+    }\n+\n     @Test\n     void testReadLines_CharSequence() throws IOException {\n         final File file = TestUtils.newFile(temporaryFolder, \"lines.txt\");\n",
  "problem_statement" : "Add missing `read` argument validation in `IOUtils`\n\nIn #790 I introduced `IOUtils#checkIndexFromLength` calls to validate arguments across the codebase. Ironically, the `IOUtils` class itself was left out.\r\n\r\nThis PR addresses that omission by adding argument validation to `IOUtils#read` and `IOUtils#readFully`.\r\n\r\nKey points:\r\n\r\n* Ensures consistency with the rest of Commons IO by validating `offset` and `length`.\r\n* Fixes inconsistent exception behavior:\r\n\r\n  * Previously, `length < 0` resulted in an `IllegalArgumentException`.\r\n  * `offset < 0` did not trigger validation and failed later with an `IndexOutOfBoundsException`.\r\n* With this change, both invalid cases are handled consistently and upfront.\r\n",
  "hints_text" : null,
  "created_at" : "Fri Oct 03 20:02:50 CEST 2025",
  "version" : null,
  "FAIL_TO_PASS" : [ "IOUtilsTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=IOUtilsTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 795,
  "metadata" : null
}, {
  "instance_id" : "apache-commons-io-PR-790",
  "repo" : "apache/commons-io",
  "base_commit" : "66db0c6610270ad58f93cf393fe2359f46d395b6",
  "patch" : "diff --git a/src/changes/changes.xml b/src/changes/changes.xml\nindex 0190734a841..7c2b0971b29 100644\n--- a/src/changes/changes.xml\n+++ b/src/changes/changes.xml\n@@ -68,6 +68,7 @@ The <action> type attribute can be add,update,fix,remove.\n       <action dev=\"ggregory\" type=\"add\"                due-to=\"Gary Gregory\">Add IOIterable.asIterable().</action>\n       <action dev=\"pkarwasz\" type=\"add\"                due-to=\"Piotr P. Karwasz\">Add NIO channel support to `AbstractStreamBuilder`.</action>\n       <action dev=\"pkarwasz\" type=\"add\"                due-to=\"Piotr P. Karwasz\">Add CloseShieldChannel to close-shielded NIO Channels #786.</action>\n+      <action dev=\"pkarwasz\" type=\"add\"                due-to=\"Piotr P. Karwasz\">Added IOUtils.checkFromIndexSize as a Java 8 backport of Objects.checkFromIndexSize #790.</action>\n       <!-- UPDATE -->\n       <action type=\"update\" dev=\"ggregory\"             due-to=\"Gary Gregory, Dependabot\">Bump org.apache.commons:commons-parent from 85 to 88 #774, #783.</action>\n       <action type=\"update\" dev=\"ggregory\"             due-to=\"Gary Gregory\">[test] Bump commons-codec:commons-codec from 1.18.0 to 1.19.0.</action>\ndiff --git a/src/main/java/org/apache/commons/io/IOUtils.java b/src/main/java/org/apache/commons/io/IOUtils.java\nindex e37eddafb3f..a882d4d87cb 100644\n--- a/src/main/java/org/apache/commons/io/IOUtils.java\n+++ b/src/main/java/org/apache/commons/io/IOUtils.java\n@@ -406,6 +406,183 @@ private static char[] charArray(final int size) {\n         return new char[size];\n     }\n \n+    /**\n+     * Validates that the sub-range {@code [off, off + len)} is within the bounds of the given array.\n+     *\n+     * <p>The range is valid if all of the following hold:</p>\n+     * <ul>\n+     *   <li>{@code off >= 0}</li>\n+     *   <li>{@code len >= 0}</li>\n+     *   <li>{@code off + len <= array.length}</li>\n+     * </ul>\n+     *\n+     * <p>If the range is invalid, throws {@link IndexOutOfBoundsException} with a descriptive message.</p>\n+     *\n+     * <p>Typical usage in {@link InputStream#read(byte[], int, int)} and {@link OutputStream#write(byte[], int, int)} implementations:</p>\n+     *\n+     * <pre><code>\n+     * public int read(byte[] b, int off, int len) throws IOException {\n+     *     IOUtils.checkFromIndexSize(b, off, len);\n+     *     if (len == 0) {\n+     *         return 0;\n+     *     }\n+     *     ensureOpen();\n+     *     // perform read...\n+     * }\n+     *\n+     * public void write(byte[] b, int off, int len) throws IOException {\n+     *     IOUtils.checkFromIndexSize(b, off, len);\n+     *     if (len == 0) {\n+     *         return;\n+     *     }\n+     *     ensureOpen();\n+     *     // perform write...\n+     * }\n+     * </code></pre>\n+     *\n+     * @param array the array against which the range is validated\n+     * @param off   the starting offset into the array (inclusive)\n+     * @param len   the number of elements to access\n+     * @throws NullPointerException      if {@code array} is {@code null}\n+     * @throws IndexOutOfBoundsException if the range {@code [off, off + len)} is out of bounds for {@code array}\n+     * @see InputStream#read(byte[], int, int)\n+     * @see OutputStream#write(byte[], int, int)\n+     * @since 2.21.0\n+     */\n+    public static void checkFromIndexSize(final byte[] array, final int off, final int len) {\n+        checkFromIndexSize(off, len, Objects.requireNonNull(array, \"byte array\").length);\n+    }\n+\n+    /**\n+     * Validates that the sub-range {@code [off, off + len)} is within the bounds of the given array.\n+     *\n+     * <p>The range is valid if all of the following hold:</p>\n+     * <ul>\n+     *   <li>{@code off >= 0}</li>\n+     *   <li>{@code len >= 0}</li>\n+     *   <li>{@code off + len <= array.length}</li>\n+     * </ul>\n+     *\n+     * <p>If the range is invalid, throws {@link IndexOutOfBoundsException} with a descriptive message.</p>\n+     *\n+     * <p>Typical usage in {@link Reader#read(char[], int, int)} and {@link Writer#write(char[], int, int)} implementations:</p>\n+     *\n+     * <pre><code>\n+     * public int read(char[] cbuf, int off, int len) throws IOException {\n+     *     ensureOpen();\n+     *     IOUtils.checkFromIndexSize(cbuf, off, len);\n+     *     if (len == 0) {\n+     *         return 0;\n+     *     }\n+     *     // perform read...\n+     * }\n+     *\n+     * public void write(char[] cbuf, int off, int len) throws IOException {\n+     *     ensureOpen();\n+     *     IOUtils.checkFromIndexSize(cbuf, off, len);\n+     *     if (len == 0) {\n+     *         return;\n+     *     }\n+     *     // perform write...\n+     * }\n+     * </code></pre>\n+     *\n+     * @param array the array against which the range is validated\n+     * @param off   the starting offset into the array (inclusive)\n+     * @param len   the number of characters to access\n+     * @throws NullPointerException      if {@code array} is {@code null}\n+     * @throws IndexOutOfBoundsException if the range {@code [off, off + len)} is out of bounds for {@code array}\n+     * @see Reader#read(char[], int, int)\n+     * @see Writer#write(char[], int, int)\n+     * @since 2.21.0\n+     */\n+    public static void checkFromIndexSize(final char[] array, final int off, final int len) {\n+        checkFromIndexSize(off, len, Objects.requireNonNull(array, \"char array\").length);\n+    }\n+\n+    /**\n+     * Validates that the sub-range {@code [off, off + len)} is within the bounds of the given string.\n+     *\n+     * <p>The range is valid if all of the following hold:</p>\n+     * <ul>\n+     *   <li>{@code off >= 0}</li>\n+     *   <li>{@code len >= 0}</li>\n+     *   <li>{@code off + len <= str.length()}</li>\n+     * </ul>\n+     *\n+     * <p>If the range is invalid, throws {@link IndexOutOfBoundsException} with a descriptive message.</p>\n+     *\n+     * <p>Typical usage in {@link Writer#write(String, int, int)} implementations:</p>\n+     *\n+     * <pre><code>\n+     * public void write(String str, int off, int len) throws IOException {\n+     *     IOUtils.checkFromIndexSize(str, off, len);\n+     *     if (len == 0) {\n+     *         return;\n+     *     }\n+     *     // perform write...\n+     * }\n+     * </code></pre>\n+     *\n+     * @param str the string against which the range is validated\n+     * @param off the starting offset into the string (inclusive)\n+     * @param len the number of characters to write\n+     * @throws NullPointerException      if {@code str} is {@code null}\n+     * @throws IndexOutOfBoundsException if the range {@code [off, off + len)} is out of bounds for {@code str}\n+     * @see Writer#write(String, int, int)\n+     * @since 2.21.0\n+     */\n+    public static void checkFromIndexSize(final String str, final int off, final int len) {\n+        checkFromIndexSize(off, len, Objects.requireNonNull(str, \"str\").length());\n+    }\n+\n+    static void checkFromIndexSize(final int off, final int len, final int arrayLength) {\n+        if ((off | len | arrayLength) < 0 || arrayLength - len < off) {\n+            throw new IndexOutOfBoundsException(String.format(\"Range [%s, %<s + %s) out of bounds for length %s\", off, len, arrayLength));\n+        }\n+    }\n+\n+    /**\n+     * Validates that the sub-sequence {@code [fromIndex, toIndex)} is within the bounds of the given {@link CharSequence}.\n+     *\n+     * <p>The sub-sequence is valid if all of the following hold:</p>\n+     * <ul>\n+     *   <li>{@code fromIndex >= 0}</li>\n+     *   <li>{@code fromIndex <= toIndex}</li>\n+     *   <li>{@code toIndex <= seq.length()}</li>\n+     * </ul>\n+     *\n+     * <p>If {@code seq} is {@code null}, it is treated as the literal string {@code \"null\"} (length {@code 4}).</p>\n+     *\n+     * <p>If the range is invalid, throws {@link IndexOutOfBoundsException} with a descriptive message.</p>\n+     *\n+     * <p>Typical usage in {@link Appendable#append(CharSequence, int, int)} implementations:</p>\n+     *\n+     * <pre><code>\n+     * public Appendable append(CharSequence csq, int start, int end) throws IOException {\n+     *     IOUtils.checkFromToIndex(csq, start, end);\n+     *     // perform append...\n+     *     return this;\n+     * }\n+     * </code></pre>\n+     *\n+     * @param seq       the character sequence to validate (may be {@code null}, treated as {@code \"null\"})\n+     * @param fromIndex the starting index (inclusive)\n+     * @param toIndex   the ending index (exclusive)\n+     * @throws IndexOutOfBoundsException if the range {@code [fromIndex, toIndex)} is out of bounds for {@code seq}\n+     * @see Appendable#append(CharSequence, int, int)\n+     * @since 2.21.0\n+     */\n+    public static void checkFromToIndex(final CharSequence seq, final int fromIndex, final int toIndex) {\n+        checkFromToIndex(fromIndex, toIndex, seq != null ? seq.length() : 4);\n+    }\n+\n+    static void checkFromToIndex(final int fromIndex, final int toIndex, final int length) {\n+        if (fromIndex < 0 || toIndex < fromIndex || length < toIndex) {\n+            throw new IndexOutOfBoundsException(String.format(\"Range [%s, %s) out of bounds for length %s\", fromIndex, toIndex, length));\n+        }\n+    }\n+\n     /**\n      * Clears any state.\n      * <ul>\ndiff --git a/src/main/java/org/apache/commons/io/input/BOMInputStream.java b/src/main/java/org/apache/commons/io/input/BOMInputStream.java\nindex c5872d7cbc9..acfe8d9ddbb 100644\n--- a/src/main/java/org/apache/commons/io/input/BOMInputStream.java\n+++ b/src/main/java/org/apache/commons/io/input/BOMInputStream.java\n@@ -419,8 +419,10 @@ public int read() throws IOException {\n      * Invokes the delegate's {@code read(byte[])} method, detecting and optionally skipping BOM.\n      *\n      * @param buf\n-     *            the buffer to read the bytes into\n+     *            the buffer to read the bytes into, never {@code null}\n      * @return the number of bytes read (excluding BOM) or -1 if the end of stream\n+     * @throws NullPointerException\n+     *             if the buffer is {@code null}\n      * @throws IOException\n      *             if an I/O error occurs\n      */\n@@ -439,11 +441,19 @@ public int read(final byte[] buf) throws IOException {\n      * @param len\n      *            The number of bytes to read (excluding BOM)\n      * @return the number of bytes read or -1 if the end of stream\n+     * @throws NullPointerException\n+     *             if the buffer is {@code null}\n+     * @throws IndexOutOfBoundsException\n+     *             if {@code off} or {@code len} are negative, or if {@code off + len} is greater than {@code buf.length}\n      * @throws IOException\n      *             if an I/O error occurs\n      */\n     @Override\n     public int read(final byte[] buf, int off, int len) throws IOException {\n+        IOUtils.checkFromIndexSize(buf, off, len);\n+        if (len == 0) {\n+            return 0;\n+        }\n         int firstCount = 0;\n         int b = 0;\n         while (len > 0 && b >= 0) {\ndiff --git a/src/main/java/org/apache/commons/io/input/BoundedReader.java b/src/main/java/org/apache/commons/io/input/BoundedReader.java\nindex 3cd0cee6259..5c1c255c0fe 100644\n--- a/src/main/java/org/apache/commons/io/input/BoundedReader.java\n+++ b/src/main/java/org/apache/commons/io/input/BoundedReader.java\n@@ -23,6 +23,8 @@\n import java.io.IOException;\n import java.io.Reader;\n \n+import org.apache.commons.io.IOUtils;\n+\n /**\n  * A reader that imposes a limit to the number of characters that can be read from an underlying reader, returning EOF\n  * when this limit is reached, regardless of state of underlying reader.\n@@ -116,11 +118,14 @@ public int read() throws IOException {\n      * @param off  The offset\n      * @param len  The number of chars to read\n      * @return the number of chars read\n+     * @throws NullPointerException if the buffer is {@code null}.\n+     * @throws IndexOutOfBoundsException if {@code off} or {@code len} are negative, or if {@code off + len} is greater than {@code cbuf.length}.\n      * @throws IOException If an I/O error occurs while calling the underlying reader's read method\n      * @see Reader#read(char[], int, int)\n      */\n     @Override\n     public int read(final char[] cbuf, final int off, final int len) throws IOException {\n+        IOUtils.checkFromIndexSize(cbuf, off, len);\n         int c;\n         for (int i = 0; i < len; i++) {\n             c = read();\ndiff --git a/src/main/java/org/apache/commons/io/input/BufferedFileChannelInputStream.java b/src/main/java/org/apache/commons/io/input/BufferedFileChannelInputStream.java\nindex bc5a9533038..8e81b34508a 100644\n--- a/src/main/java/org/apache/commons/io/input/BufferedFileChannelInputStream.java\n+++ b/src/main/java/org/apache/commons/io/input/BufferedFileChannelInputStream.java\n@@ -254,8 +254,9 @@ public synchronized int read() throws IOException {\n \n     @Override\n     public synchronized int read(final byte[] b, final int offset, int len) throws IOException {\n-        if (offset < 0 || len < 0 || offset + len < 0 || offset + len > b.length) {\n-            throw new IndexOutOfBoundsException();\n+        IOUtils.checkFromIndexSize(b, offset, len);\n+        if (len == 0) {\n+            return 0;\n         }\n         if (!refill()) {\n             return EOF;\ndiff --git a/src/main/java/org/apache/commons/io/input/CharSequenceInputStream.java b/src/main/java/org/apache/commons/io/input/CharSequenceInputStream.java\nindex 8666105491a..874dcf1cb39 100644\n--- a/src/main/java/org/apache/commons/io/input/CharSequenceInputStream.java\n+++ b/src/main/java/org/apache/commons/io/input/CharSequenceInputStream.java\n@@ -28,7 +28,6 @@\n import java.nio.charset.CharsetEncoder;\n import java.nio.charset.CoderResult;\n import java.nio.charset.CodingErrorAction;\n-import java.util.Objects;\n \n import org.apache.commons.io.Charsets;\n import org.apache.commons.io.IOUtils;\n@@ -319,10 +318,7 @@ public int read(final byte[] b) throws IOException {\n \n     @Override\n     public int read(final byte[] array, int off, int len) throws IOException {\n-        Objects.requireNonNull(array, \"array\");\n-        if (len < 0 || off + len > array.length) {\n-            throw new IndexOutOfBoundsException(\"Array Size=\" + array.length + \", offset=\" + off + \", length=\" + len);\n-        }\n+        IOUtils.checkFromIndexSize(array, off, len);\n         if (len == 0) {\n             return 0; // must return 0 for zero length read\n         }\ndiff --git a/src/main/java/org/apache/commons/io/input/CharSequenceReader.java b/src/main/java/org/apache/commons/io/input/CharSequenceReader.java\nindex 8fee366b2da..bb2be3692c9 100644\n--- a/src/main/java/org/apache/commons/io/input/CharSequenceReader.java\n+++ b/src/main/java/org/apache/commons/io/input/CharSequenceReader.java\n@@ -20,7 +20,8 @@\n \n import java.io.Reader;\n import java.io.Serializable;\n-import java.util.Objects;\n+\n+import org.apache.commons.io.IOUtils;\n \n /**\n  * {@link Reader} implementation that can read from String, StringBuffer,\n@@ -204,19 +205,19 @@ public int read() {\n      * @param array The array to store the characters in\n      * @param offset The starting position in the array to store\n      * @param length The maximum number of characters to read\n-     * @return The number of characters read or -1 if there are\n-     * no more\n+     * @return The number of characters read or -1 if there are no more\n+     * @throws NullPointerException if the array is {@code null}.\n+     * @throws IndexOutOfBoundsException if {@code offset} or {@code length} are negative, or if {@code offset + length} is greater than {@code array.length}.\n      */\n     @Override\n     public int read(final char[] array, final int offset, final int length) {\n+        IOUtils.checkFromIndexSize(array, offset, length);\n+        if (length == 0) {\n+            return 0;\n+        }\n         if (idx >= end()) {\n             return EOF;\n         }\n-        Objects.requireNonNull(array, \"array\");\n-        if (length < 0 || offset < 0 || offset + length > array.length) {\n-            throw new IndexOutOfBoundsException(\"Array Size=\" + array.length +\n-                    \", offset=\" + offset + \", length=\" + length);\n-        }\n \n         if (charSequence instanceof String) {\n             final int count = Math.min(length, end() - idx);\ndiff --git a/src/main/java/org/apache/commons/io/input/ClosedInputStream.java b/src/main/java/org/apache/commons/io/input/ClosedInputStream.java\nindex ceab0176090..11bc7be6e19 100644\n--- a/src/main/java/org/apache/commons/io/input/ClosedInputStream.java\n+++ b/src/main/java/org/apache/commons/io/input/ClosedInputStream.java\n@@ -79,13 +79,19 @@ public int read() {\n     /**\n      * Returns {@code -1} to indicate that the stream is closed.\n      *\n-     * @param b ignored.\n-     * @param off ignored.\n-     * @param len ignored.\n-     * @return always -1.\n+     * @param b The buffer to read bytes into.\n+     * @param off The start offset.\n+     * @param len The number of bytes to read.\n+     * @return If len is zero, then {@code 0}; otherwise {@code -1}.\n+     * @throws NullPointerException if the byte array is {@code null}.\n+     * @throws IndexOutOfBoundsException if {@code off} or {@code len} are negative, or if {@code off + len} is greater than {@code b.length}.\n      */\n     @Override\n     public int read(final byte[] b, final int off, final int len) throws IOException {\n+        IOUtils.checkFromIndexSize(b, off, len);\n+        if (len == 0) {\n+            return 0;\n+        }\n         return EOF;\n     }\n \ndiff --git a/src/main/java/org/apache/commons/io/input/ClosedReader.java b/src/main/java/org/apache/commons/io/input/ClosedReader.java\nindex 93c99e3c550..b50721c120d 100644\n--- a/src/main/java/org/apache/commons/io/input/ClosedReader.java\n+++ b/src/main/java/org/apache/commons/io/input/ClosedReader.java\n@@ -62,15 +62,26 @@ public void close() throws IOException {\n     }\n \n     /**\n-     * Returns -1 to indicate that the stream is closed.\n+     * A no-op read method that always indicates end-of-stream.\n      *\n-     * @param cbuf ignored\n-     * @param off ignored\n-     * @param len ignored\n-     * @return always -1\n+     * <p>Behavior:</p>\n+     * <ul>\n+     *   <li>If {@code len == 0}, returns {@code 0} immediately (no characters are read).</li>\n+     *   <li>Otherwise, always returns {@value IOUtils#EOF} to signal that the stream is closed or at end-of-stream.</li>\n+     * </ul>\n+     *\n+     * @param cbuf The destination buffer.\n+     * @param off  The offset at which to start storing characters.\n+     * @param len  The maximum number of characters to read.\n+     * @return {@code 0} if {@code len == 0}; otherwise always {@value IOUtils#EOF}.\n+     * @throws IndexOutOfBoundsException If {@code off < 0}, {@code len < 0}, or {@code off + len > cbuf.length}.\n      */\n     @Override\n     public int read(final char[] cbuf, final int off, final int len) {\n+        IOUtils.checkFromIndexSize(cbuf, off, len);\n+        if (len == 0) {\n+            return 0;\n+        }\n         return EOF;\n     }\n \ndiff --git a/src/main/java/org/apache/commons/io/input/MemoryMappedFileInputStream.java b/src/main/java/org/apache/commons/io/input/MemoryMappedFileInputStream.java\nindex 8fdd7aec8b9..22fae70ca75 100644\n--- a/src/main/java/org/apache/commons/io/input/MemoryMappedFileInputStream.java\n+++ b/src/main/java/org/apache/commons/io/input/MemoryMappedFileInputStream.java\n@@ -27,6 +27,7 @@\n import java.nio.file.Path;\n import java.nio.file.StandardOpenOption;\n \n+import org.apache.commons.io.IOUtils;\n import org.apache.commons.io.build.AbstractStreamBuilder;\n \n /**\n@@ -216,6 +217,10 @@ public int read() throws IOException {\n \n     @Override\n     public int read(final byte[] b, final int off, final int len) throws IOException {\n+        IOUtils.checkFromIndexSize(b, off, len);\n+        if (len == 0) {\n+            return 0;\n+        }\n         checkOpen();\n         if (!buffer.hasRemaining()) {\n             nextBuffer();\ndiff --git a/src/main/java/org/apache/commons/io/input/NullInputStream.java b/src/main/java/org/apache/commons/io/input/NullInputStream.java\nindex 5f3497863b0..5fa9b817b5c 100644\n--- a/src/main/java/org/apache/commons/io/input/NullInputStream.java\n+++ b/src/main/java/org/apache/commons/io/input/NullInputStream.java\n@@ -22,6 +22,8 @@\n import java.io.IOException;\n import java.io.InputStream;\n \n+import org.apache.commons.io.IOUtils;\n+\n /**\n  * A lightweight {@link InputStream} that emulates a stream of a specified size.\n  * <p>\n@@ -241,9 +243,9 @@ protected int processByte() {\n      * This implementation leaves the byte array unchanged.\n      * </p>\n      *\n-     * @param bytes  The byte array\n-     * @param offset The offset to start at.\n-     * @param length The number of bytes.\n+     * @param bytes  The byte array, never {@code null}.\n+     * @param offset The offset to start at, always non-negative.\n+     * @param length The number of bytes to process, always non-negative and at most {@code bytes.length - offset}.\n      */\n     protected void processBytes(final byte[] bytes, final int offset, final int length) {\n         // do nothing - overridable by subclass\n@@ -272,6 +274,7 @@ public int read() throws IOException {\n      *\n      * @param bytes The byte array to read into\n      * @return The number of bytes read or {@code -1} if the end of file has been reached and {@code throwEofException} is set to {@code false}.\n+     * @throws NullPointerException if the byte array is {@code null}.\n      * @throws EOFException if the end of file is reached and {@code throwEofException} is set to {@code true}.\n      * @throws IOException  if trying to read past the end of file.\n      */\n@@ -287,12 +290,15 @@ public int read(final byte[] bytes) throws IOException {\n      * @param offset The offset to start reading bytes into.\n      * @param length The number of bytes to read.\n      * @return The number of bytes read or {@code -1} if the end of file has been reached and {@code throwEofException} is set to {@code false}.\n+     * @throws NullPointerException if the byte array is {@code null}.\n+     * @throws IndexOutOfBoundsException if {@code offset} or {@code length} are negative, or if {@code offset + length} is greater than {@code bytes.length}.\n      * @throws EOFException if the end of file is reached and {@code throwEofException} is set to {@code true}.\n      * @throws IOException  if trying to read past the end of file.\n      */\n     @Override\n     public int read(final byte[] bytes, final int offset, final int length) throws IOException {\n-        if (bytes.length == 0 || length == 0) {\n+        IOUtils.checkFromIndexSize(bytes, offset, length);\n+        if (length == 0) {\n             return 0;\n         }\n         checkOpen();\ndiff --git a/src/main/java/org/apache/commons/io/input/NullReader.java b/src/main/java/org/apache/commons/io/input/NullReader.java\nindex c5ae530a170..28f3d37eb21 100644\n--- a/src/main/java/org/apache/commons/io/input/NullReader.java\n+++ b/src/main/java/org/apache/commons/io/input/NullReader.java\n@@ -22,6 +22,8 @@\n import java.io.IOException;\n import java.io.Reader;\n \n+import org.apache.commons.io.IOUtils;\n+\n /**\n  * A functional, lightweight {@link Reader} that emulates\n  * a reader of a specified size.\n@@ -270,12 +272,18 @@ public int read(final char[] chars) throws IOException {\n      * @return The number of characters read or {@code -1}\n      * if the end of file has been reached and\n      * {@code throwEofException} is set to {@code false}.\n+     * @throws NullPointerException if the array is {@code null}.\n+     * @throws IndexOutOfBoundsException if {@code offset} or {@code length} are negative, or if {@code offset + length} is greater than {@code chars.length}.\n      * @throws EOFException if the end of file is reached and\n      * {@code throwEofException} is set to {@code true}.\n      * @throws IOException if trying to read past the end of file.\n      */\n     @Override\n     public int read(final char[] chars, final int offset, final int length) throws IOException {\n+        IOUtils.checkFromIndexSize(chars, offset, length);\n+        if (length == 0) {\n+            return 0;\n+        }\n         if (eof) {\n             throw new IOException(\"Read after end of file\");\n         }\ndiff --git a/src/main/java/org/apache/commons/io/input/QueueInputStream.java b/src/main/java/org/apache/commons/io/input/QueueInputStream.java\nindex 1515eb94036..5f701945cb3 100644\n--- a/src/main/java/org/apache/commons/io/input/QueueInputStream.java\n+++ b/src/main/java/org/apache/commons/io/input/QueueInputStream.java\n@@ -30,6 +30,7 @@\n import java.util.concurrent.LinkedBlockingQueue;\n import java.util.concurrent.TimeUnit;\n \n+import org.apache.commons.io.IOUtils;\n import org.apache.commons.io.build.AbstractStreamBuilder;\n import org.apache.commons.io.output.QueueOutputStream;\n \n@@ -244,13 +245,7 @@ public int read() {\n      */\n     @Override\n     public int read(final byte[] b, final int offset, final int length) {\n-        if (b == null) {\n-            throw new NullPointerException();\n-        }\n-        if (offset < 0 || length < 0 || length > b.length - offset) {\n-            throw new IndexOutOfBoundsException(\n-                    String.format(\"Range [%d, %<d + %d) out of bounds for length %d\", offset, length, b.length));\n-        }\n+        IOUtils.checkFromIndexSize(b, offset, length);\n         if (length == 0) {\n             return 0;\n         }\ndiff --git a/src/main/java/org/apache/commons/io/input/ReadAheadInputStream.java b/src/main/java/org/apache/commons/io/input/ReadAheadInputStream.java\nindex 08e0182373e..bcee009a431 100644\n--- a/src/main/java/org/apache/commons/io/input/ReadAheadInputStream.java\n+++ b/src/main/java/org/apache/commons/io/input/ReadAheadInputStream.java\n@@ -30,6 +30,7 @@\n import java.util.concurrent.locks.Condition;\n import java.util.concurrent.locks.ReentrantLock;\n \n+import org.apache.commons.io.IOUtils;\n import org.apache.commons.io.build.AbstractStreamBuilder;\n \n /**\n@@ -341,9 +342,7 @@ public int read() throws IOException {\n \n     @Override\n     public int read(final byte[] b, final int offset, int len) throws IOException {\n-        if (offset < 0 || len < 0 || len > b.length - offset) {\n-            throw new IndexOutOfBoundsException();\n-        }\n+        IOUtils.checkFromIndexSize(b, offset, len);\n         if (len == 0) {\n             return 0;\n         }\ndiff --git a/src/main/java/org/apache/commons/io/input/ReaderInputStream.java b/src/main/java/org/apache/commons/io/input/ReaderInputStream.java\nindex bcd03abd565..4d22d28f891 100644\n--- a/src/main/java/org/apache/commons/io/input/ReaderInputStream.java\n+++ b/src/main/java/org/apache/commons/io/input/ReaderInputStream.java\n@@ -30,7 +30,6 @@\n import java.nio.charset.CharsetEncoder;\n import java.nio.charset.CoderResult;\n import java.nio.charset.CodingErrorAction;\n-import java.util.Objects;\n \n import org.apache.commons.io.Charsets;\n import org.apache.commons.io.IOUtils;\n@@ -436,8 +435,9 @@ public int read() throws IOException {\n     /**\n      * Reads the specified number of bytes into an array.\n      *\n-     * @param b the byte array to read into\n+     * @param b the byte array to read into, must not be {@code null}\n      * @return the number of bytes read or {@code -1} if the end of the stream has been reached\n+     * @throws NullPointerException if the byte array is {@code null}.\n      * @throws IOException if an I/O error occurs.\n      */\n     @Override\n@@ -452,18 +452,17 @@ public int read(final byte[] b) throws IOException {\n      * @param off   the offset to start reading bytes into\n      * @param len   the number of bytes to read\n      * @return the number of bytes read or {@code -1} if the end of the stream has been reached\n+     * @throws NullPointerException      if the byte array is {@code null}.\n+     * @throws IndexOutOfBoundsException if {@code off} or {@code len} are negative, or if {@code off + len} is greater than {@code array.length}.\n      * @throws IOException if an I/O error occurs.\n      */\n     @Override\n     public int read(final byte[] array, int off, int len) throws IOException {\n-        Objects.requireNonNull(array, \"array\");\n-        if (len < 0 || off < 0 || off + len > array.length) {\n-            throw new IndexOutOfBoundsException(\"Array size=\" + array.length + \", offset=\" + off + \", length=\" + len);\n-        }\n-        int read = 0;\n+        IOUtils.checkFromIndexSize(array, off, len);\n         if (len == 0) {\n             return 0; // Always return 0 if len == 0\n         }\n+        int read = 0;\n         while (len > 0) {\n             if (encoderOut.hasRemaining()) { // Data from the last read not fully copied\n                 final int c = Math.min(encoderOut.remaining(), len);\ndiff --git a/src/main/java/org/apache/commons/io/input/SequenceReader.java b/src/main/java/org/apache/commons/io/input/SequenceReader.java\nindex 6632917030b..daeb71faa92 100644\n--- a/src/main/java/org/apache/commons/io/input/SequenceReader.java\n+++ b/src/main/java/org/apache/commons/io/input/SequenceReader.java\n@@ -25,6 +25,7 @@\n import java.util.Iterator;\n import java.util.Objects;\n \n+import org.apache.commons.io.IOUtils;\n import org.apache.commons.io.function.Uncheck;\n \n /**\n@@ -107,16 +108,11 @@ public int read() throws IOException {\n         return c;\n     }\n \n-    /*\n-     * (non-Javadoc)\n-     *\n-     * @see Reader#read()\n-     */\n     @Override\n     public int read(final char[] cbuf, int off, int len) throws IOException {\n-        Objects.requireNonNull(cbuf, \"cbuf\");\n-        if (len < 0 || off < 0 || off + len > cbuf.length) {\n-            throw new IndexOutOfBoundsException(\"Array Size=\" + cbuf.length + \", offset=\" + off + \", length=\" + len);\n+        IOUtils.checkFromIndexSize(cbuf, off, len);\n+        if (len == 0) {\n+            return 0;\n         }\n         int count = 0;\n         while (reader != null) {\ndiff --git a/src/main/java/org/apache/commons/io/input/UnsynchronizedBufferedInputStream.java b/src/main/java/org/apache/commons/io/input/UnsynchronizedBufferedInputStream.java\nindex 8106a065631..8d60f6cedb8 100644\n--- a/src/main/java/org/apache/commons/io/input/UnsynchronizedBufferedInputStream.java\n+++ b/src/main/java/org/apache/commons/io/input/UnsynchronizedBufferedInputStream.java\n@@ -306,19 +306,16 @@ public int read() throws IOException {\n      */\n     @Override\n     public int read(final byte[] dest, int offset, final int length) throws IOException {\n+        IOUtils.checkFromIndexSize(dest, offset, length);\n+        if (length == 0) {\n+            return 0;\n+        }\n         // Use local ref since buf may be invalidated by an unsynchronized\n         // close()\n         byte[] localBuf = buffer;\n         if (localBuf == null) {\n             throw new IOException(\"Stream is closed\");\n         }\n-        // avoid int overflow\n-        if (offset > dest.length - length || offset < 0 || length < 0) {\n-            throw new IndexOutOfBoundsException();\n-        }\n-        if (length == 0) {\n-            return 0;\n-        }\n         final InputStream localIn = inputStream;\n         if (localIn == null) {\n             throw new IOException(\"Stream is closed\");\ndiff --git a/src/main/java/org/apache/commons/io/input/UnsynchronizedBufferedReader.java b/src/main/java/org/apache/commons/io/input/UnsynchronizedBufferedReader.java\nindex 51b48c07af3..bde55873f24 100644\n--- a/src/main/java/org/apache/commons/io/input/UnsynchronizedBufferedReader.java\n+++ b/src/main/java/org/apache/commons/io/input/UnsynchronizedBufferedReader.java\n@@ -271,10 +271,17 @@ public int read() throws IOException {\n      */\n     @Override\n     public int read(final char[] buffer, int offset, final int length) throws IOException {\n+        /*\n+         * First throw on a closed reader, then check the parameters.\n+         *\n+         * This behavior is not specified in the Javadoc, but is followed by most readers in java.io.\n+         */\n         checkOpen();\n-        if (offset < 0 || offset > buffer.length - length || length < 0) {\n-            throw new IndexOutOfBoundsException();\n+        IOUtils.checkFromIndexSize(buffer, offset, length);\n+        if (length == 0) {\n+            return 0;\n         }\n+\n         int outstanding = length;\n         while (outstanding > 0) {\n \ndiff --git a/src/main/java/org/apache/commons/io/input/UnsynchronizedByteArrayInputStream.java b/src/main/java/org/apache/commons/io/input/UnsynchronizedByteArrayInputStream.java\nindex cb2f5d3ddc5..a56dec7206c 100644\n--- a/src/main/java/org/apache/commons/io/input/UnsynchronizedByteArrayInputStream.java\n+++ b/src/main/java/org/apache/commons/io/input/UnsynchronizedByteArrayInputStream.java\n@@ -21,6 +21,7 @@\n import java.io.InputStream;\n import java.util.Objects;\n \n+import org.apache.commons.io.IOUtils;\n import org.apache.commons.io.build.AbstractOrigin;\n import org.apache.commons.io.build.AbstractStreamBuilder;\n \n@@ -288,9 +289,9 @@ public int read(final byte[] dest) {\n \n     @Override\n     public int read(final byte[] dest, final int off, final int len) {\n-        Objects.requireNonNull(dest, \"dest\");\n-        if (off < 0 || len < 0 || off + len > dest.length) {\n-            throw new IndexOutOfBoundsException();\n+        IOUtils.checkFromIndexSize(dest, off, len);\n+        if (len == 0) {\n+            return 0;\n         }\n \n         if (offset >= eod) {\ndiff --git a/src/main/java/org/apache/commons/io/input/buffer/CircularBufferInputStream.java b/src/main/java/org/apache/commons/io/input/buffer/CircularBufferInputStream.java\nindex 8be305ddd04..b92163478d0 100644\n--- a/src/main/java/org/apache/commons/io/input/buffer/CircularBufferInputStream.java\n+++ b/src/main/java/org/apache/commons/io/input/buffer/CircularBufferInputStream.java\n@@ -125,12 +125,9 @@ public int read() throws IOException {\n \n     @Override\n     public int read(final byte[] targetBuffer, final int offset, final int length) throws IOException {\n-        Objects.requireNonNull(targetBuffer, \"targetBuffer\");\n-        if (offset < 0) {\n-            throw new IllegalArgumentException(\"Offset must not be negative\");\n-        }\n-        if (length < 0) {\n-            throw new IllegalArgumentException(\"Length must not be negative\");\n+        IOUtils.checkFromIndexSize(targetBuffer, offset, length);\n+        if (length == 0) {\n+            return 0;\n         }\n         if (!haveBytes(length)) {\n             return EOF;\ndiff --git a/src/main/java/org/apache/commons/io/output/AppendableWriter.java b/src/main/java/org/apache/commons/io/output/AppendableWriter.java\nindex 2130e448dea..b1ace0b908c 100644\n--- a/src/main/java/org/apache/commons/io/output/AppendableWriter.java\n+++ b/src/main/java/org/apache/commons/io/output/AppendableWriter.java\n@@ -21,6 +21,8 @@\n import java.io.Writer;\n import java.util.Objects;\n \n+import org.apache.commons.io.IOUtils;\n+\n /**\n  * Writer implementation that writes the data to an {@link Appendable} Object.\n  * <p>\n@@ -77,6 +79,8 @@ public Writer append(final CharSequence csq) throws IOException {\n      * @param start the index of the first character in the subsequence\n      * @param end   the index of the character following the last character in the subsequence\n      * @return this writer\n+     * @throws IndexOutOfBoundsException If {@code start} or {@code end} are negative, {@code start} is greater than\n+     *                                   {@code end}, or {@code end} is greater than {@code csq.length()}.\n      * @throws IOException If an I/O error occurs.\n      */\n     @Override\n@@ -120,14 +124,13 @@ public T getAppendable() {\n      * @param cbuf an array with the characters to write.\n      * @param off  offset from which to start writing characters.\n      * @param len  number of characters to write.\n+     * @throws NullPointerException if the array is {@code null}.\n+     * @throws IndexOutOfBoundsException if {@code off} or {@code len} are negative, or if {@code off + len} is greater than {@code cbuf.length}.\n      * @throws IOException If an I/O error occurs.\n      */\n     @Override\n     public void write(final char[] cbuf, final int off, final int len) throws IOException {\n-        Objects.requireNonNull(cbuf, \"cbuf\");\n-        if (len < 0 || off + len > cbuf.length) {\n-            throw new IndexOutOfBoundsException(\"Array Size=\" + cbuf.length + \", offset=\" + off + \", length=\" + len);\n-        }\n+        IOUtils.checkFromIndexSize(cbuf, off, len);\n         for (int i = 0; i < len; i++) {\n             appendable.append(cbuf[off + i]);\n         }\n@@ -150,6 +153,8 @@ public void write(final int c) throws IOException {\n      * @param str a string.\n      * @param off offset from which to start writing characters.\n      * @param len number of characters to write.\n+     * @throws NullPointerException if the string is {@code null}.\n+     * @throws IndexOutOfBoundsException if {@code off} or {@code len} are negative, or if {@code off + len} is greater than {@code str.length()}.\n      * @throws IOException If an I/O error occurs.\n      */\n     @Override\ndiff --git a/src/main/java/org/apache/commons/io/output/ByteArrayOutputStream.java b/src/main/java/org/apache/commons/io/output/ByteArrayOutputStream.java\nindex b2a9afbfc58..48fb793669b 100644\n--- a/src/main/java/org/apache/commons/io/output/ByteArrayOutputStream.java\n+++ b/src/main/java/org/apache/commons/io/output/ByteArrayOutputStream.java\n@@ -21,6 +21,8 @@\n import java.io.InputStream;\n import java.io.OutputStream;\n \n+import org.apache.commons.io.IOUtils;\n+\n /**\n  * Implements a ThreadSafe version of {@link AbstractByteArrayOutputStream} using instance synchronization.\n  */\n@@ -130,13 +132,7 @@ public synchronized InputStream toInputStream() {\n \n     @Override\n     public void write(final byte[] b, final int off, final int len) {\n-        if (off < 0\n-                || off > b.length\n-                || len < 0\n-                || off + len > b.length\n-                || off + len < 0) {\n-            throw new IndexOutOfBoundsException();\n-        }\n+        IOUtils.checkFromIndexSize(b, off, len);\n         if (len == 0) {\n             return;\n         }\ndiff --git a/src/main/java/org/apache/commons/io/output/ChunkedOutputStream.java b/src/main/java/org/apache/commons/io/output/ChunkedOutputStream.java\nindex 4612a7de2f7..2588264e172 100644\n--- a/src/main/java/org/apache/commons/io/output/ChunkedOutputStream.java\n+++ b/src/main/java/org/apache/commons/io/output/ChunkedOutputStream.java\n@@ -168,10 +168,14 @@ int getChunkSize() {\n      * @param data      the data to write.\n      * @param srcOffset the offset.\n      * @param length    the length of data to write.\n+     * @throws NullPointerException if the data is {@code null}.\n+     * @throws IndexOutOfBoundsException if {@code srcOffset} or {@code length} are negative,\n+     *                                   or if {@code srcOffset + length} is greater than {@code data.length}.\n      * @throws IOException if an I/O error occurs.\n      */\n     @Override\n     public void write(final byte[] data, final int srcOffset, final int length) throws IOException {\n+        IOUtils.checkFromIndexSize(data, srcOffset, length);\n         int bytes = length;\n         int dstOffset = srcOffset;\n         while (bytes > 0) {\ndiff --git a/src/main/java/org/apache/commons/io/output/ChunkedWriter.java b/src/main/java/org/apache/commons/io/output/ChunkedWriter.java\nindex 6a6492882b1..ed22625b667 100644\n--- a/src/main/java/org/apache/commons/io/output/ChunkedWriter.java\n+++ b/src/main/java/org/apache/commons/io/output/ChunkedWriter.java\n@@ -70,10 +70,14 @@ public ChunkedWriter(final Writer writer, final int chunkSize) {\n      * @param data      The data.\n      * @param srcOffset the offset.\n      * @param length    the number of bytes to write.\n+     * @throws NullPointerException if the data is {@code null}.\n+     * @throws IndexOutOfBoundsException if {@code srcOffset} or {@code length} are negative,\n+     *                                   or if {@code srcOffset + length} is greater than {@code data.length}.\n      * @throws IOException If an I/O error occurs.\n      */\n     @Override\n     public void write(final char[] data, final int srcOffset, final int length) throws IOException {\n+        IOUtils.checkFromIndexSize(data, srcOffset, length);\n         int bytes = length;\n         int dstOffset = srcOffset;\n         while (bytes > 0) {\ndiff --git a/src/main/java/org/apache/commons/io/output/ClosedOutputStream.java b/src/main/java/org/apache/commons/io/output/ClosedOutputStream.java\nindex 18783481d44..c7216ce6f90 100644\n--- a/src/main/java/org/apache/commons/io/output/ClosedOutputStream.java\n+++ b/src/main/java/org/apache/commons/io/output/ClosedOutputStream.java\n@@ -20,6 +20,8 @@\n import java.io.IOException;\n import java.io.OutputStream;\n \n+import org.apache.commons.io.IOUtils;\n+\n /**\n  * Throws an IOException on all attempts to write to the stream.\n  * <p>\n@@ -66,13 +68,16 @@ public void flush() throws IOException {\n     /**\n      * Throws an {@link IOException} to indicate that the stream is closed.\n      *\n-     * @param b   ignored.\n-     * @param off ignored.\n-     * @param len ignored.\n+     * @param b   Byte array, never {@code null}.\n+     * @param off The start offset in the byte array.\n+     * @param len The number of bytes to write.\n+     * @throws NullPointerException if the byte array is {@code null}.\n+     * @throws IndexOutOfBoundsException if {@code off} or {@code len} are negative, or if {@code off + len} is greater than {@code b.length}.\n      * @throws IOException always thrown.\n      */\n     @Override\n     public void write(final byte b[], final int off, final int len) throws IOException {\n+        IOUtils.checkFromIndexSize(b, off, len);\n         throw new IOException(\"write(byte[], int, int) failed: stream is closed\");\n     }\n \ndiff --git a/src/main/java/org/apache/commons/io/output/ClosedWriter.java b/src/main/java/org/apache/commons/io/output/ClosedWriter.java\nindex 58c3993acd3..c4e1d93b93c 100644\n--- a/src/main/java/org/apache/commons/io/output/ClosedWriter.java\n+++ b/src/main/java/org/apache/commons/io/output/ClosedWriter.java\n@@ -19,6 +19,7 @@\n \n import java.io.IOException;\n import java.io.Writer;\n+import java.util.Arrays;\n \n /**\n  * Throws an IOException on all attempts to write with {@link #close()} implemented as a noop.\n@@ -77,6 +78,6 @@ public void flush() throws IOException {\n      */\n     @Override\n     public void write(final char[] cbuf, final int off, final int len) throws IOException {\n-        throw new IOException(\"write(\" + new String(cbuf) + \", \" + off + \", \" + len + \") failed: stream is closed\");\n+        throw new IOException(String.format(\"write(%s, %d, %d) failed: stream is closed\", Arrays.toString(cbuf), off, len));\n     }\n }\ndiff --git a/src/main/java/org/apache/commons/io/output/NullAppendable.java b/src/main/java/org/apache/commons/io/output/NullAppendable.java\nindex 520daa3a64b..c5ea2cfcbeb 100644\n--- a/src/main/java/org/apache/commons/io/output/NullAppendable.java\n+++ b/src/main/java/org/apache/commons/io/output/NullAppendable.java\n@@ -19,6 +19,8 @@\n \n import java.io.IOException;\n \n+import org.apache.commons.io.IOUtils;\n+\n /**\n  * Appends all data to the famous <strong>/dev/null</strong>.\n  * <p>\n@@ -49,8 +51,24 @@ public Appendable append(final CharSequence csq) throws IOException {\n         return this;\n     }\n \n+    /**\n+     * Does nothing except argument validation, like writing to {@code /dev/null}.\n+     *\n+     * @param csq   The character sequence from which a subsequence will be\n+     *              appended.\n+     *              If {@code csq} is {@code null}, it is treated as if it were\n+     *              {@code \"null\"}.\n+     * @param start The index of the first character in the subsequence.\n+     * @param end   The index of the character following the last character in the\n+     *              subsequence.\n+     * @return {@code this} instance.\n+     * @throws IndexOutOfBoundsException If {@code start} or {@code end} are negative, {@code end} is\n+     *                                   greater than {@code csq.length()}, or {@code start} is greater\n+     *                                   than {@code end}.\n+     */\n     @Override\n     public Appendable append(final CharSequence csq, final int start, final int end) throws IOException {\n+        IOUtils.checkFromToIndex(csq, start, end);\n         return this;\n     }\n \ndiff --git a/src/main/java/org/apache/commons/io/output/NullOutputStream.java b/src/main/java/org/apache/commons/io/output/NullOutputStream.java\nindex 5275aea9c75..0334a4ea4b8 100644\n--- a/src/main/java/org/apache/commons/io/output/NullOutputStream.java\n+++ b/src/main/java/org/apache/commons/io/output/NullOutputStream.java\n@@ -19,6 +19,8 @@\n import java.io.IOException;\n import java.io.OutputStream;\n \n+import org.apache.commons.io.IOUtils;\n+\n /**\n  * Never writes data. Calls never go beyond this class.\n  * <p>\n@@ -67,15 +69,20 @@ public void write(final byte[] b) throws IOException {\n     }\n \n     /**\n-     * Does nothing.\n+     * No-op operation.\n      *\n-     * @param b This method ignores this parameter.\n-     * @param off This method ignores this parameter.\n-     * @param len This method ignores this parameter.\n+     * <p>Validates the arguments but does not write the data.</p>\n+     *\n+     * @param b   The byte array to write from, not {@code null}.\n+     * @param off The offset to start at.\n+     * @param len The number of bytes to write.\n+     * @throws NullPointerException      If {@code b} is {@code null}.\n+     * @throws IndexOutOfBoundsException If {@code off} or {@code len} are negative, {@code off + len} is greater than\n+     *                                   {@code b.length}.\n      */\n     @Override\n     public void write(final byte[] b, final int off, final int len) {\n-        // noop\n+        IOUtils.checkFromIndexSize(b, off, len);\n     }\n \n     /**\ndiff --git a/src/main/java/org/apache/commons/io/output/NullWriter.java b/src/main/java/org/apache/commons/io/output/NullWriter.java\nindex ab7f4ddd6f8..635ffb044a6 100644\n--- a/src/main/java/org/apache/commons/io/output/NullWriter.java\n+++ b/src/main/java/org/apache/commons/io/output/NullWriter.java\n@@ -18,6 +18,8 @@\n \n import java.io.Writer;\n \n+import org.apache.commons.io.IOUtils;\n+\n /**\n  * Never writes data. Calls never go beyond this class.\n  * <p>\n@@ -77,16 +79,24 @@ public Writer append(final CharSequence csq) {\n     }\n \n     /**\n-     * Does nothing, like writing to {@code /dev/null}.\n+     * Does nothing except argument validation, like writing to {@code /dev/null}.\n      *\n-     * @param csq The character sequence to write.\n-     * @param start The index of the first character to write.\n-     * @param end  The index of the first character to write (exclusive).\n-     * @return this writer.\n+     * @param csq   The character sequence from which a subsequence will be\n+     *              appended.\n+     *              If {@code csq} is {@code null}, it is treated as if it were\n+     *              {@code \"null\"}.\n+     * @param start The index of the first character in the subsequence.\n+     * @param end   The index of the character following the last character in the\n+     *              subsequence.\n+     * @return {@code this} instance.\n+     * @throws IndexOutOfBoundsException If {@code start} or {@code end} are negative, {@code end} is\n+     *                                   greater than {@code csq.length()}, or {@code start} is greater\n+     *                                   than {@code end}.\n      * @since 2.0\n      */\n     @Override\n     public Writer append(final CharSequence csq, final int start, final int end) {\n+        IOUtils.checkFromToIndex(csq, start, end);\n         //to /dev/null\n         return this;\n     }\n@@ -104,24 +114,29 @@ public void flush() {\n     }\n \n     /**\n-     * Does nothing, like writing to {@code /dev/null}.\n+     * Does nothing except argument validation, like writing to {@code /dev/null}.\n      *\n-     * @param chr The characters to write\n+     * @param chr The characters to write, not {@code null}.\n+     * @throws NullPointerException if {@code chr} is {@code null}.\n      */\n     @Override\n     public void write(final char[] chr) {\n+        write(chr, 0, chr.length);\n         //to /dev/null\n     }\n \n     /**\n-     * Does nothing, like writing to {@code /dev/null}.\n+     * Does nothing except argument validation, like writing to {@code /dev/null}.\n      *\n-     * @param chr The characters to write.\n-     * @param st The start offset.\n-     * @param end The number of characters to write.\n+     * @param cbuf The characters to write, not {@code null}.\n+     * @param off  The start offset.\n+     * @param len  The number of characters to write.\n+     * @throws NullPointerException      if {@code chr} is {@code null}.\n+     * @throws IndexOutOfBoundsException If ({@code off} or {@code len} are negative, or {@code off + len} is greater than {@code cbuf.length}.\n      */\n     @Override\n-    public void write(final char[] chr, final int st, final int end) {\n+    public void write(final char[] cbuf, final int off, final int len) {\n+        IOUtils.checkFromIndexSize(cbuf, off, len);\n         //to /dev/null\n     }\n \n@@ -136,24 +151,29 @@ public void write(final int b) {\n     }\n \n     /**\n-     * Does nothing, like writing to {@code /dev/null}.\n+     * Does nothing except argument validation, like writing to {@code /dev/null}.\n      *\n-     * @param str The string to write.\n+     * @param str The string to write, not {@code null}.\n+     * @throws NullPointerException if {@code str} is {@code null}.\n      */\n     @Override\n     public void write(final String str) {\n+        write(str, 0, str.length());\n         //to /dev/null\n     }\n \n     /**\n-     * Does nothing, like writing to {@code /dev/null}.\n+     * Does nothing except argument validation, like writing to {@code /dev/null}.\n      *\n-     * @param str The string to write.\n-     * @param st The start offset.\n-     * @param end The number of characters to write.\n+     * @param str The string to write, not {@code null}.\n+     * @param off The start offset.\n+     * @param len The number of characters to write.\n+     * @throws NullPointerException      If {@code str} is {@code null}.\n+     * @throws IndexOutOfBoundsException If ({@code off} or {@code len} are negative, or {@code off + len} is greater than {@code str.length()}.\n      */\n     @Override\n-    public void write(final String str, final int st, final int end) {\n+    public void write(final String str, final int off, final int len) {\n+        IOUtils.checkFromIndexSize(str, off, len);\n         //to /dev/null\n     }\n \ndiff --git a/src/main/java/org/apache/commons/io/output/StringBuilderWriter.java b/src/main/java/org/apache/commons/io/output/StringBuilderWriter.java\nindex 106525e88f9..bdb757cf684 100644\n--- a/src/main/java/org/apache/commons/io/output/StringBuilderWriter.java\n+++ b/src/main/java/org/apache/commons/io/output/StringBuilderWriter.java\n@@ -20,6 +20,8 @@\n import java.io.StringWriter;\n import java.io.Writer;\n \n+import org.apache.commons.io.IOUtils;\n+\n /**\n  * {@link Writer} implementation that outputs to a {@link StringBuilder}.\n  * <p>\n@@ -146,10 +148,12 @@ public String toString() {\n      * @param value The value to write.\n      * @param offset The index of the first character.\n      * @param length The number of characters to write.\n+     * @throws IndexOutOfBoundsException if {@code offset} or {@code length} are negative, or if {@code offset + length} is greater than {@code value.length}.\n      */\n     @Override\n     public void write(final char[] value, final int offset, final int length) {\n         if (value != null) {\n+            IOUtils.checkFromIndexSize(value, offset, length);\n             builder.append(value, offset, length);\n         }\n     }\ndiff --git a/src/main/java/org/apache/commons/io/output/ThresholdingOutputStream.java b/src/main/java/org/apache/commons/io/output/ThresholdingOutputStream.java\nindex e5892dbd885..742572b2ebc 100644\n--- a/src/main/java/org/apache/commons/io/output/ThresholdingOutputStream.java\n+++ b/src/main/java/org/apache/commons/io/output/ThresholdingOutputStream.java\n@@ -19,6 +19,7 @@\n import java.io.IOException;\n import java.io.OutputStream;\n \n+import org.apache.commons.io.IOUtils;\n import org.apache.commons.io.function.IOConsumer;\n import org.apache.commons.io.function.IOFunction;\n \n@@ -227,6 +228,7 @@ protected void thresholdReached() throws IOException {\n      * Writes {@code b.length} bytes from the specified byte array to this output stream.\n      *\n      * @param b The array of bytes to be written.\n+     * @throws NullPointerException if the byte array is {@code null}.\n      * @throws IOException if an error occurs.\n      */\n     @SuppressWarnings(\"resource\") // the underlying stream is managed by a subclass.\n@@ -244,11 +246,14 @@ public void write(final byte[] b) throws IOException {\n      * @param b The byte array from which the data will be written.\n      * @param off The start offset in the byte array.\n      * @param len The number of bytes to write.\n+     * @throws NullPointerException if the byte array is {@code null}.\n+     * @throws IndexOutOfBoundsException if {@code off} or {@code len} are negative, or if {@code off + len} is greater than {@code b.length}.\n      * @throws IOException if an error occurs.\n      */\n     @SuppressWarnings(\"resource\") // the underlying stream is managed by a subclass.\n     @Override\n     public void write(final byte[] b, final int off, final int len) throws IOException {\n+        IOUtils.checkFromIndexSize(b, off, len);\n         // TODO we could write the sub-array up the threshold, fire the event,\n         // and then write the rest so the event is always fired at the precise point.\n         checkThreshold(len);\ndiff --git a/src/main/java/org/apache/commons/io/output/UnsynchronizedByteArrayOutputStream.java b/src/main/java/org/apache/commons/io/output/UnsynchronizedByteArrayOutputStream.java\nindex f20ccefad74..a47a3b2aa2a 100644\n--- a/src/main/java/org/apache/commons/io/output/UnsynchronizedByteArrayOutputStream.java\n+++ b/src/main/java/org/apache/commons/io/output/UnsynchronizedByteArrayOutputStream.java\n@@ -21,6 +21,7 @@\n import java.io.InputStream;\n import java.io.OutputStream;\n \n+import org.apache.commons.io.IOUtils;\n import org.apache.commons.io.build.AbstractOrigin;\n import org.apache.commons.io.build.AbstractStreamBuilder;\n import org.apache.commons.io.function.Uncheck;\n@@ -214,9 +215,7 @@ public InputStream toInputStream() {\n \n     @Override\n     public void write(final byte[] b, final int off, final int len) {\n-        if (off < 0 || off > b.length || len < 0 || off + len > b.length || off + len < 0) {\n-            throw new IndexOutOfBoundsException(String.format(\"offset=%,d, length=%,d\", off, len));\n-        }\n+        IOUtils.checkFromIndexSize(b, off, len);\n         if (len == 0) {\n             return;\n         }\ndiff --git a/src/main/java/org/apache/commons/io/output/WriterOutputStream.java b/src/main/java/org/apache/commons/io/output/WriterOutputStream.java\nindex dcb6e226e72..d17318f79b6 100644\n--- a/src/main/java/org/apache/commons/io/output/WriterOutputStream.java\n+++ b/src/main/java/org/apache/commons/io/output/WriterOutputStream.java\n@@ -431,6 +431,7 @@ private void processInput(final boolean endOfInput) throws IOException {\n      * Writes bytes from the specified byte array to the stream.\n      *\n      * @param b the byte array containing the bytes to write.\n+     * @throws NullPointerException if the byte array is {@code null}.\n      * @throws IOException if an I/O error occurs.\n      */\n     @Override\n@@ -444,10 +445,13 @@ public void write(final byte[] b) throws IOException {\n      * @param b   the byte array containing the bytes to write.\n      * @param off the start offset in the byte array.\n      * @param len the number of bytes to write.\n+     * @throws NullPointerException      if the byte array is {@code null}.\n+     * @throws IndexOutOfBoundsException if {@code off} or {@code len} are negative, or if {@code off + len} is greater than {@code b.length}.\n      * @throws IOException if an I/O error occurs.\n      */\n     @Override\n     public void write(final byte[] b, int off, int len) throws IOException {\n+        IOUtils.checkFromIndexSize(b, off, len);\n         while (len > 0) {\n             final int c = Math.min(len, decoderIn.remaining());\n             decoderIn.put(b, off, c);\ndiff --git a/src/main/java/org/apache/commons/io/output/XmlStreamWriter.java b/src/main/java/org/apache/commons/io/output/XmlStreamWriter.java\nindex 40fdcc8f730..873df0238d8 100644\n--- a/src/main/java/org/apache/commons/io/output/XmlStreamWriter.java\n+++ b/src/main/java/org/apache/commons/io/output/XmlStreamWriter.java\n@@ -302,10 +302,14 @@ public String getEncoding() {\n      * @param cbuf the buffer to write the characters from.\n      * @param off The start offset.\n      * @param len The number of characters to write.\n+     * @throws NullPointerException if the buffer is {@code null}.\n+     * @throws IndexOutOfBoundsException if {@code off} or {@code len} are negative,\n+     *                                   or if {@code off + len} is greater than {@code cbuf.length}.\n      * @throws IOException if an error occurs detecting the encoding.\n      */\n     @Override\n     public void write(final char[] cbuf, final int off, final int len) throws IOException {\n+        IOUtils.checkFromIndexSize(cbuf, off, len);\n         if (prologWriter != null) {\n             detectEncoding(cbuf, off, len);\n         } else {\n",
  "test_patch" : "diff --git a/src/test/java/org/apache/commons/io/IOUtilsTest.java b/src/test/java/org/apache/commons/io/IOUtilsTest.java\nindex bae8f59e374..02574946bf8 100644\n--- a/src/test/java/org/apache/commons/io/IOUtilsTest.java\n+++ b/src/test/java/org/apache/commons/io/IOUtilsTest.java\n@@ -50,6 +50,7 @@\n import java.io.SequenceInputStream;\n import java.io.StringReader;\n import java.io.Writer;\n+import java.lang.reflect.InvocationTargetException;\n import java.net.ServerSocket;\n import java.net.Socket;\n import java.net.URI;\n@@ -65,6 +66,7 @@\n import java.util.Arrays;\n import java.util.Collections;\n import java.util.List;\n+import java.util.Objects;\n import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.function.Consumer;\n import java.util.function.Supplier;\n@@ -85,7 +87,9 @@\n import org.apache.commons.io.output.UnsynchronizedByteArrayOutputStream;\n import org.apache.commons.io.test.TestUtils;\n import org.apache.commons.io.test.ThrowOnCloseReader;\n+import org.apache.commons.lang3.JavaVersion;\n import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.SystemUtils;\n import org.apache.commons.lang3.exception.ExceptionUtils;\n import org.junit.jupiter.api.AfterAll;\n import org.junit.jupiter.api.BeforeAll;\n@@ -348,6 +352,104 @@ void testByteArrayWithNegativeSize() {\n         assertThrows(NegativeArraySizeException.class, () -> IOUtils.byteArray(-1));\n     }\n \n+    static Stream<Arguments> testCheckFromIndexSizeValidCases() {\n+        return Stream.of(\n+                // Valid cases\n+                Arguments.of(0, 0, 42),\n+                Arguments.of(0, 1, 42),\n+                Arguments.of(0, 42, 42),\n+                Arguments.of(41, 1, 42),\n+                Arguments.of(42, 0, 42)\n+        );\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    void testCheckFromIndexSizeValidCases(int off, int len, int arrayLength) {\n+        assertDoesNotThrow(() -> IOUtils.checkFromIndexSize(off, len, arrayLength));\n+    }\n+\n+    static Stream<Arguments> testCheckFromIndexSizeInvalidCases() {\n+        return Stream.of(\n+                Arguments.of(-1, 0, 42),\n+                Arguments.of(0, -1, 42),\n+                Arguments.of(0, 0, -1),\n+                // off + len > arrayLength\n+                Arguments.of(1, 42, 42),\n+                Arguments.of(Integer.MAX_VALUE, 1, Integer.MAX_VALUE)\n+        );\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    void testCheckFromIndexSizeInvalidCases(int off, int len, int arrayLength) {\n+        final IndexOutOfBoundsException ex = assertThrows(IndexOutOfBoundsException.class, () -> IOUtils.checkFromIndexSize(off, len, arrayLength));\n+        assertTrue(ex.getMessage().contains(String.valueOf(off)));\n+        assertTrue(ex.getMessage().contains(String.valueOf(len)));\n+        assertTrue(ex.getMessage().contains(String.valueOf(arrayLength)));\n+        // Optional requirement: compare the exception message for Java 8 and Java 9+\n+        if (SystemUtils.isJavaVersionAtLeast(JavaVersion.JAVA_9)) {\n+            final IndexOutOfBoundsException jreEx = assertThrows(IndexOutOfBoundsException.class, () -> {\n+                try {\n+                    Objects.class.getDeclaredMethod(\"checkFromIndexSize\", int.class, int.class, int.class).invoke(null, off, len, arrayLength);\n+                } catch (InvocationTargetException ite) {\n+                    throw ite.getTargetException();\n+                }\n+            });\n+            assertEquals(jreEx.getMessage(), ex.getMessage());\n+        }\n+    }\n+\n+    static Stream<Arguments> testCheckFromToIndexValidCases() {\n+        return Stream.of(\n+                // Valid cases\n+                Arguments.of(0, 0, 42),\n+                Arguments.of(0, 1, 42),\n+                Arguments.of(0, 42, 42),\n+                Arguments.of(41, 42, 42),\n+                Arguments.of(42, 42, 42)\n+        );\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    void testCheckFromToIndexValidCases(int from, int to, int arrayLength) {\n+        assertDoesNotThrow(() -> IOUtils.checkFromToIndex(from, to, arrayLength));\n+    }\n+\n+    static Stream<Arguments> testCheckFromToIndexInvalidCases() {\n+        return Stream.of(\n+                Arguments.of(-1, 0, 42),\n+                Arguments.of(0, -1, 42),\n+                Arguments.of(0, 0, -1),\n+                // from > to\n+                Arguments.of(1, 0, 42),\n+                // to > arrayLength\n+                Arguments.of(0, 43, 42),\n+                Arguments.of(1, 43, 42)\n+        );\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    void testCheckFromToIndexInvalidCases(int from, int to, int arrayLength) {\n+        final IndexOutOfBoundsException ex = assertThrows(IndexOutOfBoundsException.class, () -> IOUtils.checkFromToIndex(from, to, arrayLength));\n+        assertTrue(ex.getMessage().contains(String.valueOf(from)));\n+        assertTrue(ex.getMessage().contains(String.valueOf(to)));\n+        assertTrue(ex.getMessage().contains(String.valueOf(arrayLength)));\n+        // Optional requirement: compare the exception message for Java 8 and Java 9+\n+        if (SystemUtils.isJavaVersionAtLeast(JavaVersion.JAVA_9)) {\n+            final IndexOutOfBoundsException jreEx = assertThrows(IndexOutOfBoundsException.class, () -> {\n+                try {\n+                    Objects.class.getDeclaredMethod(\"checkFromToIndex\", int.class, int.class, int.class).invoke(null, from, to, arrayLength);\n+                } catch (InvocationTargetException ite) {\n+                    throw ite.getTargetException();\n+                }\n+            });\n+            assertEquals(jreEx.getMessage(), ex.getMessage());\n+        }\n+    }\n+\n     @Test\n     void testClose() {\n         assertDoesNotThrow(() -> IOUtils.close((Closeable) null));\ndiff --git a/src/test/java/org/apache/commons/io/input/BrokenReaderTest.java b/src/test/java/org/apache/commons/io/input/BrokenReaderTest.java\nindex aca91077e6b..a47687abf3d 100644\n--- a/src/test/java/org/apache/commons/io/input/BrokenReaderTest.java\n+++ b/src/test/java/org/apache/commons/io/input/BrokenReaderTest.java\n@@ -22,6 +22,7 @@\n \n import java.io.IOException;\n import java.io.Reader;\n+import java.nio.CharBuffer;\n \n import org.junit.jupiter.api.Test;\n import org.junit.jupiter.params.ParameterizedTest;\n@@ -45,7 +46,7 @@ void testClose(final Class<Exception> clazz) throws Exception {\n         final Throwable exception = clazz.newInstance();\n         @SuppressWarnings(\"resource\")\n         final BrokenReader brokenReader = createBrokenReader(exception);\n-        assertEquals(exception, assertThrows(clazz, () -> brokenReader.close()));\n+        assertEquals(exception, assertThrows(clazz, brokenReader::close));\n     }\n \n     @Test\n@@ -68,7 +69,7 @@ void testRead(final Class<Throwable> clazz) throws Exception {\n         final Throwable exception = clazz.newInstance();\n         @SuppressWarnings(\"resource\")\n         final BrokenReader brokenReader = createBrokenReader(exception);\n-        assertEquals(exception, assertThrows(clazz, () -> brokenReader.read()));\n+        assertEquals(exception, assertThrows(clazz, brokenReader::read));\n     }\n \n     @ParameterizedTest\n@@ -86,7 +87,24 @@ void testReadCharArrayIndexed(final Class<Throwable> clazz) throws Exception {\n         final Throwable exception = clazz.newInstance();\n         @SuppressWarnings(\"resource\")\n         final BrokenReader brokenReader = createBrokenReader(exception);\n-        assertEquals(exception, assertThrows(clazz, () -> brokenReader.read(new char[1], 0, 1)));\n+        final char[] cbuf = new char[1];\n+        assertEquals(exception, assertThrows(clazz, () -> brokenReader.read(cbuf, 0, 1)));\n+        // Also throws the exception before checking arguments\n+        assertEquals(exception, assertThrows(clazz, () -> brokenReader.read(cbuf, -1, 1)));\n+        assertEquals(exception, assertThrows(clazz, () -> brokenReader.read(cbuf, 0, -1)));\n+        assertEquals(exception, assertThrows(clazz, () -> brokenReader.read(cbuf, 1, 1)));\n+        assertEquals(exception, assertThrows(clazz, () -> brokenReader.read(null, 0, 0)));\n+\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"org.apache.commons.io.BrokenTestFactories#parameters\")\n+    void testReadCharBuffer(final Class<Throwable> clazz) throws Exception {\n+        final Throwable exception = clazz.newInstance();\n+        @SuppressWarnings(\"resource\")\n+        final BrokenReader brokenReader = createBrokenReader(exception);\n+        final CharBuffer charBuffer = CharBuffer.allocate(1);\n+        assertEquals(exception, assertThrows(clazz, () -> brokenReader.read(charBuffer)));\n     }\n \n     @ParameterizedTest\n@@ -95,7 +113,7 @@ void testReady(final Class<Throwable> clazz) throws Exception {\n         final Throwable exception = clazz.newInstance();\n         @SuppressWarnings(\"resource\")\n         final BrokenReader brokenReader = createBrokenReader(exception);\n-        assertEquals(exception, assertThrows(clazz, () -> brokenReader.ready()));\n+        assertEquals(exception, assertThrows(clazz, brokenReader::ready));\n     }\n \n     @ParameterizedTest\n@@ -104,7 +122,7 @@ void testReset(final Class<Throwable> clazz) throws Exception {\n         final Throwable exception = clazz.newInstance();\n         @SuppressWarnings(\"resource\")\n         final BrokenReader brokenReader = createBrokenReader(exception);\n-        assertEquals(exception, assertThrows(clazz, () -> brokenReader.reset()));\n+        assertEquals(exception, assertThrows(clazz, brokenReader::reset));\n     }\n \n     @ParameterizedTest\ndiff --git a/src/test/java/org/apache/commons/io/input/ClosedInputStreamTest.java b/src/test/java/org/apache/commons/io/input/ClosedInputStreamTest.java\nindex b19364d8a17..2586806b3a5 100644\n--- a/src/test/java/org/apache/commons/io/input/ClosedInputStreamTest.java\n+++ b/src/test/java/org/apache/commons/io/input/ClosedInputStreamTest.java\n@@ -22,6 +22,7 @@\n \n import java.io.InputStream;\n \n+import org.apache.commons.io.IOUtils;\n import org.junit.jupiter.api.Test;\n \n /**\n@@ -86,7 +87,7 @@ void testReadArray() throws Exception {\n         try (ClosedInputStream cis = new ClosedInputStream()) {\n             assertEquals(EOF, cis.read(new byte[4096]));\n             assertEquals(EOF, cis.read(new byte[1]));\n-            assertEquals(EOF, cis.read(new byte[0]));\n+            assertEquals(0, cis.read(IOUtils.EMPTY_BYTE_ARRAY));\n         }\n     }\n \n@@ -95,7 +96,7 @@ void testReadArrayIndex() throws Exception {\n         try (ClosedInputStream cis = new ClosedInputStream()) {\n             assertEquals(EOF, cis.read(new byte[4096], 0, 1));\n             assertEquals(EOF, cis.read(new byte[1], 0, 1));\n-            assertEquals(EOF, cis.read(new byte[0], 0, 0));\n+            assertEquals(0, cis.read(IOUtils.EMPTY_BYTE_ARRAY, 0, 0));\n         }\n     }\n \ndiff --git a/src/test/java/org/apache/commons/io/input/ClosedReaderTest.java b/src/test/java/org/apache/commons/io/input/ClosedReaderTest.java\nindex cb57f9e6f91..57b87ddfb09 100644\n--- a/src/test/java/org/apache/commons/io/input/ClosedReaderTest.java\n+++ b/src/test/java/org/apache/commons/io/input/ClosedReaderTest.java\n@@ -18,6 +18,7 @@\n \n import static org.apache.commons.io.IOUtils.EOF;\n import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n \n import java.io.IOException;\n import java.io.Reader;\n@@ -46,25 +47,39 @@ void testReadArray() throws Exception {\n         try (Reader reader = new ClosedReader()) {\n             assertEquals(EOF, reader.read(new char[4096]));\n             assertEquals(EOF, reader.read(new char[1]));\n-            assertEquals(EOF, reader.read(new char[0]));\n+            assertEquals(0, reader.read(new char[0]));\n+            assertThrows(NullPointerException.class, () -> reader.read((char[]) null));\n         }\n     }\n \n     @Test\n     void testReadArrayIndex() throws Exception {\n         try (Reader reader = new ClosedReader()) {\n-            assertEquals(EOF, reader.read(CharBuffer.wrap(new char[4096])));\n-            assertEquals(EOF, reader.read(CharBuffer.wrap(new char[1])));\n-            assertEquals(EOF, reader.read(CharBuffer.wrap(new char[0])));\n+            final char[] cbuf = new char[4096];\n+            assertEquals(EOF, reader.read(cbuf, 0, 2048));\n+            assertEquals(EOF, reader.read(cbuf, 2048, 2048));\n+            assertEquals(0, reader.read(cbuf, 4096, 0));\n+            assertThrows(IndexOutOfBoundsException.class, () -> reader.read(cbuf, -1, 1));\n+            assertThrows(IndexOutOfBoundsException.class, () -> reader.read(cbuf, 0, 4097));\n+            assertThrows(IndexOutOfBoundsException.class, () -> reader.read(cbuf, 1, -1));\n+\n+            assertEquals(EOF, reader.read(new char[1]));\n+            assertEquals(0, reader.read(new char[0]));\n+            assertThrows(NullPointerException.class, () -> reader.read(null, 0, 0));\n         }\n     }\n \n     @Test\n     void testReadCharBuffer() throws Exception {\n         try (Reader reader = new ClosedReader()) {\n-            assertEquals(EOF, reader.read(new char[4096]));\n-            assertEquals(EOF, reader.read(new char[1]));\n-            assertEquals(EOF, reader.read(new char[0]));\n+            final CharBuffer charBuffer = CharBuffer.wrap(new char[4096]);\n+            assertEquals(EOF, reader.read(charBuffer));\n+            charBuffer.position(4096);\n+            assertEquals(0, reader.read(charBuffer));\n+\n+            assertEquals(EOF, reader.read(CharBuffer.wrap(new char[1])));\n+            assertEquals(0, reader.read(CharBuffer.wrap(new char[0])));\n+            assertThrows(NullPointerException.class, () -> reader.read((CharBuffer) null));\n         }\n     }\n \ndiff --git a/src/test/java/org/apache/commons/io/input/MarkShieldInputStreamTest.java b/src/test/java/org/apache/commons/io/input/MarkShieldInputStreamTest.java\nindex a1e4d17f457..2566f8b51e6 100644\n--- a/src/test/java/org/apache/commons/io/input/MarkShieldInputStreamTest.java\n+++ b/src/test/java/org/apache/commons/io/input/MarkShieldInputStreamTest.java\n@@ -152,7 +152,7 @@ void testReadByteArrayIntIntAfterClose(final int len) throws Exception {\n                 MarkShieldInputStream msis = new MarkShieldInputStream(in)) {\n             assertEquals(len, in.available());\n             in.close();\n-            assertEquals(0, in.read(new byte[0], 0, 1));\n+            assertThrows(IndexOutOfBoundsException.class, () -> in.read(new byte[0], 0, 1));\n             assertEquals(0, in.read(new byte[1], 0, 0));\n             assertThrows(IOException.class, () -> in.read(new byte[2], 0, 1));\n         }\ndiff --git a/src/test/java/org/apache/commons/io/input/NullInputStreamTest.java b/src/test/java/org/apache/commons/io/input/NullInputStreamTest.java\nindex b79555d8c02..9b59ac90c0e 100644\n--- a/src/test/java/org/apache/commons/io/input/NullInputStreamTest.java\n+++ b/src/test/java/org/apache/commons/io/input/NullInputStreamTest.java\n@@ -249,7 +249,7 @@ void testReadByteArrayIntIntAfterClose() throws Exception {\n         try (InputStream in = new NullInputStream()) {\n             assertEquals(0, in.available());\n             in.close();\n-            assertEquals(0, in.read(new byte[0], 0, 1));\n+            assertThrows(IndexOutOfBoundsException.class, () -> in.read(new byte[0], 0, 1));\n             assertEquals(0, in.read(new byte[1], 0, 0));\n             assertThrows(IOException.class, () -> in.read(new byte[2], 0, 1));\n         }\ndiff --git a/src/test/java/org/apache/commons/io/input/ProxyReaderTest.java b/src/test/java/org/apache/commons/io/input/ProxyReaderTest.java\nindex f33979ce1b8..681ab90eae0 100644\n--- a/src/test/java/org/apache/commons/io/input/ProxyReaderTest.java\n+++ b/src/test/java/org/apache/commons/io/input/ProxyReaderTest.java\n@@ -38,6 +38,11 @@ public int read(final char[] chars) throws IOException {\n             return chars == null ? 0 : super.read(chars);\n         }\n \n+        @Override\n+        public int read(final char[] chars, final int offset, final int length) throws IOException {\n+            return chars == null ? 0 : super.read(chars, offset, length);\n+        }\n+\n         @Override\n         public int read(final CharBuffer target) throws IOException {\n             return target == null ? 0 : super.read(target);\ndiff --git a/src/test/java/org/apache/commons/io/input/UnsynchronizedBufferedReaderTest.java b/src/test/java/org/apache/commons/io/input/UnsynchronizedBufferedReaderTest.java\nindex 9c7dbf6fd81..a144bc418d0 100644\n--- a/src/test/java/org/apache/commons/io/input/UnsynchronizedBufferedReaderTest.java\n+++ b/src/test/java/org/apache/commons/io/input/UnsynchronizedBufferedReaderTest.java\n@@ -353,35 +353,46 @@ void testRead() throws IOException {\n      * @throws IOException test failure.\n      */\n     @Test\n-    void testReadArray() throws IOException {\n+    void testReadArray1() throws IOException {\n         final char[] ca = new char[2];\n         try (UnsynchronizedBufferedReader toRet = new UnsynchronizedBufferedReader(new InputStreamReader(new ByteArrayInputStream(new byte[0])))) {\n-            /* Null buffer should throw NPE even when len == 0 */\n+            /* Validate parameters, before returning 0 */\n             assertThrows(NullPointerException.class, () -> toRet.read(null, 1, 0));\n+            assertThrows(IndexOutOfBoundsException.class, () -> toRet.read(ca, 1, 5));\n+            /* Read zero bytes should return 0 */\n+            assertEquals(0, toRet.read(ca, 0, 0));\n             toRet.close();\n-            assertThrows(IOException.class, () -> toRet.read(null, 1, 0));\n-            /* Closed reader should throw IOException reading zero bytes */\n-            assertThrows(IOException.class, () -> toRet.read(ca, 0, 0));\n             /*\n-             * Closed reader should throw IOException in preference to index out of bounds\n+             * After close, readers in java.io consistently throw IOException before checking parameters or returning 0.\n              */\n-            // Read should throw IOException before\n-            // ArrayIndexOutOfBoundException\n+            assertThrows(IOException.class, () -> toRet.read(null, 1, 0));\n             assertThrows(IOException.class, () -> toRet.read(ca, 1, 5));\n+            assertThrows(IOException.class, () -> toRet.read(ca, 0, 0));\n         }\n+    }\n+\n+    @Test\n+    void testReadArray2() throws IOException {\n+        final char[] ca = new char[2];\n         // Test to ensure that a drained stream returns 0 at EOF\n         try (UnsynchronizedBufferedReader toRet2 = new UnsynchronizedBufferedReader(new InputStreamReader(new ByteArrayInputStream(new byte[2])))) {\n             assertEquals(2, toRet2.read(ca, 0, 2));\n             assertEquals(-1, toRet2.read(ca, 0, 2));\n             assertEquals(0, toRet2.read(ca, 0, 0));\n         }\n+    }\n \n+    @Test\n+    void testReadArray3() throws IOException {\n         // Test for method int UnsynchronizedBufferedReader.read(char [], int, int)\n         final char[] buf = new char[testString.length()];\n         br = new UnsynchronizedBufferedReader(new StringReader(testString));\n         br.read(buf, 50, 500);\n         assertTrue(new String(buf, 50, 500).equals(testString.substring(0, 500)));\n+    }\n \n+    @Test\n+    void testReadArray4() throws IOException {\n         try (UnsynchronizedBufferedReader bufin = new UnsynchronizedBufferedReader(new Reader() {\n             int size = 2;\n             int pos;\n@@ -424,11 +435,18 @@ public boolean ready() throws IOException {\n             final int result = bufin.read(new char[2], 0, 2);\n             assertEquals(result, 1);\n         }\n+    }\n+\n+    @Test\n+    void testReadArray_HARMONY_831() throws IOException {\n         // regression for HARMONY-831\n         try (Reader reader = new UnsynchronizedBufferedReader(new PipedReader(), 9)) {\n             assertThrows(IndexOutOfBoundsException.class, () -> reader.read(new char[] {}, 7, 0));\n         }\n+    }\n \n+    @Test\n+    void testReadArray_HARMONY_54() throws IOException {\n         // Regression for HARMONY-54\n         final char[] ch = {};\n         @SuppressWarnings(\"resource\")\n@@ -456,13 +474,12 @@ void testReadArrayException() throws IOException {\n         br = new UnsynchronizedBufferedReader(new StringReader(testString));\n         final char[] nullCharArray = null;\n         final char[] charArray = testString.toCharArray();\n-        assertThrows(IndexOutOfBoundsException.class, () -> br.read(nullCharArray, -1, -1));\n-        assertThrows(IndexOutOfBoundsException.class, () -> br.read(nullCharArray, -1, 0));\n+        assertThrows(NullPointerException.class, () -> br.read(nullCharArray, -1, 0));\n         assertThrows(NullPointerException.class, () -> br.read(nullCharArray, 0, -1));\n-        assertThrows(NullPointerException.class, () -> br.read(nullCharArray, 0, 0));\n-        assertThrows(NullPointerException.class, () -> br.read(nullCharArray, 0, 1));\n-        assertThrows(IndexOutOfBoundsException.class, () -> br.read(charArray, -1, -1));\n+        assertThrows(NullPointerException.class, () -> br.read(nullCharArray, 1, 1));\n         assertThrows(IndexOutOfBoundsException.class, () -> br.read(charArray, -1, 0));\n+        assertThrows(IndexOutOfBoundsException.class, () -> br.read(charArray, 0, -1));\n+        assertThrows(IndexOutOfBoundsException.class, () -> br.read(charArray, charArray.length, 1));\n \n         br.read(charArray, 0, 0);\n         br.read(charArray, 0, charArray.length);\ndiff --git a/src/test/java/org/apache/commons/io/output/BrokenWriterTest.java b/src/test/java/org/apache/commons/io/output/BrokenWriterTest.java\nindex f8db50a6729..dffeb7907ae 100644\n--- a/src/test/java/org/apache/commons/io/output/BrokenWriterTest.java\n+++ b/src/test/java/org/apache/commons/io/output/BrokenWriterTest.java\n@@ -55,6 +55,7 @@ void testAppendCharSequence(final Class<Throwable> clazz) throws Exception {\n         @SuppressWarnings(\"resource\")\n         final BrokenWriter brokenWriter = createBrokenWriter(exception);\n         assertEquals(exception, assertThrows(clazz, () -> brokenWriter.append(\"01\")));\n+        assertEquals(exception, assertThrows(clazz, () -> brokenWriter.append(null)));\n     }\n \n     @ParameterizedTest\n@@ -64,6 +65,7 @@ void testAppendCharSequenceIndexed(final Class<Throwable> clazz) throws Exceptio\n         @SuppressWarnings(\"resource\")\n         final BrokenWriter brokenWriter = createBrokenWriter(exception);\n         assertEquals(exception, assertThrows(clazz, () -> brokenWriter.append(\"01\", 0, 1)));\n+        assertEquals(exception, assertThrows(clazz, () -> brokenWriter.append(null, 0, 4)));\n     }\n \n     @ParameterizedTest\n@@ -72,7 +74,7 @@ void testClose(final Class<Throwable> clazz) throws Exception {\n         final Throwable exception = clazz.newInstance();\n         @SuppressWarnings(\"resource\")\n         final BrokenWriter brokenWriter = createBrokenWriter(exception);\n-        assertEquals(exception, assertThrows(clazz, () -> brokenWriter.close()));\n+        assertEquals(exception, assertThrows(clazz, brokenWriter::close));\n     }\n \n     @ParameterizedTest\n@@ -81,7 +83,7 @@ void testFlush(final Class<Throwable> clazz) throws Exception {\n         final Throwable exception = clazz.newInstance();\n         @SuppressWarnings(\"resource\")\n         final BrokenWriter brokenWriter = createBrokenWriter(exception);\n-        assertEquals(exception, assertThrows(clazz, () -> brokenWriter.flush()));\n+        assertEquals(exception, assertThrows(clazz, brokenWriter::flush));\n     }\n \n     @Test\n@@ -119,7 +121,13 @@ void testWriteCharArrayIndexed(final Class<Throwable> clazz) throws Exception {\n         final Throwable exception = clazz.newInstance();\n         @SuppressWarnings(\"resource\")\n         final BrokenWriter brokenWriter = createBrokenWriter(exception);\n-        assertEquals(exception, assertThrows(clazz, () -> brokenWriter.write(new char[1], 0, 1)));\n+        final char[] cbuf = new char[1];\n+        assertEquals(exception, assertThrows(clazz, () -> brokenWriter.write(cbuf, 0, 1)));\n+        // Verify that the exception is thrown before checking the parameters.\n+        assertEquals(exception, assertThrows(clazz, () -> brokenWriter.write(cbuf, -1, 0)));\n+        assertEquals(exception, assertThrows(clazz, () -> brokenWriter.write(cbuf, 0, -1)));\n+        assertEquals(exception, assertThrows(clazz, () -> brokenWriter.write(cbuf, 0, 2)));\n+        assertEquals(exception, assertThrows(clazz, () -> brokenWriter.write((char[]) null, 0, 0)));\n     }\n \n     @ParameterizedTest\ndiff --git a/src/test/java/org/apache/commons/io/output/ByteArrayOutputStreamTest.java b/src/test/java/org/apache/commons/io/output/ByteArrayOutputStreamTest.java\nindex fa19ba2a41a..9bae1cb5f62 100644\n--- a/src/test/java/org/apache/commons/io/output/ByteArrayOutputStreamTest.java\n+++ b/src/test/java/org/apache/commons/io/output/ByteArrayOutputStreamTest.java\n@@ -177,7 +177,7 @@ void testInvalidWriteOffsetOver(final String baosName, final BAOSFactory<?> baos\n     @MethodSource(\"baosFactories\")\n     void testInvalidWriteOffsetUnder(final String baosName, final BAOSFactory<?> baosFactory) throws IOException {\n         try (AbstractByteArrayOutputStream<?> baout = baosFactory.newInstance()) {\n-            assertThrows(IndexOutOfBoundsException.class, () -> baout.write(null, -1, 0));\n+            assertThrows(IndexOutOfBoundsException.class, () -> baout.write(IOUtils.EMPTY_BYTE_ARRAY, -1, 0));\n         }\n     }\n \ndiff --git a/src/test/java/org/apache/commons/io/output/ClosedWriterTest.java b/src/test/java/org/apache/commons/io/output/ClosedWriterTest.java\nindex 4f57957a885..b9758729f1b 100644\n--- a/src/test/java/org/apache/commons/io/output/ClosedWriterTest.java\n+++ b/src/test/java/org/apache/commons/io/output/ClosedWriterTest.java\n@@ -43,7 +43,13 @@ void testFlush() throws IOException {\n     @Test\n     void testWrite() throws IOException {\n         try (ClosedWriter cw = new ClosedWriter()) {\n-            assertThrows(IOException.class, () -> cw.write(new char[0], 0, 0));\n+            final char[] cbuf = new char[1];\n+            assertThrows(IOException.class, () -> cw.write(new char[0], 0, 1));\n+            // In writers, testing for closed always comes before argument validation\n+            assertThrows(IOException.class, () -> cw.write(cbuf, -1, 0));\n+            assertThrows(IOException.class, () -> cw.write(cbuf, 0, -1));\n+            assertThrows(IOException.class, () -> cw.write(cbuf, 0, 2));\n+            assertThrows(IOException.class, () -> cw.write((char[]) null, 0, 0));\n         }\n     }\n \ndiff --git a/src/test/java/org/apache/commons/io/output/NullAppendableTest.java b/src/test/java/org/apache/commons/io/output/NullAppendableTest.java\nindex 6caa15023d9..aa5ef7137ed 100644\n--- a/src/test/java/org/apache/commons/io/output/NullAppendableTest.java\n+++ b/src/test/java/org/apache/commons/io/output/NullAppendableTest.java\n@@ -16,6 +16,8 @@\n  */\n package org.apache.commons.io.output;\n \n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n import java.io.IOException;\n \n import org.junit.jupiter.api.Test;\n@@ -32,7 +34,12 @@ void testNull() throws IOException {\n         appendable.append(\"A\");\n         appendable.append(\"A\", 0, 1);\n         appendable.append(null, 0, 1);\n-        appendable.append(null, -1, -1);\n+        // Check argument validation\n+        final CharSequence csq = \"ABCDE\";\n+        assertThrows(IndexOutOfBoundsException.class, () -> appendable.append(csq, -1, 0));\n+        assertThrows(IndexOutOfBoundsException.class, () -> appendable.append(csq, 0, -1));\n+        assertThrows(IndexOutOfBoundsException.class, () -> appendable.append(csq, 1, 0));\n+        assertThrows(IndexOutOfBoundsException.class, () -> appendable.append(csq, 0, 6));\n     }\n \n }\ndiff --git a/src/test/java/org/apache/commons/io/output/NullOutputStreamTest.java b/src/test/java/org/apache/commons/io/output/NullOutputStreamTest.java\nindex bdecc0e0a68..097566fc6e2 100644\n--- a/src/test/java/org/apache/commons/io/output/NullOutputStreamTest.java\n+++ b/src/test/java/org/apache/commons/io/output/NullOutputStreamTest.java\n@@ -16,6 +16,8 @@\n  */\n package org.apache.commons.io.output;\n \n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n import java.io.IOException;\n \n import org.junit.jupiter.api.Test;\n@@ -34,11 +36,18 @@ private void process(final NullOutputStream nos) throws IOException {\n         nos.close();\n         nos.write(\"allowed\".getBytes());\n         nos.write(255);\n+        // Test arguments validation\n+        final byte[] b = new byte[1];\n+        assertThrows(IndexOutOfBoundsException.class, () -> nos.write(b, -1, 0));\n+        assertThrows(IndexOutOfBoundsException.class, () -> nos.write(b, 0, -1));\n+        assertThrows(IndexOutOfBoundsException.class, () -> nos.write(b, 0, 2));\n+        assertThrows(NullPointerException.class, () -> nos.write(null, 0, 0));\n     }\n \n     @Test\n+    @SuppressWarnings(\"deprecation\")\n     void testNewInstance() throws IOException {\n-        try (NullOutputStream nos = NullOutputStream.INSTANCE) {\n+        try (NullOutputStream nos = new NullOutputStream()) {\n             process(nos);\n         }\n     }\ndiff --git a/src/test/java/org/apache/commons/io/output/NullWriterTest.java b/src/test/java/org/apache/commons/io/output/NullWriterTest.java\nindex f1b603a3776..424d076ee21 100644\n--- a/src/test/java/org/apache/commons/io/output/NullWriterTest.java\n+++ b/src/test/java/org/apache/commons/io/output/NullWriterTest.java\n@@ -16,6 +16,9 @@\n  */\n package org.apache.commons.io.output;\n \n+import static org.junit.jupiter.api.Assertions.assertSame;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n import org.junit.jupiter.api.Test;\n \n /**\n@@ -24,17 +27,96 @@\n  */\n class NullWriterTest {\n \n+    private static final String TEST_STRING = \"ABC\";\n+    private static final char[] TEST_CHARS = TEST_STRING.toCharArray();\n+\n+    @Test\n+    void testAppendChar() {\n+        try (NullWriter writer = NullWriter.INSTANCE) {\n+            assertSame(writer, writer.append('X'));\n+        }\n+    }\n+\n+    @Test\n+    void testAppendCharSequence() {\n+        try (NullWriter writer = NullWriter.INSTANCE) {\n+            assertSame(writer, writer.append(TEST_STRING));\n+            assertSame(writer, writer.append(null));\n+        }\n+    }\n+\n     @Test\n-    void testNull() {\n-        final char[] chars = { 'A', 'B', 'C' };\n+    void testAppendCharSequenceWithRange() {\n+        try (NullWriter writer = NullWriter.INSTANCE) {\n+            assertSame(writer, writer.append(TEST_STRING, 1, 2));\n+            assertSame(writer, writer.append(null, 0, 4));\n+            // Test argument validation\n+            assertThrows(IndexOutOfBoundsException.class, () -> writer.append(TEST_STRING, -1, 2));\n+            assertThrows(IndexOutOfBoundsException.class, () -> writer.append(TEST_STRING, 1, 5));\n+            assertThrows(IndexOutOfBoundsException.class, () -> writer.append(TEST_STRING, 2, 1));\n+        }\n+    }\n+\n+    @Test\n+    void testCloseNoOp() {\n+        final NullWriter writer = NullWriter.INSTANCE;\n+        writer.close();\n+        writer.write(TEST_CHARS);\n+    }\n+\n+    @Test\n+    void testFlush() {\n         try (NullWriter writer = NullWriter.INSTANCE) {\n-            writer.write(1);\n-            writer.write(chars);\n-            writer.write(chars, 1, 1);\n-            writer.write(\"some string\");\n-            writer.write(\"some string\", 2, 2);\n             writer.flush();\n         }\n     }\n \n+    @Test\n+    void testWriteCharArray() {\n+        try (NullWriter writer = NullWriter.INSTANCE) {\n+            writer.write(TEST_CHARS);\n+            // Test argument validation\n+            assertThrows(NullPointerException.class, () -> writer.write((char[]) null));\n+        }\n+    }\n+\n+    @Test\n+    void testWriteCharArrayWithOffset() {\n+        try (NullWriter writer = NullWriter.INSTANCE) {\n+            writer.write(TEST_CHARS, 1, 2);\n+            // Test argument validation\n+            assertThrows(IndexOutOfBoundsException.class, () -> writer.write(TEST_CHARS, -1, 0));\n+            assertThrows(IndexOutOfBoundsException.class, () -> writer.write(TEST_CHARS, 0, -1));\n+            assertThrows(IndexOutOfBoundsException.class, () -> writer.write(TEST_CHARS, 0, 4));\n+            assertThrows(NullPointerException.class, () -> writer.write((char[]) null, 0, 0));\n+        }\n+    }\n+\n+    @Test\n+    void testWriteInt() {\n+        try (NullWriter writer = NullWriter.INSTANCE) {\n+            writer.write(42);\n+        }\n+    }\n+\n+    @Test\n+    void testWriteString() {\n+        try (NullWriter writer = NullWriter.INSTANCE) {\n+            writer.write(TEST_STRING);\n+            // Test argument validation\n+            assertThrows(NullPointerException.class, () -> writer.write((String) null));\n+        }\n+    }\n+\n+    @Test\n+    void testWriteStringWithOffset() {\n+        try (NullWriter writer = NullWriter.INSTANCE) {\n+            writer.write(TEST_STRING, 1, 1);\n+            // Test argument validation\n+            assertThrows(IndexOutOfBoundsException.class, () -> writer.write(TEST_STRING, -1, 0));\n+            assertThrows(IndexOutOfBoundsException.class, () -> writer.write(TEST_STRING, 0, -1));\n+            assertThrows(IndexOutOfBoundsException.class, () -> writer.write(TEST_STRING, 0, 4));\n+            assertThrows(NullPointerException.class, () -> writer.write((String) null, 0, 0));\n+        }\n+    }\n }\ndiff --git a/src/test/java/org/apache/commons/io/output/ProxyWriterTest.java b/src/test/java/org/apache/commons/io/output/ProxyWriterTest.java\nindex 9954ca06803..e810d39d726 100644\n--- a/src/test/java/org/apache/commons/io/output/ProxyWriterTest.java\n+++ b/src/test/java/org/apache/commons/io/output/ProxyWriterTest.java\n@@ -205,8 +205,8 @@ public void write(final String str, final int off, final int len) throws IOExcep\n     @Test\n     void testNullCharArray() throws Exception {\n         try (ProxyWriter proxy = new ProxyWriter(NullWriter.INSTANCE)) {\n-            proxy.write((char[]) null);\n-            proxy.write((char[]) null, 0, 0);\n+            assertThrows(NullPointerException.class, () -> proxy.write((char[]) null));\n+            assertThrows(NullPointerException.class, () -> proxy.write((char[]) null, 0, 0));\n         }\n     }\n \n@@ -220,8 +220,9 @@ void testNullCharSequence() throws Exception {\n     @Test\n     void testNullString() throws Exception {\n         try (ProxyWriter proxy = new ProxyWriter(NullWriter.INSTANCE)) {\n-            proxy.write((String) null);\n-            proxy.write((String) null, 0, 0);\n+            // Default implementation delegates to write(char[], int, int)\n+            assertThrows(NullPointerException.class, () -> proxy.write((String) null));\n+            assertThrows(NullPointerException.class, () -> proxy.write((String) null, 0, 0));\n         }\n     }\n \n",
  "problem_statement" : "Backport `Objects.checkFromIndexSize` to `IOUtils`\n\nJava 9 introduced `Objects.checkFromIndexSize` for validating the offset/length ranges used in `read` and `write` operations.\r\n\r\nThis PR adds an equivalent method, `IOUtils.checkFromIndexSize`, to provide the same validation in Commons IO. It simplifies range checks in stream implementations and makes the utility available to projects that still target Java 8.\r\n",
  "hints_text" : null,
  "created_at" : "Sun Sep 28 15:53:55 CEST 2025",
  "version" : null,
  "FAIL_TO_PASS" : [ "BrokenReaderTest", "ClosedInputStreamTest", "MarkShieldInputStreamTest", "BrokenWriterTest", "ClosedWriterTest", "IOUtilsTest", "ByteArrayOutputStreamTest", "NullAppendableTest", "NullWriterTest", "ProxyReaderTest", "NullInputStreamTest", "ProxyWriterTest", "NullOutputStreamTest", "UnsynchronizedBufferedReaderTest", "ClosedReaderTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=BrokenReaderTest,ClosedInputStreamTest,MarkShieldInputStreamTest,BrokenWriterTest,ClosedWriterTest,IOUtilsTest,ByteArrayOutputStreamTest,NullAppendableTest,NullWriterTest,ProxyReaderTest,NullInputStreamTest,ProxyWriterTest,NullOutputStreamTest,UnsynchronizedBufferedReaderTest,ClosedReaderTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 790,
  "metadata" : null
}, {
  "instance_id" : "apache-commons-io-PR-786",
  "repo" : "apache/commons-io",
  "base_commit" : "3c0677e8b7241a81e27d02791f0cf57fd1ab9a78",
  "patch" : "diff --git a/src/changes/changes.xml b/src/changes/changes.xml\nindex 3fa2e390dfa..b0b5846358c 100644\n--- a/src/changes/changes.xml\n+++ b/src/changes/changes.xml\n@@ -66,6 +66,7 @@ The <action> type attribute can be add,update,fix,remove.\n       <action dev=\"pkarwasz\" type=\"add\"                due-to=\"Piotr P. Karwasz\">Add org.apache.commons.io.file.PathUtils.getPath(String, String).</action>\n       <action dev=\"ggregory\" type=\"add\"                due-to=\"Gary Gregory\">Add org.apache.commons.io.channels.ByteArraySeekableByteChannel.</action>\n       <action dev=\"ggregory\" type=\"add\"                due-to=\"Gary Gregory\">Add IOIterable.asIterable().</action>\n+      <action dev=\"pkarwasz\" type=\"add\"                due-to=\"Piotr P. Karwasz\">Add Channels.closeShield(Channel) for close-shielded NIO Channel proxies.</action>\n       <!-- UPDATE -->\n       <action type=\"update\" dev=\"ggregory\"             due-to=\"Gary Gregory, Dependabot\">Bump org.apache.commons:commons-parent from 85 to 88 #774, #783.</action>\n       <action type=\"update\" dev=\"ggregory\"             due-to=\"Gary Gregory\">[test] Bump commons-codec:commons-codec from 1.18.0 to 1.19.0.</action>\ndiff --git a/src/main/java/org/apache/commons/io/channels/CloseShieldChannel.java b/src/main/java/org/apache/commons/io/channels/CloseShieldChannel.java\nnew file mode 100644\nindex 00000000000..00f269f9a97\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/io/channels/CloseShieldChannel.java\n@@ -0,0 +1,84 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.io.channels;\n+\n+import java.lang.reflect.InvocationHandler;\n+import java.lang.reflect.Proxy;\n+import java.nio.channels.Channel;\n+import java.util.LinkedHashSet;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+/**\n+ * Utility to create a close-shielding proxy for a {@link Channel}.\n+ *\n+ * <p>The returned proxy will implement all {@link Channel} sub-interfaces that the delegate implements.</p>\n+ *\n+ * @since 2.21.0\n+ */\n+public final class CloseShieldChannel {\n+\n+    private CloseShieldChannel() {\n+        // no instance\n+    }\n+\n+    /**\n+     * Wraps a channel to shield it from being closed.\n+     *\n+     * @param channel The underlying channel to shield, not {@code null}.\n+     * @param <T>     Any Channel type (interface or class).\n+     * @return A proxy that shields {@code close()} and enforces closed semantics on other calls.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <T extends Channel> T wrap(final T channel) {\n+        Objects.requireNonNull(channel, \"channel\");\n+\n+        // Fast path: already our shield\n+        if (Proxy.isProxyClass(channel.getClass())) {\n+            final InvocationHandler handler = Proxy.getInvocationHandler(channel);\n+            if (handler instanceof CloseShieldChannelHandler) {\n+                return channel;\n+            }\n+        }\n+\n+        // Collect only Channel sub-interfaces.\n+        Class<?>[] ifaces = collectChannelInterfaces(channel.getClass());\n+        if (ifaces.length == 0) {\n+            ifaces = new Class<?>[] {Channel.class}; // fallback to minimal surface\n+        }\n+\n+        return (T) Proxy.newProxyInstance(\n+                channel.getClass().getClassLoader(), // use delegate's loader\n+                ifaces,\n+                new CloseShieldChannelHandler(channel));\n+    }\n+\n+    private static Class<?>[] collectChannelInterfaces(final Class<?> type) {\n+        final Set<Class<?>> out = new LinkedHashSet<>();\n+        collectChannelInterfaces(type, out);\n+        return out.toArray(new Class<?>[0]);\n+    }\n+\n+    private static void collectChannelInterfaces(final Class<?> type, final Set<Class<?>> out) {\n+        // Visit interfaces\n+        for (Class<?> iface : type.getInterfaces()) {\n+            if (Channel.class.isAssignableFrom(iface) && out.add(iface)) {\n+                collectChannelInterfaces(iface, out);\n+            }\n+        }\n+    }\n+}\ndiff --git a/src/main/java/org/apache/commons/io/channels/CloseShieldChannelHandler.java b/src/main/java/org/apache/commons/io/channels/CloseShieldChannelHandler.java\nnew file mode 100644\nindex 00000000000..7fcdea4d51e\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/io/channels/CloseShieldChannelHandler.java\n@@ -0,0 +1,135 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.io.channels;\n+\n+import java.lang.reflect.InvocationHandler;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Proxy;\n+import java.nio.channels.Channel;\n+import java.nio.channels.ClosedChannelException;\n+import java.nio.channels.NetworkChannel;\n+import java.nio.channels.SeekableByteChannel;\n+import java.util.Objects;\n+\n+final class CloseShieldChannelHandler implements InvocationHandler {\n+\n+    private final Channel delegate;\n+    private volatile boolean closed;\n+\n+    CloseShieldChannelHandler(final Channel delegate) {\n+        this.delegate = Objects.requireNonNull(delegate, \"delegate\");\n+    }\n+\n+    @Override\n+    public Object invoke(final Object proxy, final Method method, final Object[] args) throws Throwable {\n+        final Class<?> declaringClass = method.getDeclaringClass();\n+        final String name = method.getName();\n+        final int parameterCount = method.getParameterCount();\n+\n+        // 1) java.lang.Object methods\n+        if (declaringClass == Object.class) {\n+            return invokeObjectMethod(proxy, method, args);\n+        }\n+\n+        // 2) Channel.close(): mark shield closed, do NOT close the delegate\n+        if (parameterCount == 0 && name.equals(\"close\")) {\n+            closed = true;\n+            return null;\n+        }\n+\n+        // 3) Channel.isOpen(): reflect shield state only\n+        if (parameterCount == 0 && name.equals(\"isOpen\")) {\n+            return !closed && delegate.isOpen();\n+        }\n+\n+        // 4) After the shield is closed, only allow a tiny allowlist of safe queries\n+        if (closed && !isAllowedAfterClose(declaringClass, name, parameterCount)) {\n+            throw new ClosedChannelException();\n+        }\n+\n+        // 5) Delegate to the underlying channel and unwrap target exceptions\n+        try {\n+            final Object result = method.invoke(delegate, args);\n+            return returnsThis(declaringClass, name, parameterCount) ? proxy : result;\n+        } catch (InvocationTargetException e) {\n+            throw e.getCause();\n+        }\n+    }\n+\n+    /**\n+     * Tests whether the given method is allowed to be called after the shield is closed.\n+     *\n+     * @param declaringClass The class declaring the method.\n+     * @param name           The method name.\n+     * @param parameterCount The number of parameters.\n+     * @return {@code true} if the method is allowed after {@code close()}, {@code false} otherwise.\n+     */\n+    private static boolean isAllowedAfterClose(Class<?> declaringClass, String name, int parameterCount) {\n+        // JDK explicitly allows NetworkChannel.supportedOptions() post-close\n+        return parameterCount == 0 && name.equals(\"supportedOptions\") && NetworkChannel.class.equals(declaringClass);\n+    }\n+\n+    /**\n+     * Tests whether the given method returns 'this' (the channel) as per JDK spec.\n+     *\n+     * @param declaringClass The class declaring the method.\n+     * @param name           The method name.\n+     * @param parameterCount The number of parameters.\n+     * @return {@code true} if the method returns 'this', {@code false} otherwise.\n+     */\n+    private static boolean returnsThis(Class<?> declaringClass, String name, int parameterCount) {\n+        if (SeekableByteChannel.class.equals(declaringClass)) {\n+            // SeekableByteChannel.position(long) and truncate(long) return 'this'\n+            return parameterCount == 1 && (name.equals(\"position\") || name.equals(\"truncate\"));\n+        }\n+        if (NetworkChannel.class.equals(declaringClass)) {\n+            // NetworkChannel.bind and NetworkChannel.setOption returns 'this'\n+            return parameterCount == 1 && name.equals(\"bind\") || parameterCount == 2 && name.equals(\"setOption\");\n+        }\n+        return false;\n+    }\n+\n+    private Object invokeObjectMethod(final Object proxy, final Method method, final Object[] args)\n+            throws ReflectiveOperationException {\n+        switch (method.getName()) {\n+            case \"toString\":\n+                return \"CloseShield(\" + delegate + \")\";\n+            case \"hashCode\":\n+                return Objects.hashCode(delegate);\n+            case \"equals\": {\n+                final Object other = args[0];\n+                if (other == null) {\n+                    return false;\n+                }\n+                if (proxy == other) {\n+                    return true;\n+                }\n+                if (Proxy.isProxyClass(other.getClass())) {\n+                    final InvocationHandler h = Proxy.getInvocationHandler(other);\n+                    if (h instanceof CloseShieldChannelHandler) {\n+                        return Objects.equals(((CloseShieldChannelHandler) h).delegate, this.delegate);\n+                    }\n+                }\n+                return false;\n+            }\n+            default:\n+                // Not possible, all non-final Object methods are handled above\n+                return null;\n+        }\n+    }\n+}\n",
  "test_patch" : "diff --git a/src/test/java/org/apache/commons/io/channels/CloseShieldChannelTest.java b/src/test/java/org/apache/commons/io/channels/CloseShieldChannelTest.java\nnew file mode 100644\nindex 00000000000..6b704ad1ed5\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/io/channels/CloseShieldChannelTest.java\n@@ -0,0 +1,269 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.io.channels;\n+\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotSame;\n+import static org.junit.jupiter.api.Assertions.assertSame;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoInteractions;\n+import static org.mockito.Mockito.verifyNoMoreInteractions;\n+import static org.mockito.Mockito.when;\n+\n+import java.nio.channels.ByteChannel;\n+import java.nio.channels.Channel;\n+import java.nio.channels.ClosedChannelException;\n+import java.nio.channels.GatheringByteChannel;\n+import java.nio.channels.NetworkChannel;\n+import java.nio.channels.ReadableByteChannel;\n+import java.nio.channels.ScatteringByteChannel;\n+import java.nio.channels.SeekableByteChannel;\n+import java.nio.channels.WritableByteChannel;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+class CloseShieldChannelTest {\n+\n+    static Stream<Class<? extends Channel>> testedInterfaces() {\n+        return Stream.of(\n+                Channel.class,\n+                ReadableByteChannel.class,\n+                ScatteringByteChannel.class,\n+                WritableByteChannel.class,\n+                GatheringByteChannel.class,\n+                ByteChannel.class,\n+                SeekableByteChannel.class,\n+                NetworkChannel.class);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"testedInterfaces\")\n+    void testPreservesInterfaces(Class<? extends Channel> channelClass) {\n+        final Channel channel = mock(channelClass);\n+        final Channel shield = CloseShieldChannel.wrap(channel);\n+        assertNotSame(channel, shield);\n+        assertTrue(channelClass.isInstance(shield));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"testedInterfaces\")\n+    void testCloseIsShielded(Class<? extends Channel> channelClass) throws Exception {\n+        final Channel channel = mock(channelClass);\n+        when(channel.isOpen()).thenReturn(true, false, true, false);\n+        final Channel shield = CloseShieldChannel.wrap(channel);\n+        // Reflects delegate state initially\n+        assertTrue(shield.isOpen(), \"isOpen reflects delegate state\");\n+        assertFalse(shield.isOpen(), \"isOpen reflects delegate state\");\n+        verify(channel, times(2)).isOpen();\n+\n+        shield.close();\n+        // Reflects shield state after close\n+        assertFalse(shield.isOpen(), \"isOpen reflects shield state\");\n+        assertFalse(shield.isOpen(), \"isOpen reflects shield state\");\n+        verify(channel, times(2)).isOpen();\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"testedInterfaces\")\n+    void testCloseDoesNotCloseDelegate(Class<? extends Channel> channelClass) throws Exception {\n+        final Channel channel = mock(channelClass);\n+        final Channel shield = CloseShieldChannel.wrap(channel);\n+        shield.close();\n+        verify(channel, never()).close();\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"testedInterfaces\")\n+    void testCloseIsIdempotent(Class<? extends Channel> channelClass) throws Exception {\n+        final Channel channel = mock(channelClass);\n+        final Channel shield = CloseShieldChannel.wrap(channel);\n+        shield.close();\n+        assertFalse(shield.isOpen());\n+        shield.close();\n+        assertFalse(shield.isOpen());\n+        verifyNoInteractions(channel);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"testedInterfaces\")\n+    void testEquals(Class<? extends Channel> channelClass) throws Exception {\n+        final Channel channel = mock(channelClass);\n+        final Channel shield = CloseShieldChannel.wrap(channel);\n+        final Channel anotherShield = CloseShieldChannel.wrap(channel);\n+        assertTrue(shield.equals(shield), \"reflexive\");\n+        assertFalse(shield.equals(null), \"null is not equal\");\n+        assertFalse(shield.equals(channel), \"shield not equal to delegate\");\n+        assertTrue(shield.equals(anotherShield), \"shields of same delegate are equal\");\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"testedInterfaces\")\n+    void testHashCode(Class<? extends Channel> channelClass) throws Exception {\n+        final Channel channel = mock(channelClass);\n+        final Channel shield = CloseShieldChannel.wrap(channel);\n+        final Channel anotherShield = CloseShieldChannel.wrap(channel);\n+        assertEquals(shield.hashCode(), channel.hashCode(), \"delegates hashCode\");\n+        assertEquals(shield.hashCode(), anotherShield.hashCode(), \"shields of same delegate have same hashCode\");\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"testedInterfaces\")\n+    void testToString(Class<? extends Channel> channelClass) throws Exception {\n+        final Channel channel = mock(channelClass);\n+        when(channel.toString()).thenReturn(\"MyChannel\");\n+        final Channel shield = CloseShieldChannel.wrap(channel);\n+        final String shieldString = shield.toString();\n+        assertTrue(shieldString.contains(\"CloseShield\"));\n+        assertTrue(shieldString.contains(\"MyChannel\"));\n+    }\n+\n+    @Test\n+    void testReadableByteChannelMethods() throws Exception {\n+        final ReadableByteChannel channel = mock(ReadableByteChannel.class);\n+        when(channel.isOpen()).thenReturn(true);\n+        final ReadableByteChannel shield = CloseShieldChannel.wrap(channel);\n+        // Before close read() should delegate\n+        when(channel.read(null)).thenReturn(42);\n+        assertEquals(42, shield.read(null));\n+        verify(channel).read(null);\n+        // After close read() should throw ClosedChannelException\n+        shield.close();\n+        assertThrows(ClosedChannelException.class, () -> shield.read(null));\n+        verifyNoMoreInteractions(channel);\n+    }\n+\n+    @Test\n+    void testScatteringByteChannelMethods() throws Exception {\n+        final ScatteringByteChannel channel = mock(ScatteringByteChannel.class);\n+        when(channel.isOpen()).thenReturn(true);\n+        final ScatteringByteChannel shield = CloseShieldChannel.wrap(channel);\n+        // Before close read() should delegate\n+        when(channel.read(null, 0, 0)).thenReturn(42L);\n+        assertEquals(42, shield.read(null, 0, 0));\n+        verify(channel).read(null, 0, 0);\n+        // After close read() should throw ClosedChannelException\n+        shield.close();\n+        assertThrows(ClosedChannelException.class, () -> shield.read(null, 0, 0));\n+        verifyNoMoreInteractions(channel);\n+    }\n+\n+    @Test\n+    void testWritableByteChannelMethods() throws Exception {\n+        final WritableByteChannel channel = mock(WritableByteChannel.class);\n+        when(channel.isOpen()).thenReturn(true);\n+        final WritableByteChannel shield = CloseShieldChannel.wrap(channel);\n+        // Before close write() should delegate\n+        when(channel.write(null)).thenReturn(42);\n+        assertEquals(42, shield.write(null));\n+        verify(channel).write(null);\n+        // After close write() should throw ClosedChannelException\n+        shield.close();\n+        assertThrows(ClosedChannelException.class, () -> shield.write(null));\n+        verifyNoMoreInteractions(channel);\n+    }\n+\n+    @Test\n+    void testGatheringByteChannelMethods() throws Exception {\n+        final GatheringByteChannel channel = mock(GatheringByteChannel.class);\n+        when(channel.isOpen()).thenReturn(true);\n+        final GatheringByteChannel shield = CloseShieldChannel.wrap(channel);\n+        // Before close write() should delegate\n+        when(channel.write(null, 0, 0)).thenReturn(42L);\n+        assertEquals(42, shield.write(null, 0, 0));\n+        verify(channel).write(null, 0, 0);\n+        // After close write() should throw ClosedChannelException\n+        shield.close();\n+        assertThrows(ClosedChannelException.class, () -> shield.write(null, 0, 0));\n+        verifyNoMoreInteractions(channel);\n+    }\n+\n+    @Test\n+    void testSeekableByteChannelMethods() throws Exception {\n+        final SeekableByteChannel channel = mock(SeekableByteChannel.class);\n+        when(channel.isOpen()).thenReturn(true);\n+        final SeekableByteChannel shield = CloseShieldChannel.wrap(channel);\n+        // Before close position() and size() should delegate\n+        when(channel.position()).thenReturn(42L);\n+        when(channel.size()).thenReturn(84L);\n+        assertEquals(42, shield.position());\n+        assertEquals(84, shield.size());\n+        verify(channel).position();\n+        verify(channel).size();\n+        // Before close position(long) and truncate(long) should delegate\n+        when(channel.position(21)).thenReturn(channel);\n+        when(channel.truncate(21)).thenReturn(channel);\n+        assertEquals(shield, shield.position(21));\n+        assertEquals(shield, shield.truncate(21));\n+        verify(channel).position(21);\n+        verify(channel).truncate(21);\n+        // After close position() should throw ClosedChannelException\n+        shield.close();\n+        assertThrows(ClosedChannelException.class, shield::position);\n+        assertThrows(ClosedChannelException.class, () -> shield.position(0));\n+        assertThrows(ClosedChannelException.class, shield::size);\n+        assertThrows(ClosedChannelException.class, () -> shield.truncate(0));\n+        verifyNoMoreInteractions(channel);\n+    }\n+\n+    @Test\n+    void testNetworkChannelMethods() throws Exception {\n+        final NetworkChannel channel = mock(NetworkChannel.class);\n+        when(channel.isOpen()).thenReturn(true);\n+        final NetworkChannel shield = CloseShieldChannel.wrap(channel);\n+        // Before close getOption(), setOption(), getLocalAddress() and bind() should delegate\n+        when(channel.getOption(null)).thenReturn(\"foo\");\n+        when(channel.setOption(null, null)).thenReturn(channel);\n+        when(channel.getLocalAddress()).thenReturn(null);\n+        when(channel.bind(null)).thenReturn(channel);\n+        assertEquals(\"foo\", shield.getOption(null));\n+        assertEquals(shield, shield.setOption(null, null));\n+        assertEquals(null, shield.getLocalAddress());\n+        assertEquals(shield, shield.bind(null));\n+        verify(channel).getOption(null);\n+        verify(channel).setOption(null, null);\n+        verify(channel).getLocalAddress();\n+        verify(channel).bind(null);\n+        // After close supportedOptions() should still work\n+        shield.close();\n+        assertDoesNotThrow(shield::supportedOptions);\n+        verify(channel).supportedOptions();\n+        // But the remaining methods should throw ClosedChannelException\n+        assertThrows(ClosedChannelException.class, () -> shield.setOption(null, null));\n+        assertThrows(ClosedChannelException.class, () -> shield.getOption(null));\n+        assertThrows(ClosedChannelException.class, shield::getLocalAddress);\n+        assertThrows(ClosedChannelException.class, () -> shield.bind(null));\n+        verifyNoMoreInteractions(channel);\n+    }\n+\n+    @Test\n+    void testDoesNotDoubleWrap() {\n+        final ByteChannel channel = mock(ByteChannel.class);\n+        final ByteChannel shield1 = CloseShieldChannel.wrap(channel);\n+        final ByteChannel shield2 = CloseShieldChannel.wrap(shield1);\n+        assertSame(shield1, shield2);\n+    }\n+}\n",
  "problem_statement" : "Add CloseShieldChannel to close-shielded NIO Channels\n\nAdds `Channels.closeShield(Channel)` to return a JDK proxy that preserves the delegateâ€™s `Channel` sub-interfaces and shields the underlying channel from `close()`.\r\n\r\n**Behavior**\r\n\r\n* `close()` flips shield state; delegate is not closed.\r\n* `isOpen()` reflects shield state and delegates if shield is not closed.\r\n* After shield-close, I/O/mutating methods throw `ClosedChannelException`; safe queries (e.g., `NetworkChannel.supportedOptions()`) still work.\r\n* Fluent methods that return `this` (e.g., `SeekableByteChannel.position/truncate`, `NetworkChannel.bind/setOption`) return the **proxy**.\r\n* Stable `equals`/`hashCode`/`toString`\r\n* The method is idempotent (no double-wrapping).\r\n\r\n**Tests**\r\n\r\n* All methods of `SeekableByteChannel` / `NetworkChannel` and super-interfaces are tested.\r\n",
  "hints_text" : null,
  "created_at" : "Mon Sep 22 23:25:15 CEST 2025",
  "version" : null,
  "FAIL_TO_PASS" : [ "CloseShieldChannelTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=CloseShieldChannelTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 786,
  "metadata" : null
}, {
  "instance_id" : "apache-commons-io-PR-785",
  "repo" : "apache/commons-io",
  "base_commit" : "a96ae748c00343eb5f09ebf77d1dde77b733be2d",
  "patch" : "diff --git a/src/changes/changes.xml b/src/changes/changes.xml\nindex daa2c4de65f..3fa2e390dfa 100644\n--- a/src/changes/changes.xml\n+++ b/src/changes/changes.xml\n@@ -53,6 +53,7 @@ The <action> type attribute can be add,update,fix,remove.\n       <action type=\"fix\" dev=\"pkarwasz\"                due-to=\"Piotr P. Karwasz\">BoundedInputStream.getRemaining() now reports Long.MAX_VALUE instead of 0 when no limit is set.</action>\n       <action type=\"fix\" dev=\"pkarwasz\"                due-to=\"Piotr P. Karwasz\">BoundedInputStream.available() correctly accounts for the maximum read limit.</action>\n       <action type=\"fix\" dev=\"ggregory\"                due-to=\"Gary Gregory, Piotr P. Karwasz\">Deprecate IOUtils.readFully(InputStream, int) in favor of toByteArray(InputStream, int).</action>\n+      <action type=\"fix\" dev=\"pkarwasz\"                due-to=\"Piotr P. Karwasz\">IOUtils.toByteArray(InputStream) now throws IOException on byte array overflow.</action>\n       <!-- ADD -->\n       <action dev=\"ggregory\" type=\"add\"                due-to=\"strangelookingnerd, Gary Gregory\">FileUtils#byteCountToDisplaySize() supports Zettabyte, Yottabyte, Ronnabyte and Quettabyte #763.</action>\n       <action dev=\"ggregory\" type=\"add\"                due-to=\"strangelookingnerd, Gary Gregory\">Add org.apache.commons.io.FileUtils.ONE_RB #763.</action>\ndiff --git a/src/main/java/org/apache/commons/io/IOUtils.java b/src/main/java/org/apache/commons/io/IOUtils.java\nindex eae4cd78ba6..19d498cdcee 100644\n--- a/src/main/java/org/apache/commons/io/IOUtils.java\n+++ b/src/main/java/org/apache/commons/io/IOUtils.java\n@@ -1645,7 +1645,7 @@ public static long copyLarge(final Reader reader, final Writer writer, final lon\n      * @param bufferSize The buffer size of the output stream; must be {@code > 0}.\n      * @return a ByteArrayOutputStream containing the read bytes.\n      */\n-    private static UnsynchronizedByteArrayOutputStream copyToOutputStream(\n+    static UnsynchronizedByteArrayOutputStream copyToOutputStream(\n             final InputStream input, final long limit, final int bufferSize) throws IOException {\n         try (UnsynchronizedByteArrayOutputStream output = UnsynchronizedByteArrayOutputStream.builder()\n                         .setBufferSize(bufferSize)\n@@ -2680,15 +2680,14 @@ public static BufferedReader toBufferedReader(final Reader reader, final int siz\n      *\n      * @param inputStream The {@link InputStream} to read; must not be {@code null}.\n      * @return A new byte array.\n-     * @throws IllegalArgumentException If the size of the stream is greater than the maximum array size.\n-     * @throws IOException              If an I/O error occurs while reading.\n+     * @throws IOException              If an I/O error occurs while reading or if the maximum array size is exceeded.\n      * @throws NullPointerException     If {@code inputStream} is {@code null}.\n      */\n     public static byte[] toByteArray(final InputStream inputStream) throws IOException {\n         // Using SOFT_MAX_ARRAY_LENGTH guarantees that size() will not overflow\n         final UnsynchronizedByteArrayOutputStream output = copyToOutputStream(inputStream, SOFT_MAX_ARRAY_LENGTH + 1, DEFAULT_BUFFER_SIZE);\n         if (output.size() > SOFT_MAX_ARRAY_LENGTH) {\n-            throw new IllegalArgumentException(String.format(\"Cannot read more than %,d into a byte array\", SOFT_MAX_ARRAY_LENGTH));\n+            throw new IOException(String.format(\"Cannot read more than %,d into a byte array\", SOFT_MAX_ARRAY_LENGTH));\n         }\n         return output.toByteArray();\n     }\n",
  "test_patch" : "diff --git a/src/test/java/org/apache/commons/io/IOUtilsTest.java b/src/test/java/org/apache/commons/io/IOUtilsTest.java\nindex 5f256d67eac..ad397ed953b 100644\n--- a/src/test/java/org/apache/commons/io/IOUtilsTest.java\n+++ b/src/test/java/org/apache/commons/io/IOUtilsTest.java\n@@ -27,6 +27,8 @@\n import static org.junit.jupiter.api.Assertions.assertThrows;\n import static org.junit.jupiter.api.Assertions.assertTrue;\n import static org.junit.jupiter.api.Assertions.fail;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n \n import java.io.BufferedInputStream;\n import java.io.BufferedOutputStream;\n@@ -80,6 +82,7 @@\n import org.apache.commons.io.output.NullOutputStream;\n import org.apache.commons.io.output.NullWriter;\n import org.apache.commons.io.output.StringBuilderWriter;\n+import org.apache.commons.io.output.UnsynchronizedByteArrayOutputStream;\n import org.apache.commons.io.test.TestUtils;\n import org.apache.commons.io.test.ThrowOnCloseReader;\n import org.apache.commons.lang3.StringUtils;\n@@ -93,6 +96,8 @@\n import org.junit.jupiter.params.ParameterizedTest;\n import org.junit.jupiter.params.provider.Arguments;\n import org.junit.jupiter.params.provider.MethodSource;\n+import org.mockito.MockedStatic;\n+import org.mockito.Mockito;\n \n /**\n  * This is used to test {@link IOUtils} for correctness. The following checks are performed:\n@@ -1965,4 +1970,23 @@ void testWriteLittleString() throws IOException {\n         }\n     }\n \n+    @Test\n+    void testToByteArray_ThrowsIOExceptionOnHugeStream() {\n+        try (MockedStatic<IOUtils> utils = Mockito.mockStatic(IOUtils.class, Mockito.CALLS_REAL_METHODS)) {\n+            // Prepare the mocks\n+            final UnsynchronizedByteArrayOutputStream mockOutputStream =\n+                    mock(UnsynchronizedByteArrayOutputStream.class);\n+            utils.when(() -> IOUtils.copyToOutputStream(\n+                            Mockito.any(InputStream.class), Mockito.anyLong(), Mockito.anyInt()))\n+                    .thenReturn(mockOutputStream);\n+            when(mockOutputStream.size()).thenReturn(IOUtils.SOFT_MAX_ARRAY_LENGTH + 1);\n+\n+            // Test and check\n+            final InputStream mockInputStream = mock(InputStream.class);\n+            final IOException exception = assertThrows(IOException.class, () -> IOUtils.toByteArray(mockInputStream));\n+            assertTrue(\n+                    exception.getMessage().contains(String.format(\"%,d\", IOUtils.SOFT_MAX_ARRAY_LENGTH)),\n+                    \"Exception message does not contain the maximum length\");\n+        }\n+    }\n }\n",
  "problem_statement" : "fix: replace IAE with IOException on byte array overflow\n\nThe method `IOUtils#toByteArray(InputStream)` previously threw an `IllegalArgumentException` when the number of bytes read exceeded what could be stored in a `byte[]`.\r\n\r\nThis change updates the method to throw an `IOException` instead, which is more semantically appropriate for stream-reading failures. A dedicated test has been added to verify this behavior.\r\n\r\nBefore you push a pull request, review this list:\r\n\r\n- [x] Read the [contribution guidelines](CONTRIBUTING.md) for this project.\r\n- [x] Read the [ASF Generative Tooling Guidance](https://www.apache.org/legal/generative-tooling.html) if you use Artificial Intelligence (AI).\r\n- [x] I used AI to create the mocked unit test.\r\n- [x] Run a successful build using the default [Maven](https://maven.apache.org/) goal with `mvn`; that's `mvn` on the command line by itself.\r\n- [x] Write unit tests that match behavioral changes, where the tests fail if the changes to the runtime are not applied. This may not always be possible, but it is a best-practice.\r\n- [x] Write a pull request description that is detailed enough to understand what the pull request does, how, and why.\r\n- [x] Each commit in the pull request should have a meaningful subject line and body. Note that a maintainer may squash commits during the merge process.\r\n",
  "hints_text" : null,
  "created_at" : "Mon Sep 22 13:33:07 CEST 2025",
  "version" : null,
  "FAIL_TO_PASS" : [ "IOUtilsTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=IOUtilsTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 785,
  "metadata" : null
}, {
  "instance_id" : "apache-commons-io-PR-784",
  "repo" : "apache/commons-io",
  "base_commit" : "886ebfca609d813d7199497a26606f209e607b07",
  "patch" : "diff --git a/src/changes/changes.xml b/src/changes/changes.xml\nindex c28573c784e..0190734a841 100644\n--- a/src/changes/changes.xml\n+++ b/src/changes/changes.xml\n@@ -63,9 +63,10 @@ The <action> type attribute can be add,update,fix,remove.\n       <action dev=\"ggregory\" type=\"add\"                due-to=\"Gary Gregory\">Add org.apache.commons.io.output.ProxyOutputStream.writeRepeat(int, long).</action>\n       <action dev=\"pkarwasz\" type=\"add\"                due-to=\"Piotr P. Karwasz\">Add length unit support in FileSystem limits.</action>\n       <action dev=\"pkarwasz\" type=\"add\"                due-to=\"Piotr P. Karwasz\">Add IOUtils.toByteArray(InputStream, int, int) for safer chunked reading with size validation.</action>\n-      <action dev=\"pkarwasz\" type=\"add\"                due-to=\"Piotr P. Karwasz\">Add org.apache.commons.io.file.PathUtils.getPath(String, String).</action>\n+      <action dev=\"ggregory\" type=\"add\"                due-to=\"Gary Gregory\">Add org.apache.commons.io.file.PathUtils.getPath(String, String).</action>\n       <action dev=\"ggregory\" type=\"add\"                due-to=\"Gary Gregory\">Add org.apache.commons.io.channels.ByteArraySeekableByteChannel.</action>\n       <action dev=\"ggregory\" type=\"add\"                due-to=\"Gary Gregory\">Add IOIterable.asIterable().</action>\n+      <action dev=\"pkarwasz\" type=\"add\"                due-to=\"Piotr P. Karwasz\">Add NIO channel support to `AbstractStreamBuilder`.</action>\n       <action dev=\"pkarwasz\" type=\"add\"                due-to=\"Piotr P. Karwasz\">Add CloseShieldChannel to close-shielded NIO Channels #786.</action>\n       <!-- UPDATE -->\n       <action type=\"update\" dev=\"ggregory\"             due-to=\"Gary Gregory, Dependabot\">Bump org.apache.commons:commons-parent from 85 to 88 #774, #783.</action>\ndiff --git a/src/main/java/org/apache/commons/io/build/AbstractOrigin.java b/src/main/java/org/apache/commons/io/build/AbstractOrigin.java\nindex 3c81bfd38bf..1706076fbaf 100644\n--- a/src/main/java/org/apache/commons/io/build/AbstractOrigin.java\n+++ b/src/main/java/org/apache/commons/io/build/AbstractOrigin.java\n@@ -19,6 +19,7 @@\n \n import java.io.ByteArrayInputStream;\n import java.io.File;\n+import java.io.FileInputStream;\n import java.io.FileNotFoundException;\n import java.io.IOException;\n import java.io.InputStream;\n@@ -29,13 +30,17 @@\n import java.io.Reader;\n import java.io.Writer;\n import java.net.URI;\n+import java.nio.channels.Channel;\n+import java.nio.channels.Channels;\n+import java.nio.channels.ReadableByteChannel;\n+import java.nio.channels.SeekableByteChannel;\n+import java.nio.channels.WritableByteChannel;\n import java.nio.charset.Charset;\n import java.nio.file.Files;\n import java.nio.file.OpenOption;\n import java.nio.file.Path;\n import java.nio.file.Paths;\n import java.nio.file.StandardOpenOption;\n-import java.nio.file.spi.FileSystemProvider;\n import java.util.Arrays;\n import java.util.Objects;\n \n@@ -44,7 +49,7 @@\n import org.apache.commons.io.IOUtils;\n import org.apache.commons.io.RandomAccessFileMode;\n import org.apache.commons.io.RandomAccessFiles;\n-import org.apache.commons.io.file.spi.FileSystemProviders;\n+import org.apache.commons.io.channels.ByteArraySeekableByteChannel;\n import org.apache.commons.io.input.BufferedFileChannelInputStream;\n import org.apache.commons.io.input.CharSequenceInputStream;\n import org.apache.commons.io.input.CharSequenceReader;\n@@ -53,15 +58,270 @@\n import org.apache.commons.io.output.WriterOutputStream;\n \n /**\n- * Abstracts the origin of data for builders like a {@link File}, {@link Path}, {@link Reader}, {@link Writer}, {@link InputStream}, {@link OutputStream}, and\n- * {@link URI}.\n+ * Abstract base class that encapsulates the <em>origin</em> of data used by Commons IO builders.\n  * <p>\n- * Some methods may throw {@link UnsupportedOperationException} if that method is not implemented in a concrete subclass, see {@link #getFile()} and\n- * {@link #getPath()}.\n+ * An origin represents where bytes/characters come from or go to, such as a {@link File}, {@link Path},\n+ * {@link Reader}, {@link Writer}, {@link InputStream}, {@link OutputStream}, or {@link URI}. Concrete subclasses\n+ * expose only the operations that make sense for the underlying source or sink; invoking an unsupported operation\n+ * results in {@link UnsupportedOperationException} (see, for example, {@link #getFile()} and {@link #getPath()}).\n  * </p>\n  *\n- * @param <T> the type of instances to build.\n- * @param <B> the type of builder subclass.\n+ * <p>\n+ * The table below summarizes which views and conversions are supported for each origin type.\n+ * Column headers show the target view; cells indicate whether that view is available from the origin in that row.\n+ * </p>\n+ *\n+ * <table>\n+ *   <caption>Origin support matrix</caption>\n+ *   <thead>\n+ *     <tr>\n+ *       <th>Origin Type</th>\n+ *       <th>byte[]</th>\n+ *       <th>CS</th>\n+ *       <th>File</th>\n+ *       <th>Path</th>\n+ *       <th>RAF</th>\n+ *       <th>IS</th>\n+ *       <th>Reader</th>\n+ *       <th>RBC</th>\n+ *       <th>OS</th>\n+ *       <th>Writer</th>\n+ *       <th>WBC</th>\n+ *       <th>Channel type<sup>2</sup></th>\n+ *     </tr>\n+ *   </thead>\n+ *   <tbody>\n+ *     <tr>\n+ *       <td>byte[]</td>\n+ *       <td>âœ”</td>\n+ *       <td>âœ”</td>\n+ *       <td>âœ–</td>\n+ *       <td>âœ–</td>\n+ *       <td>âœ–</td>\n+ *       <td>âœ”</td>\n+ *       <td>âœ”</td>\n+ *       <td>âœ”</td>\n+ *       <td>âœ–</td>\n+ *       <td>âœ–</td>\n+ *       <td>âœ–</td>\n+ *       <td>SBC</td>\n+ *     </tr>\n+ *     <tr>\n+ *       <td>CharSequence (CS)</td>\n+ *       <td>âœ”</td>\n+ *       <td>âœ”</td>\n+ *       <td>âœ–</td>\n+ *       <td>âœ–</td>\n+ *       <td>âœ–</td>\n+ *       <td>âœ”<sup>1</sup></td>\n+ *       <td>âœ”</td>\n+ *       <td>âœ”<sup>1</sup></td>\n+ *       <td>âœ–</td>\n+ *       <td>âœ–</td>\n+ *       <td>âœ–</td>\n+ *       <td>SBC</td>\n+ *     </tr>\n+ *     <tr>\n+ *       <td>File</td>\n+ *       <td>âœ”</td>\n+ *       <td>âœ”</td>\n+ *       <td>âœ”</td>\n+ *       <td>âœ”</td>\n+ *       <td>âœ”</td>\n+ *       <td>âœ”</td>\n+ *       <td>âœ”</td>\n+ *       <td>âœ”</td>\n+ *       <td>âœ”</td>\n+ *       <td>âœ”</td>\n+ *       <td>âœ”</td>\n+ *       <td>FC</td>\n+ *     </tr>\n+ *     <tr>\n+ *       <td>Path</td>\n+ *       <td>âœ”</td>\n+ *       <td>âœ”</td>\n+ *       <td>âœ”</td>\n+ *       <td>âœ”</td>\n+ *       <td>âœ”</td>\n+ *       <td>âœ”</td>\n+ *       <td>âœ”</td>\n+ *       <td>âœ”</td>\n+ *       <td>âœ”</td>\n+ *       <td>âœ”</td>\n+ *       <td>âœ”</td>\n+ *       <td>FC</td>\n+ *     </tr>\n+ *     <tr>\n+ *       <td>IORandomAccessFile</td>\n+ *       <td>âœ”</td>\n+ *       <td>âœ”</td>\n+ *       <td>âœ”</td>\n+ *       <td>âœ”</td>\n+ *       <td>âœ”</td>\n+ *       <td>âœ”</td>\n+ *       <td>âœ”</td>\n+ *       <td>âœ”</td>\n+ *       <td>âœ”</td>\n+ *       <td>âœ”</td>\n+ *       <td>âœ”</td>\n+ *       <td>FC</td>\n+ *     </tr>\n+ *     <tr>\n+ *       <td>RandomAccessFile (RAF)</td>\n+ *       <td>âœ”</td>\n+ *       <td>âœ”</td>\n+ *       <td>âœ–</td>\n+ *       <td>âœ–</td>\n+ *       <td>âœ”</td>\n+ *       <td>âœ”</td>\n+ *       <td>âœ”</td>\n+ *       <td>âœ”</td>\n+ *       <td>âœ”</td>\n+ *       <td>âœ”</td>\n+ *       <td>âœ”</td>\n+ *       <td>FC</td>\n+ *     </tr>\n+ *     <tr>\n+ *       <td>InputStream (IS)</td>\n+ *       <td>âœ”</td>\n+ *       <td>âœ”</td>\n+ *       <td>âœ–</td>\n+ *       <td>âœ–</td>\n+ *       <td>âœ–</td>\n+ *       <td>âœ”</td>\n+ *       <td>âœ”</td>\n+ *       <td>âœ”</td>\n+ *       <td>âœ–</td>\n+ *       <td>âœ–</td>\n+ *       <td>âœ–</td>\n+ *       <td>RBC</td>\n+ *     </tr>\n+ *     <tr>\n+ *       <td>Reader</td>\n+ *       <td>âœ”</td>\n+ *       <td>âœ”</td>\n+ *       <td>âœ–</td>\n+ *       <td>âœ–</td>\n+ *       <td>âœ–</td>\n+ *       <td>âœ”<sup>1</sup></td>\n+ *       <td>âœ”</td>\n+ *       <td>âœ”<sup>1</sup></td>\n+ *       <td>âœ–</td>\n+ *       <td>âœ–</td>\n+ *       <td>âœ–</td>\n+ *       <td>RBC</td>\n+ *     </tr>\n+ *     <tr>\n+ *       <td>ReadableByteChannel (RBC)</td>\n+ *       <td>âœ”</td>\n+ *       <td>âœ”</td>\n+ *       <td>âœ–</td>\n+ *       <td>âœ–</td>\n+ *       <td>âœ–</td>\n+ *       <td>âœ”</td>\n+ *       <td>âœ”</td>\n+ *       <td>âœ”</td>\n+ *       <td>âœ–</td>\n+ *       <td>âœ–</td>\n+ *       <td>âœ–</td>\n+ *       <td>RBC</td>\n+ *     </tr>\n+ *     <tr>\n+ *       <td>OutputStream (OS)</td>\n+ *       <td>âœ–</td>\n+ *       <td>âœ–</td>\n+ *       <td>âœ–</td>\n+ *       <td>âœ–</td>\n+ *       <td>âœ–</td>\n+ *       <td>âœ–</td>\n+ *       <td>âœ–</td>\n+ *       <td>âœ–</td>\n+ *       <td>âœ”</td>\n+ *       <td>âœ”</td>\n+ *       <td>âœ”</td>\n+ *       <td>WBC</td>\n+ *     </tr>\n+ *     <tr>\n+ *       <td>Writer</td>\n+ *       <td>âœ–</td>\n+ *       <td>âœ–</td>\n+ *       <td>âœ–</td>\n+ *       <td>âœ–</td>\n+ *       <td>âœ–</td>\n+ *       <td>âœ–</td>\n+ *       <td>âœ–</td>\n+ *       <td>âœ–</td>\n+ *       <td>âœ”<sup>1</sup></td>\n+ *       <td>âœ”</td>\n+ *       <td>âœ”<sup>1</sup></td>\n+ *       <td>WBC</td>\n+ *     </tr>\n+ *     <tr>\n+ *       <td>WritableByteChannel (WBC)</td>\n+ *       <td>âœ–</td>\n+ *       <td>âœ–</td>\n+ *       <td>âœ–</td>\n+ *       <td>âœ–</td>\n+ *       <td>âœ–</td>\n+ *       <td>âœ–</td>\n+ *       <td>âœ–</td>\n+ *       <td>âœ–</td>\n+ *       <td>âœ”</td>\n+ *       <td>âœ”</td>\n+ *       <td>âœ”</td>\n+ *       <td>WBC</td>\n+ *     </tr>\n+ *     <tr>\n+ *       <td>URI (FileSystem)</td>\n+ *       <td>âœ”</td>\n+ *       <td>âœ”</td>\n+ *       <td>âœ”</td>\n+ *       <td>âœ”</td>\n+ *       <td>âœ”</td>\n+ *       <td>âœ”</td>\n+ *       <td>âœ”</td>\n+ *       <td>âœ”</td>\n+ *       <td>âœ”</td>\n+ *       <td>âœ”</td>\n+ *       <td>âœ”</td>\n+ *       <td>FC</td>\n+ *     </tr>\n+ *     <tr>\n+ *       <td>URI (http/https))</td>\n+ *       <td>âœ”</td>\n+ *       <td>âœ”</td>\n+ *       <td>âœ–</td>\n+ *       <td>âœ–</td>\n+ *       <td>âœ–</td>\n+ *       <td>âœ”</td>\n+ *       <td>âœ”</td>\n+ *       <td>âœ”</td>\n+ *       <td>âœ–</td>\n+ *       <td>âœ–</td>\n+ *       <td>âœ–</td>\n+ *       <td>RBC</td>\n+ *     </tr>\n+ *   </tbody>\n+ * </table>\n+ *\n+ * <p><strong>Legend</strong></p>\n+ * <ul>\n+ *   <li>âœ” = Supported</li>\n+ *   <li>âœ– = Not supported (throws {@link UnsupportedOperationException})</li>\n+ *   <li><sup>1</sup> = Characters are converted to bytes using the default {@link Charset}.</li>\n+ *   <li><sup>2</sup> Minimum channel type provided by the origin:\n+ *     <ul>\n+ *         <li>RBC = ReadableByteChannel</li>\n+ *         <li>WBC = WritableByteChannel</li>\n+ *         <li>SBC = SeekableByteChannel</li>\n+ *         <li>FC = FileChannel</li>\n+ *     </ul>\n+ *     The exact channel type may be a subtype of the minimum shown.\n+ *   </li>\n+ * </ul>\n+ *\n+ * @param <T> the type produced by the builder.\n+ * @param <B> the concrete builder subclass type.\n  * @since 2.12.0\n  */\n public abstract class AbstractOrigin<T, B extends AbstractOrigin<T, B>> extends AbstractSupplier<T, B> {\n@@ -137,6 +397,11 @@ public Writer getWriter(final Charset charset, final OpenOption... options) thro\n             return new OutputStreamWriter(getOutputStream(options), Charsets.toCharset(charset));\n         }\n \n+        @Override\n+        protected Channel getChannel(OpenOption... options) throws IOException {\n+            return getRandomAccessFile(options).getChannel();\n+        }\n+\n         @Override\n         public long size() throws IOException {\n             return origin.length();\n@@ -179,6 +444,17 @@ public Reader getReader(final Charset charset) throws IOException {\n             return new InputStreamReader(getInputStream(), Charsets.toCharset(charset));\n         }\n \n+        @Override\n+        protected Channel getChannel(OpenOption... options) throws IOException {\n+            for (final OpenOption option : options) {\n+                if (option == StandardOpenOption.WRITE) {\n+                    throw new UnsupportedOperationException(\n+                            \"Only READ is supported for byte[] origins: \" + Arrays.toString(options));\n+                }\n+            }\n+            return ByteArraySeekableByteChannel.wrap(getByteArray());\n+        }\n+\n         @Override\n         public long size() throws IOException {\n             return origin.length;\n@@ -241,6 +517,17 @@ public Reader getReader(final Charset charset) throws IOException {\n             return new CharSequenceReader(get());\n         }\n \n+        @Override\n+        protected Channel getChannel(OpenOption... options) throws IOException {\n+            for (final OpenOption option : options) {\n+                if (option == StandardOpenOption.WRITE) {\n+                    throw new UnsupportedOperationException(\n+                            \"Only READ is supported for CharSequence origins: \" + Arrays.toString(options));\n+                }\n+            }\n+            return ByteArraySeekableByteChannel.wrap(getByteArray());\n+        }\n+\n         @Override\n         public long size() throws IOException {\n             return origin.length();\n@@ -283,6 +570,10 @@ public Path getPath() {\n             return get().toPath();\n         }\n \n+        @Override\n+        protected Channel getChannel(OpenOption... options) throws IOException {\n+            return Files.newByteChannel(getPath(), options);\n+        }\n     }\n \n     /**\n@@ -324,6 +615,19 @@ public Reader getReader(final Charset charset) throws IOException {\n             return new InputStreamReader(getInputStream(), Charsets.toCharset(charset));\n         }\n \n+        @Override\n+        protected Channel getChannel(OpenOption... options) throws IOException {\n+            return Channels.newChannel(getInputStream(options));\n+        }\n+\n+        @Override\n+        public long size() throws IOException {\n+            if (origin instanceof FileInputStream) {\n+                final FileInputStream fileInputStream = (FileInputStream) origin;\n+                return fileInputStream.getChannel().size();\n+            }\n+            throw unsupportedOperation(\"size\");\n+        }\n     }\n \n     /**\n@@ -394,6 +698,11 @@ public OutputStream getOutputStream(final OpenOption... options) {\n         public Writer getWriter(final Charset charset, final OpenOption... options) throws IOException {\n             return new OutputStreamWriter(origin, Charsets.toCharset(charset));\n         }\n+\n+        @Override\n+        protected Channel getChannel(OpenOption... options) throws IOException {\n+            return Channels.newChannel(getOutputStream(options));\n+        }\n     }\n \n     /**\n@@ -429,6 +738,10 @@ public Path getPath() {\n             return get();\n         }\n \n+        @Override\n+        protected Channel getChannel(OpenOption... options) throws IOException {\n+            return Files.newByteChannel(getPath(), options);\n+        }\n     }\n \n     /**\n@@ -511,6 +824,11 @@ public Reader getReader(final Charset charset) throws IOException {\n             // No conversion\n             return get();\n         }\n+\n+        @Override\n+        protected Channel getChannel(OpenOption... options) throws IOException {\n+            return Channels.newChannel(getInputStream());\n+        }\n     }\n \n     /**\n@@ -539,10 +857,6 @@ public File getFile() {\n         public InputStream getInputStream(final OpenOption... options) throws IOException {\n             final URI uri = get();\n             final String scheme = uri.getScheme();\n-            final FileSystemProvider fileSystemProvider = FileSystemProviders.installed().getFileSystemProvider(scheme);\n-            if (fileSystemProvider != null) {\n-                return Files.newInputStream(fileSystemProvider.getPath(uri), options);\n-            }\n             if (SCHEME_HTTP.equalsIgnoreCase(scheme) || SCHEME_HTTPS.equalsIgnoreCase(scheme)) {\n                 return uri.toURL().openStream();\n             }\n@@ -553,6 +867,16 @@ public InputStream getInputStream(final OpenOption... options) throws IOExceptio\n         public Path getPath() {\n             return Paths.get(get());\n         }\n+\n+        @Override\n+        protected Channel getChannel(OpenOption... options) throws IOException {\n+            final URI uri = get();\n+            final String scheme = uri.getScheme();\n+            if (SCHEME_HTTP.equalsIgnoreCase(scheme) || SCHEME_HTTPS.equalsIgnoreCase(scheme)) {\n+                return Channels.newChannel(uri.toURL().openStream());\n+            }\n+            return Files.newByteChannel(getPath(), options);\n+        }\n     }\n \n     /**\n@@ -598,6 +922,73 @@ public Writer getWriter(final Charset charset, final OpenOption... options) thro\n             // No conversion\n             return get();\n         }\n+\n+        @Override\n+        protected Channel getChannel(OpenOption... options) throws IOException {\n+            return Channels.newChannel(getOutputStream());\n+        }\n+    }\n+\n+    /**\n+     * A {@link Channel} origin.\n+     *\n+     * @since 2.21.0\n+     */\n+    public static class ChannelOrigin extends AbstractOrigin<Channel, ChannelOrigin> {\n+\n+        /**\n+         * Constructs a new instance for the given origin.\n+         *\n+         * @param origin The origin, not null.\n+         */\n+        public ChannelOrigin(final Channel origin) {\n+            super(origin);\n+        }\n+\n+        @Override\n+        public byte[] getByteArray() throws IOException {\n+            return IOUtils.toByteArray(getInputStream());\n+        }\n+\n+        @Override\n+        public InputStream getInputStream(final OpenOption... options) throws IOException {\n+            return Channels.newInputStream(getChannel(ReadableByteChannel.class, options));\n+        }\n+\n+        @Override\n+        public Reader getReader(Charset charset) throws IOException {\n+            return Channels.newReader(\n+                    getChannel(ReadableByteChannel.class),\n+                    Charsets.toCharset(charset).newDecoder(),\n+                    -1);\n+        }\n+\n+        @Override\n+        public OutputStream getOutputStream(final OpenOption... options) throws IOException {\n+            return Channels.newOutputStream(getChannel(WritableByteChannel.class, options));\n+        }\n+\n+        @Override\n+        public Writer getWriter(Charset charset, OpenOption... options) throws IOException {\n+            return Channels.newWriter(\n+                    getChannel(WritableByteChannel.class, options),\n+                    Charsets.toCharset(charset).newEncoder(),\n+                    -1);\n+        }\n+\n+        @Override\n+        protected Channel getChannel(OpenOption... options) throws IOException {\n+            // No conversion\n+            return get();\n+        }\n+\n+        @Override\n+        public long size() throws IOException {\n+            if (origin instanceof SeekableByteChannel) {\n+                return ((SeekableByteChannel) origin).size();\n+            }\n+            throw unsupportedOperation(\"size\");\n+        }\n     }\n \n     /**\n@@ -675,8 +1066,7 @@ public CharSequence getCharSequence(final Charset charset) throws IOException {\n      * @throws UnsupportedOperationException if this method is not implemented in a concrete subclass.\n      */\n     public File getFile() {\n-        throw new UnsupportedOperationException(\n-                String.format(\"%s#getFile() for %s origin %s\", getSimpleClassName(), origin.getClass().getSimpleName(), origin));\n+        throw unsupportedOperation(\"getFile\");\n     }\n \n     /**\n@@ -710,8 +1100,7 @@ public OutputStream getOutputStream(final OpenOption... options) throws IOExcept\n      * @throws UnsupportedOperationException if this method is not implemented in a concrete subclass.\n      */\n     public Path getPath() {\n-        throw new UnsupportedOperationException(\n-                String.format(\"%s#getPath() for %s origin %s\", getSimpleClassName(), origin.getClass().getSimpleName(), origin));\n+        throw unsupportedOperation(\"getPath\");\n     }\n \n     /**\n@@ -755,6 +1144,39 @@ public Writer getWriter(final Charset charset, final OpenOption... options) thro\n         return Files.newBufferedWriter(getPath(), Charsets.toCharset(charset), options);\n     }\n \n+    /**\n+     * Gets this origin as a Channel of the given type, if possible.\n+     *\n+     * @param channelType The type of channel to return.\n+     * @param options Options specifying how a file-based origin is opened, ignored otherwise.\n+     * @return A new Channel on the origin of the given type.\n+     * @param <C> The type of channel to return.\n+     * @throws IOException                   If an I/O error occurs.\n+     * @throws UnsupportedOperationException If this origin cannot be converted to a channel of the given type.\n+     * @since 2.21.0\n+     */\n+    public final <C extends Channel> C getChannel(Class<C> channelType, OpenOption... options) throws IOException {\n+        Objects.requireNonNull(channelType, \"channelType\");\n+        final Channel channel = getChannel(options);\n+        if (channelType.isInstance(channel)) {\n+            return channelType.cast(channel);\n+        }\n+        throw unsupportedChannelType(channelType);\n+    }\n+\n+    /**\n+     * Gets this origin as a Channel, if possible.\n+     *\n+     * @param options Options specifying how a file-based origin is opened, ignored otherwise.\n+     * @return A new Channel on the origin.\n+     * @throws IOException                   If an I/O error occurs.\n+     * @throws UnsupportedOperationException If this origin cannot be converted to a channel.\n+     * @since 2.21.0\n+     */\n+    protected Channel getChannel(OpenOption... options) throws IOException {\n+        throw unsupportedOperation(\"getChannel\");\n+    }\n+\n     /**\n      * Gets the size of the origin, if possible.\n      *\n@@ -770,4 +1192,19 @@ public long size() throws IOException {\n     public String toString() {\n         return getSimpleClassName() + \"[\" + origin.toString() + \"]\";\n     }\n+\n+    UnsupportedOperationException unsupportedOperation(String method) {\n+        return new UnsupportedOperationException(String.format(\n+                \"%s#%s() for %s origin %s\",\n+                getSimpleClassName(), method, origin.getClass().getSimpleName(), origin));\n+    }\n+\n+    UnsupportedOperationException unsupportedChannelType(Class<? extends Channel> channelType) {\n+        return new UnsupportedOperationException(String.format(\n+                \"%s#getChannel(%s) for %s origin %s\",\n+                getSimpleClassName(),\n+                channelType.getSimpleName(),\n+                origin.getClass().getSimpleName(),\n+                origin));\n+    }\n }\ndiff --git a/src/main/java/org/apache/commons/io/build/AbstractOriginSupplier.java b/src/main/java/org/apache/commons/io/build/AbstractOriginSupplier.java\nindex 8f2354d95bf..6f14fac3bfc 100644\n--- a/src/main/java/org/apache/commons/io/build/AbstractOriginSupplier.java\n+++ b/src/main/java/org/apache/commons/io/build/AbstractOriginSupplier.java\n@@ -24,11 +24,13 @@\n import java.io.Reader;\n import java.io.Writer;\n import java.net.URI;\n+import java.nio.channels.Channel;\n import java.nio.file.Path;\n import java.nio.file.Paths;\n \n import org.apache.commons.io.IORandomAccessFile;\n import org.apache.commons.io.build.AbstractOrigin.ByteArrayOrigin;\n+import org.apache.commons.io.build.AbstractOrigin.ChannelOrigin;\n import org.apache.commons.io.build.AbstractOrigin.CharSequenceOrigin;\n import org.apache.commons.io.build.AbstractOrigin.FileOrigin;\n import org.apache.commons.io.build.AbstractOrigin.IORandomAccessFileOrigin;\n@@ -182,6 +184,17 @@ protected static WriterOrigin newWriterOrigin(final Writer origin) {\n         return new WriterOrigin(origin);\n     }\n \n+    /**\n+     * Constructs a new channel origin for a channel.\n+     *\n+     * @param origin the channel.\n+     * @return a new channel origin.\n+     * @since 2.21.0\n+     */\n+    protected static ChannelOrigin newChannelOrigin(final Channel origin) {\n+        return new ChannelOrigin(origin);\n+    }\n+\n     /**\n      * The underlying origin.\n      */\n@@ -368,4 +381,15 @@ public B setURI(final URI origin) {\n     public B setWriter(final Writer origin) {\n         return setOrigin(newWriterOrigin(origin));\n     }\n+\n+    /**\n+     * Sets a new origin.\n+     *\n+     * @param origin the new origin.\n+     * @return {@code this} instance.\n+     * @since 2.21.0\n+     */\n+    public B setChannel(final Channel origin) {\n+        return setOrigin(newChannelOrigin(origin));\n+    }\n }\ndiff --git a/src/main/java/org/apache/commons/io/build/AbstractStreamBuilder.java b/src/main/java/org/apache/commons/io/build/AbstractStreamBuilder.java\nindex 3feac4a6533..fe37c5eedab 100644\n--- a/src/main/java/org/apache/commons/io/build/AbstractStreamBuilder.java\n+++ b/src/main/java/org/apache/commons/io/build/AbstractStreamBuilder.java\n@@ -24,6 +24,8 @@\n import java.io.RandomAccessFile;\n import java.io.Reader;\n import java.io.Writer;\n+import java.nio.channels.Channel;\n+import java.nio.channels.ReadableByteChannel;\n import java.nio.charset.Charset;\n import java.nio.file.OpenOption;\n import java.nio.file.Path;\n@@ -258,6 +260,23 @@ public Writer getWriter() throws IOException {\n         return checkOrigin().getWriter(getCharset(), getOpenOptions());\n     }\n \n+    /**\n+     * Gets a Channel from the origin with OpenOption[].\n+     *\n+     * @param channelType The channel type, not null.\n+     * @return A channel of the specified type.\n+     * @param <C>         The channel type.\n+     * @throws IllegalStateException         if the {@code origin} is {@code null}.\n+     * @throws UnsupportedOperationException if the origin cannot be converted to a {@link ReadableByteChannel}.\n+     * @throws IOException                   if an I/O error occurs.\n+     * @see AbstractOrigin#getChannel\n+     * @see #getOpenOptions()\n+     * @since 2.21.0\n+     */\n+    public <C extends Channel> C getChannel(Class<C> channelType) throws IOException {\n+        return checkOrigin().getChannel(channelType, getOpenOptions());\n+    }\n+\n     /**\n      * Sets the buffer size. Invalid input (bufferSize &lt;= 0) resets the value to its default.\n      * <p>\ndiff --git a/src/main/java/org/apache/commons/io/channels/ByteArraySeekableByteChannel.java b/src/main/java/org/apache/commons/io/channels/ByteArraySeekableByteChannel.java\nindex 51e8c182447..d1aff851500 100644\n--- a/src/main/java/org/apache/commons/io/channels/ByteArraySeekableByteChannel.java\n+++ b/src/main/java/org/apache/commons/io/channels/ByteArraySeekableByteChannel.java\n@@ -19,12 +19,14 @@\n \n package org.apache.commons.io.channels;\n \n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n import java.io.IOException;\n import java.nio.ByteBuffer;\n import java.nio.channels.ClosedChannelException;\n import java.nio.channels.SeekableByteChannel;\n import java.util.Arrays;\n-import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.Objects;\n import java.util.concurrent.locks.ReentrantLock;\n \n import org.apache.commons.io.IOUtils;\n@@ -37,41 +39,73 @@\n  * accessed via {@link ByteArraySeekableByteChannel#array()}.\n  * </p>\n  *\n- * @since 2.19.0\n+ * @since 2.21.0\n  */\n public class ByteArraySeekableByteChannel implements SeekableByteChannel {\n \n     private static final int RESIZE_LIMIT = Integer.MAX_VALUE >> 1;\n+\n+    /**\n+     * Constructs a new channel backed directly by the given byte array.\n+     *\n+     * <p>The channel initially contains the full contents of the array, with its\n+     * size set to {@code bytes.length} and its position set to {@code 0}.</p>\n+     *\n+     * <p>Reads and writes operate on the shared array.\n+     * If a write operation extends beyond the current capacity, the channel will\n+     * automatically allocate a larger backing array and copy the existing contents.</p>\n+     *\n+     * @param bytes The byte array to wrap, must not be {@code null}\n+     * @return A new channel that uses the given array as its initial backing store\n+     * @throws NullPointerException If {@code bytes} is {@code null}\n+     * @see #array()\n+     * @see ByteArrayInputStream#ByteArrayInputStream(byte[])\n+     */\n+    public static ByteArraySeekableByteChannel wrap(byte[] bytes) {\n+        Objects.requireNonNull(bytes, \"bytes\");\n+        return new ByteArraySeekableByteChannel(bytes);\n+    }\n+\n     private byte[] data;\n-    private final AtomicBoolean closed = new AtomicBoolean();\n+    private volatile boolean closed;\n     private int position;\n     private int size;\n     private final ReentrantLock lock = new ReentrantLock();\n \n     /**\n-     * Constructs a new instance using a default empty buffer.\n+     * Constructs a new instance, with a default internal buffer capacity.\n+     * <p>\n+     * The initial size and position of the channel are 0.\n+     * </p>\n+     *\n+     * @see ByteArrayOutputStream#ByteArrayOutputStream()\n      */\n     public ByteArraySeekableByteChannel() {\n-        this(0);\n+        this(IOUtils.DEFAULT_BUFFER_SIZE);\n     }\n \n     /**\n-     * Constructs a new instance from a byte array.\n+     * Constructs a new instance, with an internal buffer of the given capacity, in bytes.\n+     * <p>\n+     * The initial size and position of the channel are 0.\n+     * </p>\n      *\n-     * @param data input data or pre-allocated array.\n+     * @param size Capacity of the internal buffer to allocate, in bytes.\n+     * @see ByteArrayOutputStream#ByteArrayOutputStream(int)\n      */\n-    public ByteArraySeekableByteChannel(final byte[] data) {\n-        this.data = data;\n-        this.size = data.length;\n+    public ByteArraySeekableByteChannel(final int size) {\n+        if (size < 0) {\n+            throw new IllegalArgumentException(\"Size must be non-negative\");\n+        }\n+        this.data = new byte[size];\n+        this.position = 0;\n+        this.size = 0;\n     }\n \n-    /**\n-     * Constructs a new instance from a size of storage to be allocated.\n-     *\n-     * @param size size of internal buffer to allocate, in bytes.\n-     */\n-    public ByteArraySeekableByteChannel(final int size) {\n-        this(new byte[size]);\n+    private ByteArraySeekableByteChannel(byte[] data) {\n+        this.data = data;\n+        this.position = 0;\n+        this.size = data.length;\n     }\n \n     /**\n@@ -86,6 +120,18 @@ public byte[] array() {\n         return data;\n     }\n \n+    /**\n+     * Gets a copy of the data stored in this channel.\n+     * <p>\n+     * The returned array is a copy of the internal buffer, sized to the actual data stored in this channel.\n+     * </p>\n+     *\n+     * @return a new byte array containing the data stored in this channel.\n+     */\n+    public byte[] toByteArray() {\n+        return Arrays.copyOf(data, size);\n+    }\n+\n     private void checkOpen() throws ClosedChannelException {\n         if (!isOpen()) {\n             throw new ClosedChannelException();\n@@ -101,7 +147,7 @@ private int checkRange(final long newSize, final String method) {\n \n     @Override\n     public void close() {\n-        closed.set(true);\n+        closed = true;\n     }\n \n     /**\n@@ -115,7 +161,7 @@ public long getSize() {\n \n     @Override\n     public boolean isOpen() {\n-        return !closed.get();\n+        return !closed;\n     }\n \n     @Override\n@@ -165,7 +211,7 @@ public int read(final ByteBuffer buf) throws IOException {\n \n     private void resize(final int newLength) {\n         int len = data.length;\n-        if (len <= 0) {\n+        if (len == 0) {\n             len = 1;\n         }\n         if (newLength < RESIZE_LIMIT) {\n@@ -212,13 +258,12 @@ public int write(final ByteBuffer b) throws IOException {\n         checkOpen();\n         lock.lock();\n         try {\n-            int wanted = b.remaining();\n-            final int possibleWithoutResize = size - position;\n+            final int wanted = b.remaining();\n+            final int possibleWithoutResize = Math.max(0, size - position);\n             if (wanted > possibleWithoutResize) {\n                 final int newSize = position + wanted;\n-                if (newSize < 0) { // overflow\n-                    resize(IOUtils.SOFT_MAX_ARRAY_LENGTH);\n-                    wanted = IOUtils.SOFT_MAX_ARRAY_LENGTH - position;\n+                if (newSize < 0 || newSize > IOUtils.SOFT_MAX_ARRAY_LENGTH) { // overflow\n+                    throw new OutOfMemoryError(\"required array size \" + Integer.toUnsignedString(newSize) + \" too large\");\n                 } else {\n                     resize(newSize);\n                 }\n",
  "test_patch" : "diff --git a/src/test/java/org/apache/commons/io/build/AbstractOriginTest.java b/src/test/java/org/apache/commons/io/build/AbstractOriginTest.java\nindex e55da41d39f..4f7d0e97f8b 100644\n--- a/src/test/java/org/apache/commons/io/build/AbstractOriginTest.java\n+++ b/src/test/java/org/apache/commons/io/build/AbstractOriginTest.java\n@@ -23,6 +23,7 @@\n import static org.junit.jupiter.api.Assertions.assertNotNull;\n import static org.junit.jupiter.api.Assertions.assertTrue;\n \n+import java.io.Closeable;\n import java.io.File;\n import java.io.IOException;\n import java.io.InputStream;\n@@ -30,18 +31,25 @@\n import java.io.RandomAccessFile;\n import java.io.Reader;\n import java.io.Writer;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ReadableByteChannel;\n+import java.nio.channels.SeekableByteChannel;\n+import java.nio.channels.WritableByteChannel;\n import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n import java.nio.file.Files;\n import java.nio.file.OpenOption;\n import java.nio.file.Path;\n-import java.nio.file.Paths;\n import java.nio.file.StandardOpenOption;\n import java.util.Objects;\n \n import org.apache.commons.io.FileUtils;\n+import org.apache.commons.io.IOUtils;\n import org.apache.commons.io.build.AbstractOrigin.RandomAccessFileOrigin;\n+import org.junit.jupiter.api.AfterEach;\n import org.junit.jupiter.api.BeforeEach;\n import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.io.TempDir;\n import org.junit.jupiter.params.ParameterizedTest;\n import org.junit.jupiter.params.provider.EnumSource;\n \n@@ -55,18 +63,34 @@ public abstract class AbstractOriginTest<T, B extends AbstractOrigin<T, B>> {\n \n     protected static final String FILE_RES_RO = \"/org/apache/commons/io/test-file-20byteslength.bin\";\n     protected static final String FILE_NAME_RO = \"src/test/resources\" + FILE_RES_RO;\n-    protected static final String FILE_NAME_RW = \"target/\" + AbstractOriginTest.class.getSimpleName() + \".txt\";\n+    protected static final String FILE_NAME_RW = AbstractOriginTest.class.getSimpleName() + \".txt\";\n     private static final int RO_LENGTH = 20;\n \n     protected AbstractOrigin<T, B> originRo;\n     protected AbstractOrigin<T, B> originRw;\n \n+    @TempDir\n+    protected Path tempPath;\n+\n     @BeforeEach\n-    public void beforeEach() throws IOException {\n+    void beforeEach() throws IOException {\n         setOriginRo(newOriginRo());\n+        resetOriginRw();\n         setOriginRw(newOriginRw());\n     }\n \n+    @AfterEach\n+    void cleanup() {\n+        final T originRo = getOriginRo().get();\n+        if (originRo instanceof Closeable) {\n+            IOUtils.closeQuietly((Closeable) originRo);\n+        }\n+        final T originRw = getOriginRw().get();\n+        if (originRw instanceof Closeable) {\n+            IOUtils.closeQuietly((Closeable) originRw);\n+        }\n+    }\n+\n     protected AbstractOrigin<T, B> getOriginRo() {\n         return Objects.requireNonNull(originRo, \"originRo\");\n     }\n@@ -92,9 +116,21 @@ protected void setOriginRw(final AbstractOrigin<T, B> origin) {\n         this.originRw = origin;\n     }\n \n+    protected void resetOriginRw() throws IOException {\n+        // No-op\n+    }\n+\n+    byte[] getFixtureByteArray() throws IOException {\n+        return IOUtils.resourceToByteArray(FILE_RES_RO);\n+    }\n+\n+    String getFixtureString() throws IOException {\n+        return IOUtils.resourceToString(FILE_RES_RO, StandardCharsets.UTF_8);\n+    }\n+\n     @Test\n     void testGetByteArray() throws IOException {\n-        assertArrayEquals(Files.readAllBytes(Paths.get(FILE_NAME_RO)), getOriginRo().getByteArray());\n+        assertArrayEquals(getFixtureByteArray(), getOriginRo().getByteArray());\n     }\n \n     @Test\n@@ -114,7 +150,9 @@ void testGetByteArrayAt_1_1() throws IOException {\n \n     @Test\n     void testGetCharSequence() throws IOException {\n-        assertNotNull(getOriginRo().getCharSequence(Charset.defaultCharset()));\n+        final CharSequence charSequence = getOriginRo().getCharSequence(StandardCharsets.UTF_8);\n+        assertNotNull(charSequence);\n+        assertEquals(getFixtureString(), charSequence.toString());\n     }\n \n     @Test\n@@ -135,6 +173,7 @@ private void testGetFile(final File file, final long expectedLen) throws IOExcep\n     void testGetInputStream() throws IOException {\n         try (InputStream inputStream = getOriginRo().getInputStream()) {\n             assertNotNull(inputStream);\n+            assertArrayEquals(getFixtureByteArray(), IOUtils.toByteArray(inputStream));\n         }\n     }\n \n@@ -224,9 +263,15 @@ void testGetReader() throws IOException {\n         try (Reader reader = getOriginRo().getReader(Charset.defaultCharset())) {\n             assertNotNull(reader);\n         }\n+        setOriginRo(newOriginRo());\n         try (Reader reader = getOriginRo().getReader(null)) {\n             assertNotNull(reader);\n         }\n+        setOriginRo(newOriginRo());\n+        try (Reader reader = getOriginRo().getReader(StandardCharsets.UTF_8)) {\n+            assertNotNull(reader);\n+            assertEquals(getFixtureString(), IOUtils.toString(reader));\n+        }\n     }\n \n     @Test\n@@ -240,8 +285,96 @@ void testGetWriter() throws IOException {\n         }\n     }\n \n+    @Test\n+    void testGetReadableByteChannel() throws IOException {\n+        try (ReadableByteChannel channel =\n+                getOriginRo().getChannel(ReadableByteChannel.class, StandardOpenOption.READ)) {\n+            final SeekableByteChannel seekable =\n+                    channel instanceof SeekableByteChannel ? (SeekableByteChannel) channel : null;\n+            assertNotNull(channel);\n+            assertTrue(channel.isOpen());\n+            if (seekable != null) {\n+                assertEquals(0, seekable.position());\n+                assertEquals(RO_LENGTH, seekable.size());\n+            }\n+            checkRead(channel);\n+            if (seekable != null) {\n+                assertEquals(RO_LENGTH, seekable.position());\n+            }\n+        }\n+    }\n+\n+    private void checkRead(ReadableByteChannel channel) throws IOException {\n+        final ByteBuffer buffer = ByteBuffer.allocate(RO_LENGTH);\n+        int read = channel.read(buffer);\n+        assertEquals(RO_LENGTH, read);\n+        assertArrayEquals(getFixtureByteArray(), buffer.array());\n+        // Channel is at EOF\n+        buffer.clear();\n+        read = channel.read(buffer);\n+        assertEquals(-1, read);\n+    }\n+\n+    @Test\n+    void testGetWritableByteChannel() throws IOException {\n+        final boolean supportsRead;\n+        try (WritableByteChannel channel =\n+                getOriginRw().getChannel(WritableByteChannel.class, StandardOpenOption.WRITE)) {\n+            supportsRead = channel instanceof ReadableByteChannel;\n+            final SeekableByteChannel seekable =\n+                    channel instanceof SeekableByteChannel ? (SeekableByteChannel) channel : null;\n+            assertNotNull(channel);\n+            assertTrue(channel.isOpen());\n+            if (seekable != null) {\n+                assertEquals(0, seekable.position());\n+                assertEquals(0, seekable.size());\n+            }\n+            checkWrite(channel);\n+            if (seekable != null) {\n+                assertEquals(RO_LENGTH, seekable.position());\n+                assertEquals(RO_LENGTH, seekable.size());\n+            }\n+        }\n+        if (supportsRead) {\n+            setOriginRw(newOriginRw());\n+            try (ReadableByteChannel channel =\n+                    getOriginRw().getChannel(ReadableByteChannel.class, StandardOpenOption.READ)) {\n+                assertNotNull(channel);\n+                assertTrue(channel.isOpen());\n+                checkRead(channel);\n+            }\n+        }\n+        setOriginRw(newOriginRw());\n+        try (WritableByteChannel channel =\n+                getOriginRw().getChannel(WritableByteChannel.class, StandardOpenOption.WRITE)) {\n+            final SeekableByteChannel seekable =\n+                    channel instanceof SeekableByteChannel ? (SeekableByteChannel) channel : null;\n+            assertNotNull(channel);\n+            assertTrue(channel.isOpen());\n+            if (seekable != null) {\n+                seekable.position(RO_LENGTH);\n+                assertEquals(RO_LENGTH, seekable.position());\n+                assertEquals(RO_LENGTH, seekable.size());\n+                // Truncate\n+                final int newSize = RO_LENGTH / 2;\n+                seekable.truncate(newSize);\n+                assertEquals(newSize, seekable.position());\n+                assertEquals(newSize, seekable.size());\n+                // Rewind\n+                seekable.position(0);\n+                assertEquals(0, seekable.position());\n+            }\n+        }\n+    }\n+\n+    private void checkWrite(WritableByteChannel channel) throws IOException {\n+        final ByteBuffer buffer = ByteBuffer.wrap(getFixtureByteArray());\n+        final int written = channel.write(buffer);\n+        assertEquals(RO_LENGTH, written);\n+    }\n+\n     @Test\n     void testSize() throws IOException {\n-        assertEquals(Files.size(Paths.get(FILE_NAME_RO)), getOriginRo().getByteArray().length);\n+        assertEquals(RO_LENGTH, getOriginRo().getByteArray().length);\n     }\n }\ndiff --git a/src/test/java/org/apache/commons/io/build/AbstractRandomAccessFileOriginTest.java b/src/test/java/org/apache/commons/io/build/AbstractRandomAccessFileOriginTest.java\nindex 369ce295ddc..28644f3c877 100644\n--- a/src/test/java/org/apache/commons/io/build/AbstractRandomAccessFileOriginTest.java\n+++ b/src/test/java/org/apache/commons/io/build/AbstractRandomAccessFileOriginTest.java\n@@ -17,12 +17,17 @@\n \n package org.apache.commons.io.build;\n \n+import java.io.IOException;\n import java.io.RandomAccessFile;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n \n import org.apache.commons.io.IORandomAccessFile;\n import org.apache.commons.io.build.AbstractOrigin.AbstractRandomAccessFileOrigin;\n import org.apache.commons.io.build.AbstractOrigin.IORandomAccessFileOrigin;\n import org.apache.commons.io.build.AbstractOrigin.RandomAccessFileOrigin;\n+import org.apache.commons.lang3.ArrayUtils;\n \n /**\n  * Tests {@link RandomAccessFileOrigin} and {@link IORandomAccessFileOrigin}.\n@@ -35,4 +40,10 @@\n public abstract class AbstractRandomAccessFileOriginTest<T extends RandomAccessFile, B extends AbstractRandomAccessFileOrigin<T, B>>\n         extends AbstractOriginTest<T, B> {\n \n+    @Override\n+    protected void resetOriginRw() throws IOException {\n+        // Reset the file\n+        final Path rwPath = tempPath.resolve(FILE_NAME_RW);\n+        Files.write(rwPath, ArrayUtils.EMPTY_BYTE_ARRAY, StandardOpenOption.CREATE);\n+    }\n }\ndiff --git a/src/test/java/org/apache/commons/io/build/AbstractStreamBuilderTest.java b/src/test/java/org/apache/commons/io/build/AbstractStreamBuilderTest.java\nindex f94957f5351..fc3bbafca6d 100644\n--- a/src/test/java/org/apache/commons/io/build/AbstractStreamBuilderTest.java\n+++ b/src/test/java/org/apache/commons/io/build/AbstractStreamBuilderTest.java\n@@ -17,13 +17,30 @@\n \n package org.apache.commons.io.build;\n \n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n import static org.junit.jupiter.api.Assertions.assertEquals;\n import static org.junit.jupiter.api.Assertions.assertNotNull;\n import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n \n+import java.io.FileInputStream;\n+import java.io.RandomAccessFile;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.nio.channels.ReadableByteChannel;\n+import java.nio.channels.SeekableByteChannel;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n import java.util.Arrays;\n+import java.util.Objects;\n+import java.util.stream.Stream;\n \n+import org.apache.commons.io.function.IOConsumer;\n+import org.apache.commons.lang3.ArrayUtils;\n import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n \n /**\n  * Tests {@link AbstractStreamBuilder}.\n@@ -65,4 +82,51 @@ void testBufferSizeChecker() {\n         // resize\n         assertResult(builder().setBufferSizeMax(2).setBufferSizeChecker(i -> 100).setBufferSize(3).get(), 100);\n     }\n+\n+    private static Stream<IOConsumer<Builder>> fileBasedConfigurers() throws URISyntaxException {\n+        final URI uri = Objects.requireNonNull(\n+                        AbstractStreamBuilderTest.class.getResource(AbstractOriginTest.FILE_RES_RO))\n+                .toURI();\n+        final Path path = Paths.get(AbstractOriginTest.FILE_NAME_RO);\n+        return Stream.of(\n+                b -> b.setByteArray(ArrayUtils.EMPTY_BYTE_ARRAY),\n+                b -> b.setFile(AbstractOriginTest.FILE_NAME_RO),\n+                b -> b.setFile(path.toFile()),\n+                b -> b.setPath(AbstractOriginTest.FILE_NAME_RO),\n+                b -> b.setPath(path),\n+                b -> b.setRandomAccessFile(new RandomAccessFile(AbstractOriginTest.FILE_NAME_RO, \"r\")),\n+                // We can convert FileInputStream to ReadableByteChannel, but not the reverse.\n+                // Therefore, we don't use Files.newInputStream.\n+                b -> b.setInputStream(new FileInputStream(AbstractOriginTest.FILE_NAME_RO)),\n+                b -> b.setChannel(Files.newByteChannel(path)),\n+                b -> b.setURI(uri));\n+    }\n+\n+    /**\n+     * Tests various ways to obtain a {@link java.io.InputStream}.\n+     *\n+     * @param configurer Lambda to configure the builder.\n+     */\n+    @ParameterizedTest\n+    @MethodSource(\"fileBasedConfigurers\")\n+    void testGetInputStream(IOConsumer<Builder> configurer) throws Exception {\n+        final Builder builder = builder();\n+            configurer.accept(builder);\n+        assertNotNull(builder.getInputStream());\n+    }\n+\n+    /**\n+     * Tests various ways to obtain a {@link SeekableByteChannel}.\n+     *\n+     * @param configurer Lambda to configure the builder.\n+     */\n+    @ParameterizedTest\n+    @MethodSource(\"fileBasedConfigurers\")\n+    void getGetSeekableByteChannel(IOConsumer<Builder> configurer) throws Exception {\n+        final Builder builder = builder();\n+        configurer.accept(builder);\n+        try (ReadableByteChannel channel = assertDoesNotThrow(() -> builder.getChannel(SeekableByteChannel.class))) {\n+            assertTrue(channel.isOpen());\n+        }\n+    }\n }\ndiff --git a/src/test/java/org/apache/commons/io/build/ByteArrayOriginTest.java b/src/test/java/org/apache/commons/io/build/ByteArrayOriginTest.java\nindex 41a6931482c..b4fd3bf0b24 100644\n--- a/src/test/java/org/apache/commons/io/build/ByteArrayOriginTest.java\n+++ b/src/test/java/org/apache/commons/io/build/ByteArrayOriginTest.java\n@@ -82,11 +82,17 @@ void testGetRandomAccessFile(final OpenOption openOption) {\n         assertThrows(UnsupportedOperationException.class, () -> super.testGetRandomAccessFile(openOption));\n     }\n \n+    @Override\n+    @Test\n+    void testGetWritableByteChannel() throws IOException {\n+        // Cannot convert a byte[] to a WritableByteChannel.\n+        assertThrows(UnsupportedOperationException.class, super::testGetWritableByteChannel);\n+    }\n+\n     @Override\n     @Test\n     void testGetWriter() {\n         // Cannot convert a byte[] to a Writer.\n         assertThrows(UnsupportedOperationException.class, super::testGetWriter);\n     }\n-\n }\ndiff --git a/src/test/java/org/apache/commons/io/build/ChannelOriginTest.java b/src/test/java/org/apache/commons/io/build/ChannelOriginTest.java\nnew file mode 100644\nindex 00000000000..156ece2949a\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/io/build/ChannelOriginTest.java\n@@ -0,0 +1,108 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.io.build;\n+\n+import static java.nio.file.StandardOpenOption.READ;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.mockito.Mockito.mock;\n+\n+import java.io.IOException;\n+import java.nio.channels.Channel;\n+import java.nio.channels.ReadableByteChannel;\n+import java.nio.channels.WritableByteChannel;\n+import java.nio.file.Files;\n+import java.nio.file.OpenOption;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardOpenOption;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+\n+import org.apache.commons.io.build.AbstractOrigin.ChannelOrigin;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.EnumSource;\n+\n+class ChannelOriginTest extends AbstractOriginTest<Channel, ChannelOrigin> {\n+    @Override\n+    protected ChannelOrigin newOriginRo() throws IOException {\n+        return new ChannelOrigin(Files.newByteChannel(Paths.get(FILE_NAME_RO), Collections.singleton(READ)));\n+    }\n+\n+    @Override\n+    protected ChannelOrigin newOriginRw() throws IOException {\n+        return new ChannelOrigin(Files.newByteChannel(\n+                tempPath.resolve(FILE_NAME_RW),\n+                new HashSet<>(Arrays.asList(StandardOpenOption.READ, StandardOpenOption.WRITE))));\n+    }\n+\n+    @Override\n+    protected void resetOriginRw() throws IOException {\n+        // Reset the file\n+        final Path rwPath = tempPath.resolve(FILE_NAME_RW);\n+        Files.write(rwPath, ArrayUtils.EMPTY_BYTE_ARRAY, StandardOpenOption.CREATE);\n+    }\n+\n+    @Override\n+    @Test\n+    void testGetFile() {\n+        // A FileByteChannel cannot be converted into a File.\n+        assertThrows(UnsupportedOperationException.class, super::testGetFile);\n+    }\n+\n+    @Override\n+    @Test\n+    void testGetPath() {\n+        // A FileByteChannel cannot be converted into a Path.\n+        assertThrows(UnsupportedOperationException.class, super::testGetPath);\n+    }\n+\n+    @Override\n+    @Test\n+    void testGetRandomAccessFile() {\n+        // A FileByteChannel cannot be converted into a RandomAccessFile.\n+        assertThrows(UnsupportedOperationException.class, super::testGetRandomAccessFile);\n+    }\n+\n+    @Override\n+    @ParameterizedTest\n+    @EnumSource(StandardOpenOption.class)\n+    void testGetRandomAccessFile(OpenOption openOption) {\n+        // A FileByteChannel cannot be converted into a RandomAccessFile.\n+        assertThrows(UnsupportedOperationException.class, () -> super.testGetRandomAccessFile(openOption));\n+    }\n+\n+    @Test\n+    void testUnsupportedOperations_ReadableByteChannel() {\n+        final ReadableByteChannel channel = mock(ReadableByteChannel.class);\n+        final ChannelOrigin origin = new ChannelOrigin(channel);\n+        assertThrows(UnsupportedOperationException.class, origin::getOutputStream);\n+        assertThrows(UnsupportedOperationException.class, () -> origin.getWriter(null));\n+        assertThrows(UnsupportedOperationException.class, () -> origin.getChannel(WritableByteChannel.class));\n+    }\n+\n+    @Test\n+    void testUnsupportedOperations_WritableByteChannel() {\n+        final Channel channel = mock(WritableByteChannel.class);\n+        final ChannelOrigin origin = new ChannelOrigin(channel);\n+        assertThrows(UnsupportedOperationException.class, origin::getInputStream);\n+        assertThrows(UnsupportedOperationException.class, () -> origin.getReader(null));\n+        assertThrows(UnsupportedOperationException.class, () -> origin.getChannel(ReadableByteChannel.class));\n+    }\n+}\ndiff --git a/src/test/java/org/apache/commons/io/build/CharSequenceOriginTest.java b/src/test/java/org/apache/commons/io/build/CharSequenceOriginTest.java\nindex df29f453af8..0fc5b9c5cc6 100644\n--- a/src/test/java/org/apache/commons/io/build/CharSequenceOriginTest.java\n+++ b/src/test/java/org/apache/commons/io/build/CharSequenceOriginTest.java\n@@ -109,6 +109,13 @@ void testGetReaderIgnoreCharsetNull() throws IOException {\n         }\n     }\n \n+    @Override\n+    @Test\n+    void testGetWritableByteChannel() throws IOException {\n+        // Cannot convert a CharSequence to a WritableByteChannel.\n+        assertThrows(UnsupportedOperationException.class, super::testGetWritableByteChannel);\n+    }\n+\n     @Override\n     @Test\n     void testGetWriter() {\ndiff --git a/src/test/java/org/apache/commons/io/build/FileOriginTest.java b/src/test/java/org/apache/commons/io/build/FileOriginTest.java\nindex 4f0cb2514c7..548d788851e 100644\n--- a/src/test/java/org/apache/commons/io/build/FileOriginTest.java\n+++ b/src/test/java/org/apache/commons/io/build/FileOriginTest.java\n@@ -17,8 +17,13 @@\n package org.apache.commons.io.build;\n \n import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n \n import org.apache.commons.io.build.AbstractOrigin.FileOrigin;\n+import org.apache.commons.lang3.ArrayUtils;\n \n /**\n  * Tests {@link FileOrigin}.\n@@ -35,8 +40,14 @@ protected FileOrigin newOriginRo() {\n     }\n \n     @Override\n-    protected FileOrigin newOriginRw() {\n-        return new FileOrigin(new File(FILE_NAME_RW));\n+    protected FileOrigin newOriginRw() throws IOException {\n+        return new FileOrigin(tempPath.resolve(FILE_NAME_RW).toFile());\n     }\n \n+    @Override\n+    protected void resetOriginRw() throws IOException {\n+        // Reset the file\n+        final Path rwPath = tempPath.resolve(FILE_NAME_RW);\n+        Files.write(rwPath, ArrayUtils.EMPTY_BYTE_ARRAY, StandardOpenOption.CREATE);\n+    }\n }\ndiff --git a/src/test/java/org/apache/commons/io/build/IORandomAccessFileOriginTest.java b/src/test/java/org/apache/commons/io/build/IORandomAccessFileOriginTest.java\nindex 8d83bba1c63..b51118c657e 100644\n--- a/src/test/java/org/apache/commons/io/build/IORandomAccessFileOriginTest.java\n+++ b/src/test/java/org/apache/commons/io/build/IORandomAccessFileOriginTest.java\n@@ -17,6 +17,7 @@\n package org.apache.commons.io.build;\n \n import java.io.FileNotFoundException;\n+import java.io.IOException;\n import java.io.RandomAccessFile;\n \n import org.apache.commons.io.IORandomAccessFile;\n@@ -38,8 +39,7 @@ protected IORandomAccessFileOrigin newOriginRo() throws FileNotFoundException {\n \n     @SuppressWarnings(\"resource\")\n     @Override\n-    protected IORandomAccessFileOrigin newOriginRw() throws FileNotFoundException {\n-        return new IORandomAccessFileOrigin(RandomAccessFileMode.READ_WRITE.io(FILE_NAME_RW));\n+    protected IORandomAccessFileOrigin newOriginRw() throws IOException {\n+        return new IORandomAccessFileOrigin(RandomAccessFileMode.READ_WRITE.io(tempPath.resolve(FILE_NAME_RW).toFile().getPath()));\n     }\n-\n }\ndiff --git a/src/test/java/org/apache/commons/io/build/InputStreamOriginTest.java b/src/test/java/org/apache/commons/io/build/InputStreamOriginTest.java\nindex ac83acbecfb..7329fdb5783 100644\n--- a/src/test/java/org/apache/commons/io/build/InputStreamOriginTest.java\n+++ b/src/test/java/org/apache/commons/io/build/InputStreamOriginTest.java\n@@ -20,6 +20,7 @@\n \n import java.io.FileInputStream;\n import java.io.FileNotFoundException;\n+import java.io.IOException;\n import java.io.InputStream;\n import java.nio.file.OpenOption;\n import java.nio.file.StandardOpenOption;\n@@ -87,11 +88,17 @@ void testGetRandomAccessFile(final OpenOption openOption) {\n         assertThrows(UnsupportedOperationException.class, () -> super.testGetRandomAccessFile(openOption));\n     }\n \n+    @Override\n+    @Test\n+    void testGetWritableByteChannel() throws IOException {\n+        // Cannot convert a InputStream to a WritableByteChannel.\n+        assertThrows(UnsupportedOperationException.class, super::testGetWritableByteChannel);\n+    }\n+\n     @Override\n     @Test\n     void testGetWriter() {\n         // Cannot convert a InputStream to a Writer.\n         assertThrows(UnsupportedOperationException.class, super::testGetWriter);\n     }\n-\n }\ndiff --git a/src/test/java/org/apache/commons/io/build/OutputStreamOriginTest.java b/src/test/java/org/apache/commons/io/build/OutputStreamOriginTest.java\nindex 5e66e244d3a..b002a7e6881 100644\n--- a/src/test/java/org/apache/commons/io/build/OutputStreamOriginTest.java\n+++ b/src/test/java/org/apache/commons/io/build/OutputStreamOriginTest.java\n@@ -18,6 +18,7 @@\n \n import static org.junit.jupiter.api.Assertions.assertThrows;\n \n+import java.io.IOException;\n import java.io.OutputStream;\n import java.nio.file.OpenOption;\n import java.nio.file.StandardOpenOption;\n@@ -125,6 +126,13 @@ void testGetReader() {\n         assertThrows(UnsupportedOperationException.class, super::testGetReader);\n     }\n \n+    @Override\n+    @Test\n+    void testGetReadableByteChannel() throws IOException {\n+        // Cannot convert a OutputStream to a ReadableByteChannel.\n+        assertThrows(UnsupportedOperationException.class, super::testGetReadableByteChannel);\n+    }\n+\n     @Override\n     @Test\n     void testSize() {\ndiff --git a/src/test/java/org/apache/commons/io/build/PathOriginTest.java b/src/test/java/org/apache/commons/io/build/PathOriginTest.java\nindex 81c4fc8d900..bc29df52b54 100644\n--- a/src/test/java/org/apache/commons/io/build/PathOriginTest.java\n+++ b/src/test/java/org/apache/commons/io/build/PathOriginTest.java\n@@ -16,10 +16,14 @@\n  */\n package org.apache.commons.io.build;\n \n+import java.io.IOException;\n+import java.nio.file.Files;\n import java.nio.file.Path;\n import java.nio.file.Paths;\n+import java.nio.file.StandardOpenOption;\n \n import org.apache.commons.io.build.AbstractOrigin.PathOrigin;\n+import org.apache.commons.lang3.ArrayUtils;\n \n /**\n  * Tests {@link PathOrigin}.\n@@ -36,8 +40,14 @@ protected PathOrigin newOriginRo() {\n     }\n \n     @Override\n-    protected PathOrigin newOriginRw() {\n-        return new PathOrigin(Paths.get(FILE_NAME_RW));\n+    protected PathOrigin newOriginRw() throws IOException {\n+        return new PathOrigin(tempPath.resolve(FILE_NAME_RW));\n     }\n \n+    @Override\n+    protected void resetOriginRw() throws IOException {\n+        // Reset the file\n+        final Path rwPath = tempPath.resolve(FILE_NAME_RW);\n+        Files.write(rwPath, ArrayUtils.EMPTY_BYTE_ARRAY, StandardOpenOption.CREATE);\n+    }\n }\ndiff --git a/src/test/java/org/apache/commons/io/build/RandomAccessFileOriginTest.java b/src/test/java/org/apache/commons/io/build/RandomAccessFileOriginTest.java\nindex 7cebf778db0..d7306c12cbc 100644\n--- a/src/test/java/org/apache/commons/io/build/RandomAccessFileOriginTest.java\n+++ b/src/test/java/org/apache/commons/io/build/RandomAccessFileOriginTest.java\n@@ -20,6 +20,7 @@\n import static org.junit.jupiter.api.Assertions.assertThrows;\n \n import java.io.FileNotFoundException;\n+import java.io.IOException;\n import java.io.RandomAccessFile;\n \n import org.apache.commons.io.RandomAccessFileMode;\n@@ -41,8 +42,8 @@ protected RandomAccessFileOrigin newOriginRo() throws FileNotFoundException {\n \n     @SuppressWarnings(\"resource\")\n     @Override\n-    protected RandomAccessFileOrigin newOriginRw() throws FileNotFoundException {\n-        return new RandomAccessFileOrigin(RandomAccessFileMode.READ_WRITE.create(FILE_NAME_RW));\n+    protected RandomAccessFileOrigin newOriginRw() throws IOException {\n+        return new RandomAccessFileOrigin(RandomAccessFileMode.READ_WRITE.create(tempPath.resolve(FILE_NAME_RW)));\n     }\n \n     @Override\ndiff --git a/src/test/java/org/apache/commons/io/build/ReaderOriginTest.java b/src/test/java/org/apache/commons/io/build/ReaderOriginTest.java\nindex 6897d241868..3c1e3032fb4 100644\n--- a/src/test/java/org/apache/commons/io/build/ReaderOriginTest.java\n+++ b/src/test/java/org/apache/commons/io/build/ReaderOriginTest.java\n@@ -20,6 +20,7 @@\n \n import java.io.FileNotFoundException;\n import java.io.FileReader;\n+import java.io.IOException;\n import java.io.Reader;\n import java.nio.file.OpenOption;\n import java.nio.file.StandardOpenOption;\n@@ -85,11 +86,17 @@ void testGetRandomAccessFile(final OpenOption openOption) {\n         assertThrows(UnsupportedOperationException.class, () -> super.testGetRandomAccessFile(openOption));\n     }\n \n+    @Override\n+    @Test\n+    void testGetWritableByteChannel() throws IOException {\n+        // Cannot convert a InputStream to a WritableByteChannel.\n+        assertThrows(UnsupportedOperationException.class, super::testGetWritableByteChannel);\n+    }\n+\n     @Override\n     @Test\n     void testGetWriter() {\n         // Cannot convert a Reader to a Writer.\n         assertThrows(UnsupportedOperationException.class, super::testGetWriter);\n     }\n-\n }\ndiff --git a/src/test/java/org/apache/commons/io/build/URIOriginTest.java b/src/test/java/org/apache/commons/io/build/URIOriginTest.java\nindex 303cfe1111a..6fd2043eb12 100644\n--- a/src/test/java/org/apache/commons/io/build/URIOriginTest.java\n+++ b/src/test/java/org/apache/commons/io/build/URIOriginTest.java\n@@ -18,11 +18,16 @@\n \n import static org.junit.jupiter.api.Assertions.assertNotEquals;\n \n+import java.io.IOException;\n import java.io.InputStream;\n import java.net.URI;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n import java.nio.file.Paths;\n+import java.nio.file.StandardOpenOption;\n \n import org.apache.commons.io.build.AbstractOrigin.URIOrigin;\n+import org.apache.commons.lang3.ArrayUtils;\n import org.junit.jupiter.api.Test;\n import org.junit.jupiter.params.ParameterizedTest;\n import org.junit.jupiter.params.provider.ValueSource;\n@@ -43,7 +48,14 @@ protected URIOrigin newOriginRo() {\n \n     @Override\n     protected URIOrigin newOriginRw() {\n-        return new URIOrigin(Paths.get(FILE_NAME_RW).toUri());\n+        return new URIOrigin(tempPath.resolve(FILE_NAME_RW).toUri());\n+    }\n+\n+    @Override\n+    protected void resetOriginRw() throws IOException {\n+        // Reset the file\n+        final Path rwPath = tempPath.resolve(FILE_NAME_RW);\n+        Files.write(rwPath, ArrayUtils.EMPTY_BYTE_ARRAY, StandardOpenOption.CREATE);\n     }\n \n     @ParameterizedTest\ndiff --git a/src/test/java/org/apache/commons/io/build/WriterStreamOriginTest.java b/src/test/java/org/apache/commons/io/build/WriterStreamOriginTest.java\nindex f0aa525127b..7b9908a11f5 100644\n--- a/src/test/java/org/apache/commons/io/build/WriterStreamOriginTest.java\n+++ b/src/test/java/org/apache/commons/io/build/WriterStreamOriginTest.java\n@@ -18,6 +18,7 @@\n \n import static org.junit.jupiter.api.Assertions.assertThrows;\n \n+import java.io.IOException;\n import java.io.StringWriter;\n import java.io.Writer;\n import java.nio.file.OpenOption;\n@@ -125,6 +126,12 @@ void testGetReader() {\n         assertThrows(UnsupportedOperationException.class, super::testGetReader);\n     }\n \n+    @Override\n+    void testGetReadableByteChannel() throws IOException {\n+        // Cannot convert a Writer to a ReadableByteChannel.\n+        assertThrows(UnsupportedOperationException.class, super::testGetReadableByteChannel);\n+    }\n+\n     @Override\n     @Test\n     void testSize() {\ndiff --git a/src/test/java/org/apache/commons/io/channels/ByteArraySeekableByteChannelCompressTest.java b/src/test/java/org/apache/commons/io/channels/ByteArraySeekableByteChannelCompressTest.java\nindex 186ed1e8d54..66c8e60b91a 100644\n--- a/src/test/java/org/apache/commons/io/channels/ByteArraySeekableByteChannelCompressTest.java\n+++ b/src/test/java/org/apache/commons/io/channels/ByteArraySeekableByteChannelCompressTest.java\n@@ -31,6 +31,7 @@\n import java.nio.charset.StandardCharsets;\n import java.util.Arrays;\n \n+import org.junit.jupiter.api.AfterEach;\n import org.junit.jupiter.api.Test;\n import org.junit.jupiter.params.ParameterizedTest;\n import org.junit.jupiter.params.provider.ValueSource;\n@@ -40,7 +41,13 @@\n  */\n class ByteArraySeekableByteChannelCompressTest {\n \n-    private final byte[] testData = \"Some data\".getBytes(StandardCharsets.UTF_8);\n+    private static final byte[] testData = \"Some data\".getBytes(StandardCharsets.UTF_8);\n+\n+    @AfterEach\n+    void afterEach() {\n+        // Reading tests don't modify the data\n+        assertArrayEquals(\"Some data\".getBytes(StandardCharsets.UTF_8), testData);\n+    }\n \n     /*\n      * <q>If the stream is already closed then invoking this method has no effect.</q>\n@@ -62,7 +69,7 @@ void testCloseIsIdempotent() throws Exception {\n     @ParameterizedTest\n     @ValueSource(ints = { 0, 1, 2, 3, 4, 5, 6 })\n     void testReadingFromAPositionAfterEndReturnsEOF(final int size) throws Exception {\n-        try (SeekableByteChannel c = new ByteArraySeekableByteChannel(size)) {\n+        try (SeekableByteChannel c = ByteArraySeekableByteChannel.wrap(new byte[size])) {\n             final int position = 2;\n             c.position(position);\n             assertEquals(position, c.position());\n@@ -74,7 +81,7 @@ void testReadingFromAPositionAfterEndReturnsEOF(final int size) throws Exception\n \n     @Test\n     void testShouldReadContentsProperly() throws IOException {\n-        try (ByteArraySeekableByteChannel c = new ByteArraySeekableByteChannel(testData)) {\n+        try (ByteArraySeekableByteChannel c = ByteArraySeekableByteChannel.wrap(testData)) {\n             final ByteBuffer readBuffer = ByteBuffer.allocate(testData.length);\n             final int readCount = c.read(readBuffer);\n             assertEquals(testData.length, readCount);\n@@ -85,7 +92,7 @@ void testShouldReadContentsProperly() throws IOException {\n \n     @Test\n     void testShouldReadContentsWhenBiggerBufferSupplied() throws IOException {\n-        try (ByteArraySeekableByteChannel c = new ByteArraySeekableByteChannel(testData)) {\n+        try (ByteArraySeekableByteChannel c = ByteArraySeekableByteChannel.wrap(testData)) {\n             final ByteBuffer readBuffer = ByteBuffer.allocate(testData.length + 1);\n             final int readCount = c.read(readBuffer);\n             assertEquals(testData.length, readCount);\n@@ -96,7 +103,7 @@ void testShouldReadContentsWhenBiggerBufferSupplied() throws IOException {\n \n     @Test\n     void testShouldReadDataFromSetPosition() throws IOException {\n-        try (ByteArraySeekableByteChannel c = new ByteArraySeekableByteChannel(testData)) {\n+        try (ByteArraySeekableByteChannel c = ByteArraySeekableByteChannel.wrap(testData)) {\n             final ByteBuffer readBuffer = ByteBuffer.allocate(4);\n             c.position(5L);\n             final int readCount = c.read(readBuffer);\n@@ -108,7 +115,7 @@ void testShouldReadDataFromSetPosition() throws IOException {\n \n     @Test\n     void testShouldSetProperPosition() throws IOException {\n-        try (ByteArraySeekableByteChannel c = new ByteArraySeekableByteChannel(testData)) {\n+        try (ByteArraySeekableByteChannel c = ByteArraySeekableByteChannel.wrap(testData)) {\n             final long posAtFour = c.position(4L).position();\n             final long posAtTheEnd = c.position(testData.length).position();\n             final long posPastTheEnd = c.position(testData.length + 1L).position();\n@@ -120,7 +127,7 @@ void testShouldSetProperPosition() throws IOException {\n \n     @Test\n     void testShouldSetProperPositionOnTruncate() throws IOException {\n-        try (ByteArraySeekableByteChannel c = new ByteArraySeekableByteChannel(testData)) {\n+        try (ByteArraySeekableByteChannel c = ByteArraySeekableByteChannel.wrap(testData)) {\n             c.position(testData.length);\n             c.truncate(4L);\n             assertEquals(4L, c.position());\n@@ -130,7 +137,7 @@ void testShouldSetProperPositionOnTruncate() throws IOException {\n \n     @Test\n     void testShouldSignalEOFWhenPositionAtTheEnd() throws IOException {\n-        try (ByteArraySeekableByteChannel c = new ByteArraySeekableByteChannel(testData)) {\n+        try (ByteArraySeekableByteChannel c = ByteArraySeekableByteChannel.wrap(testData)) {\n             final ByteBuffer readBuffer = ByteBuffer.allocate(testData.length);\n             c.position(testData.length + 1);\n             final int readCount = c.read(readBuffer);\n@@ -170,7 +177,7 @@ void testShouldThrowExceptionWhenTruncatingToIncorrectSize() {\n \n     @Test\n     void testShouldTruncateContentsProperly() throws ClosedChannelException {\n-        try (ByteArraySeekableByteChannel c = new ByteArraySeekableByteChannel(testData)) {\n+        try (ByteArraySeekableByteChannel c = ByteArraySeekableByteChannel.wrap(testData)) {\n             c.truncate(4);\n             final byte[] bytes = Arrays.copyOf(c.array(), (int) c.size());\n             assertEquals(\"Some\", new String(bytes, StandardCharsets.UTF_8));\n@@ -193,7 +200,7 @@ void testShouldWriteDataProperly() throws IOException {\n \n     @Test\n     void testShouldWriteDataProperlyAfterPositionSet() throws IOException {\n-        try (ByteArraySeekableByteChannel c = new ByteArraySeekableByteChannel(testData)) {\n+        try (ByteArraySeekableByteChannel c = ByteArraySeekableByteChannel.wrap(testData.clone())) {\n             final ByteBuffer inData = ByteBuffer.wrap(testData);\n             final ByteBuffer expectedData = ByteBuffer.allocate(testData.length + 5).put(testData, 0, 5).put(testData);\n             c.position(5L);\n@@ -242,7 +249,7 @@ void testThrowsIOExceptionWhenPositionIsSetToANegativeValue() throws Exception {\n      */\n     @Test\n     void testTruncateDoesntChangeSmallPosition() throws Exception {\n-        try (SeekableByteChannel c = new ByteArraySeekableByteChannel(testData)) {\n+        try (SeekableByteChannel c = ByteArraySeekableByteChannel.wrap(testData)) {\n             c.position(1);\n             c.truncate(testData.length - 1);\n             assertEquals(testData.length - 1, c.size());\n@@ -255,7 +262,7 @@ void testTruncateDoesntChangeSmallPosition() throws Exception {\n      */\n     @Test\n     void testTruncateMovesPositionWhenNewSizeIsBiggerThanSizeAndPositionIsEvenBigger() throws Exception {\n-        try (SeekableByteChannel c = new ByteArraySeekableByteChannel(testData)) {\n+        try (SeekableByteChannel c = ByteArraySeekableByteChannel.wrap(testData)) {\n             c.position(2 * testData.length);\n             c.truncate(testData.length + 1);\n             assertEquals(testData.length, c.size());\n@@ -269,7 +276,7 @@ void testTruncateMovesPositionWhenNewSizeIsBiggerThanSizeAndPositionIsEvenBigger\n      */\n     @Test\n     void testTruncateMovesPositionWhenNotResizingButPositionBiggerThanSize() throws Exception {\n-        try (SeekableByteChannel c = new ByteArraySeekableByteChannel(testData)) {\n+        try (SeekableByteChannel c = ByteArraySeekableByteChannel.wrap(testData)) {\n             c.position(2 * testData.length);\n             c.truncate(testData.length);\n             assertEquals(testData.length, c.size());\n@@ -282,7 +289,7 @@ void testTruncateMovesPositionWhenNotResizingButPositionBiggerThanSize() throws\n      */\n     @Test\n     void testTruncateMovesPositionWhenShrinkingBeyondPosition() throws Exception {\n-        try (SeekableByteChannel c = new ByteArraySeekableByteChannel(testData)) {\n+        try (SeekableByteChannel c = ByteArraySeekableByteChannel.wrap(testData)) {\n             c.position(4);\n             c.truncate(3);\n             assertEquals(3, c.size());\n@@ -295,7 +302,7 @@ void testTruncateMovesPositionWhenShrinkingBeyondPosition() throws Exception {\n      */\n     @Test\n     void testTruncateToBiggerSizeDoesntChangeAnything() throws Exception {\n-        try (SeekableByteChannel c = new ByteArraySeekableByteChannel(testData)) {\n+        try (SeekableByteChannel c = ByteArraySeekableByteChannel.wrap(testData)) {\n             assertEquals(testData.length, c.size());\n             c.truncate(testData.length + 1);\n             assertEquals(testData.length, c.size());\n@@ -310,7 +317,7 @@ void testTruncateToBiggerSizeDoesntChangeAnything() throws Exception {\n      */\n     @Test\n     void testTruncateToCurrentSizeDoesntChangeAnything() throws Exception {\n-        try (SeekableByteChannel c = new ByteArraySeekableByteChannel(testData)) {\n+        try (SeekableByteChannel c = ByteArraySeekableByteChannel.wrap(testData)) {\n             assertEquals(testData.length, c.size());\n             c.truncate(testData.length);\n             assertEquals(testData.length, c.size());\ndiff --git a/src/test/java/org/apache/commons/io/channels/ByteArraySeekableByteChannelTest.java b/src/test/java/org/apache/commons/io/channels/ByteArraySeekableByteChannelTest.java\nindex 96cd377d2ad..e5e1442bed0 100644\n--- a/src/test/java/org/apache/commons/io/channels/ByteArraySeekableByteChannelTest.java\n+++ b/src/test/java/org/apache/commons/io/channels/ByteArraySeekableByteChannelTest.java\n@@ -17,8 +17,24 @@\n \n package org.apache.commons.io.channels;\n \n+import static org.apache.commons.lang3.ArrayUtils.EMPTY_BYTE_ARRAY;\n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n import java.io.IOException;\n+import java.nio.ByteBuffer;\n import java.nio.channels.SeekableByteChannel;\n+import java.nio.charset.StandardCharsets;\n+import java.util.stream.Stream;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.io.function.IOSupplier;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n \n /**\n  * A sanity test to make sure {@link AbstractSeekableByteChannelTest} works for files.\n@@ -30,4 +46,71 @@ protected SeekableByteChannel createChannel() throws IOException {\n         return new ByteArraySeekableByteChannel();\n     }\n \n+    private static final byte[] testData = \"Some data\".getBytes(StandardCharsets.UTF_8);\n+\n+    static Stream<Arguments> testConstructor() {\n+        return Stream.of(\n+                Arguments.of(\n+                        (IOSupplier<ByteArraySeekableByteChannel>) ByteArraySeekableByteChannel::new,\n+                        EMPTY_BYTE_ARRAY,\n+                        IOUtils.DEFAULT_BUFFER_SIZE),\n+                Arguments.of(\n+                        (IOSupplier<ByteArraySeekableByteChannel>) () -> new ByteArraySeekableByteChannel(8),\n+                        EMPTY_BYTE_ARRAY,\n+                        8),\n+                Arguments.of(\n+                        (IOSupplier<ByteArraySeekableByteChannel>) () -> new ByteArraySeekableByteChannel(16),\n+                        EMPTY_BYTE_ARRAY,\n+                        16),\n+                Arguments.of(\n+                        (IOSupplier<ByteArraySeekableByteChannel>)\n+                                () -> ByteArraySeekableByteChannel.wrap(EMPTY_BYTE_ARRAY),\n+                        EMPTY_BYTE_ARRAY,\n+                        0),\n+                Arguments.of(\n+                        (IOSupplier<ByteArraySeekableByteChannel>)\n+                                () -> ByteArraySeekableByteChannel.wrap(testData),\n+                        testData,\n+                        testData.length));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    void testConstructor(IOSupplier<ByteArraySeekableByteChannel> supplier, byte[] expected, int capacity) throws IOException {\n+        try (ByteArraySeekableByteChannel channel = supplier.get()) {\n+            assertEquals(0, channel.position());\n+            assertEquals(expected.length, channel.size());\n+            assertEquals(capacity, channel.array().length);\n+            assertArrayEquals(expected, channel.toByteArray());\n+        }\n+    }\n+\n+    @Test\n+    void testConstructorInvalid() {\n+        assertThrows(IllegalArgumentException.class, () -> new ByteArraySeekableByteChannel(-1));\n+        assertThrows(NullPointerException.class, () -> ByteArraySeekableByteChannel.wrap(null));\n+    }\n+\n+    static Stream<Arguments> testShouldResizeWhenWritingMoreDataThanCapacity() {\n+        return Stream.of(\n+                // Resize from 0\n+                Arguments.of(EMPTY_BYTE_ARRAY, 1),\n+                // Resize less than double\n+                Arguments.of(new byte[8], 1),\n+                // Resize more that double\n+                Arguments.of(new byte[8], 20));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    void testShouldResizeWhenWritingMoreDataThanCapacity(byte[] data, int wanted) throws IOException {\n+        try (ByteArraySeekableByteChannel c = ByteArraySeekableByteChannel.wrap(data)) {\n+            c.position(data.length);\n+            final ByteBuffer inData = ByteBuffer.wrap(new byte[wanted]);\n+            final int writeCount = c.write(inData);\n+            assertEquals(wanted, writeCount);\n+            assertTrue(c.array().length >= data.length + wanted, \"Capacity not increased sufficiently\");\n+        }\n+    }\n+\n }\n",
  "problem_statement" : "Add NIO channel support to `AbstractStreamBuilder`\n\nSome builders derived from `AbstractStreamBuilder` (for example, `SevenZFile.Builder` in Commons Compress) need to produce a `SeekableByteChannel` as their data source. Until now this required ad-hoc `instanceof` switches across different origin types.\r\n\r\nThis change integrates channel support directly into the origin/builder abstraction, leading to a cleaner and more object-oriented design.\r\n\r\n### Key changes\r\n\r\n* Add `getReadableByteChannel()` and `getWritableByteChannel()` to `AbstractOrigin` and propagate to `AbstractStreamBuilder`.\r\n* Introduce `ChannelOrigin`, an `AbstractOrigin` implementation backed by an existing `ReadableByteChannel`/`WritableByteChannel`.\r\n* Add `ByteArrayChannel`, a simple in-memory `SeekableByteChannel` implementation.\r\n* Extend unit tests to cover the new methods and types.\r\n\r\nBefore you push a pull request, review this list:\r\n\r\n- [x] Read the [contribution guidelines](CONTRIBUTING.md) for this project.\r\n- [x] Read the [ASF Generative Tooling Guidance](https://www.apache.org/legal/generative-tooling.html) if you use Artificial Intelligence (AI).\r\n- [x] I used AI to improve the PR description.\r\n- [x] Run a successful build using the default [Maven](https://maven.apache.org/) goal with `mvn`; that's `mvn` on the command line by itself.\r\n- [x] Write unit tests that match behavioral changes, where the tests fail if the changes to the runtime are not applied. This may not always be possible, but it is a best-practice.\r\n- [x] Write a pull request description that is detailed enough to understand what the pull request does, how, and why.\r\n- [x] Each commit in the pull request should have a meaningful subject line and body. Note that a maintainer may squash commits during the merge process.\r\n",
  "hints_text" : null,
  "created_at" : "Sun Sep 21 18:11:31 CEST 2025",
  "version" : null,
  "FAIL_TO_PASS" : [ "CharSequenceOriginTest", "PathOriginTest", "ByteArraySeekableByteChannelCompressTest", "IORandomAccessFileOriginTest", "FileOriginTest", "URIOriginTest", "OutputStreamOriginTest", "ReaderOriginTest", "AbstractStreamBuilderTest", "ByteArrayOriginTest", "ByteArraySeekableByteChannelTest", "AbstractRandomAccessFileOriginTest", "ChannelOriginTest", "InputStreamOriginTest", "WriterStreamOriginTest", "AbstractOriginTest", "RandomAccessFileOriginTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=CharSequenceOriginTest,PathOriginTest,ByteArraySeekableByteChannelCompressTest,IORandomAccessFileOriginTest,FileOriginTest,URIOriginTest,OutputStreamOriginTest,ReaderOriginTest,AbstractStreamBuilderTest,ByteArrayOriginTest,ByteArraySeekableByteChannelTest,AbstractRandomAccessFileOriginTest,ChannelOriginTest,InputStreamOriginTest,WriterStreamOriginTest,AbstractOriginTest,RandomAccessFileOriginTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 784,
  "metadata" : null
}, {
  "instance_id" : "apache-commons-io-PR-781",
  "repo" : "apache/commons-io",
  "base_commit" : "cd20ecebc3facaf3c3b3eaba331d40b289ffe3b9",
  "patch" : "diff --git a/src/changes/changes.xml b/src/changes/changes.xml\nindex a50fe9d3587..0b72c76f9ee 100644\n--- a/src/changes/changes.xml\n+++ b/src/changes/changes.xml\n@@ -60,6 +60,7 @@ The <action> type attribute can be add,update,fix,remove.\n       <action dev=\"ggregory\" type=\"add\"                due-to=\"Gary Gregory\">Add org.apache.commons.io.output.ProxyOutputStream.writeRepeat(byte[], int, int, long).</action>\n       <action dev=\"ggregory\" type=\"add\"                due-to=\"Gary Gregory\">Add org.apache.commons.io.output.ProxyOutputStream.writeRepeat(byte[], long).</action>\n       <action dev=\"ggregory\" type=\"add\"                due-to=\"Gary Gregory\">Add org.apache.commons.io.output.ProxyOutputStream.writeRepeat(int, long).</action>\n+      <action dev=\"pkarwasz\" type=\"add\"                due-to=\"Piotr P. Karwasz\">Add length unit support in FileSystem limits.</action>\n       <action dev=\"pkarwasz\" type=\"add\"                due-to=\"Piotr P. Karwasz\">Add IOUtils.toByteArray(InputStream, int, int) for safer chunked reading with size validation.</action>\n       <!-- UPDATE -->\n       <action type=\"update\" dev=\"ggregory\"             due-to=\"Gary Gregory, Dependabot\">Bump org.apache.commons:commons-parent from 85 to 87 #774.</action>\ndiff --git a/src/main/java/org/apache/commons/io/FileSystem.java b/src/main/java/org/apache/commons/io/FileSystem.java\nindex 0e0ddf05aff..3cccbe7f2d6 100644\n--- a/src/main/java/org/apache/commons/io/FileSystem.java\n+++ b/src/main/java/org/apache/commons/io/FileSystem.java\n@@ -17,6 +17,16 @@\n \n package org.apache.commons.io;\n \n+import static java.nio.charset.StandardCharsets.UTF_16;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.CharBuffer;\n+import java.nio.charset.CharacterCodingException;\n+import java.nio.charset.Charset;\n+import java.nio.charset.CharsetEncoder;\n+import java.nio.charset.CoderResult;\n+import java.nio.charset.CodingErrorAction;\n+import java.text.BreakIterator;\n import java.util.Arrays;\n import java.util.Locale;\n import java.util.Objects;\n@@ -36,7 +46,12 @@ public enum FileSystem {\n     /**\n      * Generic file system.\n      */\n-    GENERIC(4096, false, false, Integer.MAX_VALUE, Integer.MAX_VALUE, new int[] { 0 }, new String[] {}, false, false, '/'),\n+    GENERIC(4096, false, false, 1020, 1024 * 1024, new int[] {\n+            // @formatter:off\n+            // ASCII NUL\n+            0\n+            // @formatter:on\n+    }, new String[] {}, false, false, '/', NameLengthStrategy.BYTES),\n \n     /**\n      * Linux file system.\n@@ -48,7 +63,7 @@ public enum FileSystem {\n             0,\n              '/'\n             // @formatter:on\n-    }, new String[] {}, false, false, '/'),\n+    }, new String[] {}, false, false, '/', NameLengthStrategy.BYTES),\n \n     /**\n      * MacOS file system.\n@@ -61,7 +76,7 @@ public enum FileSystem {\n             '/',\n              ':'\n             // @formatter:on\n-    }, new String[] {}, false, false, '/'),\n+    }, new String[] {}, false, false, '/', NameLengthStrategy.BYTES),\n \n     /**\n      * Windows file system.\n@@ -78,7 +93,7 @@ public enum FileSystem {\n      */\n     // @formatter:off\n     WINDOWS(4096, false, true,\n-            255, 32000, // KEEP THIS ARRAY SORTED!\n+            255, 32767, // KEEP THIS ARRAY SORTED!\n             new int[] {\n                     // KEEP THIS ARRAY SORTED!\n                     // ASCII NUL\n@@ -95,7 +110,7 @@ public enum FileSystem {\n                     \"LPT1\", \"LPT2\", \"LPT3\", \"LPT4\", \"LPT5\", \"LPT6\", \"LPT7\", \"LPT8\", \"LPT9\",\n                     \"LPT\\u00b2\", \"LPT\\u00b3\", \"LPT\\u00b9\", // Superscript 2 3 1 in that order\n                     \"NUL\", \"PRN\"\n-            }, true, true, '\\\\');\n+            }, true, true, '\\\\', NameLengthStrategy.UTF16_CODE_UNITS);\n     // @formatter:on\n \n     /**\n@@ -200,74 +215,16 @@ private static String getSystemProperty(final String property) {\n         }\n     }\n \n-    /**\n-     * Copied from Apache Commons Lang CharSequenceUtils.\n-     *\n-     * Returns the index within {@code cs} of the first occurrence of the\n-     * specified character, starting the search at the specified index.\n-     * <p>\n-     * If a character with value {@code searchChar} occurs in the\n-     * character sequence represented by the {@code cs}\n-     * object at an index no smaller than {@code start}, then\n-     * the index of the first such occurrence is returned. For values\n-     * of {@code searchChar} in the range from 0 to 0xFFFF (inclusive),\n-     * this is the smallest value <em>k</em> such that:\n-     * </p>\n-     * <blockquote><pre>\n-     * (this.charAt(<em>k</em>) == searchChar) &amp;&amp; (<em>k</em> &gt;= start)\n-     * </pre></blockquote>\n-     * is true. For other values of {@code searchChar}, it is the\n-     * smallest value <em>k</em> such that:\n-     * <blockquote><pre>\n-     * (this.codePointAt(<em>k</em>) == searchChar) &amp;&amp; (<em>k</em> &gt;= start)\n-     * </pre></blockquote>\n-     * <p>\n-     * is true. In either case, if no such character occurs in {@code cs}\n-     * at or after position {@code start}, then\n-     * {@code -1} is returned.\n-     * </p>\n-     * <p>\n-     * There is no restriction on the value of {@code start}. If it\n-     * is negative, it has the same effect as if it were zero: the entire\n-     * {@link CharSequence} may be searched. If it is greater than\n-     * the length of {@code cs}, it has the same effect as if it were\n-     * equal to the length of {@code cs}: {@code -1} is returned.\n-     * </p>\n-     * <p>All indices are specified in {@code char} values\n-     * (Unicode code units).\n-     * </p>\n-     *\n-     * @param cs  the {@link CharSequence} to be processed, not null\n-     * @param searchChar  the char to be searched for\n-     * @param start  the start index, negative starts at the string start\n-     * @return the index where the search char was found, -1 if not found\n-     * @since 3.6 updated to behave more like {@link String}\n+    /*\n+     * Finds the index of the first dot in a CharSequence.\n      */\n-    private static int indexOf(final CharSequence cs, final int searchChar, int start) {\n+    private static int indexOfFirstDot(final CharSequence cs) {\n         if (cs instanceof String) {\n-            return ((String) cs).indexOf(searchChar, start);\n-        }\n-        final int sz = cs.length();\n-        if (start < 0) {\n-            start = 0;\n-        }\n-        if (searchChar < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n-            for (int i = start; i < sz; i++) {\n-                if (cs.charAt(i) == searchChar) {\n-                    return i;\n-                }\n-            }\n-            return -1;\n+            return ((String) cs).indexOf('.');\n         }\n-        //supplementary characters (LANG1300)\n-        if (searchChar <= Character.MAX_CODE_POINT) {\n-            final char[] chars = Character.toChars(searchChar);\n-            for (int i = start; i < sz - 1; i++) {\n-                final char high = cs.charAt(i);\n-                final char low = cs.charAt(i + 1);\n-                if (high == chars[0] && low == chars[1]) {\n-                    return i;\n-                }\n+        for (int i = 0; i < cs.length(); i++) {\n+            if (cs.charAt(i) == '.') {\n+                return i;\n             }\n         }\n         return -1;\n@@ -315,6 +272,7 @@ private static String replace(final String path, final char oldChar, final char\n     private final boolean supportsDriveLetter;\n     private final char nameSeparator;\n     private final char nameSeparatorOther;\n+    private final NameLengthStrategy nameLengthStrategy;\n \n     /**\n      * Constructs a new instance.\n@@ -329,10 +287,12 @@ private static String replace(final String path, final char oldChar, final char\n      * @param reservedFileNamesExtensions TODO\n      * @param supportsDriveLetter Whether this file system support driver letters.\n      * @param nameSeparator The name separator, '\\\\' on Windows, '/' on Linux.\n+     * @param nameLengthStrategy The strategy for measuring and truncating file and path names.\n      */\n     FileSystem(final int blockSize, final boolean caseSensitive, final boolean casePreserving,\n         final int maxFileLength, final int maxPathLength, final int[] illegalFileNameChars,\n-        final String[] reservedFileNames, final boolean reservedFileNamesExtensions, final boolean supportsDriveLetter, final char nameSeparator) {\n+        final String[] reservedFileNames, final boolean reservedFileNamesExtensions, final boolean supportsDriveLetter,\n+        final char nameSeparator, final NameLengthStrategy nameLengthStrategy) {\n         this.blockSize = blockSize;\n         this.maxFileNameLength = maxFileLength;\n         this.maxPathLength = maxPathLength;\n@@ -345,6 +305,7 @@ private static String replace(final String path, final char oldChar, final char\n         this.supportsDriveLetter = supportsDriveLetter;\n         this.nameSeparator = nameSeparator;\n         this.nameSeparatorOther = FilenameUtils.flipSeparator(nameSeparator);\n+        this.nameLengthStrategy = nameLengthStrategy;\n     }\n \n     /**\n@@ -380,18 +341,49 @@ public int[] getIllegalFileNameCodePoints() {\n     }\n \n     /**\n-     * Gets the maximum length for file names. The file name does not include folders.\n+     * Gets the maximum length for file names (excluding any folder path).\n+     *\n+     * <p>This limit applies only to the file name itself, excluding any parent\n+     * directories.</p>\n+     *\n+     * <p>The value is expressed in Java {@code char} units (UTF-16 code units).</p>\n+     *\n+     * <p><strong>Note:</strong> Because many file systems enforce limits in\n+     * <em>bytes</em> using a specific encoding rather than in UTF-16 code\n+     * units, a name that fits this limit may still be rejected by the\n+     * underlying file system.</p>\n+     *\n+     * <p>Use {@link #isLegalFileName} to check whether a given name is valid\n+     * for the current file system and charset.</p>\n+     *\n+     * <p>However, any file name longer than this limit is guaranteed to be\n+     * invalid on the current file system.</p>\n      *\n-     * @return the maximum length for file names.\n+     * @return the maximum file name length in characters.\n      */\n     public int getMaxFileNameLength() {\n         return maxFileNameLength;\n     }\n \n     /**\n-     * Gets the maximum length of the path to a file. This can include folders.\n+     * Gets the maximum length for file paths (may include folders).\n      *\n-     * @return the maximum length of the path to a file.\n+     * <p>This value is inclusive of all path components and separators.\n+     * For a limit of each path component see {@link #getMaxFileNameLength()}.</p>\n+     *\n+     * <p>The value is expressed in Java {@code char} units (UTF-16 code units)\n+     * and represents the longest path that can be safely passed to Java\n+     * {@link java.io.File} and {@link java.nio.file.Path} APIs.</p>\n+     *\n+     * <p><strong>Note:</strong> many operating systems and file systems enforce\n+     * path length limits in <em>bytes</em> using a specific encoding, rather than\n+     * in UTF-16 code units. As a result, a path that fits within this limit may\n+     * still be rejected by the underlying platform.</p>\n+     *\n+     * <p>Conversely, any path longer than this limit is guaranteed to fail with\n+     * at least some operating system API calls.</p>\n+     *\n+     * @return the maximum file path length in characters.\n      */\n     public int getMaxPathLength() {\n         return maxPathLength;\n@@ -446,22 +438,46 @@ private boolean isIllegalFileNameChar(final int c) {\n     }\n \n     /**\n-     * Tests if a candidate file name (without a path) such as {@code \"filename.ext\"} or {@code \"filename\"} is a\n-     * potentially legal file name. If the file name length exceeds {@link #getMaxFileNameLength()}, or if it contains\n-     * an illegal character then the check fails.\n+     * Tests if a candidate file name (without a path) is a legal file name.\n+     *\n+     * <p>Takes a file name like {@code \"filename.ext\"} or {@code \"filename\"} and checks:</p>\n+     * <ul>\n+     * <li>if the file name length is legal</li>\n+     * <li>if the file name is not a reserved file name</li>\n+     * <li>if the file name does not contain illegal characters</li>\n+     * </ul>\n      *\n      * @param candidate\n-     *            a candidate file name (without a path) like {@code \"filename.ext\"} or {@code \"filename\"}\n+     *            A candidate file name (without a path) like {@code \"filename.ext\"} or {@code \"filename\"}\n      * @return {@code true} if the candidate name is legal\n      */\n     public boolean isLegalFileName(final CharSequence candidate) {\n-        if (candidate == null || candidate.length() == 0 || candidate.length() > maxFileNameLength) {\n-            return false;\n-        }\n-        if (isReservedFileName(candidate)) {\n-            return false;\n-        }\n-        return candidate.chars().noneMatch(this::isIllegalFileNameChar);\n+        return isLegalFileName(candidate, Charset.defaultCharset());\n+    }\n+\n+    /**\n+     * Tests if a candidate file name (without a path) is a legal file name.\n+     *\n+     * <p>Takes a file name like {@code \"filename.ext\"} or {@code \"filename\"} and checks:</p>\n+     * <ul>\n+     * <li>if the file name length is legal</li>\n+     * <li>if the file name is not a reserved file name</li>\n+     * <li>if the file name does not contain illegal characters</li>\n+     * </ul>\n+     *\n+     * @param candidate\n+     *            A candidate file name (without a path) like {@code \"filename.ext\"} or {@code \"filename\"}\n+     * @param charset\n+     *            The charset to use when the file name length is measured in bytes\n+     * @return {@code true} if the candidate name is legal\n+     * @since 2.21.0\n+     */\n+    public boolean isLegalFileName(final CharSequence candidate, final Charset charset) {\n+        return candidate != null\n+                && candidate.length() != 0\n+                && nameLengthStrategy.isWithinLimit(candidate, getMaxFileNameLength(), charset)\n+                && !isReservedFileName(candidate)\n+                && candidate.chars().noneMatch(this::isIllegalFileNameChar);\n     }\n \n     /**\n@@ -504,30 +520,224 @@ public boolean supportsDriveLetter() {\n     }\n \n     /**\n-     * Converts a candidate file name (without a path) like {@code \"filename.ext\"} or {@code \"filename\"} to a legal file\n-     * name. Illegal characters in the candidate name are replaced by the {@code replacement} character. If the file\n-     * name length exceeds {@link #getMaxFileNameLength()}, then the name is truncated to\n-     * {@link #getMaxFileNameLength()}.\n+     * Converts a candidate file name (without a path) to a legal file name.\n+     *\n+     * <p>Takes a file name like {@code \"filename.ext\"} or {@code \"filename\"} and:</p>\n+     * <ul>\n+     *     <li>replaces illegal characters by the given replacement character</li>\n+     *     <li>truncates the name to {@link #getMaxFileNameLength()} if necessary</li>\n+     * </ul>\n      *\n      * @param candidate\n-     *            a candidate file name (without a path) like {@code \"filename.ext\"} or {@code \"filename\"}\n+     *            A candidate file name (without a path) like {@code \"filename.ext\"} or {@code \"filename\"}\n      * @param replacement\n      *            Illegal characters in the candidate name are replaced by this character\n      * @return a String without illegal characters\n      */\n     public String toLegalFileName(final String candidate, final char replacement) {\n+        return toLegalFileName(candidate, replacement, Charset.defaultCharset());\n+    }\n+\n+    /**\n+     * Converts a candidate file name (without a path) to a legal file name.\n+     *\n+     * <p>Takes a file name like {@code \"filename.ext\"} or {@code \"filename\"} and:</p>\n+     * <ul>\n+     *     <li>replaces illegal characters by the given replacement character</li>\n+     *     <li>truncates the name to {@link #getMaxFileNameLength()} if necessary</li>\n+     * </ul>\n+     *\n+     * @param candidate\n+     *            A candidate file name (without a path) like {@code \"filename.ext\"} or {@code \"filename\"}\n+     * @param replacement\n+     *            Illegal characters in the candidate name are replaced by this character\n+     * @param charset\n+     *            The charset to use when the file name length is measured in bytes\n+     * @return a String without illegal characters\n+     * @since 2.21.0\n+     */\n+    public String toLegalFileName(final String candidate, final char replacement, final Charset charset) {\n+        Objects.requireNonNull(candidate, \"candidate\");\n+        if (candidate.isEmpty()) {\n+            throw new IllegalArgumentException(\"The candidate file name is empty\");\n+        }\n         if (isIllegalFileNameChar(replacement)) {\n             // %s does not work properly with NUL\n             throw new IllegalArgumentException(String.format(\"The replacement character '%s' cannot be one of the %s illegal characters: %s\",\n                 replacement == '\\0' ? \"\\\\0\" : replacement, name(), Arrays.toString(illegalFileNameChars)));\n         }\n-        final String truncated = candidate.length() > maxFileNameLength ? candidate.substring(0, maxFileNameLength) : candidate;\n+        final CharSequence truncated = nameLengthStrategy.truncate(candidate, getMaxFileNameLength(), charset);\n         final int[] array = truncated.chars().map(i -> isIllegalFileNameChar(i) ? replacement : i).toArray();\n         return new String(array, 0, array.length);\n     }\n \n-    CharSequence trimExtension(final CharSequence cs) {\n-        final int index = indexOf(cs, '.', 0);\n-        return index < 0 ? cs : cs.subSequence(0, index);\n+    static CharSequence trimExtension(final CharSequence cs) {\n+        final int index = indexOfFirstDot(cs);\n+        // An initial dot is not an extension\n+        return index < 1 ? cs : cs.subSequence(0, index);\n     }\n+\n+    static CharSequence[] splitExtension(final CharSequence value) {\n+        final int index = indexOfFirstDot(value);\n+        // An initial dot is not an extension\n+        return index < 1\n+                ? new CharSequence[] {value, \"\"}\n+                : new CharSequence[] {value.subSequence(0, index), value.subSequence(index, value.length())};\n+    }\n+\n+    /**\n+     * Truncates a string respecting grapheme cluster boundaries.\n+     *\n+     * @param value The value to truncate.\n+     * @param limit The maximum length.\n+     * @return The truncated value.\n+     * @throws IllegalArgumentException If the first grapheme cluster is longer than the limit.\n+     */\n+    private static CharSequence safeTruncate(final CharSequence value, final int limit) {\n+        if (value.length() <= limit) {\n+            return value;\n+        }\n+        final BreakIterator boundary = BreakIterator.getCharacterInstance(Locale.ROOT);\n+        final String text = value.toString();\n+        boundary.setText(text);\n+        final int end = boundary.preceding(limit + 1);\n+        assert end != BreakIterator.DONE;\n+        if (end == 0) {\n+            final String limitMessage = limit <= 1 ? \"1 character\" : limit + \" characters\";\n+            throw new IllegalArgumentException(\"The value \" + value + \" can not be truncated to \" + limitMessage\n+                    + \" without breaking the first codepoint or grapheme cluster\");\n+        }\n+        return text.substring(0, end);\n+    }\n+\n+    /**\n+     * Strategy for measuring and truncating file or path names in different units.\n+     * Implementations measure length and can truncate to a specified limit.\n+     */\n+    enum NameLengthStrategy {\n+        /** Length measured as encoded bytes. */\n+        BYTES {\n+            @Override\n+            int getLength(final CharSequence value, final Charset charset) {\n+                final CharsetEncoder enc = charset.newEncoder()\n+                        .onMalformedInput(CodingErrorAction.REPORT)\n+                        .onUnmappableCharacter(CodingErrorAction.REPORT);\n+                try {\n+                    return enc.encode(CharBuffer.wrap(value)).remaining();\n+                } catch (CharacterCodingException e) {\n+                    // Unencodable, does not fit any byte limit.\n+                    return Integer.MAX_VALUE;\n+                }\n+            }\n+\n+            @Override\n+            CharSequence truncate(final CharSequence value, final int limit, final Charset charset) {\n+                final CharsetEncoder encoder = charset.newEncoder()\n+                        .onMalformedInput(CodingErrorAction.REPORT)\n+                        .onUnmappableCharacter(CodingErrorAction.REPORT);\n+\n+                if (!encoder.canEncode(value)) {\n+                    throw new IllegalArgumentException(\n+                            \"The value \" + value + \" cannot be encoded using \" + charset.name());\n+                }\n+\n+                // Fast path: if even the worst-case expansion fits, we're done.\n+                if (value.length() <= Math.floor(limit / encoder.maxBytesPerChar())) {\n+                    return value;\n+                }\n+\n+                // Slow path: encode into a fixed-size byte buffer.\n+                // 1. Compute length of extension in bytes (if any).\n+                final CharSequence[] parts = splitExtension(value);\n+                final int extensionLength = getLength(parts[1], charset);\n+                if (extensionLength > 0 && extensionLength >= limit) {\n+                    // Extension itself does not fit\n+                    throw new IllegalArgumentException(\n+                            \"The extension of \" + value + \" is too long to fit within \" + limit + \" bytes\");\n+                }\n+\n+                // 2. Compute the character part that fits within the remaining byte budget.\n+                final ByteBuffer byteBuffer = ByteBuffer.allocate(limit - extensionLength);\n+                final CharBuffer charBuffer = CharBuffer.wrap(parts[0]);\n+\n+                // Encode until the first character that would exceed the byte budget.\n+                final CoderResult cr = encoder.encode(charBuffer, byteBuffer, true);\n+\n+                if (cr.isUnderflow()) {\n+                    // Entire candidate fit within maxFileNameLength bytes.\n+                    return value;\n+                }\n+\n+                final CharSequence truncated = safeTruncate(value, charBuffer.position());\n+                return extensionLength == 0 ? truncated : truncated.toString() + parts[1];\n+            }\n+        },\n+\n+        /** Length measured as UTF-16 code units (i.e., {@code CharSequence.length()}). */\n+        UTF16_CODE_UNITS {\n+            @Override\n+            int getLength(final CharSequence value, final Charset charset) {\n+                return value.length();\n+            }\n+\n+            @Override\n+            CharSequence truncate(final CharSequence value, final int limit, final Charset charset) {\n+                if (!UTF_16.newEncoder().canEncode(value)) {\n+                    throw new IllegalArgumentException(\n+                            \"The value \" + value + \" can not be encoded using \" + UTF_16.name());\n+                }\n+\n+                // Fast path: no truncation needed.\n+                if (value.length() <= limit) {\n+                    return value;\n+                }\n+\n+                // Slow path: truncate to limit.\n+                // 1. Compute length of extension in chars (if any).\n+                final CharSequence[] parts = splitExtension(value);\n+                final int extensionLength = parts[1].length();\n+                if (extensionLength > 0 && extensionLength >= limit) {\n+                    // Extension itself does not fit\n+                    throw new IllegalArgumentException(\n+                            \"The extension of \" + value + \" is too long to fit within \" + limit + \" characters\");\n+                }\n+\n+                // 2. Truncate the non-extension part and append the extension (if any).\n+                final CharSequence truncated = safeTruncate(value, limit - extensionLength);\n+                return extensionLength == 0 ? truncated : truncated.toString() + parts[1];\n+            }\n+        };\n+\n+        /**\n+         * Gets the measured length in this strategyâ€™s unit.\n+         *\n+         * @param value The value to measure, not null.\n+         * @param charset The charset to use when measuring in bytes.\n+         * @return The length in this strategyâ€™s unit.\n+         */\n+        abstract int getLength(CharSequence value, Charset charset);\n+\n+        /**\n+         * Tests if the measured length is less or equal the {@code limit}.\n+         *\n+         * @param value The value to measure, not null.\n+         * @param limit The limit to compare to.\n+         * @param charset The charset to use when measuring in bytes.\n+         * @return {@code true} if the measured length is less or equal the {@code limit}, {@code false} otherwise.\n+         */\n+        final boolean isWithinLimit(final CharSequence value, final int limit, final Charset charset) {\n+            return getLength(value, charset) <= limit;\n+        }\n+\n+        /**\n+         * Truncates to {@code limit} in this strategyâ€™s unit (no-op if already within limit).\n+         *\n+         * @param value The value to truncate, not null.\n+         * @param limit The limit to truncate to.\n+         * @param charset The charset to use when measuring in bytes.\n+         * @return The truncated value, not null.\n+         */\n+        abstract CharSequence truncate(CharSequence value, int limit, Charset charset);\n+    }\n+\n }\n",
  "test_patch" : "diff --git a/src/test/java/org/apache/commons/io/FileSystemTest.java b/src/test/java/org/apache/commons/io/FileSystemTest.java\nindex d061a618e01..0a3c0524ab7 100644\n--- a/src/test/java/org/apache/commons/io/FileSystemTest.java\n+++ b/src/test/java/org/apache/commons/io/FileSystemTest.java\n@@ -17,21 +17,106 @@\n \n package org.apache.commons.io;\n \n+import static java.nio.charset.StandardCharsets.ISO_8859_1;\n+import static java.nio.charset.StandardCharsets.US_ASCII;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static org.apache.commons.io.FileSystem.NameLengthStrategy.BYTES;\n+import static org.apache.commons.io.FileSystem.NameLengthStrategy.UTF16_CODE_UNITS;\n+import static org.apache.commons.lang3.StringUtils.repeat;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n import static org.junit.jupiter.api.Assertions.assertEquals;\n import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertInstanceOf;\n import static org.junit.jupiter.api.Assertions.assertNotSame;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n import static org.junit.jupiter.api.Assertions.assertTrue;\n \n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.nio.charset.Charset;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.stream.Stream;\n+\n+import org.apache.commons.io.FileSystem.NameLengthStrategy;\n+import org.apache.commons.lang3.JavaVersion;\n+import org.apache.commons.lang3.SystemProperties;\n import org.apache.commons.lang3.SystemUtils;\n import org.junit.jupiter.api.Test;\n-import org.junit.jupiter.api.condition.EnabledOnOs;\n-import org.junit.jupiter.api.condition.OS;\n+import org.junit.jupiter.api.io.TempDir;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.EnumSource;\n+import org.junit.jupiter.params.provider.MethodSource;\n \n /**\n  * Tests {@link FileSystem}.\n  */\n class FileSystemTest {\n \n+    /** A single ASCII character that encodes to 1 UTF-8 byte. */\n+    private static final String CHAR_UTF8_1B = \"a\";\n+\n+    /** A single Unicode character that encodes to 2 UTF-8 bytes. */\n+    private static final String CHAR_UTF8_2B = \"Ã©\";\n+\n+    /** A single Unicode character that encodes to 3 UTF-8 bytes. */\n+    private static final String CHAR_UTF8_3B = \"â˜…\";\n+\n+    /** A single Unicode codepoint that encodes to 2 UTF-16 code units and 4 UTF-8 bytes. */\n+    private static final String CHAR_UTF8_4B = \"\uD83D\uDE00\";\n+\n+    /**\n+     * A grapheme cluster that encodes to 69 UTF-8 bytes and 31 UTF-16 code units: \uD83D\uDC69\uD83C\uDFFBâ€\uD83E\uDDB0â€\uD83D\uDC68\uD83C\uDFFFâ€\uD83E\uDDB2â€\uD83D\uDC67\uD83C\uDFFDâ€\uD83E\uDDB1â€\uD83D\uDC66\uD83C\uDFFCâ€\uD83E\uDDB3\n+     * <p>\n+     *     This should be treated as a single character in JDK 20+ for truncation purposes,\n+     *     even if it contains parts that have a meaning on their own.\n+     * </p>\n+     * <ul>\n+     *     <li>{@code \uD83D\uDC69}: 4 UTF-8 bytes and 2 UTF-16 code points.</li>\n+     *     <li>{@code \uD83D\uDC69\uD83C\uDFFBâ€\uD83E\uDDB0}: 15 UTF-8 bytes and 7 UTF-16 code points.</li>\n+     * </ul>\n+     */\n+    private static final String CHAR_UTF8_69B =\n+            // woman + light skin + ZWJ + red hair = 15 bytes\n+            \"\\uD83D\\uDC69\\uD83C\\uDFFB\\u200D\\uD83E\\uDDB0\"\n+                    // ZWJ = 3 bytes\n+                    + \"\\u200D\"\n+                    // man + dark skin + ZWJ + bald = 15 bytes\n+                    + \"\\uD83D\\uDC68\\uD83C\\uDFFF\\u200D\\uD83E\\uDDB2\"\n+                    // ZWJ = 3 bytes\n+                    + \"\\u200D\"\n+                    // girl + medium skin + ZWJ + curly hair = 15 bytes\n+                    + \"\\uD83D\\uDC67\\uD83C\\uDFFD\\u200D\\uD83E\\uDDB1\"\n+                    // ZWJ = 3 bytes\n+                    + \"\\u200D\"\n+                    // boy + medium-light skin + ZWJ + white hair = 15 bytes\n+                    + \"\\uD83D\\uDC66\\uD83C\\uDFFC\\u200D\\uD83E\\uDDB3\";\n+\n+    /** File name of 255 bytes and 255 UTF-16 code units. */\n+    private static final String FILE_NAME_255BYTES_UTF8_1B = repeat(CHAR_UTF8_1B, 255);\n+\n+    /** File name of 255 bytes and 128 UTF-16 code units. */\n+    private static final String FILE_NAME_255BYTES_UTF8_2B = repeat(CHAR_UTF8_2B, 127) + CHAR_UTF8_1B;\n+\n+    /** File name of 255 bytes and 85 UTF-16 code units. */\n+    private static final String FILE_NAME_255BYTES_UTF8_3B = repeat(CHAR_UTF8_3B, 85);\n+\n+    /** File name of 255 bytes and 64 UTF-16 code units. */\n+    private static final String FILE_NAME_255BYTES_UTF8_4B = repeat(CHAR_UTF8_4B, 63) + CHAR_UTF8_3B;\n+\n+    /** File name of 255 bytes and 255 UTF-16 code units. */\n+    private static final String FILE_NAME_255CHARS_UTF8_1B = FILE_NAME_255BYTES_UTF8_1B;\n+\n+    /** File name of 510 bytes and 255 UTF-16 code units. */\n+    private static final String FILE_NAME_255CHARS_UTF8_2B = repeat(CHAR_UTF8_2B, 255);\n+\n+    /** File name of 765 bytes and 255 UTF-16 code units. */\n+    private static final String FILE_NAME_255CHARS_UTF8_3B = repeat(CHAR_UTF8_3B, 255);\n+\n+    /** File name of 511 bytes and 255 UTF-16 code units. */\n+    private static final String FILE_NAME_255CHARS_UTF8_4B = repeat(CHAR_UTF8_4B, 127) + CHAR_UTF8_3B;\n+\n     @Test\n     void testGetBlockSize() {\n         assertTrue(FileSystem.getCurrent().getBlockSize() >= 0);\n@@ -57,19 +142,63 @@ void testGetIllegalFileNameChars() {\n     }\n \n     @Test\n-    void testIsLegalName() {\n-        for (final FileSystem fs : FileSystem.values()) {\n-            assertFalse(fs.isLegalFileName(\"\"), fs.name()); // Empty is always illegal\n-            assertFalse(fs.isLegalFileName(null), fs.name()); // null is always illegal\n-            assertFalse(fs.isLegalFileName(\"\\0\"), fs.name()); // Assume NUL is always illegal\n-            assertTrue(fs.isLegalFileName(\"0\"), fs.name()); // Assume simple name always legal\n-            for (final String candidate : fs.getReservedFileNames()) {\n-                // Reserved file names are not legal\n-                assertFalse(fs.isLegalFileName(candidate), candidate);\n-            }\n+    void testGetNameSeparator() {\n+        final FileSystem current = FileSystem.getCurrent();\n+        assertEquals(SystemProperties.getFileSeparator(), Character.toString(current.getNameSeparator()));\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(FileSystem.class)\n+    void testIsLegalName(final FileSystem fs) {\n+        assertFalse(fs.isLegalFileName(\"\"), fs.name()); // Empty is always illegal\n+        assertFalse(fs.isLegalFileName(null), fs.name()); // null is always illegal\n+        assertFalse(fs.isLegalFileName(\"\\0\"), fs.name()); // Assume NUL is always illegal\n+        assertTrue(fs.isLegalFileName(\"0\"), fs.name()); // Assume simple name always legal\n+        for (final String candidate : fs.getReservedFileNames()) {\n+            // Reserved file names are not legal\n+            assertFalse(fs.isLegalFileName(candidate), candidate);\n         }\n     }\n \n+    static Stream<Arguments> testIsLegalName_Length() {\n+        return Stream.of(\n+                Arguments.of(FileSystem.GENERIC, repeat(FILE_NAME_255BYTES_UTF8_1B, 4), UTF_8),\n+                Arguments.of(FileSystem.GENERIC, repeat(FILE_NAME_255BYTES_UTF8_2B, 4), UTF_8),\n+                Arguments.of(FileSystem.GENERIC, repeat(FILE_NAME_255BYTES_UTF8_3B, 4), UTF_8),\n+                Arguments.of(FileSystem.GENERIC, repeat(FILE_NAME_255BYTES_UTF8_4B, 4), UTF_8),\n+                Arguments.of(FileSystem.LINUX, FILE_NAME_255BYTES_UTF8_1B, UTF_8),\n+                Arguments.of(FileSystem.LINUX, FILE_NAME_255BYTES_UTF8_2B, UTF_8),\n+                Arguments.of(FileSystem.LINUX, FILE_NAME_255BYTES_UTF8_3B, UTF_8),\n+                Arguments.of(FileSystem.LINUX, FILE_NAME_255BYTES_UTF8_4B, UTF_8),\n+                Arguments.of(FileSystem.MAC_OSX, FILE_NAME_255BYTES_UTF8_1B, UTF_8),\n+                Arguments.of(FileSystem.MAC_OSX, FILE_NAME_255BYTES_UTF8_2B, UTF_8),\n+                Arguments.of(FileSystem.MAC_OSX, FILE_NAME_255BYTES_UTF8_3B, UTF_8),\n+                Arguments.of(FileSystem.MAC_OSX, FILE_NAME_255BYTES_UTF8_4B, UTF_8),\n+                Arguments.of(FileSystem.WINDOWS, FILE_NAME_255CHARS_UTF8_1B, UTF_8),\n+                Arguments.of(FileSystem.WINDOWS, FILE_NAME_255CHARS_UTF8_2B, UTF_8),\n+                Arguments.of(FileSystem.WINDOWS, FILE_NAME_255CHARS_UTF8_3B, UTF_8),\n+                Arguments.of(FileSystem.WINDOWS, FILE_NAME_255CHARS_UTF8_4B, UTF_8),\n+                // Repeat some tests with other encodings for GENERIC and LINUX\n+                Arguments.of(FileSystem.GENERIC, repeat(FILE_NAME_255BYTES_UTF8_1B, 4), US_ASCII),\n+                Arguments.of(FileSystem.GENERIC, repeat(CHAR_UTF8_2B, 1020), ISO_8859_1),\n+                Arguments.of(FileSystem.LINUX, FILE_NAME_255BYTES_UTF8_1B, US_ASCII),\n+                Arguments.of(FileSystem.LINUX, repeat(CHAR_UTF8_2B, 255), ISO_8859_1));\n+    }\n+\n+    @ParameterizedTest(name = \"{index}: {0} with charset {2}\")\n+    @MethodSource\n+    void testIsLegalName_Length(FileSystem fs, String nameAtLimit, Charset charset) {\n+        assertTrue(fs.isLegalFileName(nameAtLimit, charset), fs.name() + \" length at limit\");\n+        final String nameOverLimit = nameAtLimit + \"a\";\n+        assertFalse(fs.isLegalFileName(nameOverLimit, charset), fs.name() + \" length over limit\");\n+    }\n+\n+    @Test\n+    void testIsLegalName_Encoding() {\n+        assertFalse(FileSystem.GENERIC.isLegalFileName(FILE_NAME_255BYTES_UTF8_3B, US_ASCII), \"US-ASCII cannot represent all chars\");\n+        assertTrue(FileSystem.GENERIC.isLegalFileName(FILE_NAME_255BYTES_UTF8_3B, UTF_8), \"UTF-8 can represent all chars\");\n+    }\n+\n     @Test\n     void testIsReservedFileName() {\n         for (final FileSystem fs : FileSystem.values()) {\n@@ -80,7 +209,6 @@ void testIsReservedFileName() {\n     }\n \n     @Test\n-    @EnabledOnOs(OS.WINDOWS)\n     void testIsReservedFileNameOnWindows() {\n         final FileSystem fs = FileSystem.WINDOWS;\n         for (final String candidate : fs.getReservedFileNames()) {\n@@ -128,6 +256,90 @@ void testSorted() {\n         }\n     }\n \n+    @Test\n+    void testMaxNameLength_MatchesRealSystem(@TempDir Path tempDir) {\n+        final FileSystem fs = FileSystem.getCurrent();\n+        final String[] validNames;\n+        switch (fs) {\n+            case MAC_OSX:\n+            case LINUX:\n+                // Names with 255 UTF-8 bytes are legal\n+                validNames = new String[] {\n+                    FILE_NAME_255BYTES_UTF8_1B,\n+                    FILE_NAME_255BYTES_UTF8_2B,\n+                    FILE_NAME_255BYTES_UTF8_3B,\n+                    FILE_NAME_255BYTES_UTF8_4B\n+                };\n+                break;\n+            case WINDOWS:\n+                // Names with 255 UTF-16 code units are legal\n+                validNames = new String[] {\n+                    FILE_NAME_255CHARS_UTF8_1B,\n+                    FILE_NAME_255CHARS_UTF8_2B,\n+                    FILE_NAME_255CHARS_UTF8_3B,\n+                    FILE_NAME_255CHARS_UTF8_4B\n+                };\n+                break;\n+            default:\n+                throw new IllegalStateException(\"Unexpected value: \" + fs);\n+        }\n+        int failures = 0;\n+        for (final String fileName : validNames) {\n+            // 1) OS should accept names at the documented limit.\n+            assertDoesNotThrow(\n+                    () -> createAndDelete(tempDir, fileName), \"OS should accept max-length name: \" + fileName);\n+\n+            // 2) Library should consider them legal.\n+            assertTrue(fs.isLegalFileName(fileName, UTF_8), \"Commons IO should accept max-length name: \" + fileName);\n+\n+            // 3) For â€œone overâ€ the limit: Commons IO must reject; OS may or may not enforce strictly.\n+            final String tooLongName = fileName + \"a\";\n+\n+            // Library contract: must be illegal.\n+            assertFalse(\n+                    fs.isLegalFileName(tooLongName, UTF_8), \"Commons IO should reject too-long name: \" + tooLongName);\n+\n+            // OS behavior: may or may not reject.\n+            try {\n+                createAndDelete(tempDir, tooLongName);\n+            } catch (final Throwable e) {\n+                failures++;\n+                assertInstanceOf(IOException.class, e, \"OS rejects too-long name\");\n+            }\n+        }\n+        // On Linux and Windows the API and the filesystem measure name length\n+        // in the same unit as the underlying limit (255 bytes on Linux/most POSIX,\n+        // 255 UTF-16 code units on Windows).\n+        // So all â€œtoo-longâ€ variants should fail.\n+        //\n+        // macOS is trickier because the API and filesystem limits donâ€™t always match:\n+        //\n+        // - POSIX API layer (getdirentries/readdir): 1023 bytes per component since macOS 10.5.\n+        //   https://man.freebsd.org/cgi/man.cgi?query=dir&sektion=5&apropos=0&manpath=macOS+15.6\n+        // - HFS+: enforces 255 UTF-16 code units per component.\n+        // - APFS: enforces 255 UTF-8 bytes per component.\n+        //\n+        // Because of this mismatch, depending on which filesystem is mounted,\n+        // either all or only FILE_NAME_255BYTES_UTF8_1B + \"a\" will be rejected.\n+        if (SystemUtils.IS_OS_MAC_OSX) {\n+            assertTrue(failures >= 1, \"Expected at least one too-long name rejected, got \" + failures);\n+        } else {\n+            assertEquals(4, failures, \"All too-long names were rejected\");\n+        }\n+    }\n+\n+    private static void createAndDelete(Path tempDir, String fileName) throws IOException {\n+        final Path filePath = tempDir.resolve(fileName);\n+        Files.createFile(filePath);\n+        try (Stream<Path> files = Files.list(tempDir)) {\n+            final boolean found = files.anyMatch(filePath::equals);\n+            if (!found) {\n+                throw new FileNotFoundException(fileName + \" not found in \" + tempDir);\n+            }\n+        }\n+        Files.delete(filePath);\n+    }\n+\n     @Test\n     void testSupportsDriveLetter() {\n         assertTrue(FileSystem.WINDOWS.supportsDriveLetter());\n@@ -156,5 +368,126 @@ void testToLegalFileNameWindows() {\n         for (char i = '0'; i < '9'; i++) {\n             assertEquals(i, fs.toLegalFileName(String.valueOf(i), replacement).charAt(0));\n         }\n+        // Null and empty\n+        assertThrows(NullPointerException.class, () -> fs.toLegalFileName(null, '_'));\n+        assertThrows(IllegalArgumentException.class, () -> fs.toLegalFileName(\"\", '_'));\n+        // Illegal replacement\n+        assertThrows(IllegalArgumentException.class, () -> fs.toLegalFileName(\"test\", '\\0'));\n+        assertThrows(IllegalArgumentException.class, () -> fs.toLegalFileName(\"test\", ':'));\n+    }\n+\n+    static Stream<Arguments> testNameLengthStrategyTruncate_Succeeds() {\n+        // The grapheme cluster CHAR_UTF8_69B is treated as a single character in JDK 20+,\n+        final String woman;\n+        final String redHeadWoman;\n+        if (SystemUtils.isJavaVersionAtMost(JavaVersion.JAVA_19)) {\n+            woman = CHAR_UTF8_69B.substring(0, 2); // \uD83D\uDC69\n+            redHeadWoman = CHAR_UTF8_69B.substring(0, 7); // \uD83D\uDC69\uD83C\uDFFBâ€\uD83E\uDDB0\n+        } else {\n+            woman = \"\";\n+            redHeadWoman = \"\";\n+        }\n+        return Stream.of(\n+                // Truncation by bytes\n+                // -------------------\n+                //\n+                // Empty\n+                Arguments.of(BYTES, 0, \"\", \"\"),\n+                // Simple name without truncation\n+                Arguments.of(BYTES, 10, \"simple.txt\", \"simple.txt\"),\n+                // Name starting with dot\n+                Arguments.of(BYTES, 10, \".\" + repeat(CHAR_UTF8_1B, 10), \".\" + repeat(CHAR_UTF8_1B, 9)),\n+                Arguments.of(BYTES, 20, \".\" + repeat(CHAR_UTF8_2B, 10), \".\" + repeat(CHAR_UTF8_2B, 9)),\n+                Arguments.of(BYTES, 30, \".\" + repeat(CHAR_UTF8_3B, 10), \".\" + repeat(CHAR_UTF8_3B, 9)),\n+                Arguments.of(BYTES, 40, \".\" + repeat(CHAR_UTF8_4B, 10), \".\" + repeat(CHAR_UTF8_4B, 9)),\n+                // Names with extensions\n+                Arguments.of(BYTES, 13, repeat(CHAR_UTF8_1B, 10) + \".txt\", repeat(CHAR_UTF8_1B, 9) + \".txt\"),\n+                Arguments.of(BYTES, 23, repeat(CHAR_UTF8_2B, 10) + \".txt\", repeat(CHAR_UTF8_2B, 9) + \".txt\"),\n+                Arguments.of(BYTES, 33, repeat(CHAR_UTF8_3B, 10) + \".txt\", repeat(CHAR_UTF8_3B, 9) + \".txt\"),\n+                Arguments.of(BYTES, 43, repeat(CHAR_UTF8_4B, 10) + \".txt\", repeat(CHAR_UTF8_4B, 9) + \".txt\"),\n+                // Names without extensions\n+                Arguments.of(BYTES, 1, CHAR_UTF8_1B, CHAR_UTF8_1B),\n+                Arguments.of(BYTES, 2, CHAR_UTF8_2B, CHAR_UTF8_2B),\n+                Arguments.of(BYTES, 3, CHAR_UTF8_3B, CHAR_UTF8_3B),\n+                Arguments.of(BYTES, 4, CHAR_UTF8_4B, CHAR_UTF8_4B),\n+                Arguments.of(BYTES, 9, repeat(CHAR_UTF8_1B, 10), repeat(CHAR_UTF8_1B, 9)),\n+                Arguments.of(BYTES, 19, repeat(CHAR_UTF8_2B, 10), repeat(CHAR_UTF8_2B, 9)),\n+                Arguments.of(BYTES, 29, repeat(CHAR_UTF8_3B, 10), repeat(CHAR_UTF8_3B, 9)),\n+                Arguments.of(BYTES, 39, repeat(CHAR_UTF8_4B, 10), repeat(CHAR_UTF8_4B, 9)),\n+                // Grapheme cluster\n+                Arguments.of(BYTES, 69, CHAR_UTF8_69B, CHAR_UTF8_69B),\n+                // Will not cut 4 or 15 bytes of the grapheme cluster\n+                Arguments.of(BYTES, 69 + 4, repeat(CHAR_UTF8_69B, 2), CHAR_UTF8_69B + woman),\n+                Arguments.of(BYTES, 69 + 15, repeat(CHAR_UTF8_69B, 2), CHAR_UTF8_69B + redHeadWoman),\n+                // Truncation by UTF-16 code units\n+                // -------------------------------\n+                // Empty\n+                Arguments.of(UTF16_CODE_UNITS, 0, \"\", \"\"),\n+                // Simple name without truncation\n+                Arguments.of(UTF16_CODE_UNITS, 10, \"simple.txt\", \"simple.txt\"),\n+                // Name starting with dot\n+                Arguments.of(UTF16_CODE_UNITS, 10, \".\" + repeat(CHAR_UTF8_1B, 10), \".\" + repeat(CHAR_UTF8_1B, 9)),\n+                Arguments.of(UTF16_CODE_UNITS, 10, \".\" + repeat(CHAR_UTF8_2B, 10), \".\" + repeat(CHAR_UTF8_2B, 9)),\n+                Arguments.of(UTF16_CODE_UNITS, 10, \".\" + repeat(CHAR_UTF8_3B, 10), \".\" + repeat(CHAR_UTF8_3B, 9)),\n+                Arguments.of(UTF16_CODE_UNITS, 20, \".\" + repeat(CHAR_UTF8_4B, 10), \".\" + repeat(CHAR_UTF8_4B, 9)),\n+                // Names with extensions\n+                Arguments.of(UTF16_CODE_UNITS, 13, repeat(CHAR_UTF8_1B, 10) + \".txt\", repeat(CHAR_UTF8_1B, 9) + \".txt\"),\n+                Arguments.of(UTF16_CODE_UNITS, 13, repeat(CHAR_UTF8_2B, 10) + \".txt\", repeat(CHAR_UTF8_2B, 9) + \".txt\"),\n+                Arguments.of(UTF16_CODE_UNITS, 13, repeat(CHAR_UTF8_3B, 10) + \".txt\", repeat(CHAR_UTF8_3B, 9) + \".txt\"),\n+                Arguments.of(UTF16_CODE_UNITS, 23, repeat(CHAR_UTF8_4B, 10) + \".txt\", repeat(CHAR_UTF8_4B, 9) + \".txt\"),\n+                // Names without extensions\n+                Arguments.of(UTF16_CODE_UNITS, 1, CHAR_UTF8_1B, CHAR_UTF8_1B),\n+                Arguments.of(UTF16_CODE_UNITS, 1, CHAR_UTF8_2B, CHAR_UTF8_2B),\n+                Arguments.of(UTF16_CODE_UNITS, 1, CHAR_UTF8_3B, CHAR_UTF8_3B),\n+                Arguments.of(UTF16_CODE_UNITS, 2, CHAR_UTF8_4B, CHAR_UTF8_4B),\n+                Arguments.of(UTF16_CODE_UNITS, 9, repeat(CHAR_UTF8_1B, 10), repeat(CHAR_UTF8_1B, 9)),\n+                Arguments.of(UTF16_CODE_UNITS, 9, repeat(CHAR_UTF8_2B, 10), repeat(CHAR_UTF8_2B, 9)),\n+                Arguments.of(UTF16_CODE_UNITS, 9, repeat(CHAR_UTF8_3B, 10), repeat(CHAR_UTF8_3B, 9)),\n+                Arguments.of(UTF16_CODE_UNITS, 19, repeat(CHAR_UTF8_4B, 10), repeat(CHAR_UTF8_4B, 9)),\n+                // Grapheme cluster\n+                Arguments.of(UTF16_CODE_UNITS, 31, CHAR_UTF8_69B, CHAR_UTF8_69B),\n+                // Will not cut 2 or 7 UTF-16 code units of the grapheme cluster\n+                Arguments.of(UTF16_CODE_UNITS, 31 + 2, repeat(CHAR_UTF8_69B, 2), CHAR_UTF8_69B + woman),\n+                Arguments.of(UTF16_CODE_UNITS, 31 + 7, repeat(CHAR_UTF8_69B, 2), CHAR_UTF8_69B + redHeadWoman));\n+    }\n+\n+    @ParameterizedTest(name = \"{index}: {0} truncates {1} to {2}\")\n+    @MethodSource\n+    void testNameLengthStrategyTruncate_Succeeds(NameLengthStrategy strategy, int limit, String input, String expected) {\n+        final CharSequence out = strategy.truncate(input, limit, UTF_8);\n+        assertEquals(expected, out.toString(), strategy.name() + \" truncates to limit\");\n+    }\n+\n+    static Stream<Arguments> testNameLengthStrategyTruncate_Throws() {\n+        final Stream<Arguments> common = Stream.of(\n+                // Encoding issues\n+                Arguments.of(BYTES, 10, \"cafÃ©\", US_ASCII, \"US-ASCII\"),\n+                Arguments.of(UTF16_CODE_UNITS, 10, \"\\uD800.txt\", UTF_8, \"UTF-16\"),\n+                Arguments.of(UTF16_CODE_UNITS, 10, \"\\uDC00.txt\", UTF_8, \"UTF-16\"),\n+                // Extension too long\n+                Arguments.of(BYTES, 4, \"a.txt\", UTF_8, \"extension\"),\n+                Arguments.of(UTF16_CODE_UNITS, 4, \"a.txt\", UTF_8, \"extension\"),\n+                // Limit too small\n+                Arguments.of(BYTES, 3, CHAR_UTF8_4B, UTF_8, \"truncated to 1 character\"),\n+                Arguments.of(UTF16_CODE_UNITS, 1, CHAR_UTF8_4B, UTF_8, \"truncated to 1 character\"));\n+        return SystemUtils.isJavaVersionAtMost(JavaVersion.JAVA_19)\n+                ? common\n+                : Stream.concat(\n+                        common,\n+                        // In JDK 20+ the grapheme cluster CHAR_UTF8_69B is treated as a single character,\n+                        // so cannot be truncated to 2 or 7 code units\n+                        Stream.of(\n+                                Arguments.of(BYTES, 68, CHAR_UTF8_69B, UTF_8, \"truncated to 29 characters\"),\n+                                Arguments.of(UTF16_CODE_UNITS, 30, CHAR_UTF8_69B, UTF_8, \"truncated to 30 characters\")));\n+    }\n+\n+    @ParameterizedTest(name = \"{index}: {0} truncates {2} with limit {1} throws\")\n+    @MethodSource\n+    void testNameLengthStrategyTruncate_Throws(\n+            NameLengthStrategy strategy, int limit, String input, Charset charset, String message) {\n+        final IllegalArgumentException ex =\n+                assertThrows(IllegalArgumentException.class, () -> strategy.truncate(input, limit, charset));\n+        final String exMessage = ex.getMessage();\n+        assertTrue(exMessage.contains(message), \"ex message contains \" + message + \": \" + exMessage);\n     }\n }\n",
  "problem_statement" : "feat: add length unit support in FileSystem limits\n\nDifferent filesystems and operating systems measure file and path lengths in different units:\r\n\r\n* <s>macOS and</s> Windows filesystems typically count **UTF-16 code units**.\r\n* Linux and other UNIX filesystems typically count **bytes**.\r\n\r\nThis change introduces explicit unit support so these limits can be interpreted consistently.\r\n\r\n### Key changes\r\n\r\n* **New API**\r\n\r\n  * <s>Added a `LengthUnit` enum and `FileSystem.getLengthUnit()` to expose the unit of measure used by `getMaxFileNameLength()` and `getMaxPathLength()`</s>.\r\n  * Added new overloads for `isLegalFileName` and `toLegalFileName` that accept a `Charset`, making conversions between bytes and UTF-16 explicit.\r\n\r\n* **Adjusted defaults**\r\n\r\n  * Reduced the `GENERIC` filesystem defaults:\r\n\r\n    * File name length â†’ **1020 bytes** (covers 255 UTF-16 characters encoded as up to 3 UTF-8 bytes).\r\n    * Path length â†’ **1 MiB** (covers 32,767 UTF-16 code units, again at 3 UTF-8 bytes each).\r\n\r\n* **Testing**\r\n\r\n  * Added unit tests to validate the new API and updated limits.\r\n",
  "hints_text" : null,
  "created_at" : "Sat Sep 06 00:48:53 CEST 2025",
  "version" : null,
  "FAIL_TO_PASS" : [ "FileSystemTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=FileSystemTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 781,
  "metadata" : null
}, {
  "instance_id" : "apache-commons-io-PR-779",
  "repo" : "apache/commons-io",
  "base_commit" : "28873d13364509716b0ac520f31081b5f62f3263",
  "patch" : "diff --git a/src/changes/changes.xml b/src/changes/changes.xml\nindex de92deabf64..f10698852c1 100644\n--- a/src/changes/changes.xml\n+++ b/src/changes/changes.xml\n@@ -50,6 +50,8 @@ The <action> type attribute can be add,update,fix,remove.\n       <action type=\"fix\" dev=\"ggregory\"                due-to=\"Gary Gregory\">When testing on Java 21 and up, enable -XX:+EnableDynamicAgentLoading.</action>\n       <action type=\"fix\" dev=\"ggregory\"                due-to=\"Gary Gregory\">When testing on Java 24 and up, don't fail FileUtilsListFilesTest for a different behavior in the JRE.</action>\n       <action type=\"fix\" dev=\"ggregory\"                due-to=\"Stanislav Fort, Gary Gregory\">ValidatingObjectInputStream does not validate dynamic proxy interfaces.</action>\n+      <action type=\"fix\" dev=\"pkarwasz\"                due-to=\"Piotr P. Karwasz\">BoundedInputStream.getRemaining() now reports Long.MAX_VALUE instead of 0 when no limit is set.</action>\n+      <action type=\"fix\" dev=\"pkarwasz\"                due-to=\"Piotr P. Karwasz\">BoundedInputStream.available() correctly accounts for the maximum read limit.</action>\n       <!-- ADD -->\n       <action dev=\"ggregory\" type=\"add\"                due-to=\"strangelookingnerd, Gary Gregory\">FileUtils#byteCountToDisplaySize() supports Zettabyte, Yottabyte, Ronnabyte and Quettabyte #763.</action>\n       <action dev=\"ggregory\" type=\"add\"                due-to=\"strangelookingnerd, Gary Gregory\">Add org.apache.commons.io.FileUtils.ONE_RB #763.</action>\ndiff --git a/src/main/java/org/apache/commons/io/input/BoundedInputStream.java b/src/main/java/org/apache/commons/io/input/BoundedInputStream.java\nindex ce642f866ef..1cbef865d24 100644\n--- a/src/main/java/org/apache/commons/io/input/BoundedInputStream.java\n+++ b/src/main/java/org/apache/commons/io/input/BoundedInputStream.java\n@@ -370,16 +370,11 @@ protected synchronized void afterRead(final int n) throws IOException {\n         super.afterRead(n);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     @Override\n     public int available() throws IOException {\n-        if (isMaxCount()) {\n-            onMaxLength(maxCount, getCount());\n-            return 0;\n-        }\n-        return in.available();\n+        // Safe cast: value is between 0 and Integer.MAX_VALUE\n+        final int remaining = (int) Math.min(getRemaining(), Integer.MAX_VALUE);\n+        return Math.min(super.available(), remaining);\n     }\n \n     /**\n@@ -405,9 +400,9 @@ public synchronized long getCount() {\n     }\n \n     /**\n-     * Gets the max count of bytes to read.\n+     * Gets the maximum number of bytes to read.\n      *\n-     * @return The max count of bytes to read.\n+     * @return The maximum number of bytes to read, or {@value IOUtils#EOF} if unbounded.\n      * @since 2.16.0\n      */\n     public long getMaxCount() {\n@@ -427,13 +422,21 @@ public long getMaxLength() {\n     }\n \n     /**\n-     * Gets how many bytes remain to read.\n+     * Gets the number of bytes remaining to read before the maximum is reached.\n+     *\n+     * <p>\n+     * This method does <strong>not</strong> report the bytes available in the\n+     * underlying stream; it only reflects the remaining allowance imposed by this\n+     * {@code BoundedInputStream}.\n+     * </p>\n      *\n-     * @return bytes how many bytes remain to read.\n+     * @return The number of bytes remaining to read before the maximum is reached,\n+     *         or {@link Long#MAX_VALUE} if no bound is set.\n      * @since 2.16.0\n      */\n     public long getRemaining() {\n-        return Math.max(0, getMaxCount() - getCount());\n+        final long maxCount = getMaxCount();\n+        return maxCount == EOF ? Long.MAX_VALUE : Math.max(0, maxCount - getCount());\n     }\n \n     private boolean isMaxCount() {\n",
  "test_patch" : "diff --git a/src/test/java/org/apache/commons/io/input/BoundedInputStreamTest.java b/src/test/java/org/apache/commons/io/input/BoundedInputStreamTest.java\nindex 9c8f679375b..3aba3c93885 100644\n--- a/src/test/java/org/apache/commons/io/input/BoundedInputStreamTest.java\n+++ b/src/test/java/org/apache/commons/io/input/BoundedInputStreamTest.java\n@@ -23,18 +23,27 @@\n import static org.junit.jupiter.api.Assertions.assertThrows;\n import static org.junit.jupiter.api.Assertions.assertThrowsExactly;\n import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoMoreInteractions;\n+import static org.mockito.Mockito.when;\n \n import java.io.ByteArrayInputStream;\n import java.io.IOException;\n import java.io.InputStream;\n import java.nio.charset.StandardCharsets;\n import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Stream;\n \n import org.apache.commons.io.IOUtils;\n import org.apache.commons.io.test.CustomIOException;\n import org.apache.commons.lang3.mutable.MutableInt;\n import org.junit.jupiter.api.Test;\n import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n import org.junit.jupiter.params.provider.ValueSource;\n \n /**\n@@ -80,21 +89,74 @@ void testAfterReadConsumer() throws Exception {\n         // @formatter:on\n     }\n \n-    @SuppressWarnings(\"resource\")\n-    @Test\n-    void testAvailableAfterClose() throws Exception {\n+    static Stream<Arguments> testAvailableAfterClose() throws IOException {\n+        // Case 1: behaves like ByteArrayInputStream â€” close() is a no-op, available() still returns a value (e.g., 42).\n+        final InputStream noOpClose = mock(InputStream.class);\n+        when(noOpClose.available()).thenReturn(42, 42);\n+\n+        // Case 2: returns 0 after close (Commons memory-backed streams that ignore close but report 0 when exhausted).\n+        final InputStream returnsZeroAfterClose = mock(InputStream.class);\n+        when(returnsZeroAfterClose.available()).thenReturn(42, 0);\n+\n+        // Case 3: throws IOException after close (e.g., FileInputStream-like behavior).\n+        final InputStream throwsAfterClose = mock(InputStream.class);\n+        when(throwsAfterClose.available()).thenReturn(42).thenThrow(new IOException(\"Stream closed\"));\n+\n+        return Stream.of(\n+                Arguments.of(\"underlying stream still returns 42 after close\", noOpClose, 42),\n+                Arguments.of(\"underlying stream returns 0 after close\", returnsZeroAfterClose, 42),\n+                Arguments.of(\"underlying stream throws IOException after close\", throwsAfterClose, 42));\n+    }\n+\n+    @ParameterizedTest(name = \"{index} â€” {0}\")\n+    @MethodSource\n+    void testAvailableAfterClose(String caseName, InputStream delegate, int expectedBeforeClose)\n+            throws Exception {\n         final InputStream shadow;\n-        try (InputStream in = BoundedInputStream.builder().setCharSequence(\"Hi\").get()) {\n-            assertTrue(in.available() > 0);\n-            shadow = in;\n-        }\n-        assertEquals(0, shadow.available());\n+        try (InputStream in = BoundedInputStream.builder()\n+                .setInputStream(delegate)\n+                .setPropagateClose(true)\n+                .get()) {\n+            // Before close: pass-through behavior\n+            assertEquals(expectedBeforeClose, in.available(), caseName + \" (before close)\");\n+            shadow = in; // keep reference to call after close\n+        }\n+        // Verify the underlying stream was closed\n+        verify(delegate, times(1)).close();\n+        // After close: behavior depends on the underlying stream\n+        assertEquals(0, shadow.available(), caseName + \" (after close)\");\n+        // Interactions: available called only once before close.\n+        verify(delegate, times(1)).available();\n+        verifyNoMoreInteractions(delegate);\n     }\n \n-    @Test\n-    void testAvailableAfterOpen() throws Exception {\n-        try (InputStream in = BoundedInputStream.builder().setCharSequence(\"Hi\").get()) {\n-            assertTrue(in.available() > 0);\n+    static Stream<Arguments> testAvailableUpperLimit() {\n+        final byte[] helloWorld = \"Hello World\".getBytes(StandardCharsets.UTF_8);\n+        return Stream.of(\n+                // Limited by maxCount\n+                Arguments.of(new ByteArrayInputStream(helloWorld), helloWorld.length - 1, helloWorld.length - 1, 0),\n+                // Limited by data length\n+                Arguments.of(new ByteArrayInputStream(helloWorld), helloWorld.length + 1, helloWorld.length, 0),\n+                // Limited by Integer.MAX_VALUE\n+                Arguments.of(\n+                        new NullInputStream(Long.MAX_VALUE), Long.MAX_VALUE, Integer.MAX_VALUE, Integer.MAX_VALUE));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    void testAvailableUpperLimit(InputStream input, long maxCount, int expectedBeforeSkip, int expectedAfterSkip)\n+            throws Exception {\n+        try (BoundedInputStream bounded = BoundedInputStream.builder()\n+                .setInputStream(input)\n+                .setMaxCount(maxCount)\n+                .get()) {\n+            assertEquals(\n+                    expectedBeforeSkip, bounded.available(), \"available should be limited by maxCount and data length\");\n+            IOUtils.skip(bounded, expectedBeforeSkip);\n+            assertEquals(\n+                    expectedAfterSkip,\n+                    bounded.available(),\n+                    \"after skipping available should be limited by maxCount and data length\");\n         }\n     }\n \n@@ -444,15 +506,58 @@ void testPublicConstructors() throws IOException {\n         }\n     }\n \n-    @SuppressWarnings(\"resource\")\n-    @Test\n-    void testReadAfterClose() throws Exception {\n-        final InputStream shadow;\n-        try (InputStream in = BoundedInputStream.builder().setCharSequence(\"Hi\").get()) {\n-            assertTrue(in.available() > 0);\n-            shadow = in;\n+    static Stream<Arguments> testReadAfterClose() throws IOException {\n+        // Case 1: no-op close (ByteArrayInputStream-like): read() still returns a value after close\n+        final InputStream noOpClose = mock(InputStream.class);\n+        when(noOpClose.read()).thenReturn(42);\n+\n+        // Case 2: returns EOF (-1) after close\n+        final InputStream returnsEofAfterClose = mock(InputStream.class);\n+        when(returnsEofAfterClose.read()).thenReturn(IOUtils.EOF);\n+\n+        // Case 3: throws IOException after close (FileInputStream-like)\n+        final InputStream throwsAfterClose = mock(InputStream.class);\n+        final IOException closed = new IOException(\"Stream closed\");\n+        when(throwsAfterClose.read()).thenThrow(closed);\n+\n+        return Stream.of(\n+                Arguments.of(\"underlying stream still reads data after close\", noOpClose, 42),\n+                Arguments.of(\"underlying stream returns EOF after close\", returnsEofAfterClose, IOUtils.EOF),\n+                Arguments.of(\"underlying stream throws IOException after close\", throwsAfterClose, closed));\n+    }\n+\n+    @ParameterizedTest(name = \"{index} â€” {0}\")\n+    @MethodSource(\"testReadAfterClose\")\n+    void testReadAfterClose(\n+            String caseName,\n+            InputStream delegate,\n+            Object expectedAfterClose // Integer (value) or IOException (expected thrown)\n+            ) throws Exception {\n+\n+        final InputStream bounded;\n+        try (InputStream in = BoundedInputStream.builder()\n+                .setInputStream(delegate)\n+                .setPropagateClose(true)\n+                .get()) {\n+            bounded = in; // call read() only after close\n+        }\n+\n+        // Underlying stream should be closed exactly once\n+        verify(delegate, times(1)).close();\n+\n+        if (expectedAfterClose instanceof Integer) {\n+            assertEquals(expectedAfterClose, bounded.read(), caseName + \" (after close)\");\n+        } else if (expectedAfterClose instanceof IOException) {\n+            final IOException actual = assertThrows(IOException.class, bounded::read, caseName + \" (after close)\");\n+            // verify it's the exact instance we configured\n+            assertSame(expectedAfterClose, actual, caseName + \" (exception instance)\");\n+        } else {\n+            fail(\"Unexpected expectedAfterClose type: \" + expectedAfterClose);\n         }\n-        assertEquals(IOUtils.EOF, shadow.read());\n+\n+        // We only performed one read() (after close)\n+        verify(delegate, times(1)).read();\n+        verifyNoMoreInteractions(delegate);\n     }\n \n     @Test\n@@ -494,6 +599,46 @@ void testReadArray() throws Exception {\n         }\n     }\n \n+    static Stream<Arguments> testRemaining() {\n+        return Stream.of(\n+                // Unbounded: any negative maxCount is treated as \"no limit\".\n+                Arguments.of(\"unbounded (EOF constant)\", IOUtils.EOF, Long.MAX_VALUE),\n+                Arguments.of(\"unbounded (arbitrary negative)\", Long.MIN_VALUE, Long.MAX_VALUE),\n+\n+                // Bounded: remaining equals the configured limit, regardless of underlying data size.\n+                Arguments.of(\"bounded (zero)\", 0L, 0L),\n+                Arguments.of(\"bounded (small)\", 1024L, 1024L),\n+                Arguments.of(\"bounded (Integer.MAX_VALUE)\", Integer.MAX_VALUE, (long) Integer.MAX_VALUE),\n+\n+                // Bounded but extremely large: still not 'unbounded'.\n+                Arguments.of(\"bounded (Long.MAX_VALUE)\", Long.MAX_VALUE, Long.MAX_VALUE));\n+    }\n+\n+    @ParameterizedTest(name = \"{index}: {0} -> initial remaining {2}\")\n+    @MethodSource\n+    void testRemaining(final String caseName, final long maxCount, final long expectedInitialRemaining)\n+            throws Exception {\n+        final byte[] data = \"Hello World\".getBytes(StandardCharsets.UTF_8); // 11 bytes\n+\n+        try (BoundedInputStream in = BoundedInputStream.builder()\n+                .setByteArray(data)\n+                .setMaxCount(maxCount)\n+                .get()) {\n+            // Initial remaining respects the imposed limit (or is Long.MAX_VALUE if unbounded).\n+            assertEquals(expectedInitialRemaining, in.getRemaining(), caseName + \" (initial)\");\n+\n+            // Skip more than the data length to exercise both bounded and unbounded paths.\n+            final long skipped = IOUtils.skip(in, 42);\n+\n+            // For unbounded streams (EOF == -1), remaining stays the same.\n+            // For bounded, it decreases by 'skipped'.\n+            final long expectedAfterSkip =\n+                    in.getMaxCount() == IOUtils.EOF ? expectedInitialRemaining : expectedInitialRemaining - skipped;\n+\n+            assertEquals(expectedAfterSkip, in.getRemaining(), caseName + \" (after skip)\");\n+        }\n+    }\n+\n     @Test\n     void testReadSingle() throws Exception {\n         final byte[] helloWorld = \"Hello World\".getBytes(StandardCharsets.UTF_8);\n",
  "problem_statement" : "fix: respect read limit in BoundedInputStream.available()\n\n> [!NOTE]\r\n> This PR depends on the fixes proposed in #778. It should not be marked as ready for review until that PR has been approved or rejected.\r\n\r\n`BoundedInputStream.available()` previously returned the underlying streamâ€™s availability without applying the configured read limit. It now caps the reported value by the remaining bytes allowed by the bound.\r\n\r\nAdditional changes:\r\n\r\n* Removed the `onMaxLength` call from `available()`, since `available()` does not consume data and cannot exceed the maximum count.\r\n* Reworked the `testAvailableAfterClose` and `testReadAfterClose` tests:\r\n\r\n  * Old versions relied too heavily on `CharSequenceInputStream`â€™s specific behavior.\r\n  * New parameterized tests cover all three typical cases of the underlying stream after close: no-op, return special value, or throw an exception.\r\n* Added a dedicated unit test for the corrected `available()` behavior.\r\n\r\nBefore you push a pull request, review this list:\r\n\r\n- [x] I used AI to improve unit tests and documentation.\r\n- [x] Run a successful build using the default [Maven](https://maven.apache.org/) goal with `mvn`; that's `mvn` on the command line by itself.\r\n- [x] Write unit tests that match behavioral changes, where the tests fail if the changes to the runtime are not applied. This may not always be possible, but it is a best-practice.\r\n- [x] Write a pull request description that is detailed enough to understand what the pull request does, how, and why.\r\n- [x] Each commit in the pull request should have a meaningful subject line and body. Note that a maintainer may squash commits during the merge process.\r\n",
  "hints_text" : null,
  "created_at" : "Fri Sep 05 15:05:21 CEST 2025",
  "version" : null,
  "FAIL_TO_PASS" : [ "BoundedInputStreamTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=BoundedInputStreamTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 779,
  "metadata" : null
}, {
  "instance_id" : "apache-commons-io-PR-776",
  "repo" : "apache/commons-io",
  "base_commit" : "e205fb9e0dfe29fefa62060ad88ef586b12745ee",
  "patch" : "diff --git a/src/changes/changes.xml b/src/changes/changes.xml\nindex de92deabf64..bb8ad58cbe6 100644\n--- a/src/changes/changes.xml\n+++ b/src/changes/changes.xml\n@@ -57,6 +57,7 @@ The <action> type attribute can be add,update,fix,remove.\n       <action dev=\"ggregory\" type=\"add\"                due-to=\"Gary Gregory\">Add org.apache.commons.io.output.ProxyOutputStream.writeRepeat(byte[], int, int, long).</action>\n       <action dev=\"ggregory\" type=\"add\"                due-to=\"Gary Gregory\">Add org.apache.commons.io.output.ProxyOutputStream.writeRepeat(byte[], long).</action>\n       <action dev=\"ggregory\" type=\"add\"                due-to=\"Gary Gregory\">Add org.apache.commons.io.output.ProxyOutputStream.writeRepeat(int, long).</action>\n+      <action dev=\"pkarwasz\" type=\"add\"                due-to=\"Piotr P. Karwasz\">Add IOUtils.toByteArray(InputStream, int, int) for safer chunked reading with size validation.</action>\n       <!-- UPDATE -->\n       <action type=\"update\" dev=\"ggregory\"             due-to=\"Gary Gregory, Dependabot\">Bump org.apache.commons:commons-parent from 85 to 87 #774.</action>\n       <action type=\"update\" dev=\"ggregory\"             due-to=\"Gary Gregory\">[test] Bump commons-codec:commons-codec from 1.18.0 to 1.19.0.</action>\ndiff --git a/src/main/java/org/apache/commons/io/IOUtils.java b/src/main/java/org/apache/commons/io/IOUtils.java\nindex 05ff9e94c1b..8a0c16320a2 100644\n--- a/src/main/java/org/apache/commons/io/IOUtils.java\n+++ b/src/main/java/org/apache/commons/io/IOUtils.java\n@@ -65,6 +65,7 @@\n import org.apache.commons.io.function.IOConsumer;\n import org.apache.commons.io.function.IOSupplier;\n import org.apache.commons.io.function.IOTriFunction;\n+import org.apache.commons.io.input.BoundedInputStream;\n import org.apache.commons.io.input.CharSequenceReader;\n import org.apache.commons.io.input.QueueInputStream;\n import org.apache.commons.io.output.AppendableWriter;\n@@ -72,7 +73,6 @@\n import org.apache.commons.io.output.NullOutputStream;\n import org.apache.commons.io.output.NullWriter;\n import org.apache.commons.io.output.StringBuilderWriter;\n-import org.apache.commons.io.output.ThresholdingOutputStream;\n import org.apache.commons.io.output.UnsynchronizedByteArrayOutputStream;\n \n /**\n@@ -221,6 +221,14 @@ public class IOUtils {\n      */\n     private static final char[] SCRATCH_CHAR_BUFFER_WO = charArray();\n \n+    /**\n+     * The maximum size of an array in many Java VMs.\n+     * <p>\n+     * The constant is copied from OpenJDK's {@link jdk.internal.util.ArraysSupport#SOFT_MAX_ARRAY_LENGTH}.\n+     * </p>\n+     */\n+    private static final int SOFT_MAX_ARRAY_LENGTH = Integer.MAX_VALUE - 8;\n+\n     /**\n      * Returns the given InputStream if it is already a {@link BufferedInputStream}, otherwise creates a\n      * BufferedInputStream from the given InputStream.\n@@ -2637,57 +2645,63 @@ public static BufferedReader toBufferedReader(final Reader reader, final int siz\n     }\n \n     /**\n-     * Gets the contents of an {@link InputStream} as a {@code byte[]}.\n-     * <p>\n-     * This method buffers the input internally, so there is no need to use a {@link BufferedInputStream}.\n-     * </p>\n+     * Reads all the bytes from an input stream in a byte array.\n      *\n-     * @param inputStream the {@link InputStream} to read.\n-     * @return the requested byte array.\n-     * @throws NullPointerException if the InputStream is {@code null}.\n-     * @throws IOException          if an I/O error occurs or reading more than {@link Integer#MAX_VALUE} occurs.\n+     * <p>The memory used by this method is <strong>proportional</strong> to the number\n+     * of bytes read, which is only limited by {@link Integer#MAX_VALUE}. Only streams\n+     * which fit into a single byte array with roughly 2 GiB limit can be processed\n+     * with this method.</p>\n+     *\n+     * @param inputStream The {@link InputStream} to read; must not be {@code null}.\n+     * @return A new byte array.\n+     * @throws IllegalArgumentException If the size of the stream is greater than the maximum array size.\n+     * @throws IOException              If an I/O error occurs while reading.\n+     * @throws NullPointerException     If {@code inputStream} is {@code null}.\n      */\n     public static byte[] toByteArray(final InputStream inputStream) throws IOException {\n-        // We use a ThresholdingOutputStream to avoid reading AND writing more than Integer.MAX_VALUE.\n-        try (UnsynchronizedByteArrayOutputStream ubaOutput = UnsynchronizedByteArrayOutputStream.builder().get();\n-                ThresholdingOutputStream thresholdOutput = new ThresholdingOutputStream(Integer.MAX_VALUE, os -> {\n-                    throw new IllegalArgumentException(String.format(\"Cannot read more than %,d into a byte array\", Integer.MAX_VALUE));\n-                }, os -> ubaOutput)) {\n-            copy(inputStream, thresholdOutput);\n-            return ubaOutput.toByteArray();\n+        // Using SOFT_MAX_ARRAY_LENGTH guarantees that size() will not overflow\n+        final UnsynchronizedByteArrayOutputStream output = copyToOutputStream(inputStream, SOFT_MAX_ARRAY_LENGTH + 1, DEFAULT_BUFFER_SIZE);\n+        if (output.size() > SOFT_MAX_ARRAY_LENGTH) {\n+            throw new IllegalArgumentException(String.format(\"Cannot read more than %,d into a byte array\", SOFT_MAX_ARRAY_LENGTH));\n         }\n+        return output.toByteArray();\n     }\n \n     /**\n-     * Gets the contents of an {@link InputStream} as a {@code byte[]}. Use this method instead of\n-     * {@link #toByteArray(InputStream)} when {@link InputStream} size is known.\n+     * Reads exactly {@code size} bytes from the given {@link InputStream} into a new {@code byte[]}.\n      *\n-     * @param input the {@link InputStream} to read.\n-     * @param size the size of {@link InputStream} to read, where 0 &lt; {@code size} &lt;= length of input stream.\n-     * @return byte [] of length {@code size}.\n-     * @throws IOException if an I/O error occurs or {@link InputStream} length is smaller than parameter {@code size}.\n-     * @throws IllegalArgumentException if {@code size} is less than zero.\n+     * <p>This variant always allocates the whole requested array size,\n+     * for a dynamic growing variant use {@link #toByteArray(InputStream, int, int)},\n+     * which enforces stricter memory usage constraints.</p>\n+     *\n+     * @param input the {@link InputStream} to read; must not be {@code null}.\n+     * @param size  the exact number of bytes to read; must be {@code >= 0}.\n+     * @return a new byte array of length {@code size}.\n+     * @throws IllegalArgumentException if {@code size} is negative.\n+     * @throws EOFException             if the stream ends before {@code size} bytes are read.\n+     * @throws IOException              if an I/O error occurs while reading.\n+     * @throws NullPointerException     if {@code input} is {@code null}.\n      * @since 2.1\n      */\n-    @SuppressWarnings(\"resource\")\n     public static byte[] toByteArray(final InputStream input, final int size) throws IOException {\n         return toByteArray(Objects.requireNonNull(input, \"input\")::read, size);\n     }\n \n     /**\n-     * Gets contents of an {@link InputStream} as a {@code byte[]}.\n-     * Use this method instead of {@link #toByteArray(InputStream)}\n-     * when {@link InputStream} size is known.\n-     * <strong>NOTE:</strong> the method checks that the length can safely be cast to an int without truncation\n-     * before using {@link IOUtils#toByteArray(InputStream, int)} to read into the byte array.\n-     * (Arrays can have no more than Integer.MAX_VALUE entries anyway.)\n+     * Reads exactly {@code size} bytes from the given {@link InputStream} into a new {@code byte[]}.\n      *\n-     * @param input the {@link InputStream} to read.\n-     * @param size the size of {@link InputStream} to read, where 0 &lt; {@code size} &lt;= min(Integer.MAX_VALUE, length of input stream).\n-     * @return byte [] the requested byte array, of length {@code size}.\n-     * @throws IOException              if an I/O error occurs or {@link InputStream} length is less than {@code size}.\n-     * @throws IllegalArgumentException if size is less than zero or size is greater than Integer.MAX_VALUE.\n-     * @see IOUtils#toByteArray(InputStream, int)\n+     * <p>This variant always allocates the whole requested array size,\n+     * for a dynamic growing variant use {@link #toByteArray(InputStream, int, int)},\n+     * which enforces stricter memory usage constraints.</p>\n+     *\n+     * @param input the {@link InputStream} to read; must not be {@code null}.\n+     * @param size  the exact number of bytes to read; must be {@code >= 0} and {@code <= Integer.MAX_VALUE}.\n+     * @return a new byte array of length {@code size}.\n+     * @throws IllegalArgumentException if {@code size} is negative or does not fit into an int.\n+     * @throws EOFException             if the stream ends before {@code size} bytes are read.\n+     * @throws IOException              if an I/O error occurs while reading.\n+     * @throws NullPointerException     if {@code input} is {@code null}.\n+     * @see #toByteArray(InputStream, int, int)\n      * @since 2.1\n      */\n     public static byte[] toByteArray(final InputStream input, final long size) throws IOException {\n@@ -2697,6 +2711,68 @@ public static byte[] toByteArray(final InputStream input, final long size) throw\n         return toByteArray(input, (int) size);\n     }\n \n+    /**\n+     * Reads exactly {@code size} bytes from the given {@link InputStream} into a new {@code byte[]}.\n+     *\n+     * <p>The memory used by this method is <strong>proportional</strong> to the number\n+     * of bytes read and limited by the specified {@code size}. This makes it suitable for\n+     * processing large input streams, provided that <strong>sufficient</strong> heap space is\n+     * available.</p>\n+     *\n+     * <p>This method processes the input stream in successive chunks of up to\n+     * {@code chunkSize} bytes.</p>\n+     *\n+     * @param input      the {@link InputStream} to read; must not be {@code null}.\n+     * @param size       the exact number of bytes to read; must be {@code >= 0}.\n+     *                   The actual bytes read are validated to equal {@code size}.\n+     * @param chunkSize  The chunk size for incremental reading; must be {@code > 0}.\n+     * @return a new byte array of length {@code size}.\n+     * @throws IllegalArgumentException if {@code size} is negative or {@code chunkSize <= 0}.\n+     * @throws EOFException             if the stream ends before {@code size} bytes are read.\n+     * @throws IOException              if an I/O error occurs while reading.\n+     * @throws NullPointerException     if {@code input} is {@code null}.\n+     * @since 2.21.0\n+     */\n+    public static byte[] toByteArray(final InputStream input, final int size, final int chunkSize) throws IOException {\n+        Objects.requireNonNull(input, \"input\");\n+        if (chunkSize <= 0) {\n+            throw new IllegalArgumentException(\"Chunk size must be greater than zero: \" + chunkSize);\n+        }\n+        if (size <= chunkSize) {\n+            // throws if size < 0\n+            return toByteArray(input::read, size);\n+        }\n+        final UnsynchronizedByteArrayOutputStream output = copyToOutputStream(input, size, chunkSize);\n+         if (output.size() != size) {\n+            throw new EOFException(\"Unexpected read size, current: \" + output.size() + \", expected: \" + size);\n+        }\n+        return output.toByteArray();\n+    }\n+\n+    /**\n+     * Copies up to {@code size} bytes from the given {@link InputStream} into a new {@link UnsynchronizedByteArrayOutputStream}.\n+     *\n+     * @param input      The {@link InputStream} to read; must not be {@code null}.\n+     * @param limit      The maximum number of bytes to read; must be {@code >= 0}.\n+     *                   The actual bytes read are validated to equal {@code size}.\n+     * @param bufferSize The buffer size of the output stream; must be {@code > 0}.\n+     * @return a ByteArrayOutputStream containing the read bytes.\n+     */\n+    private static UnsynchronizedByteArrayOutputStream copyToOutputStream(\n+            final InputStream input, final long limit, final int bufferSize) throws IOException {\n+        try (UnsynchronizedByteArrayOutputStream output = UnsynchronizedByteArrayOutputStream.builder()\n+                        .setBufferSize(bufferSize)\n+                        .get();\n+                InputStream boundedInput = BoundedInputStream.builder()\n+                        .setMaxCount(limit)\n+                        .setPropagateClose(false)\n+                        .setInputStream(input)\n+                        .get()) {\n+            output.write(boundedInput);\n+            return output;\n+        }\n+    }\n+\n     /**\n      * Gets the contents of an input as a {@code byte[]}.\n      *\n",
  "test_patch" : "diff --git a/src/test/java/org/apache/commons/io/IOUtilsTest.java b/src/test/java/org/apache/commons/io/IOUtilsTest.java\nindex 56fd1307eb1..92925bdd785 100644\n--- a/src/test/java/org/apache/commons/io/IOUtilsTest.java\n+++ b/src/test/java/org/apache/commons/io/IOUtilsTest.java\n@@ -90,6 +90,9 @@\n import org.junit.jupiter.api.Disabled;\n import org.junit.jupiter.api.Test;\n import org.junit.jupiter.api.io.TempDir;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n \n /**\n  * This is used to test {@link IOUtils} for correctness. The following checks are performed:\n@@ -1659,6 +1662,48 @@ void testToByteArray_InputStream_SizeZero() throws Exception {\n         }\n     }\n \n+    @ParameterizedTest\n+    @MethodSource\n+    void testToByteArray_InputStream_Size_BufferSize_Succeeds(byte[] data, int size, int bufferSize) throws IOException {\n+        final ByteArrayInputStream input = new ByteArrayInputStream(data);\n+        final byte[] expected = Arrays.copyOf(data, size);\n+        final byte[] actual = IOUtils.toByteArray(input, size, bufferSize);\n+        assertArrayEquals(expected, actual);\n+    }\n+\n+    private static Stream<Arguments> testToByteArray_InputStream_Size_BufferSize_Succeeds() {\n+        final byte[] data = new byte[1024];\n+        for (int i = 0; i < 1024; i++) {\n+            data[i] = (byte) i;\n+        }\n+        return Stream.of(\n+                // Eager reading\n+                Arguments.of(data.clone(), 512, 1024),\n+                // Incremental reading\n+                Arguments.of(data.clone(), 1024, 512),\n+                // No reading\n+                Arguments.of(data.clone(), 0, 128));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    void testToByteArray_InputStream_Size_BufferSize_Throws(\n+            int size, int bufferSize, Class<? extends Exception> exceptionClass) throws IOException {\n+        try (InputStream input = new NullInputStream(0)) {\n+            assertThrows(exceptionClass, () -> IOUtils.toByteArray(input, size, bufferSize));\n+        }\n+    }\n+\n+    static Stream<Arguments> testToByteArray_InputStream_Size_BufferSize_Throws() {\n+        return Stream.of(\n+                // Negative size\n+                Arguments.of(-1, 128, IllegalArgumentException.class),\n+                // Invalid buffer size\n+                Arguments.of(0, 0, IllegalArgumentException.class),\n+                // Huge size: should not cause OutOfMemoryError\n+                Arguments.of(Integer.MAX_VALUE, 128, EOFException.class));\n+    }\n+\n     @Test\n     void testToByteArray_Reader() throws IOException {\n         final String charsetName = UTF_8;\n",
  "problem_statement" : "Add toByteArray(InputStream input, int size, int bufferSize)\n\nThis introduces `toByteArray(InputStream input, int size, int bufferSize)`, which reads the stream in chunks of `bufferSize` instead of allocating the full array up front.\r\n\r\nBy reading incrementally, the method:\r\n\r\n* Validates that the stream actually contains `size` bytes before completing the allocation.\r\n* Prevents excessive memory usage if a corrupted or malicious `size` value is provided.\r\n* Offers safer handling for untrusted input compared to the direct-allocation variant.\r\n\r\n- [x] I used AI to create the Javadoc.\r\n- [x] Run a successful build using the default [Maven](https://maven.apache.org/) goal with `mvn`; that's `mvn` on the command line by itself.\r\n- [x] Write unit tests that match behavioral changes, where the tests fail if the changes to the runtime are not applied. This may not always be possible, but it is a best-practice.\r\n- [x] Write a pull request description that is detailed enough to understand what the pull request does, how, and why.\r\n- [x] Each commit in the pull request should have a meaningful subject line and body. Note that a maintainer may squash commits during the merge process.\r\n",
  "hints_text" : null,
  "created_at" : "Thu Sep 04 23:19:46 CEST 2025",
  "version" : null,
  "FAIL_TO_PASS" : [ "IOUtilsTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=IOUtilsTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 776,
  "metadata" : null
}, {
  "instance_id" : "apache-commons-io-PR-763",
  "repo" : "apache/commons-io",
  "base_commit" : "ea8ba68c8839db85c2db17e9414c806f1085462c",
  "patch" : "diff --git a/src/main/java/org/apache/commons/io/FileUtils.java b/src/main/java/org/apache/commons/io/FileUtils.java\nindex ffd59f92ab5..cc17576b622 100644\n--- a/src/main/java/org/apache/commons/io/FileUtils.java\n+++ b/src/main/java/org/apache/commons/io/FileUtils.java\n@@ -194,13 +194,27 @@ public class FileUtils {\n     /**\n      * The number of bytes in a zettabyte.\n      */\n-    public static final BigInteger ONE_ZB = BigInteger.valueOf(ONE_KB).multiply(BigInteger.valueOf(ONE_EB));\n+    public static final BigInteger ONE_ZB = ONE_KB_BI.multiply(ONE_EB_BI);\n \n     /**\n      * The number of bytes in a yottabyte.\n      */\n     public static final BigInteger ONE_YB = ONE_KB_BI.multiply(ONE_ZB);\n \n+    /**\n+     * The number of bytes in a ronnabyte.\n+     *\n+     * @since 2.21.0\n+     */\n+    public static final BigInteger ONE_RB = ONE_KB_BI.multiply(ONE_YB);\n+\n+    /**\n+     * The number of bytes in a quettabyte.\n+     *\n+     * @since 2.21.0\n+     */\n+    public static final BigInteger ONE_QB = ONE_KB_BI.multiply(ONE_RB);\n+\n     /**\n      * An empty array of type {@link File}.\n      */\n@@ -217,7 +231,7 @@ public class FileUtils {\n      * </p>\n      *\n      * @param size the number of bytes\n-     * @return a human-readable display value (includes units - EB, PB, TB, GB, MB, KB or bytes)\n+     * @return a human-readable display value (includes units - QB, RB, YB, ZB, EB, PB, TB, GB, MB, KB or bytes)\n      * @throws NullPointerException if the given {@link BigInteger} is {@code null}.\n      * @see <a href=\"https://issues.apache.org/jira/browse/IO-226\">IO-226 - should the rounding be changed?</a>\n      * @since 2.4\n@@ -227,7 +241,15 @@ public static String byteCountToDisplaySize(final BigInteger size) {\n         Objects.requireNonNull(size, \"size\");\n         final String displaySize;\n \n-        if (size.divide(ONE_EB_BI).compareTo(BigInteger.ZERO) > 0) {\n+        if (size.divide(ONE_QB).compareTo(BigInteger.ZERO) > 0) {\n+            displaySize = size.divide(ONE_QB) + \" QB\";\n+        } else if (size.divide(ONE_RB).compareTo(BigInteger.ZERO) > 0) {\n+            displaySize = size.divide(ONE_RB) + \" RB\";\n+        } else if (size.divide(ONE_YB).compareTo(BigInteger.ZERO) > 0) {\n+            displaySize = size.divide(ONE_YB) + \" YB\";\n+        } else if (size.divide(ONE_ZB).compareTo(BigInteger.ZERO) > 0) {\n+            displaySize = size.divide(ONE_ZB) + \" ZB\";\n+        } else if (size.divide(ONE_EB_BI).compareTo(BigInteger.ZERO) > 0) {\n             displaySize = size.divide(ONE_EB_BI) + \" EB\";\n         } else if (size.divide(ONE_PB_BI).compareTo(BigInteger.ZERO) > 0) {\n             displaySize = size.divide(ONE_PB_BI) + \" PB\";\n",
  "test_patch" : "diff --git a/src/test/java/org/apache/commons/io/FileUtilsTest.java b/src/test/java/org/apache/commons/io/FileUtilsTest.java\nindex cf62cf2c195..dc501ee0834 100644\n--- a/src/test/java/org/apache/commons/io/FileUtilsTest.java\n+++ b/src/test/java/org/apache/commons/io/FileUtilsTest.java\n@@ -370,6 +370,10 @@ void testByteCountToDisplaySizeBigInteger() {\n         final BigInteger TB1 = GB1.multiply(KB1);\n         final BigInteger PB1 = TB1.multiply(KB1);\n         final BigInteger EB1 = PB1.multiply(KB1);\n+        final BigInteger ZB1 = EB1.multiply(KB1);\n+        final BigInteger YB1 = ZB1.multiply(KB1);\n+        final BigInteger RB1 = YB1.multiply(KB1);\n+        final BigInteger QB1 = RB1.multiply(KB1);\n         assertEquals(\"0 bytes\", FileUtils.byteCountToDisplaySize(BigInteger.ZERO));\n         assertEquals(\"1 bytes\", FileUtils.byteCountToDisplaySize(BigInteger.ONE));\n         assertEquals(\"1023 bytes\", FileUtils.byteCountToDisplaySize(b1023));\n@@ -386,6 +390,10 @@ void testByteCountToDisplaySizeBigInteger() {\n         assertEquals(\"1 TB\", FileUtils.byteCountToDisplaySize(TB1));\n         assertEquals(\"1 PB\", FileUtils.byteCountToDisplaySize(PB1));\n         assertEquals(\"1 EB\", FileUtils.byteCountToDisplaySize(EB1));\n+        assertEquals(\"1 ZB\", FileUtils.byteCountToDisplaySize(ZB1));\n+        assertEquals(\"1 YB\", FileUtils.byteCountToDisplaySize(YB1));\n+        assertEquals(\"1 RB\", FileUtils.byteCountToDisplaySize(RB1));\n+        assertEquals(\"1 QB\", FileUtils.byteCountToDisplaySize(QB1));\n         assertEquals(\"7 EB\", FileUtils.byteCountToDisplaySize(Long.MAX_VALUE));\n         // Other MAX_VALUEs\n         assertEquals(\"63 KB\", FileUtils.byteCountToDisplaySize(BigInteger.valueOf(Character.MAX_VALUE)));\n",
  "problem_statement" : "`FileUtils#byteCountToDisplaySize` supports Zettabyte, Yottabyte, Ronnabyte and Quettabyte\n\nAdd support for Zettabyte (ZB), Yottabyte (YB), Ronnabyte (RB) and Quettabyte (QB) in `FileUtils#byteCountToDisplaySize`\r\n\r\nIn November 2022 the International Bureau of Weights and Measures (BIPM) added the prefixes `ronnaâ€‘` (10Â²â·) and `quettaâ€‘` (10Â³â°) \r\n[source](https://www.bipm.org/en/measurement-units/si-prefixes).\r\n\r\n<!--\r\n  Licensed to the Apache Software Foundation (ASF) under one\r\n  or more contributor license agreements.  See the NOTICE file\r\n  distributed with this work for additional information\r\n  regarding copyright ownership.  The ASF licenses this file\r\n  to you under the Apache License, Version 2.0 (the\r\n  \"License\"); you may not use this file except in compliance\r\n  with the License.  You may obtain a copy of the License at\r\n\r\n    https://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing,\r\n  software distributed under the License is distributed on an\r\n  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n  KIND, either express or implied.  See the License for the\r\n  specific language governing permissions and limitations\r\n  under the License.\r\n-->\r\n\r\nThanks for your contribution to [Apache Commons](https://commons.apache.org/)! Your help is appreciated!\r\n\r\nBefore you push a pull request, review this list:\r\n\r\n- [x] Read the [contribution guidelines](CONTRIBUTING.md) for this project.\r\n- [x] Read the [ASF Generative Tooling Guidance](https://www.apache.org/legal/generative-tooling.html) if you use Artificial Intelligence (AI).\r\n- [ ] I used AI to create any part of, or all of, this pull request.\r\n- [x] Run a successful build using the default [Maven](https://maven.apache.org/) goal with `mvn`; that's `mvn` on the command line by itself.\r\n- [x] Write unit tests that match behavioral changes, where the tests fail if the changes to the runtime are not applied. This may not always be possible, but it is a best-practice.\r\n- [x] Write a pull request description that is detailed enough to understand what the pull request does, how, and why.\r\n- [x] Each commit in the pull request should have a meaningful subject line and body. Note that a maintainer may squash commits during the merge process.\r\n",
  "hints_text" : null,
  "created_at" : "Mon Jul 21 14:39:19 CEST 2025",
  "version" : null,
  "FAIL_TO_PASS" : [ "FileUtilsTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=FileUtilsTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 763,
  "metadata" : null
}, {
  "instance_id" : "apache-commons-io-PR-758",
  "repo" : "apache/commons-io",
  "base_commit" : "4fe3854a6bef9674ac9fc1062fdd1ad8614dc7cd",
  "patch" : "diff --git a/src/main/java/org/apache/commons/io/output/AbstractByteArrayOutputStream.java b/src/main/java/org/apache/commons/io/output/AbstractByteArrayOutputStream.java\nindex 8f959751d36..b8b90b6511d 100644\n--- a/src/main/java/org/apache/commons/io/output/AbstractByteArrayOutputStream.java\n+++ b/src/main/java/org/apache/commons/io/output/AbstractByteArrayOutputStream.java\n@@ -92,7 +92,7 @@ protected interface InputStreamConstructor<T extends InputStream> {\n     private byte[] currentBuffer;\n \n     /** The index of the current buffer. */\n-    private int currentBufferIndex;\n+    private int currentBufferIndex = -1;\n \n     /** The total count of bytes in all the filled buffers. */\n     private int filledBufferSum;\n@@ -147,7 +147,8 @@ protected void needNewBuffer(final int newCount) {\n             // Creating new buffer\n             final int newBufferSize;\n             if (currentBuffer == null) {\n-                newBufferSize = newCount;\n+                // prevents 0 size buffers\n+                newBufferSize = newCount > 0 ? newCount : DEFAULT_SIZE;\n                 filledBufferSum = 0;\n             } else {\n                 newBufferSize = Math.max(currentBuffer.length << 1, newCount - filledBufferSum);\n",
  "test_patch" : "diff --git a/src/test/java/org/apache/commons/io/output/ByteArrayOutputStreamTest.java b/src/test/java/org/apache/commons/io/output/ByteArrayOutputStreamTest.java\nindex 791d74e85da..0274d8bcad9 100644\n--- a/src/test/java/org/apache/commons/io/output/ByteArrayOutputStreamTest.java\n+++ b/src/test/java/org/apache/commons/io/output/ByteArrayOutputStreamTest.java\n@@ -28,12 +28,15 @@\n import java.io.IOException;\n import java.io.InputStream;\n import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n import java.util.Arrays;\n import java.util.stream.Stream;\n \n import org.apache.commons.io.IOUtils;\n import org.apache.commons.io.function.IOFunction;\n import org.apache.commons.io.input.ClosedInputStream;\n+import org.junit.jupiter.api.io.TempDir;\n import org.junit.jupiter.params.ParameterizedTest;\n import org.junit.jupiter.params.provider.Arguments;\n import org.junit.jupiter.params.provider.MethodSource;\n@@ -100,14 +103,19 @@ private static boolean byteCmp(final byte[] src, final byte[] cmp) {\n     private static Stream<Arguments> toBufferedInputStreamFunctionFactories() {\n         final IOFunction<InputStream, InputStream> syncBaosToBufferedInputStream = ByteArrayOutputStream::toBufferedInputStream;\n         final IOFunction<InputStream, InputStream> syncBaosToBufferedInputStreamWithSize = is -> ByteArrayOutputStream.toBufferedInputStream(is, 1024);\n+        final IOFunction<InputStream, InputStream> syncBaosToBufferedInputStreamWith0Size = is -> ByteArrayOutputStream.toBufferedInputStream(is, 0);\n         final IOFunction<InputStream, InputStream> unSyncBaosToBufferedInputStream = UnsynchronizedByteArrayOutputStream::toBufferedInputStream;\n-        final IOFunction<InputStream, InputStream> unSyncBaosToBufferedInputStreamWithSize = is -> UnsynchronizedByteArrayOutputStream.toBufferedInputStream(is,\n-                1024);\n+        final IOFunction<InputStream, InputStream> unSyncBaosToBufferedInputStreamWithSize = is -> UnsynchronizedByteArrayOutputStream.toBufferedInputStream(\n+                is, 1024);\n+        final IOFunction<InputStream, InputStream> unSyncBaosToBufferedInputStreamWith0Size = is -> UnsynchronizedByteArrayOutputStream.toBufferedInputStream(\n+                is, 0);\n \n         return Stream.of(Arguments.of(\"ByteArrayOutputStream.toBufferedInputStream(InputStream)\", syncBaosToBufferedInputStream),\n                 Arguments.of(\"ByteArrayOutputStream.toBufferedInputStream(InputStream, int)\", syncBaosToBufferedInputStreamWithSize),\n+                Arguments.of(\"ByteArrayOutputStream.toBufferedInputStream(InputStream, 0)\", syncBaosToBufferedInputStreamWith0Size),\n                 Arguments.of(\"UnsynchronizedByteArrayOutputStream.toBufferedInputStream(InputStream)\", unSyncBaosToBufferedInputStream),\n-                Arguments.of(\"UnsynchronizedByteArrayOutputStream.toBufferedInputStream(InputStream, int)\", unSyncBaosToBufferedInputStreamWithSize));\n+                Arguments.of(\"UnsynchronizedByteArrayOutputStream.toBufferedInputStream(InputStream, int)\", unSyncBaosToBufferedInputStreamWithSize),\n+                Arguments.of(\"UnsynchronizedByteArrayOutputStream.toBufferedInputStream(InputStream, 0)\", unSyncBaosToBufferedInputStreamWith0Size));\n     }\n \n     private void checkByteArrays(final byte[] expected, final byte[] actual) {\n@@ -184,7 +192,6 @@ void testToBufferedInputStream(final String baosName, final IOFunction<InputStre\n                 assertEquals(data.length, buffered.available());\n \n                 assertArrayEquals(data, IOUtils.toByteArray(buffered));\n-\n             }\n         }\n     }\n@@ -198,7 +205,23 @@ void testToBufferedInputStreamEmpty(final String baosName, final IOFunction<Inpu\n \n             try (InputStream buffered = toBufferedInputStreamFunction.apply(bain)) {\n                 assertEquals(0, buffered.available());\n+            }\n+        }\n+    }\n+\n+    @ParameterizedTest(name = \"[{index}] {0}\")\n+    @MethodSource(\"toBufferedInputStreamFunctionFactories\")\n+    void testToBufferedInputStreamEmptyFile(final String baosName, final IOFunction<InputStream, InputStream> toBufferedInputStreamFunction,\n+                                            final @TempDir Path temporaryFolder) throws IOException {\n+        final Path emptyFile = Files.createTempFile(temporaryFolder, getClass().getSimpleName(), \"-empty.txt\");\n+\n+        try (InputStream is = Files.newInputStream(emptyFile)) {\n+            assertEquals(0, is.available());\n+\n+            try (InputStream buffered = toBufferedInputStreamFunction.apply(is)) {\n+                assertEquals(0, buffered.available());\n \n+                assertArrayEquals(IOUtils.EMPTY_BYTE_ARRAY, IOUtils.toByteArray(buffered));\n             }\n         }\n     }\n",
  "problem_statement" : "Fix infinite loop in AbstractByteArrayOutputStream.\n\nFix infinite loop in AbstractByteArrayOutputStream.\r\nWhen an AbstractByteArrayOutputStream is initialized with a 0 size buffer and writeImpl(InputStream) is called an infinite loop may occur and eventually cause an OOM exception.\r\nThis is due to passing 0 as the maximum bytes to read in InputStream#read which returns 0, then a new 0 size buffer is created, and then InputStream#read is called again therefore repeating the loop forever.\r\nFix this infinite loop by updating needNewBuffer to use DEFAULT_SIZE as the initial buffer size instead of 0.\r\nThis will allow InputStream#read to properly populate the buffer as expected and terminate the loop when EOF is reached.\r\nSet initial value of currentBufferIndex to -1 so it is properly initialized to 0 when needNewBuffer is called; unrelated to the infinite loop bug.\r\n",
  "hints_text" : null,
  "created_at" : "Thu Jul 03 08:50:35 CEST 2025",
  "version" : null,
  "FAIL_TO_PASS" : [ "ByteArrayOutputStreamTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=ByteArrayOutputStreamTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 758,
  "metadata" : null
}, {
  "instance_id" : "apache-commons-io-PR-757",
  "repo" : "apache/commons-io",
  "base_commit" : "4fe3854a6bef9674ac9fc1062fdd1ad8614dc7cd",
  "patch" : "diff --git a/src/main/java/org/apache/commons/io/input/Tailer.java b/src/main/java/org/apache/commons/io/input/Tailer.java\nindex cdae768f4cc..52f88742717 100644\n--- a/src/main/java/org/apache/commons/io/input/Tailer.java\n+++ b/src/main/java/org/apache/commons/io/input/Tailer.java\n@@ -138,6 +138,7 @@\n  *        VFS</a>.\n  */\n public class Tailer implements Runnable, AutoCloseable {\n+    private static final boolean DEFAULT_IGNORE_TOUCH = false;\n \n     // @formatter:off\n     /**\n@@ -186,6 +187,7 @@ private static Thread newDaemonThread(final Runnable runnable) {\n         private boolean tailFromEnd;\n         private boolean reOpen;\n         private boolean startThread = true;\n+        private boolean ignoreTouch = DEFAULT_IGNORE_TOUCH;\n         private ExecutorService executorService = Executors.newSingleThreadExecutor(Builder::newDaemonThread);\n \n         /**\n@@ -216,7 +218,7 @@ public Builder() {\n          */\n         @Override\n         public Tailer get() {\n-            final Tailer tailer = new Tailer(tailable, getCharset(), tailerListener, delayDuration, tailFromEnd, reOpen, getBufferSize());\n+            final Tailer tailer = new Tailer(tailable, getCharset(), tailerListener, delayDuration, tailFromEnd, reOpen, getBufferSize(), ignoreTouch);\n             if (startThread) {\n                 executorService.submit(tailer);\n             }\n@@ -310,6 +312,23 @@ public Builder setTailFromEnd(final boolean end) {\n             this.tailFromEnd = end;\n             return this;\n         }\n+\n+        /**\n+         * Sets ignoreTouch behaviour\n+         *\n+         * @param ignoreTouch This can be useful when your watched file gets touched (meaning it gets more recent timestamps\n+         *        without changing the file) for some reason or when you are working on file systems where timestamp\n+         *        is updated before content.\n+         *        The default behaviour (ignoreTouch=false) would then reissue the whole current file, while\n+         *        ignoreTouch=true does nothing in that case.\n+         *\n+         * @return {@code this} instance.\n+         * @since 2.20.0\n+         */\n+        public Builder setIgnoreTouch(final boolean ignoreTouch) {\n+            this.ignoreTouch = ignoreTouch;\n+            return this;\n+        }\n     }\n \n     /**\n@@ -695,6 +714,8 @@ public static Tailer create(final File file, final TailerListener listener, fina\n      */\n     private volatile boolean run = true;\n \n+    private boolean ignoreTouch = DEFAULT_IGNORE_TOUCH;\n+\n     /**\n      * Creates a Tailer for the given file, with a specified buffer size.\n      *\n@@ -710,7 +731,7 @@ public static Tailer create(final File file, final TailerListener listener, fina\n     @Deprecated\n     public Tailer(final File file, final Charset charset, final TailerListener listener, final long delayMillis, final boolean end, final boolean reOpen,\n         final int bufSize) {\n-        this(new TailablePath(file.toPath()), charset, listener, Duration.ofMillis(delayMillis), end, reOpen, bufSize);\n+        this(new TailablePath(file.toPath()), charset, listener, Duration.ofMillis(delayMillis), end, reOpen, bufSize, DEFAULT_IGNORE_TOUCH);\n     }\n \n     /**\n@@ -807,10 +828,11 @@ public Tailer(final File file, final TailerListener listener, final long delayMi\n      * @param delayDuration the delay between checks of the file for new content in milliseconds.\n      * @param end Set to true to tail from the end of the file, false to tail from the beginning of the file.\n      * @param reOpen if true, close and reopen the file between reading chunks\n+     * @param ignoreTouch if true, file timestamp changes without content change get ignored\n      * @param bufferSize Buffer size\n      */\n     private Tailer(final Tailable tailable, final Charset charset, final TailerListener listener, final Duration delayDuration, final boolean end,\n-        final boolean reOpen, final int bufferSize) {\n+        final boolean reOpen, final int bufferSize, final boolean ignoreTouch) {\n         this.tailable = Objects.requireNonNull(tailable, \"tailable\");\n         this.listener = Objects.requireNonNull(listener, \"listener\");\n         this.delayDuration = delayDuration;\n@@ -821,6 +843,7 @@ private Tailer(final Tailable tailable, final Charset charset, final TailerListe\n         listener.init(this);\n         this.reOpen = reOpen;\n         this.charset = charset;\n+        this.ignoreTouch = ignoreTouch;\n     }\n \n     /**\n@@ -996,14 +1019,22 @@ public void run() {\n                     last = tailable.lastModifiedFileTime();\n                 } else if (newer) {\n                     /*\n-                     * This can happen if the file is truncated or overwritten with the exact same length of information. In cases like\n-                     * this, the file position needs to be reset\n+                     * This can happen if the file\n+                     * - is overwritten with the exact same length of information\n+                     * - gets \"touched\"\n+                     * - Files.getLastModifiedTime returns a new timestamp but newer data is not yet there (\n+                     *   was reported to happen on busy systems or samba network shares, see IO-279)\n+                     * The default behaviour is to replay the whole file. If this is unsdesired in your usecase,\n+                     * use the ignoreTouch builder flag\n                      */\n-                    position = 0;\n-                    reader.seek(position); // cannot be null here\n+                    if (!ignoreTouch) {\n+                        position = 0;\n+                        reader.seek(position); // cannot be null here\n \n-                    // Now we can read new lines\n-                    position = readLines(reader);\n+                        // Now we can read new lines\n+                        position = readLines(reader);\n+                    }\n+                    // we eitherway continue with the new timestamp\n                     last = tailable.lastModifiedFileTime();\n                 }\n                 if (reOpen && reader != null) {\n",
  "test_patch" : "diff --git a/src/test/java/org/apache/commons/io/input/TailerTest.java b/src/test/java/org/apache/commons/io/input/TailerTest.java\nindex 2256d3e4e58..4e7e4fd7d1f 100644\n--- a/src/test/java/org/apache/commons/io/input/TailerTest.java\n+++ b/src/test/java/org/apache/commons/io/input/TailerTest.java\n@@ -37,6 +37,7 @@\n import java.nio.file.Files;\n import java.nio.file.StandardOpenOption;\n import java.nio.file.attribute.FileTime;\n+import java.time.Duration;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collections;\n@@ -576,6 +577,76 @@ void testStopWithNoFileUsingExecutor() throws Exception {\n         assertEquals(0, listener.reachedEndOfFile, \"end of file never reached\");\n     }\n \n+    @Test\n+    void testTailerIgnoreTouch() throws Exception {\n+        // Create & start the Tailer\n+        final long delayMillis = 50;\n+        final File file = new File(temporaryFolder, \"tailer1-testIgnoreTouch.txt\");\n+        createFile(file, 0);\n+        final TestTailerListener listener = new TestTailerListener();\n+        try (Tailer tailer = Tailer.builder()\n+                .setFile(file)\n+                .setTailerListener(listener)\n+                .setDelayDuration(Duration.ofMillis(delayMillis))\n+                .setStartThread(false)\n+                .setIgnoreTouch(true)\n+                .get()) {\n+            final Thread thread = new Thread(tailer);\n+            thread.start();\n+\n+            // Write some lines to the file\n+            write(file, \"Line one\");\n+            final long testDelayMillis = delayMillis * 10;\n+            TestUtils.sleep(testDelayMillis);\n+            List<String> lines = listener.getLines();\n+            assertEquals(1, lines.size(), \"1 line count\");\n+            assertEquals(\"Line one\", lines.get(0), \"1 line 1\");\n+            listener.clear();\n+\n+            // touch the file\n+            file.setLastModified(System.currentTimeMillis());\n+            TestUtils.sleep(testDelayMillis);\n+            lines = listener.getLines();\n+            assertEquals(0, lines.size(), \"nothing should have changed by touching\");\n+        }\n+    }\n+\n+    @Test\n+    void testTailerReissueOnTouch() throws Exception {\n+        // Create & start the Tailer\n+        final long delayMillis = 50;\n+        final File file = new File(temporaryFolder, \"tailer1-testReissueOnTouch.txt\");\n+        createFile(file, 0);\n+        final TestTailerListener listener = new TestTailerListener();\n+        try (Tailer tailer = Tailer.builder()\n+                .setFile(file)\n+                .setTailerListener(listener)\n+                .setDelayDuration(Duration.ofMillis(delayMillis))\n+                .setStartThread(false)\n+                .setIgnoreTouch(false)\n+                .get()) {\n+            final Thread thread = new Thread(tailer);\n+            thread.start();\n+\n+            // Write some lines to the file\n+            write(file, \"Line one\");\n+            final long testDelayMillis = delayMillis * 10;\n+            TestUtils.sleep(testDelayMillis);\n+            List<String> lines = listener.getLines();\n+            assertEquals(1, lines.size(), \"1 line count\");\n+            assertEquals(\"Line one\", lines.get(0), \"1 line 1\");\n+            listener.clear();\n+\n+            // touch the file\n+            file.setLastModified(System.currentTimeMillis());\n+            TestUtils.sleep(testDelayMillis);\n+            lines = listener.getLines();\n+            assertEquals(1, lines.size(), \"1 line count\");\n+            assertEquals(\"Line one\", lines.get(0), \"1 line 1\");\n+            listener.clear();\n+        }\n+    }\n+\n     @Test\n     void testTailer() throws Exception {\n \n",
  "problem_statement" : "[IO-279] Add Tailer ignoreTouch option \n\nâ€¦oose to ignore touching of watched file\r\n\r\nSo I got late to the old io-279 Tailer issue. In the long history, some changes were already made long ago.\r\nHowever from reading the last comments, some users want to avoid to get the whole file replayed \r\nwhen the timestamp of the watched file changes without a content update. I added an ignoreTouch option, the default is false and resembles current behaviour (file gets replayed) (inspired from the  2015 patch by gh user myyron).\r\nWhen changed to true via the Builder pattern, a newertimestamp with constant content gets ignored.\r\nThat makes the Tailer more similar to \"tail -f\" (issuing touch on the watched file is ignored then), but note that subtle differences remain. When you copy the identical file onto watched  file, \"tail -f\" realizes that and replays the whole file. With ignoreTouch=true, the Tailer ignores that, as it looks identical to touching. \r\n\r\nAdded 2 Junit tests to verify both behaviours explictly. ",
  "hints_text" : null,
  "created_at" : "Thu Jul 03 04:57:35 CEST 2025",
  "version" : null,
  "FAIL_TO_PASS" : [ "TailerTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=TailerTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 757,
  "metadata" : null
}, {
  "instance_id" : "apache-commons-io-PR-756",
  "repo" : "apache/commons-io",
  "base_commit" : "53371a208d4215c26d0f5f3b3aa960d274ff5211",
  "patch" : "diff --git a/src/main/java/org/apache/commons/io/FileUtils.java b/src/main/java/org/apache/commons/io/FileUtils.java\nindex 60dc05a67af..9b82bf3eb8b 100644\n--- a/src/main/java/org/apache/commons/io/FileUtils.java\n+++ b/src/main/java/org/apache/commons/io/FileUtils.java\n@@ -294,7 +294,7 @@ public static String byteCountToDisplaySize(final Number size) {\n      */\n     private static void checkExists(final File file, final boolean strict) throws FileNotFoundException {\n         Objects.requireNonNull(file, PROTOCOL_FILE);\n-        if (strict && !file.exists()) {\n+        if (strict && !file.exists() && !isSymlink(file)) {\n             throw new FileNotFoundException(file.toString());\n         }\n     }\n",
  "test_patch" : "diff --git a/src/test/java/org/apache/commons/io/FileUtilsTest.java b/src/test/java/org/apache/commons/io/FileUtilsTest.java\nindex 6d4c2444802..4c6413756a1 100644\n--- a/src/test/java/org/apache/commons/io/FileUtilsTest.java\n+++ b/src/test/java/org/apache/commons/io/FileUtilsTest.java\n@@ -1761,6 +1761,42 @@ void testForceDeleteUnwritableFile() throws Exception {\n         }\n     }\n \n+    @Test\n+    public void testForceDeleteBrokenSymlink() throws Exception {\n+        final ImmutablePair<Path, Path> pair = createTempSymbolicLinkedRelativeDir();\n+        final Path symlinkedDir = pair.getLeft();\n+        final Path targetDir = pair.getRight();\n+\n+        Files.delete(targetDir);\n+        assertFalse(Files.exists(symlinkedDir));\n+        assertTrue(Files.isSymbolicLink(symlinkedDir));\n+\n+        FileUtils.forceDelete(symlinkedDir.toFile());\n+\n+        // check targeted symlink is gone\n+        assertFalse(Files.exists(symlinkedDir));\n+        assertFalse(Files.isSymbolicLink(symlinkedDir));\n+    }\n+\n+    @Test\n+    public void testForceDeleteSymlink() throws Exception {\n+        final ImmutablePair<Path, Path> pair = createTempSymbolicLinkedRelativeDir();\n+        final Path symlinkedDir = pair.getLeft();\n+        final Path targetDir = pair.getRight();\n+\n+        assertTrue(Files.exists(symlinkedDir));\n+        assertTrue(Files.isSymbolicLink(symlinkedDir));\n+        assertTrue(Files.exists(targetDir));\n+\n+        FileUtils.forceDelete(symlinkedDir.toFile());\n+\n+        // check targeted symlink is gone\n+        assertFalse(Files.exists(symlinkedDir));\n+        assertFalse(Files.isSymbolicLink(symlinkedDir));\n+        // dir targeted by symlink is not deleted\n+        assertTrue(Files.exists(targetDir));\n+    }\n+\n     @Test\n     void testForceMkdir() throws Exception {\n         // Tests with existing directory\n",
  "problem_statement" : "[IO-874] FileUtils.forceDelete can delete a broken symlink again\n\nThe fix for https://issues.apache.org/jira/browse/IO-859 introduced this regression bug https://issues.apache.org/jira/browse/IO-874, which is triggered when a broken/dangling symlink is tried to be deleted.\r\nBefore 2.16.1, FileUtils.forceDelete() deleted broken/dangling symbolic links successfully, since then it throws FileNotFoundException. With this fix a FileNotFoundException is only thrown, when the target file does not exist AND is not a symlink. 2 tests have been added to check that a  broken link is deleted and that an ok link only deletes the link but not the file itself (increase test coverage).\r\n\r\nNote: This is my first contribution. I just signed the ICLA as JoergBudi@gmx.de, shared it with secretary@apache.org and got a receipt, but haven't got an apacheid yet (my preferred apacheid would be jbudi , but I am in no hurry in case that is handed out only after more contribs).",
  "hints_text" : null,
  "created_at" : "Mon Jun 30 23:12:57 CEST 2025",
  "version" : null,
  "FAIL_TO_PASS" : [ "FileUtilsTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=FileUtilsTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 756,
  "metadata" : null
}, {
  "instance_id" : "apache-commons-io-PR-748",
  "repo" : "apache/commons-io",
  "base_commit" : "5080fa310dc19c20f9631bd18cfc3a5a63ef160e",
  "patch" : "diff --git a/src/changes/changes.xml b/src/changes/changes.xml\nindex ba3cb87d15d..fd5d64367b7 100644\n--- a/src/changes/changes.xml\n+++ b/src/changes/changes.xml\n@@ -47,6 +47,7 @@ The <action> type attribute can be add,update,fix,remove.\n   <body>\n     <release version=\"2.20.0\" date=\"YYYY-MM-DD\" description=\"Version 2.19.1: Java 8 or later is required.\">\n       <!-- FIX -->\n+      <action dev=\"maxxedev\" type=\"fix\"                due-to=\"maxxedev\">QueueInputStream reads all but the first byte without waiting</action>\n       <action dev=\"ggregory\" type=\"fix\"                due-to=\"Jesse Glick\">[javadoc] Rename parameter of ProxyOutputStream.write(int) #740.</action>\n       <action dev=\"ggregory\" type=\"fix\" issue=\"IO-875\" due-to=\"Pierre Baumard, Gary Gregory\">CopyDirectoryVisitor ignores fileFilter #743.</action>\n       <action dev=\"ggregory\" type=\"fix\"                due-to=\"Gary Gregory\">org.apache.commons.io.build.AbstractOrigin.getReader(Charset) now maps a null Charset to the default Charset.</action>\ndiff --git a/src/main/java/org/apache/commons/io/input/QueueInputStream.java b/src/main/java/org/apache/commons/io/input/QueueInputStream.java\nindex cc72bc29d3e..a6f3699e269 100644\n--- a/src/main/java/org/apache/commons/io/input/QueueInputStream.java\n+++ b/src/main/java/org/apache/commons/io/input/QueueInputStream.java\n@@ -23,6 +23,8 @@\n import java.io.PipedInputStream;\n import java.io.PipedOutputStream;\n import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n import java.util.Objects;\n import java.util.concurrent.BlockingQueue;\n import java.util.concurrent.LinkedBlockingQueue;\n@@ -224,4 +226,49 @@ public int read() {\n         }\n     }\n \n+    /**\n+     * Reads up to {@code length} bytes of data from the input stream into\n+     * an array of bytes.  The first byte is read while honoring the timeout; the rest are read while <i>not</i> honoring\n+     * the timeout. The number of bytes actually read is returned as an integer.\n+     *\n+     * @param b     the buffer into which the data is read.\n+     * @param offset   the start offset in array {@code b} at which the data is written.\n+     * @param length   the maximum number of bytes to read.\n+     * @return     the total number of bytes read into the buffer, or {@code -1} if there is no more data because the\n+     *              end of the stream has been reached.\n+     * @throws NullPointerException If {@code b} is {@code null}.\n+     * @throws IllegalStateException if thread is interrupted while waiting for the first byte.\n+     * @throws IndexOutOfBoundsException if {@code offset} is negative, {@code length} is negative, or {@code length} is\n+     *             greater than {@code b.length - offset}.\n+     * @since 2.20.0\n+     */\n+    @Override\n+    public int read(final byte[] b, final int offset, final int length) {\n+        if (b == null) {\n+            throw new NullPointerException();\n+        } else if (offset < 0 || length < 0 || length > b.length - offset) {\n+            throw new IndexOutOfBoundsException(\n+                    String.format(\"Range [%d, %<d + %d) out of bounds for length %d\", offset, length, b.length));\n+        } else if (length == 0) {\n+            return 0;\n+        }\n+        final List<Integer> drain = new ArrayList<>(Math.min(length, blockingQueue.size()));\n+        blockingQueue.drainTo(drain, length);\n+        if (drain.isEmpty()) {\n+            // no data immediately available. wait for first byte\n+            final int value = read();\n+            if (value == EOF) {\n+                return EOF;\n+            }\n+            drain.add(value);\n+            blockingQueue.drainTo(drain, length - 1);\n+        }\n+        int i = 0;\n+        for (final Integer value : drain) {\n+            b[offset + i] = (byte) (0xFF & value);\n+            i++;\n+        }\n+        return i;\n+    }\n+\n }\n",
  "test_patch" : "diff --git a/src/test/java/org/apache/commons/io/input/QueueInputStreamTest.java b/src/test/java/org/apache/commons/io/input/QueueInputStreamTest.java\nindex 742698b5f72..267480e253a 100644\n--- a/src/test/java/org/apache/commons/io/input/QueueInputStreamTest.java\n+++ b/src/test/java/org/apache/commons/io/input/QueueInputStreamTest.java\n@@ -16,19 +16,30 @@\n  */\n package org.apache.commons.io.input;\n \n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static org.apache.commons.lang3.ArrayUtils.EMPTY_BYTE_ARRAY;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n import static org.junit.jupiter.api.Assertions.assertEquals;\n import static org.junit.jupiter.api.Assertions.assertThrows;\n import static org.junit.jupiter.api.Assertions.assertTimeout;\n import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assumptions.assumeFalse;\n+import static org.junit.jupiter.api.DynamicTest.dynamicTest;\n \n import java.io.BufferedInputStream;\n import java.io.BufferedOutputStream;\n+import java.io.BufferedReader;\n import java.io.ByteArrayOutputStream;\n import java.io.IOException;\n import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n import java.time.Duration;\n import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.CompletableFuture;\n import java.util.concurrent.CountDownLatch;\n import java.util.concurrent.LinkedBlockingQueue;\n import java.util.concurrent.TimeUnit;\n@@ -40,7 +51,9 @@\n import org.apache.commons.io.output.QueueOutputStreamTest;\n import org.apache.commons.lang3.StringUtils;\n import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.DynamicTest;\n import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestFactory;\n import org.junit.jupiter.params.ParameterizedTest;\n import org.junit.jupiter.params.provider.Arguments;\n import org.junit.jupiter.params.provider.MethodSource;\n@@ -124,13 +137,125 @@ public void testAvailableAfterOpen(final String inputData) throws IOException {\n     public void testBufferedReads(final String inputData) throws IOException {\n         final BlockingQueue<Integer> queue = new LinkedBlockingQueue<>();\n         try (BufferedInputStream inputStream = new BufferedInputStream(new QueueInputStream(queue));\n-                QueueOutputStream outputStream = new QueueOutputStream(queue)) {\n+             QueueOutputStream outputStream = new QueueOutputStream(queue)) {\n             outputStream.write(inputData.getBytes(StandardCharsets.UTF_8));\n             final String actualData = IOUtils.toString(inputStream, StandardCharsets.UTF_8);\n             assertEquals(inputData, actualData);\n         }\n     }\n \n+    @ParameterizedTest(name = \"inputData={0}\")\n+    @MethodSource(\"inputData\")\n+    public void testReadLineByLineQueue(final String inputData) throws IOException {\n+        final String[] lines = inputData.split(\"\\n\");\n+        final BlockingQueue<Integer> queue = new LinkedBlockingQueue<>();\n+        try (QueueInputStream inputStream = QueueInputStream.builder()\n+                .setBlockingQueue(queue)\n+                .setTimeout(Duration.ofHours(1))\n+                .get();\n+             QueueOutputStream outputStream = inputStream.newQueueOutputStream()) {\n+\n+            doTestReadLineByLine(inputData, inputStream, outputStream);\n+        }\n+    }\n+\n+    @ParameterizedTest(name = \"inputData={0}\")\n+    @MethodSource(\"inputData\")\n+    public void testReadLineByLineFile(final String inputData) throws IOException {\n+        final Path tempFile = Files.createTempFile(getClass().getSimpleName(), \".txt\");\n+        try (InputStream inputStream = Files.newInputStream(tempFile);\n+             OutputStream outputStream = Files.newOutputStream(tempFile)) {\n+\n+            doTestReadLineByLine(inputData, inputStream, outputStream);\n+        } finally {\n+            Files.delete(tempFile);\n+        }\n+    }\n+\n+    private void doTestReadLineByLine(final String inputData, final InputStream inputStream, final OutputStream outputStream) throws IOException {\n+        final String[] lines = inputData.split(\"\\n\");\n+        try (BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream, UTF_8))) {\n+            for (String line : lines) {\n+                outputStream.write(line.getBytes(UTF_8));\n+                outputStream.write('\\n');\n+\n+                final String actualLine = reader.readLine();\n+                assertEquals(line, actualLine);\n+            }\n+        }\n+    }\n+\n+    @TestFactory\n+    public DynamicTest[] bulkReadErrorHandlingTests() {\n+        final QueueInputStream queueInputStream = new QueueInputStream();\n+        return new DynamicTest[] {\n+                dynamicTest(\"Offset too big\", () ->\n+                        assertThrows(IndexOutOfBoundsException.class, () ->\n+                                queueInputStream.read(EMPTY_BYTE_ARRAY, 1, 0))),\n+\n+                dynamicTest(\"Offset negative\", () ->\n+                        assertThrows(IndexOutOfBoundsException.class, () ->\n+                                queueInputStream.read(EMPTY_BYTE_ARRAY, -1, 0))),\n+\n+                dynamicTest(\"Length too big\", () ->\n+                        assertThrows(IndexOutOfBoundsException.class, () ->\n+                                queueInputStream.read(EMPTY_BYTE_ARRAY, 0, 1))),\n+\n+                dynamicTest(\"Length negative\", () ->\n+                        assertThrows(IndexOutOfBoundsException.class, () ->\n+                                queueInputStream.read(EMPTY_BYTE_ARRAY, 0, -1))),\n+        };\n+    }\n+\n+    @Test\n+    public void testBulkReadZeroLength() {\n+        final QueueInputStream queueInputStream = new QueueInputStream();\n+        final int read = queueInputStream.read(EMPTY_BYTE_ARRAY, 0, 0);\n+        assertEquals(0, read);\n+    }\n+\n+    @ParameterizedTest(name = \"inputData={0}\")\n+    @MethodSource(\"inputData\")\n+    public void testBulkReadWaiting(final String inputData) throws IOException {\n+        assumeFalse(inputData.isEmpty());\n+\n+        final CountDownLatch onPollLatch = new CountDownLatch(1);\n+        final CountDownLatch afterWriteLatch = new CountDownLatch(1);\n+        final LinkedBlockingQueue<Integer> queue = new LinkedBlockingQueue<Integer>() {\n+            @Override\n+            public Integer poll(final long timeout, final TimeUnit unit) throws InterruptedException {\n+                onPollLatch.countDown();\n+                afterWriteLatch.await(1, TimeUnit.HOURS);\n+                return super.poll(timeout, unit);\n+            }\n+        };\n+\n+        // Simulate scenario where there is not data immediately available when bulk reading and QueueInputStream has to\n+        // wait.\n+        try (QueueInputStream queueInputStream = QueueInputStream.builder()\n+                .setBlockingQueue(queue)\n+                .setTimeout(Duration.ofHours(1))\n+                .get()) {\n+            final QueueOutputStream queueOutputStream = queueInputStream.newQueueOutputStream();\n+            final CompletableFuture<Void> future = CompletableFuture.runAsync(() -> {\n+                try {\n+                    onPollLatch.await(1, TimeUnit.HOURS);\n+                    queueOutputStream.write(inputData.getBytes(UTF_8));\n+                    afterWriteLatch.countDown();\n+                } catch (final Exception e) {\n+                    throw new RuntimeException(e);\n+                }\n+            });\n+\n+            final byte[] data = new byte[inputData.length()];\n+            final int read = queueInputStream.read(data, 0, data.length);\n+            assertEquals(inputData.length(), read);\n+            final String outputData = new String(data, 0, read, StandardCharsets.UTF_8);\n+            assertEquals(inputData, outputData);\n+            assertDoesNotThrow(() -> future.get());\n+        }\n+    }\n+\n     @ParameterizedTest(name = \"inputData={0}\")\n     @MethodSource(\"inputData\")\n     public void testBufferedReadWrite(final String inputData) throws IOException {\ndiff --git a/src/test/java/org/apache/commons/io/jmh/QueueStreamBenchmark.java b/src/test/java/org/apache/commons/io/jmh/QueueStreamBenchmark.java\nnew file mode 100644\nindex 00000000000..eebcb30a542\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/io/jmh/QueueStreamBenchmark.java\n@@ -0,0 +1,76 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.io.jmh;\n+\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.apache.commons.io.input.QueueInputStream;\n+import org.apache.commons.io.output.QueueOutputStream;\n+import org.apache.commons.lang3.RandomUtils;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Group;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+/**\n+ * Measures the amount of time to push 1 MiB to a {@link QueueOutputStream} and read it using a {@link QueueInputStream}\n+ */\n+@BenchmarkMode(Mode.SampleTime)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Group)\n+public class QueueStreamBenchmark {\n+\n+    private static final int CAPACITY = 1024 * 1024;\n+    private static final int BUFFER_SIZE = 1024;\n+\n+    private final BlockingQueue<Integer> queue = new LinkedBlockingQueue<>(CAPACITY);\n+    private final QueueInputStream inputStream = QueueInputStream.builder()\n+            .setBlockingQueue(queue)\n+            .get();\n+    private final QueueOutputStream outputStream = inputStream.newQueueOutputStream();\n+\n+    private final byte[] input = RandomUtils.insecure().randomBytes(CAPACITY);\n+    private final byte[] output = new byte[BUFFER_SIZE];\n+\n+    @Benchmark\n+    @Group(\"streams\")\n+    public void output() throws Exception {\n+        int sent = 0;\n+        while (sent < CAPACITY) {\n+            final int len = Math.min(CAPACITY - sent, BUFFER_SIZE);\n+            outputStream.write(input, sent, len);\n+            sent += len;\n+        }\n+    }\n+\n+    @Benchmark\n+    @Group(\"streams\")\n+    public void input(Blackhole bh) throws Exception {\n+        int received = 0;\n+        while (received < CAPACITY) {\n+            final int len = inputStream.read(output, 0, BUFFER_SIZE);\n+            bh.consume(output);\n+            received += len;\n+        }\n+    }\n+}\n",
  "problem_statement" : "QueueInputStream reads all but the first byte without waiting.\n\n```\r\nQueueInputStream reads all but the first byte without waiting.\r\n\r\nFix so that bulk reads avoid getting stuck if a timeout is set and at least one byte is available.\r\n```\r\n",
  "hints_text" : null,
  "created_at" : "Sat May 17 08:00:08 CEST 2025",
  "version" : null,
  "FAIL_TO_PASS" : [ "QueueInputStreamTest", "QueueStreamBenchmark" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=QueueInputStreamTest,QueueStreamBenchmark",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 748,
  "metadata" : null
}, {
  "instance_id" : "apache-commons-io-PR-744",
  "repo" : "apache/commons-io",
  "base_commit" : "41419d10eae6306c902499102eef16f5e3ef2939",
  "patch" : "diff --git a/src/main/java/org/apache/commons/io/FileUtils.java b/src/main/java/org/apache/commons/io/FileUtils.java\nindex e04977670e6..c29399435f8 100644\n--- a/src/main/java/org/apache/commons/io/FileUtils.java\n+++ b/src/main/java/org/apache/commons/io/FileUtils.java\n@@ -2817,7 +2817,7 @@ public static List<String> readLines(final File file) throws IOException {\n      * @since 2.3\n      */\n     public static List<String> readLines(final File file, final Charset charset) throws IOException {\n-        return Files.readAllLines(file.toPath(), charset);\n+        return Files.readAllLines(file.toPath(), Charsets.toCharset(charset));\n     }\n \n     /**\n",
  "test_patch" : "diff --git a/src/test/java/org/apache/commons/io/FileUtilsTest.java b/src/test/java/org/apache/commons/io/FileUtilsTest.java\nindex b46a55f88b7..661c41288fe 100644\n--- a/src/test/java/org/apache/commons/io/FileUtilsTest.java\n+++ b/src/test/java/org/apache/commons/io/FileUtilsTest.java\n@@ -2839,6 +2839,25 @@ public void testReadLines_Errors() {\n         assertThrows(UnsupportedCharsetException.class, () -> FileUtils.readLines(tempDirFile, \"unsupported-charset\"));\n     }\n \n+    @Test\n+    public void testReadLines_Defaults() throws Exception {\n+        final File file = TestUtils.newFile(tempDirFile, \"lines.txt\");\n+        try {\n+            final String[] data = {\"hello\", \"this is\", \"some text\"};\n+            TestUtils.createLineFileUtf8(file, data);\n+\n+            final List<String> lines1 = FileUtils.readLines(file);\n+            final List<String> lines2 = FileUtils.readLines(file, (Charset) null);\n+            final List<String> lines3 = FileUtils.readLines(file, Charset.defaultCharset());\n+\n+            assertEquals(lines1, Arrays.asList(data));\n+            assertEquals(lines1, lines2);\n+            assertEquals(lines1, lines3);\n+        } finally {\n+            TestUtils.deleteFile(file);\n+        }\n+    }\n+\n     @Test\n     @EnabledIf(\"isPosixFilePermissionsSupported\")\n     public void testReadLines_IOExceptionOnPosixFileSystem() throws Exception {\n",
  "problem_statement" : "Handling null charset in `FileUtils.readLines(File, Charset)`\n\nI recently upgraded to the latest commons-io and the code where we were passing in null Charsets blew up.  The javadoc for this method says null should be handled, and this seems to be how you handle it elsewhere in the file.",
  "hints_text" : null,
  "created_at" : "Tue May 06 01:19:39 CEST 2025",
  "version" : null,
  "FAIL_TO_PASS" : [ "FileUtilsTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=FileUtilsTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 744,
  "metadata" : null
} ]