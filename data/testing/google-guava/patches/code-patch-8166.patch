diff --git a/android/guava/src/com/google/common/collect/ObjectArrays.java b/android/guava/src/com/google/common/collect/ObjectArrays.java
index 148587a068ac..3d02072e91d8 100644
--- a/android/guava/src/com/google/common/collect/ObjectArrays.java
+++ b/android/guava/src/com/google/common/collect/ObjectArrays.java
@@ -58,8 +58,14 @@ private ObjectArrays() {}
    * @param reference any array of the desired type
    * @param length the length of the new array
    */
+  /*
+   * The new array contains nulls, even if the old array did not. If we wanted to be accurate, we
+   * would declare a return type of `@Nullable T[]`. However, we've decided not to think too hard
+   * about arrays for now, as they're a mess.
+   */
   public static <T extends @Nullable Object> T[] newArray(T[] reference, int length) {
-    return Platform.newArray(reference, length);
+    T[] empty = reference.length == 0 ? reference : Arrays.copyOf(reference, 0);
+    return Arrays.copyOf(empty, length);
   }
 
   /**
diff --git a/android/guava/src/com/google/common/collect/Platform.java b/android/guava/src/com/google/common/collect/Platform.java
index a087f484c97b..b3b375ddd336 100644
--- a/android/guava/src/com/google/common/collect/Platform.java
+++ b/android/guava/src/com/google/common/collect/Platform.java
@@ -84,23 +84,6 @@ Map<K, V> preservesInsertionOrderOnPutsMapWithExpectedSize(int expectedSize) {
     return CompactHashSet.create();
   }
 
-  /**
-   * Returns a new array of the given length with the same type as a reference array.
-   *
-   * @param reference any array of the desired type
-   * @param length the length of the new array
-   */
-  /*
-   * The new array contains nulls, even if the old array did not. If we wanted to be accurate, we
-   * would declare a return type of `@Nullable T[]`. However, we've decided not to think too hard
-   * about arrays for now, as they're a mess. (We previously discussed this in the review of
-   * ObjectArrays, which is the main caller of this method.)
-   */
-  static <T extends @Nullable Object> T[] newArray(T[] reference, int length) {
-    T[] empty = reference.length == 0 ? reference : Arrays.copyOf(reference, 0);
-    return Arrays.copyOf(empty, length);
-  }
-
   /** Equivalent to Arrays.copyOfRange(source, from, to, arrayOfType.getClass()). */
   /*
    * Arrays are a mess from a nullness perspective, and Class instances for object-array types are
diff --git a/guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/Platform.java b/guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/Platform.java
index 8023264757fa..6a055913bbf7 100644
--- a/guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/Platform.java
+++ b/guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/Platform.java
@@ -16,7 +16,8 @@
 
 package com.google.common.collect;
 
-import java.util.Arrays;
+import static com.google.common.collect.ObjectArrays.newArray;
+
 import java.util.Collections;
 import java.util.LinkedHashMap;
 import java.util.LinkedHashSet;
@@ -87,11 +88,6 @@ Map<K, V> preservesInsertionOrderOnPutsMapWithExpectedSize(int expectedSize) {
     return new LinkedHashSet<>();
   }
 
-  static <T extends @Nullable Object> T[] newArray(T[] reference, int length) {
-    T[] empty = reference.length == 0 ? reference : Arrays.copyOf(reference, 0);
-    return Arrays.copyOf(empty, length);
-  }
-
   /** Equivalent to Arrays.copyOfRange(source, from, to, arrayOfType.getClass()). */
   static <T extends @Nullable Object> T[] copy(Object[] source, int from, int to, T[] arrayOfType) {
     T[] result = newArray(arrayOfType, to - from);
diff --git a/guava/src/com/google/common/collect/ObjectArrays.java b/guava/src/com/google/common/collect/ObjectArrays.java
index 148587a068ac..3d02072e91d8 100644
--- a/guava/src/com/google/common/collect/ObjectArrays.java
+++ b/guava/src/com/google/common/collect/ObjectArrays.java
@@ -58,8 +58,14 @@ private ObjectArrays() {}
    * @param reference any array of the desired type
    * @param length the length of the new array
    */
+  /*
+   * The new array contains nulls, even if the old array did not. If we wanted to be accurate, we
+   * would declare a return type of `@Nullable T[]`. However, we've decided not to think too hard
+   * about arrays for now, as they're a mess.
+   */
   public static <T extends @Nullable Object> T[] newArray(T[] reference, int length) {
-    return Platform.newArray(reference, length);
+    T[] empty = reference.length == 0 ? reference : Arrays.copyOf(reference, 0);
+    return Arrays.copyOf(empty, length);
   }
 
   /**
diff --git a/guava/src/com/google/common/collect/Platform.java b/guava/src/com/google/common/collect/Platform.java
index e04b80ce13e1..11eff870f120 100644
--- a/guava/src/com/google/common/collect/Platform.java
+++ b/guava/src/com/google/common/collect/Platform.java
@@ -92,23 +92,6 @@ Map<K, V> preservesInsertionOrderOnPutsMapWithExpectedSize(int expectedSize) {
     return CompactHashSet.create();
   }
 
-  /**
-   * Returns a new array of the given length with the same type as a reference array.
-   *
-   * @param reference any array of the desired type
-   * @param length the length of the new array
-   */
-  /*
-   * The new array contains nulls, even if the old array did not. If we wanted to be accurate, we
-   * would declare a return type of `@Nullable T[]`. However, we've decided not to think too hard
-   * about arrays for now, as they're a mess. (We previously discussed this in the review of
-   * ObjectArrays, which is the main caller of this method.)
-   */
-  static <T extends @Nullable Object> T[] newArray(T[] reference, int length) {
-    T[] empty = reference.length == 0 ? reference : Arrays.copyOf(reference, 0);
-    return Arrays.copyOf(empty, length);
-  }
-
   /** Equivalent to Arrays.copyOfRange(source, from, to, arrayOfType.getClass()). */
   /*
    * Arrays are a mess from a nullness perspective, and Class instances for object-array types are
