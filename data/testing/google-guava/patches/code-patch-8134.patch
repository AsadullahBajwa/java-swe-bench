diff --git a/android/guava-testlib/src/com/google/common/collect/testing/google/MapGenerators.java b/android/guava-testlib/src/com/google/common/collect/testing/google/MapGenerators.java
index f00017c89252..5a3c696c7e25 100644
--- a/android/guava-testlib/src/com/google/common/collect/testing/google/MapGenerators.java
+++ b/android/guava-testlib/src/com/google/common/collect/testing/google/MapGenerators.java
@@ -18,13 +18,13 @@
 
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.collect.Iterables.getOnlyElement;
+import static com.google.common.collect.Maps.immutableEnumMap;
 import static com.google.common.collect.testing.Helpers.mapEntry;
 import static java.util.Arrays.asList;
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.Maps;
 import com.google.common.collect.Ordering;
 import com.google.common.collect.testing.AnEnum;
 import com.google.common.collect.testing.SampleElements;
@@ -162,7 +162,7 @@ protected Map<AnEnum, String> create(Entry<AnEnum, String>[] entries) {
         checkNotNull(entry);
         map.put(entry.getKey(), entry.getValue());
       }
-      return Maps.immutableEnumMap(map);
+      return immutableEnumMap(map);
     }
   }
 
diff --git a/android/guava/src/com/google/common/collect/CompactHashing.java b/android/guava/src/com/google/common/collect/CompactHashing.java
index 55dc414c868a..e4dc8d54fa3b 100644
--- a/android/guava/src/com/google/common/collect/CompactHashing.java
+++ b/android/guava/src/com/google/common/collect/CompactHashing.java
@@ -16,6 +16,8 @@
 
 package com.google.common.collect;
 
+import static com.google.common.collect.Hashing.closedTableSize;
+import static com.google.common.collect.Hashing.smearedHash;
 import static java.lang.Math.max;
 
 import com.google.common.annotations.GwtIncompatible;
@@ -69,7 +71,7 @@ private CompactHashing() {}
    */
   static int tableSize(int expectedSize) {
     // We use entries next == 0 to indicate UNSET, so actual capacity is 1 less than requested.
-    return max(MIN_HASH_TABLE_SIZE, Hashing.closedTableSize(expectedSize + 1, 1.0));
+    return max(MIN_HASH_TABLE_SIZE, closedTableSize(expectedSize + 1, 1.0));
   }
 
   /** Creates and returns a properly-sized array with the given number of buckets. */
@@ -164,7 +166,7 @@ static int remove(
       int[] entries,
       @Nullable Object[] keys,
       @Nullable Object @Nullable [] values) {
-    int hash = Hashing.smearedHash(key);
+    int hash = smearedHash(key);
     int tableIndex = hash & mask;
     int next = tableGet(table, tableIndex);
     if (next == UNSET) {
diff --git a/android/guava/src/com/google/common/collect/ConcurrentHashMultiset.java b/android/guava/src/com/google/common/collect/ConcurrentHashMultiset.java
index 6363a26d2555..f3edde6d29ae 100644
--- a/android/guava/src/com/google/common/collect/ConcurrentHashMultiset.java
+++ b/android/guava/src/com/google/common/collect/ConcurrentHashMultiset.java
@@ -20,6 +20,7 @@
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.collect.CollectPreconditions.checkNonnegative;
+import static com.google.common.collect.CollectPreconditions.checkPositive;
 import static com.google.common.collect.Lists.newArrayListWithExpectedSize;
 import static com.google.common.collect.Maps.safeGet;
 import static java.lang.Math.max;
@@ -229,7 +230,7 @@ public int add(E element, int occurrences) {
     if (occurrences == 0) {
       return count(element);
     }
-    CollectPreconditions.checkPositive(occurrences, "occurrences");
+    checkPositive(occurrences, "occurrences");
 
     while (true) {
       AtomicInteger existingCounter = safeGet(countMap, element);
@@ -295,7 +296,7 @@ public int remove(@Nullable Object element, int occurrences) {
     if (occurrences == 0) {
       return count(element);
     }
-    CollectPreconditions.checkPositive(occurrences, "occurrences");
+    checkPositive(occurrences, "occurrences");
 
     AtomicInteger existingCounter = safeGet(countMap, element);
     if (existingCounter == null) {
@@ -336,7 +337,7 @@ public boolean removeExactly(@Nullable Object element, int occurrences) {
     if (occurrences == 0) {
       return true;
     }
-    CollectPreconditions.checkPositive(occurrences, "occurrences");
+    checkPositive(occurrences, "occurrences");
 
     AtomicInteger existingCounter = safeGet(countMap, element);
     if (existingCounter == null) {
diff --git a/android/guava/src/com/google/common/collect/HashBiMap.java b/android/guava/src/com/google/common/collect/HashBiMap.java
index 897f8db58a5e..e374bf92a7ad 100644
--- a/android/guava/src/com/google/common/collect/HashBiMap.java
+++ b/android/guava/src/com/google/common/collect/HashBiMap.java
@@ -16,6 +16,7 @@
 
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.collect.CollectPreconditions.checkNonnegative;
+import static com.google.common.collect.Hashing.smearedHash;
 import static com.google.common.collect.NullnessCasts.uncheckedCastNullableTToT;
 import static com.google.common.collect.NullnessCasts.unsafeNull;
 
@@ -187,12 +188,12 @@ private void ensureCapacity(int minCapacity) {
       hashTableVToK = createFilledWithAbsent(newTableSize);
 
       for (int entryToRehash = 0; entryToRehash < size; entryToRehash++) {
-        int keyHash = Hashing.smearedHash(keys[entryToRehash]);
+        int keyHash = smearedHash(keys[entryToRehash]);
         int keyBucket = bucket(keyHash);
         nextInBucketKToV[entryToRehash] = hashTableKToV[keyBucket];
         hashTableKToV[keyBucket] = entryToRehash;
 
-        int valueHash = Hashing.smearedHash(values[entryToRehash]);
+        int valueHash = smearedHash(values[entryToRehash]);
         int valueBucket = bucket(valueHash);
         nextInBucketVToK[entryToRehash] = hashTableVToK[valueBucket];
         hashTableVToK[valueBucket] = entryToRehash;
@@ -210,7 +211,7 @@ private int bucket(int hash) {
 
   /** Given a key, returns the index of the entry in the tables, or ABSENT if not found. */
   private int findEntryByKey(@Nullable Object key) {
-    return findEntryByKey(key, Hashing.smearedHash(key));
+    return findEntryByKey(key, smearedHash(key));
   }
 
   /**
@@ -222,7 +223,7 @@ private int findEntryByKey(@Nullable Object key, int keyHash) {
 
   /** Given a value, returns the index of the entry in the tables, or ABSENT if not found. */
   private int findEntryByValue(@Nullable Object value) {
-    return findEntryByValue(value, Hashing.smearedHash(value));
+    return findEntryByValue(value, smearedHash(value));
   }
 
   /**
@@ -285,7 +286,7 @@ public boolean containsValue(@Nullable Object value) {
   }
 
   private @Nullable V put(@ParametricNullness K key, @ParametricNullness V value, boolean force) {
-    int keyHash = Hashing.smearedHash(key);
+    int keyHash = smearedHash(key);
     int entryForKey = findEntryByKey(key, keyHash);
     if (entryForKey != ABSENT) {
       V oldValue = values[entryForKey];
@@ -297,7 +298,7 @@ public boolean containsValue(@Nullable Object value) {
       }
     }
 
-    int valueHash = Hashing.smearedHash(value);
+    int valueHash = smearedHash(value);
     int valueEntry = findEntryByValue(value, valueHash);
     if (force) {
       if (valueEntry != ABSENT) {
@@ -330,7 +331,7 @@ public boolean containsValue(@Nullable Object value) {
   @CanIgnoreReturnValue
   private @Nullable K putInverse(
       @ParametricNullness V value, @ParametricNullness K key, boolean force) {
-    int valueHash = Hashing.smearedHash(value);
+    int valueHash = smearedHash(value);
     int entryForValue = findEntryByValue(value, valueHash);
     if (entryForValue != ABSENT) {
       K oldKey = keys[entryForValue];
@@ -343,7 +344,7 @@ public boolean containsValue(@Nullable Object value) {
     }
 
     int predecessor = lastInInsertionOrder;
-    int keyHash = Hashing.smearedHash(key);
+    int keyHash = smearedHash(key);
     int keyEntry = findEntryByKey(key, keyHash);
     if (force) {
       if (keyEntry != ABSENT) {
@@ -476,7 +477,7 @@ private void deleteFromTableVToK(int entry, int valueHash) {
    */
   private void replaceValueInEntry(int entry, @ParametricNullness V newValue, boolean force) {
     checkArgument(entry != ABSENT);
-    int newValueHash = Hashing.smearedHash(newValue);
+    int newValueHash = smearedHash(newValue);
     int newValueIndex = findEntryByValue(newValue, newValueHash);
     if (newValueIndex != ABSENT) {
       if (force) {
@@ -489,7 +490,7 @@ private void replaceValueInEntry(int entry, @ParametricNullness V newValue, bool
       }
     }
     // we do *not* update insertion order, and it isn't a structural modification!
-    deleteFromTableVToK(entry, Hashing.smearedHash(values[entry]));
+    deleteFromTableVToK(entry, smearedHash(values[entry]));
     values[entry] = newValue;
     insertIntoTableVToK(entry, newValueHash);
   }
@@ -501,7 +502,7 @@ private void replaceValueInEntry(int entry, @ParametricNullness V newValue, bool
    */
   private void replaceKeyInEntry(int entry, @ParametricNullness K newKey, boolean force) {
     checkArgument(entry != ABSENT);
-    int newKeyHash = Hashing.smearedHash(newKey);
+    int newKeyHash = smearedHash(newKey);
     int newKeyIndex = findEntryByKey(newKey, newKeyHash);
 
     int newPredecessor = lastInInsertionOrder;
@@ -534,9 +535,9 @@ private void replaceKeyInEntry(int entry, @ParametricNullness K newKey, boolean
     int oldSuccessor = nextInInsertionOrder[entry];
     setSucceeds(oldPredecessor, oldSuccessor); // remove from insertion order linked list
 
-    deleteFromTableKToV(entry, Hashing.smearedHash(keys[entry]));
+    deleteFromTableKToV(entry, smearedHash(keys[entry]));
     keys[entry] = newKey;
-    insertIntoTableKToV(entry, Hashing.smearedHash(newKey));
+    insertIntoTableKToV(entry, smearedHash(newKey));
 
     // insert into insertion order linked list, usually at the end
     setSucceeds(newPredecessor, entry);
@@ -546,7 +547,7 @@ private void replaceKeyInEntry(int entry, @ParametricNullness K newKey, boolean
   @CanIgnoreReturnValue
   @Override
   public @Nullable V remove(@Nullable Object key) {
-    int keyHash = Hashing.smearedHash(key);
+    int keyHash = smearedHash(key);
     int entry = findEntryByKey(key, keyHash);
     if (entry == ABSENT) {
       return null;
@@ -558,7 +559,7 @@ private void replaceKeyInEntry(int entry, @ParametricNullness K newKey, boolean
   }
 
   private @Nullable K removeInverse(@Nullable Object value) {
-    int valueHash = Hashing.smearedHash(value);
+    int valueHash = smearedHash(value);
     int entry = findEntryByValue(value, valueHash);
     if (entry == ABSENT) {
       return null;
@@ -571,7 +572,7 @@ private void replaceKeyInEntry(int entry, @ParametricNullness K newKey, boolean
 
   /** Removes the entry at the specified index with no additional data. */
   private void removeEntry(int entry) {
-    removeEntryKeyHashKnown(entry, Hashing.smearedHash(keys[entry]));
+    removeEntryKeyHashKnown(entry, smearedHash(keys[entry]));
   }
 
   /** Removes the entry at the specified index, given the hash of its key and value. */
@@ -593,12 +594,12 @@ private void removeEntry(int entry, int keyHash, int valueHash) {
 
   /** Removes the entry at the specified index, given the hash of its key. */
   private void removeEntryKeyHashKnown(int entry, int keyHash) {
-    removeEntry(entry, keyHash, Hashing.smearedHash(values[entry]));
+    removeEntry(entry, keyHash, smearedHash(values[entry]));
   }
 
   /** Removes the entry at the specified index, given the hash of its value. */
   private void removeEntryValueHashKnown(int entry, int valueHash) {
-    removeEntry(entry, Hashing.smearedHash(keys[entry]), valueHash);
+    removeEntry(entry, smearedHash(keys[entry]), valueHash);
   }
 
   /**
@@ -621,7 +622,7 @@ private void moveEntryToIndex(int src, int dest) {
     values[dest] = value;
 
     // update pointers in hashTableKToV
-    int keyHash = Hashing.smearedHash(key);
+    int keyHash = smearedHash(key);
     int keyBucket = bucket(keyHash);
     if (hashTableKToV[keyBucket] == src) {
       hashTableKToV[keyBucket] = dest;
@@ -641,7 +642,7 @@ private void moveEntryToIndex(int src, int dest) {
     nextInBucketKToV[src] = ABSENT;
 
     // update pointers in hashTableVToK
-    int valueHash = Hashing.smearedHash(value);
+    int valueHash = smearedHash(value);
     int valueBucket = bucket(valueHash);
     if (hashTableVToK[valueBucket] == src) {
       hashTableVToK[valueBucket] = dest;
@@ -778,7 +779,7 @@ public boolean contains(@Nullable Object o) {
 
     @Override
     public boolean remove(@Nullable Object o) {
-      int oHash = Hashing.smearedHash(o);
+      int oHash = smearedHash(o);
       int entry = findEntryByKey(o, oHash);
       if (entry != ABSENT) {
         removeEntryKeyHashKnown(entry, oHash);
@@ -816,7 +817,7 @@ public boolean contains(@Nullable Object o) {
 
     @Override
     public boolean remove(@Nullable Object o) {
-      int oHash = Hashing.smearedHash(o);
+      int oHash = smearedHash(o);
       int entry = findEntryByValue(o, oHash);
       if (entry != ABSENT) {
         removeEntryValueHashKnown(entry, oHash);
@@ -859,7 +860,7 @@ public boolean remove(@Nullable Object o) {
         Entry<?, ?> e = (Entry<?, ?>) o;
         Object k = e.getKey();
         Object v = e.getValue();
-        int kHash = Hashing.smearedHash(k);
+        int kHash = smearedHash(k);
         int eIndex = findEntryByKey(k, kHash);
         if (eIndex != ABSENT && Objects.equals(v, values[eIndex])) {
           removeEntryKeyHashKnown(eIndex, kHash);
@@ -1067,7 +1068,7 @@ public boolean remove(@Nullable Object o) {
         Entry<?, ?> e = (Entry<?, ?>) o;
         Object obverseValue = e.getKey();
         Object obverseKey = e.getValue();
-        int obverseValueHash = Hashing.smearedHash(obverseValue);
+        int obverseValueHash = smearedHash(obverseValue);
         int eIndex = obverse.findEntryByValue(obverseValue, obverseValueHash);
         if (eIndex != ABSENT && Objects.equals(obverse.keys[eIndex], obverseKey)) {
           obverse.removeEntryValueHashKnown(eIndex, obverseValueHash);
diff --git a/android/guava/src/com/google/common/collect/LinkedHashMultimap.java b/android/guava/src/com/google/common/collect/LinkedHashMultimap.java
index a55bd41febd0..7824ddfd54ec 100644
--- a/android/guava/src/com/google/common/collect/LinkedHashMultimap.java
+++ b/android/guava/src/com/google/common/collect/LinkedHashMultimap.java
@@ -18,6 +18,8 @@
 
 import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.collect.CollectPreconditions.checkNonnegative;
+import static com.google.common.collect.Hashing.closedTableSize;
+import static com.google.common.collect.Hashing.smearedHash;
 import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtCompatible;
@@ -269,7 +271,7 @@ final class ValueSet extends Sets.ImprovedAbstractSet<V> {
     ValueSet(@ParametricNullness K key, int expectedValues) {
       this.key = key;
       // Round expected values up to a power of 2 to get the table size.
-      int tableSize = Hashing.closedTableSize(expectedValues, VALUE_SET_LOAD_FACTOR);
+      int tableSize = closedTableSize(expectedValues, VALUE_SET_LOAD_FACTOR);
 
       @SuppressWarnings({"rawtypes", "unchecked"})
       @Nullable ValueEntry<K, V>[] hashTable = new @Nullable ValueEntry[tableSize];
@@ -354,7 +356,7 @@ public int size() {
 
     @Override
     public boolean contains(@Nullable Object o) {
-      int smearedHash = Hashing.smearedHash(o);
+      int smearedHash = smearedHash(o);
       for (ValueEntry<K, V> entry = hashTable[smearedHash & mask()];
           entry != null;
           entry = entry.nextInValueBucket) {
@@ -367,7 +369,7 @@ public boolean contains(@Nullable Object o) {
 
     @Override
     public boolean add(@ParametricNullness V value) {
-      int smearedHash = Hashing.smearedHash(value);
+      int smearedHash = smearedHash(value);
       int bucket = smearedHash & mask();
       ValueEntry<K, V> rowHead = hashTable[bucket];
       for (ValueEntry<K, V> entry = rowHead; entry != null; entry = entry.nextInValueBucket) {
@@ -406,7 +408,7 @@ private void rehashIfNecessary() {
     @CanIgnoreReturnValue
     @Override
     public boolean remove(@Nullable Object o) {
-      int smearedHash = Hashing.smearedHash(o);
+      int smearedHash = smearedHash(o);
       int bucket = smearedHash & mask();
       ValueEntry<K, V> prev = null;
       for (ValueEntry<K, V> entry = hashTable[bucket];
diff --git a/android/guava/src/com/google/common/collect/RegularImmutableSet.java b/android/guava/src/com/google/common/collect/RegularImmutableSet.java
index 2e1eb9a267f2..d56c82cc4d1f 100644
--- a/android/guava/src/com/google/common/collect/RegularImmutableSet.java
+++ b/android/guava/src/com/google/common/collect/RegularImmutableSet.java
@@ -16,6 +16,7 @@
 
 package com.google.common.collect;
 
+import static com.google.common.collect.Hashing.smearedHash;
 import static java.lang.System.arraycopy;
 
 import com.google.common.annotations.GwtCompatible;
@@ -60,7 +61,7 @@ public boolean contains(@Nullable Object target) {
     if (target == null || table.length == 0) {
       return false;
     }
-    for (int i = Hashing.smearedHash(target); ; i++) {
+    for (int i = smearedHash(target); ; i++) {
       i &= mask;
       Object candidate = table[i];
       if (candidate == null) {
diff --git a/guava-testlib/src/com/google/common/collect/testing/google/MapGenerators.java b/guava-testlib/src/com/google/common/collect/testing/google/MapGenerators.java
index f00017c89252..5a3c696c7e25 100644
--- a/guava-testlib/src/com/google/common/collect/testing/google/MapGenerators.java
+++ b/guava-testlib/src/com/google/common/collect/testing/google/MapGenerators.java
@@ -18,13 +18,13 @@
 
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.collect.Iterables.getOnlyElement;
+import static com.google.common.collect.Maps.immutableEnumMap;
 import static com.google.common.collect.testing.Helpers.mapEntry;
 import static java.util.Arrays.asList;
 
 import com.google.common.annotations.GwtCompatible;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.Maps;
 import com.google.common.collect.Ordering;
 import com.google.common.collect.testing.AnEnum;
 import com.google.common.collect.testing.SampleElements;
@@ -162,7 +162,7 @@ protected Map<AnEnum, String> create(Entry<AnEnum, String>[] entries) {
         checkNotNull(entry);
         map.put(entry.getKey(), entry.getValue());
       }
-      return Maps.immutableEnumMap(map);
+      return immutableEnumMap(map);
     }
   }
 
diff --git a/guava/src/com/google/common/collect/CompactHashing.java b/guava/src/com/google/common/collect/CompactHashing.java
index 55dc414c868a..e4dc8d54fa3b 100644
--- a/guava/src/com/google/common/collect/CompactHashing.java
+++ b/guava/src/com/google/common/collect/CompactHashing.java
@@ -16,6 +16,8 @@
 
 package com.google.common.collect;
 
+import static com.google.common.collect.Hashing.closedTableSize;
+import static com.google.common.collect.Hashing.smearedHash;
 import static java.lang.Math.max;
 
 import com.google.common.annotations.GwtIncompatible;
@@ -69,7 +71,7 @@ private CompactHashing() {}
    */
   static int tableSize(int expectedSize) {
     // We use entries next == 0 to indicate UNSET, so actual capacity is 1 less than requested.
-    return max(MIN_HASH_TABLE_SIZE, Hashing.closedTableSize(expectedSize + 1, 1.0));
+    return max(MIN_HASH_TABLE_SIZE, closedTableSize(expectedSize + 1, 1.0));
   }
 
   /** Creates and returns a properly-sized array with the given number of buckets. */
@@ -164,7 +166,7 @@ static int remove(
       int[] entries,
       @Nullable Object[] keys,
       @Nullable Object @Nullable [] values) {
-    int hash = Hashing.smearedHash(key);
+    int hash = smearedHash(key);
     int tableIndex = hash & mask;
     int next = tableGet(table, tableIndex);
     if (next == UNSET) {
diff --git a/guava/src/com/google/common/collect/ConcurrentHashMultiset.java b/guava/src/com/google/common/collect/ConcurrentHashMultiset.java
index 6363a26d2555..f3edde6d29ae 100644
--- a/guava/src/com/google/common/collect/ConcurrentHashMultiset.java
+++ b/guava/src/com/google/common/collect/ConcurrentHashMultiset.java
@@ -20,6 +20,7 @@
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.collect.CollectPreconditions.checkNonnegative;
+import static com.google.common.collect.CollectPreconditions.checkPositive;
 import static com.google.common.collect.Lists.newArrayListWithExpectedSize;
 import static com.google.common.collect.Maps.safeGet;
 import static java.lang.Math.max;
@@ -229,7 +230,7 @@ public int add(E element, int occurrences) {
     if (occurrences == 0) {
       return count(element);
     }
-    CollectPreconditions.checkPositive(occurrences, "occurrences");
+    checkPositive(occurrences, "occurrences");
 
     while (true) {
       AtomicInteger existingCounter = safeGet(countMap, element);
@@ -295,7 +296,7 @@ public int remove(@Nullable Object element, int occurrences) {
     if (occurrences == 0) {
       return count(element);
     }
-    CollectPreconditions.checkPositive(occurrences, "occurrences");
+    checkPositive(occurrences, "occurrences");
 
     AtomicInteger existingCounter = safeGet(countMap, element);
     if (existingCounter == null) {
@@ -336,7 +337,7 @@ public boolean removeExactly(@Nullable Object element, int occurrences) {
     if (occurrences == 0) {
       return true;
     }
-    CollectPreconditions.checkPositive(occurrences, "occurrences");
+    checkPositive(occurrences, "occurrences");
 
     AtomicInteger existingCounter = safeGet(countMap, element);
     if (existingCounter == null) {
diff --git a/guava/src/com/google/common/collect/HashBiMap.java b/guava/src/com/google/common/collect/HashBiMap.java
index fcb12945ca6d..8a8c0c81b321 100644
--- a/guava/src/com/google/common/collect/HashBiMap.java
+++ b/guava/src/com/google/common/collect/HashBiMap.java
@@ -17,6 +17,7 @@
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.collect.CollectPreconditions.checkNonnegative;
+import static com.google.common.collect.Hashing.closedTableSize;
 import static com.google.common.collect.Hashing.smearedHash;
 import static java.util.Objects.requireNonNull;
 
@@ -144,7 +145,7 @@ private HashBiMap(int expectedSize) {
 
   private void init(int expectedSize) {
     checkNonnegative(expectedSize, "expectedSize");
-    int tableSize = Hashing.closedTableSize(expectedSize, LOAD_FACTOR);
+    int tableSize = closedTableSize(expectedSize, LOAD_FACTOR);
     this.hashTableKToV = createTable(tableSize);
     this.hashTableVToK = createTable(tableSize);
     this.firstInKeyInsertionOrder = null;
diff --git a/guava/src/com/google/common/collect/LinkedHashMultimap.java b/guava/src/com/google/common/collect/LinkedHashMultimap.java
index c1e871eb966e..fbca2936ba6a 100644
--- a/guava/src/com/google/common/collect/LinkedHashMultimap.java
+++ b/guava/src/com/google/common/collect/LinkedHashMultimap.java
@@ -19,6 +19,8 @@
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.collect.CollectPreconditions.checkNonnegative;
+import static com.google.common.collect.Hashing.closedTableSize;
+import static com.google.common.collect.Hashing.smearedHash;
 import static java.util.Objects.requireNonNull;
 
 import com.google.common.annotations.GwtCompatible;
@@ -273,7 +275,7 @@ final class ValueSet extends Sets.ImprovedAbstractSet<V> {
     ValueSet(@ParametricNullness K key, int expectedValues) {
       this.key = key;
       // Round expected values up to a power of 2 to get the table size.
-      int tableSize = Hashing.closedTableSize(expectedValues, VALUE_SET_LOAD_FACTOR);
+      int tableSize = closedTableSize(expectedValues, VALUE_SET_LOAD_FACTOR);
 
       @SuppressWarnings({"rawtypes", "unchecked"})
       @Nullable ValueEntry<K, V>[] hashTable = new @Nullable ValueEntry[tableSize];
@@ -366,7 +368,7 @@ public int size() {
 
     @Override
     public boolean contains(@Nullable Object o) {
-      int smearedHash = Hashing.smearedHash(o);
+      int smearedHash = smearedHash(o);
       for (ValueEntry<K, V> entry = hashTable[smearedHash & mask()];
           entry != null;
           entry = entry.nextInValueBucket) {
@@ -379,7 +381,7 @@ public boolean contains(@Nullable Object o) {
 
     @Override
     public boolean add(@ParametricNullness V value) {
-      int smearedHash = Hashing.smearedHash(value);
+      int smearedHash = smearedHash(value);
       int bucket = smearedHash & mask();
       ValueEntry<K, V> rowHead = hashTable[bucket];
       for (ValueEntry<K, V> entry = rowHead; entry != null; entry = entry.nextInValueBucket) {
@@ -418,7 +420,7 @@ private void rehashIfNecessary() {
     @CanIgnoreReturnValue
     @Override
     public boolean remove(@Nullable Object o) {
-      int smearedHash = Hashing.smearedHash(o);
+      int smearedHash = smearedHash(o);
       int bucket = smearedHash & mask();
       ValueEntry<K, V> prev = null;
       for (ValueEntry<K, V> entry = hashTable[bucket];
diff --git a/guava/src/com/google/common/collect/RegularImmutableBiMap.java b/guava/src/com/google/common/collect/RegularImmutableBiMap.java
index 2103573a38d8..33f36178a952 100644
--- a/guava/src/com/google/common/collect/RegularImmutableBiMap.java
+++ b/guava/src/com/google/common/collect/RegularImmutableBiMap.java
@@ -19,6 +19,7 @@
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkPositionIndex;
 import static com.google.common.collect.CollectPreconditions.checkEntryNotNull;
+import static com.google.common.collect.Hashing.closedTableSize;
 import static com.google.common.collect.ImmutableMapEntry.createEntryArray;
 import static com.google.common.collect.Maps.immutableEntry;
 import static com.google.common.collect.RegularImmutableMap.MAX_HASH_BUCKET_LENGTH;
@@ -67,7 +68,7 @@ static <K, V> ImmutableBiMap<K, V> fromEntries(Entry<K, V>... entries) {
 
   static <K, V> ImmutableBiMap<K, V> fromEntryArray(int n, @Nullable Entry<K, V>[] entryArray) {
     checkPositionIndex(n, entryArray.length);
-    int tableSize = Hashing.closedTableSize(n, MAX_LOAD_FACTOR);
+    int tableSize = closedTableSize(n, MAX_LOAD_FACTOR);
     int mask = tableSize - 1;
     @Nullable ImmutableMapEntry<K, V>[] keyTable = createEntryArray(tableSize);
     @Nullable ImmutableMapEntry<K, V>[] valueTable = createEntryArray(tableSize);
diff --git a/guava/src/com/google/common/collect/RegularImmutableMap.java b/guava/src/com/google/common/collect/RegularImmutableMap.java
index 0a707a1ea247..66e5bd571f77 100644
--- a/guava/src/com/google/common/collect/RegularImmutableMap.java
+++ b/guava/src/com/google/common/collect/RegularImmutableMap.java
@@ -19,6 +19,7 @@
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkPositionIndex;
 import static com.google.common.collect.CollectPreconditions.checkEntryNotNull;
+import static com.google.common.collect.Hashing.closedTableSize;
 import static com.google.common.collect.ImmutableMapEntry.createEntryArray;
 import static java.util.Objects.requireNonNull;
 
@@ -112,7 +113,7 @@ private static <K, V> ImmutableMap<K, V> fromEntryArrayCheckingBucketOverflow(
     @SuppressWarnings("nullness")
     Entry<K, V>[] entries =
         (n == entryArray.length) ? (Entry<K, V>[]) entryArray : createEntryArray(n);
-    int tableSize = Hashing.closedTableSize(n, MAX_LOAD_FACTOR);
+    int tableSize = closedTableSize(n, MAX_LOAD_FACTOR);
     @Nullable ImmutableMapEntry<K, V>[] table = createEntryArray(tableSize);
     int mask = tableSize - 1;
     // If duplicates are allowed, this IdentityHashMap will record the final Entry for each
@@ -161,7 +162,7 @@ private static <K, V> ImmutableMap<K, V> fromEntryArrayCheckingBucketOverflow(
     }
     if (duplicates != null) {
       entries = removeDuplicates(entries, n, n - dupCount, duplicates);
-      int newTableSize = Hashing.closedTableSize(entries.length, MAX_LOAD_FACTOR);
+      int newTableSize = closedTableSize(entries.length, MAX_LOAD_FACTOR);
       if (newTableSize != tableSize) {
         return fromEntryArrayCheckingBucketOverflow(
             entries.length, entries, /* throwIfDuplicateKeys= */ true);
diff --git a/guava/src/com/google/common/collect/RegularImmutableMultiset.java b/guava/src/com/google/common/collect/RegularImmutableMultiset.java
index 61ea433703bb..d21929df722e 100644
--- a/guava/src/com/google/common/collect/RegularImmutableMultiset.java
+++ b/guava/src/com/google/common/collect/RegularImmutableMultiset.java
@@ -15,6 +15,8 @@
 package com.google.common.collect;
 
 import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.collect.Hashing.closedTableSize;
+import static com.google.common.collect.Hashing.smearedHash;
 import static com.google.common.collect.ImmutableList.asImmutableList;
 
 import com.google.common.annotations.GwtCompatible;
@@ -48,7 +50,7 @@ static <E> ImmutableMultiset<E> create(Collection<? extends Entry<? extends E>>
     if (distinct == 0) {
       return new RegularImmutableMultiset<>(entryArray, EMPTY_ARRAY, 0, 0, ImmutableSet.of());
     }
-    int tableSize = Hashing.closedTableSize(distinct, MAX_LOAD_FACTOR);
+    int tableSize = closedTableSize(distinct, MAX_LOAD_FACTOR);
     int mask = tableSize - 1;
     @SuppressWarnings({"unchecked", "rawtypes"})
     @Nullable ImmutableEntry<E>[] hashTable = new @Nullable ImmutableEntry[tableSize];
@@ -162,7 +164,7 @@ public int count(@Nullable Object element) {
     if (element == null || hashTable.length == 0) {
       return 0;
     }
-    int hash = Hashing.smearedHash(element);
+    int hash = smearedHash(element);
     int mask = hashTable.length - 1;
     for (ImmutableEntry<?> entry = hashTable[hash & mask];
         entry != null;
diff --git a/guava/src/com/google/common/collect/RegularImmutableSet.java b/guava/src/com/google/common/collect/RegularImmutableSet.java
index 951a5d5e3768..86137aedf9ae 100644
--- a/guava/src/com/google/common/collect/RegularImmutableSet.java
+++ b/guava/src/com/google/common/collect/RegularImmutableSet.java
@@ -16,6 +16,7 @@
 
 package com.google.common.collect;
 
+import static com.google.common.collect.Hashing.smearedHash;
 import static java.lang.System.arraycopy;
 
 import com.google.common.annotations.GwtCompatible;
@@ -58,7 +59,7 @@ public boolean contains(@Nullable Object target) {
     if (target == null || table.length == 0) {
       return false;
     }
-    for (int i = Hashing.smearedHash(target); ; i++) {
+    for (int i = smearedHash(target); ; i++) {
       i &= mask;
       Object candidate = table[i];
       if (candidate == null) {
