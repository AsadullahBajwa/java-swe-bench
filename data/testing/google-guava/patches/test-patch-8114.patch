diff --git a/android/guava-tests/test/com/google/common/collect/ConcurrentHashMultisetBasherTest.java b/android/guava-tests/test/com/google/common/collect/ConcurrentHashMultisetBasherTest.java
index 325aa4d7b14f..dee4ed06db80 100644
--- a/android/guava-tests/test/com/google/common/collect/ConcurrentHashMultisetBasherTest.java
+++ b/android/guava-tests/test/com/google/common/collect/ConcurrentHashMultisetBasherTest.java
@@ -21,7 +21,6 @@
 import static java.lang.Math.min;
 import static java.util.concurrent.Executors.newFixedThreadPool;
 
-import com.google.common.base.Function;
 import com.google.common.primitives.Ints;
 import java.util.List;
 import java.util.Random;
@@ -49,24 +48,24 @@
 public class ConcurrentHashMultisetBasherTest extends TestCase {
 
   public void testAddAndRemove_concurrentHashMap() throws Exception {
-    testAddAndRemove(new ConcurrentHashMap<String, AtomicInteger>());
+    testAddAndRemove(new ConcurrentHashMap<>());
   }
 
   public void testAddAndRemove_concurrentSkipListMap() throws Exception {
-    testAddAndRemove(new ConcurrentSkipListMap<String, AtomicInteger>());
+    testAddAndRemove(new ConcurrentSkipListMap<>());
   }
 
   public void testAddAndRemove_mapMakerMap() throws Exception {
     MapMaker mapMaker = new MapMaker();
     // force MapMaker to use its own MapMakerInternalMap
     mapMaker.useCustomMap = true;
-    testAddAndRemove(mapMaker.<String, AtomicInteger>makeMap());
+    testAddAndRemove(mapMaker.makeMap());
   }
 
   private void testAddAndRemove(ConcurrentMap<String, AtomicInteger> map)
       throws ExecutionException, InterruptedException {
 
-    ConcurrentHashMultiset<String> multiset = new ConcurrentHashMultiset<>(map);
+    ConcurrentHashMultiset<String> multiset = ConcurrentHashMultiset.create(map);
     int nThreads = 20;
     int tasksPerThread = 10;
     int nTasks = nThreads * tasksPerThread;
@@ -86,15 +85,7 @@ private void testAddAndRemove(ConcurrentMap<String, AtomicInteger> map)
         }
       }
 
-      List<Integer> actualCounts =
-          transform(
-              keys,
-              new Function<String, Integer>() {
-                @Override
-                public Integer apply(String key) {
-                  return multiset.count(key);
-                }
-              });
+      List<Integer> actualCounts = transform(keys, multiset::count);
       assertEquals("Counts not as expected", Ints.asList(deltas), actualCounts);
     } finally {
       pool.shutdownNow();
@@ -117,7 +108,7 @@ private MutateTask(ConcurrentHashMultiset<String> multiset, ImmutableList<String
     }
 
     @Override
-    public int[] call() throws Exception {
+    public int[] call() {
       int iterations = 100000;
       int nKeys = keys.size();
       int[] deltas = new int[nKeys];
diff --git a/android/guava-tests/test/com/google/common/collect/ConcurrentHashMultisetTest.java b/android/guava-tests/test/com/google/common/collect/ConcurrentHashMultisetTest.java
index fe00fc868560..636c4d84d623 100644
--- a/android/guava-tests/test/com/google/common/collect/ConcurrentHashMultisetTest.java
+++ b/android/guava-tests/test/com/google/common/collect/ConcurrentHashMultisetTest.java
@@ -18,7 +18,9 @@
 
 import static com.google.common.collect.MapMakerInternalMap.Strength.STRONG;
 import static com.google.common.collect.MapMakerInternalMap.Strength.WEAK;
+import static com.google.common.testing.SerializableTester.reserialize;
 import static com.google.common.testing.SerializableTester.reserializeAndAssert;
+import static com.google.common.truth.Truth.assertThat;
 import static java.util.Arrays.asList;
 import static org.junit.Assert.assertThrows;
 import static org.mockito.ArgumentMatchers.isA;
@@ -31,6 +33,7 @@
 import com.google.common.collect.testing.features.CollectionSize;
 import com.google.common.collect.testing.google.MultisetTestSuiteBuilder;
 import com.google.common.collect.testing.google.TestStringMultisetGenerator;
+import java.io.Serializable;
 import java.util.Collections;
 import java.util.Iterator;
 import java.util.List;
@@ -92,8 +95,7 @@ private static TestStringMultisetGenerator concurrentSkipListMultisetGenerator()
     return new TestStringMultisetGenerator() {
       @Override
       protected Multiset<String> create(String[] elements) {
-        Multiset<String> multiset =
-            new ConcurrentHashMultiset<>(new ConcurrentSkipListMap<String, AtomicInteger>());
+        Multiset<String> multiset = ConcurrentHashMultiset.create(new ConcurrentSkipListMap<>());
         Collections.addAll(multiset, elements);
         return multiset;
       }
@@ -116,7 +118,7 @@ protected void setUp() {
     backingMap = mock(ConcurrentMap.class);
     when(backingMap.isEmpty()).thenReturn(true);
 
-    multiset = new ConcurrentHashMultiset<>(backingMap);
+    multiset = ConcurrentHashMultiset.create(backingMap);
   }
 
   public void testCount_elementPresent() {
@@ -309,6 +311,54 @@ public void testSetCount_0_nonePresent() {
     assertEquals(0, multiset.setCount(KEY, 0));
   }
 
+  public void testSerialCycle() {
+    ConcurrentHashMultiset<ContainsMultiset> multiset = ConcurrentHashMultiset.create();
+    ContainsMultiset containsMultiset = new ContainsMultiset(multiset);
+    multiset.add(containsMultiset);
+    ContainsBothWithMultisetFirst multisetFirst =
+        new ContainsBothWithMultisetFirst(multiset, containsMultiset);
+    ContainsBothWithContainsMultisetFirst containsMultisetFirst =
+        new ContainsBothWithContainsMultisetFirst(containsMultiset, multiset);
+
+    ContainsBothWithMultisetFirst reMultisetFirst = reserialize(multisetFirst);
+    assertThat(reMultisetFirst.a.isEmpty()).isFalse();
+    // The following NPE is a side effect of our changes to avoid mutating `final` fields.
+    assertThrows(NullPointerException.class, () -> reMultisetFirst.z.multiset.isEmpty());
+
+    ContainsBothWithContainsMultisetFirst reContainsMultisetFirst =
+        reserialize(containsMultisetFirst);
+    assertThat(reContainsMultisetFirst.a.multiset.isEmpty()).isFalse();
+    assertThat(reContainsMultisetFirst.z.isEmpty()).isFalse();
+  }
+
+  private static final class ContainsMultiset implements Serializable {
+    private final ConcurrentHashMultiset<?> multiset;
+
+    ContainsMultiset(ConcurrentHashMultiset<?> multiset) {
+      this.multiset = multiset;
+    }
+  }
+
+  private static final class ContainsBothWithMultisetFirst implements Serializable {
+    private final ConcurrentHashMultiset<?> a;
+    private final ContainsMultiset z;
+
+    ContainsBothWithMultisetFirst(ConcurrentHashMultiset<?> a, ContainsMultiset z) {
+      this.a = a;
+      this.z = z;
+    }
+  }
+
+  private static final class ContainsBothWithContainsMultisetFirst implements Serializable {
+    private final ContainsMultiset a;
+    private final ConcurrentHashMultiset<?> z;
+
+    ContainsBothWithContainsMultisetFirst(ContainsMultiset a, ConcurrentHashMultiset<?> z) {
+      this.a = a;
+      this.z = z;
+    }
+  }
+
   public void testCreate() {
     ConcurrentHashMultiset<Integer> multiset = ConcurrentHashMultiset.create();
     assertTrue(multiset.isEmpty());
diff --git a/guava-tests/test/com/google/common/collect/ConcurrentHashMultisetBasherTest.java b/guava-tests/test/com/google/common/collect/ConcurrentHashMultisetBasherTest.java
index 325aa4d7b14f..dee4ed06db80 100644
--- a/guava-tests/test/com/google/common/collect/ConcurrentHashMultisetBasherTest.java
+++ b/guava-tests/test/com/google/common/collect/ConcurrentHashMultisetBasherTest.java
@@ -21,7 +21,6 @@
 import static java.lang.Math.min;
 import static java.util.concurrent.Executors.newFixedThreadPool;
 
-import com.google.common.base.Function;
 import com.google.common.primitives.Ints;
 import java.util.List;
 import java.util.Random;
@@ -49,24 +48,24 @@
 public class ConcurrentHashMultisetBasherTest extends TestCase {
 
   public void testAddAndRemove_concurrentHashMap() throws Exception {
-    testAddAndRemove(new ConcurrentHashMap<String, AtomicInteger>());
+    testAddAndRemove(new ConcurrentHashMap<>());
   }
 
   public void testAddAndRemove_concurrentSkipListMap() throws Exception {
-    testAddAndRemove(new ConcurrentSkipListMap<String, AtomicInteger>());
+    testAddAndRemove(new ConcurrentSkipListMap<>());
   }
 
   public void testAddAndRemove_mapMakerMap() throws Exception {
     MapMaker mapMaker = new MapMaker();
     // force MapMaker to use its own MapMakerInternalMap
     mapMaker.useCustomMap = true;
-    testAddAndRemove(mapMaker.<String, AtomicInteger>makeMap());
+    testAddAndRemove(mapMaker.makeMap());
   }
 
   private void testAddAndRemove(ConcurrentMap<String, AtomicInteger> map)
       throws ExecutionException, InterruptedException {
 
-    ConcurrentHashMultiset<String> multiset = new ConcurrentHashMultiset<>(map);
+    ConcurrentHashMultiset<String> multiset = ConcurrentHashMultiset.create(map);
     int nThreads = 20;
     int tasksPerThread = 10;
     int nTasks = nThreads * tasksPerThread;
@@ -86,15 +85,7 @@ private void testAddAndRemove(ConcurrentMap<String, AtomicInteger> map)
         }
       }
 
-      List<Integer> actualCounts =
-          transform(
-              keys,
-              new Function<String, Integer>() {
-                @Override
-                public Integer apply(String key) {
-                  return multiset.count(key);
-                }
-              });
+      List<Integer> actualCounts = transform(keys, multiset::count);
       assertEquals("Counts not as expected", Ints.asList(deltas), actualCounts);
     } finally {
       pool.shutdownNow();
@@ -117,7 +108,7 @@ private MutateTask(ConcurrentHashMultiset<String> multiset, ImmutableList<String
     }
 
     @Override
-    public int[] call() throws Exception {
+    public int[] call() {
       int iterations = 100000;
       int nKeys = keys.size();
       int[] deltas = new int[nKeys];
diff --git a/guava-tests/test/com/google/common/collect/ConcurrentHashMultisetTest.java b/guava-tests/test/com/google/common/collect/ConcurrentHashMultisetTest.java
index fe00fc868560..636c4d84d623 100644
--- a/guava-tests/test/com/google/common/collect/ConcurrentHashMultisetTest.java
+++ b/guava-tests/test/com/google/common/collect/ConcurrentHashMultisetTest.java
@@ -18,7 +18,9 @@
 
 import static com.google.common.collect.MapMakerInternalMap.Strength.STRONG;
 import static com.google.common.collect.MapMakerInternalMap.Strength.WEAK;
+import static com.google.common.testing.SerializableTester.reserialize;
 import static com.google.common.testing.SerializableTester.reserializeAndAssert;
+import static com.google.common.truth.Truth.assertThat;
 import static java.util.Arrays.asList;
 import static org.junit.Assert.assertThrows;
 import static org.mockito.ArgumentMatchers.isA;
@@ -31,6 +33,7 @@
 import com.google.common.collect.testing.features.CollectionSize;
 import com.google.common.collect.testing.google.MultisetTestSuiteBuilder;
 import com.google.common.collect.testing.google.TestStringMultisetGenerator;
+import java.io.Serializable;
 import java.util.Collections;
 import java.util.Iterator;
 import java.util.List;
@@ -92,8 +95,7 @@ private static TestStringMultisetGenerator concurrentSkipListMultisetGenerator()
     return new TestStringMultisetGenerator() {
       @Override
       protected Multiset<String> create(String[] elements) {
-        Multiset<String> multiset =
-            new ConcurrentHashMultiset<>(new ConcurrentSkipListMap<String, AtomicInteger>());
+        Multiset<String> multiset = ConcurrentHashMultiset.create(new ConcurrentSkipListMap<>());
         Collections.addAll(multiset, elements);
         return multiset;
       }
@@ -116,7 +118,7 @@ protected void setUp() {
     backingMap = mock(ConcurrentMap.class);
     when(backingMap.isEmpty()).thenReturn(true);
 
-    multiset = new ConcurrentHashMultiset<>(backingMap);
+    multiset = ConcurrentHashMultiset.create(backingMap);
   }
 
   public void testCount_elementPresent() {
@@ -309,6 +311,54 @@ public void testSetCount_0_nonePresent() {
     assertEquals(0, multiset.setCount(KEY, 0));
   }
 
+  public void testSerialCycle() {
+    ConcurrentHashMultiset<ContainsMultiset> multiset = ConcurrentHashMultiset.create();
+    ContainsMultiset containsMultiset = new ContainsMultiset(multiset);
+    multiset.add(containsMultiset);
+    ContainsBothWithMultisetFirst multisetFirst =
+        new ContainsBothWithMultisetFirst(multiset, containsMultiset);
+    ContainsBothWithContainsMultisetFirst containsMultisetFirst =
+        new ContainsBothWithContainsMultisetFirst(containsMultiset, multiset);
+
+    ContainsBothWithMultisetFirst reMultisetFirst = reserialize(multisetFirst);
+    assertThat(reMultisetFirst.a.isEmpty()).isFalse();
+    // The following NPE is a side effect of our changes to avoid mutating `final` fields.
+    assertThrows(NullPointerException.class, () -> reMultisetFirst.z.multiset.isEmpty());
+
+    ContainsBothWithContainsMultisetFirst reContainsMultisetFirst =
+        reserialize(containsMultisetFirst);
+    assertThat(reContainsMultisetFirst.a.multiset.isEmpty()).isFalse();
+    assertThat(reContainsMultisetFirst.z.isEmpty()).isFalse();
+  }
+
+  private static final class ContainsMultiset implements Serializable {
+    private final ConcurrentHashMultiset<?> multiset;
+
+    ContainsMultiset(ConcurrentHashMultiset<?> multiset) {
+      this.multiset = multiset;
+    }
+  }
+
+  private static final class ContainsBothWithMultisetFirst implements Serializable {
+    private final ConcurrentHashMultiset<?> a;
+    private final ContainsMultiset z;
+
+    ContainsBothWithMultisetFirst(ConcurrentHashMultiset<?> a, ContainsMultiset z) {
+      this.a = a;
+      this.z = z;
+    }
+  }
+
+  private static final class ContainsBothWithContainsMultisetFirst implements Serializable {
+    private final ContainsMultiset a;
+    private final ConcurrentHashMultiset<?> z;
+
+    ContainsBothWithContainsMultisetFirst(ContainsMultiset a, ConcurrentHashMultiset<?> z) {
+      this.a = a;
+      this.z = z;
+    }
+  }
+
   public void testCreate() {
     ConcurrentHashMultiset<Integer> multiset = ConcurrentHashMultiset.create();
     assertTrue(multiset.isEmpty());
