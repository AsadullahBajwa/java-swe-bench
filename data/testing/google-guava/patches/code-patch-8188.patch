diff --git a/android/guava/src/com/google/common/util/concurrent/Uninterruptibles.java b/android/guava/src/com/google/common/util/concurrent/Uninterruptibles.java
index 14607b91b513..70d9d1826a79 100644
--- a/android/guava/src/com/google/common/util/concurrent/Uninterruptibles.java
+++ b/android/guava/src/com/google/common/util/concurrent/Uninterruptibles.java
@@ -47,10 +47,6 @@
  */
 @GwtCompatible
 public final class Uninterruptibles {
-
-  // Implementation Note: As of 3-7-11, the logic for each blocking/timeout
-  // methods is identical, save for method being invoked.
-
   /** Invokes {@code latch.}{@link CountDownLatch#await() await()} uninterruptibly. */
   @J2ktIncompatible
   @GwtIncompatible // concurrency
@@ -115,9 +111,18 @@ public static boolean awaitUninterruptibly(CountDownLatch latch, long timeout, T
   }
 
   /**
-   * Invokes {@code condition.}{@link Condition#await(long, TimeUnit) await(timeout, unit)}
-   * uninterruptibly.
+   * Invokes {@code condition.}{@link Condition#await(long, TimeUnit) await(timeout, unit)} in a way
+   * that more conveniently supports uninterruptible waits.
    *
+   * <p>If the underlying {@code await} call is interrupted, then {@code awaitUninterruptibly}
+   * converts that into a <a
+   * href="https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/locks/Condition.html#implementation-considerations-heading">spurious
+   * wakeup</a>. This means that resulting wait is not "uninterruptible" in the normal sense of
+   * {@link Uninterruptibles}. Still, this method allows callers to write <a
+   * href="https://errorprone.info/bugpattern/WaitNotInLoop">the standard, required loop for waiting on a {@code
+   * Condition}</a> but without the need to handle interruption.
+   *
+   * @return {@code false} if the waiting time detectably elapsed before return from the method
    * @since 33.4.0 (but since 28.0 in the JRE flavor)
    */
   @J2ktIncompatible
@@ -128,32 +133,58 @@ public static boolean awaitUninterruptibly(Condition condition, Duration timeout
   }
 
   /**
-   * Invokes {@code condition.}{@link Condition#await(long, TimeUnit) await(timeout, unit)}
-   * uninterruptibly.
+   * Invokes {@code condition.}{@link Condition#await(long, TimeUnit) await(timeout, unit)} in a way
+   * that more conveniently supports uninterruptible waits.
    *
+   * <p>If the underlying {@code await} call is interrupted, then {@code awaitUninterruptibly}
+   * converts that into a <a
+   * href="https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/locks/Condition.html#implementation-considerations-heading">spurious
+   * wakeup</a>. This means that resulting wait is not "uninterruptible" in the normal sense of
+   * {@link Uninterruptibles}. Still, this method allows callers to write <a
+   * href="https://errorprone.info/bugpattern/WaitNotInLoop">the standard, required loop for waiting on a {@code
+   * Condition}</a> but without the need to handle interruption.
+   *
+   * @return {@code false} if the waiting time detectably elapsed before return from the method
    * @since 23.6
    */
   @J2ktIncompatible
   @GwtIncompatible // concurrency
   @SuppressWarnings("GoodTime") // should accept a java.time.Duration
   public static boolean awaitUninterruptibly(Condition condition, long timeout, TimeUnit unit) {
-    boolean interrupted = false;
-    try {
-      long remainingNanos = unit.toNanos(timeout);
-      long end = System.nanoTime() + remainingNanos;
+    /*
+     * An uninterruptible wait on a Condition requires different logic than an uninterruptible wait
+     * on most other types: In cases in which we "should" receive both an interrupt and a
+     * notification nearly simultaneously, we sometimes receive only an interrupt. Thus, when we're
+     * interrupted, we can't just poll whether it's time to end the wait because our "end the wait"
+     * notification has been lost. (This is in contrast to how we can poll with, say, a
+     * CountDownLatch.) In order to avoid hiding the requested notification from the caller, we need
+     * to return. Fortunately, a wait on a Condition is allowed to return early on account of a
+     * "spurious wakeup," so we're allowed to convert interruptions into such wakeups.
+     */
+
+    /*
+     * Since we can't loop inside awaitUninterruptibly(Condition, ...), the user is responsible for
+     * calling us again in case of interrupt. Then, if we were to call await(...) immediately, as we
+     * do in the other Uninterruptibles methods, it would throw immediately. Then we'd restore the
+     * interrupt and return again, and the user would call us again, creating a busy wait.
+     *
+     * Thus, we need to clear the interrupt eagerly in case it's an interrupt from a previous call
+     * to awaitUninterruptibly in the user code's Condition loop.
+     */
+    boolean wasAlreadyInterrupted = Thread.interrupted();
+    long remainingNanos = unit.toNanos(timeout);
+    long end = System.nanoTime() + remainingNanos;
 
-      while (true) {
-        try {
-          return condition.await(remainingNanos, NANOSECONDS);
-        } catch (InterruptedException e) {
-          interrupted = true;
-          remainingNanos = end - System.nanoTime();
-        }
-      }
-    } finally {
-      if (interrupted) {
+    try {
+      boolean result = condition.await(remainingNanos, NANOSECONDS);
+      if (wasAlreadyInterrupted) {
         Thread.currentThread().interrupt();
       }
+      return result;
+    } catch (InterruptedException e) {
+      Thread.currentThread().interrupt();
+      // better than `end > System.nanoTime()` because `System.nanoTime()` could wrap around
+      return end - System.nanoTime() > 0;
     }
   }
 
diff --git a/guava/src/com/google/common/util/concurrent/Uninterruptibles.java b/guava/src/com/google/common/util/concurrent/Uninterruptibles.java
index 3ca308c288fe..162dc188f48c 100644
--- a/guava/src/com/google/common/util/concurrent/Uninterruptibles.java
+++ b/guava/src/com/google/common/util/concurrent/Uninterruptibles.java
@@ -47,10 +47,6 @@
  */
 @GwtCompatible
 public final class Uninterruptibles {
-
-  // Implementation Note: As of 3-7-11, the logic for each blocking/timeout
-  // methods is identical, save for method being invoked.
-
   /** Invokes {@code latch.}{@link CountDownLatch#await() await()} uninterruptibly. */
   @J2ktIncompatible
   @GwtIncompatible // concurrency
@@ -114,9 +110,18 @@ public static boolean awaitUninterruptibly(CountDownLatch latch, long timeout, T
   }
 
   /**
-   * Invokes {@code condition.}{@link Condition#await(long, TimeUnit) await(timeout, unit)}
-   * uninterruptibly.
+   * Invokes {@code condition.}{@link Condition#await(long, TimeUnit) await(timeout, unit)} in a way
+   * that more conveniently supports uninterruptible waits.
    *
+   * <p>If the underlying {@code await} call is interrupted, then {@code awaitUninterruptibly}
+   * converts that into a <a
+   * href="https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/locks/Condition.html#implementation-considerations-heading">spurious
+   * wakeup</a>. This means that resulting wait is not "uninterruptible" in the normal sense of
+   * {@link Uninterruptibles}. Still, this method allows callers to write <a
+   * href="https://errorprone.info/bugpattern/WaitNotInLoop">the standard, required loop for waiting on a {@code
+   * Condition}</a> but without the need to handle interruption.
+   *
+   * @return {@code false} if the waiting time detectably elapsed before return from the method
    * @since 28.0 (but only since 33.4.0 in the Android flavor)
    */
   @J2ktIncompatible
@@ -126,32 +131,58 @@ public static boolean awaitUninterruptibly(Condition condition, Duration timeout
   }
 
   /**
-   * Invokes {@code condition.}{@link Condition#await(long, TimeUnit) await(timeout, unit)}
-   * uninterruptibly.
+   * Invokes {@code condition.}{@link Condition#await(long, TimeUnit) await(timeout, unit)} in a way
+   * that more conveniently supports uninterruptible waits.
    *
+   * <p>If the underlying {@code await} call is interrupted, then {@code awaitUninterruptibly}
+   * converts that into a <a
+   * href="https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/locks/Condition.html#implementation-considerations-heading">spurious
+   * wakeup</a>. This means that resulting wait is not "uninterruptible" in the normal sense of
+   * {@link Uninterruptibles}. Still, this method allows callers to write <a
+   * href="https://errorprone.info/bugpattern/WaitNotInLoop">the standard, required loop for waiting on a {@code
+   * Condition}</a> but without the need to handle interruption.
+   *
+   * @return {@code false} if the waiting time detectably elapsed before return from the method
    * @since 23.6
    */
   @J2ktIncompatible
   @GwtIncompatible // concurrency
   @SuppressWarnings("GoodTime") // should accept a java.time.Duration
   public static boolean awaitUninterruptibly(Condition condition, long timeout, TimeUnit unit) {
-    boolean interrupted = false;
-    try {
-      long remainingNanos = unit.toNanos(timeout);
-      long end = System.nanoTime() + remainingNanos;
+    /*
+     * An uninterruptible wait on a Condition requires different logic than an uninterruptible wait
+     * on most other types: In cases in which we "should" receive both an interrupt and a
+     * notification nearly simultaneously, we sometimes receive only an interrupt. Thus, when we're
+     * interrupted, we can't just poll whether it's time to end the wait because our "end the wait"
+     * notification has been lost. (This is in contrast to how we can poll with, say, a
+     * CountDownLatch.) In order to avoid hiding the requested notification from the caller, we need
+     * to return. Fortunately, a wait on a Condition is allowed to return early on account of a
+     * "spurious wakeup," so we're allowed to convert interruptions into such wakeups.
+     */
+
+    /*
+     * Since we can't loop inside awaitUninterruptibly(Condition, ...), the user is responsible for
+     * calling us again in case of interrupt. Then, if we were to call await(...) immediately, as we
+     * do in the other Uninterruptibles methods, it would throw immediately. Then we'd restore the
+     * interrupt and return again, and the user would call us again, creating a busy wait.
+     *
+     * Thus, we need to clear the interrupt eagerly in case it's an interrupt from a previous call
+     * to awaitUninterruptibly in the user code's Condition loop.
+     */
+    boolean wasAlreadyInterrupted = Thread.interrupted();
+    long remainingNanos = unit.toNanos(timeout);
+    long end = System.nanoTime() + remainingNanos;
 
-      while (true) {
-        try {
-          return condition.await(remainingNanos, NANOSECONDS);
-        } catch (InterruptedException e) {
-          interrupted = true;
-          remainingNanos = end - System.nanoTime();
-        }
-      }
-    } finally {
-      if (interrupted) {
+    try {
+      boolean result = condition.await(remainingNanos, NANOSECONDS);
+      if (wasAlreadyInterrupted) {
         Thread.currentThread().interrupt();
       }
+      return result;
+    } catch (InterruptedException e) {
+      Thread.currentThread().interrupt();
+      // better than `end > System.nanoTime()` because `System.nanoTime()` could wrap around
+      return end - System.nanoTime() > 0;
     }
   }
 
