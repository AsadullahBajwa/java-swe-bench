[ {
  "instance_id" : "FasterXML-jackson-core-PR-1523",
  "repo" : "FasterXML/jackson-core",
  "base_commit" : "5f4e7046dbf4f75dfa96b0608ca6c2fc5ed8eff8",
  "patch" : "diff --git a/.github/workflows/main.yml b/.github/workflows/main.yml\nindex 79a034b491..c04a0982b9 100644\n--- a/.github/workflows/main.yml\n+++ b/.github/workflows/main.yml\n@@ -72,6 +72,22 @@ jobs:\n         token: ${{ secrets.CODECOV_TOKEN }}\n         files: ./target/site/jacoco/jacoco.xml\n         flags: unittests\n+    - name: Upload coverage report as artifact\n+      if: ${{ matrix.release_build && github.event_name != 'pull_request' }}\n+      uses: actions/upload-artifact@v4\n+      with:\n+        name: jacoco-report\n+        path: target/site/jacoco/jacoco.csv\n+        retention-days: 30\n+    - name: Download base branch coverage\n+      if: ${{ matrix.release_build && github.event_name == 'pull_request' }}\n+      uses: dawidd6/action-download-artifact@v6\n+      continue-on-error: true\n+      with:\n+        workflow: main.yml\n+        branch: ${{ github.event.pull_request.base.ref }}\n+        name: jacoco-report\n+        path: base-coverage/\n     - name: Add coverage delta report to PR\n       if: ${{ matrix.release_build && github.event_name == 'pull_request' }}\n       uses: madrapps/jacoco-report@v1.7.1\n@@ -98,6 +114,51 @@ jobs:\n         COVERAGE=$(awk -v cov=\"${{ steps.jacoco.outputs.coverage }}\" 'BEGIN { printf \"%.1f\", cov * 100 }')\n         BRANCHES=$(awk -v br=\"${{ steps.jacoco.outputs.branches }}\" 'BEGIN { printf \"%.1f\", br * 100 }')\n \n+        # Check if base coverage artifact was downloaded\n+        if [ -f \"base-coverage/jacoco.csv\" ]; then\n+          echo \"Found base branch coverage from artifact\"\n+          BASE_CSV=\"base-coverage/jacoco.csv\"\n+\n+          # Parse base branch coverage\n+          BASE_COVERAGE=$(awk -F',' 'NR>1 && $1==\"Jackson-core\" {\n+            missed=$4; covered=$5;\n+            if (missed + covered > 0) printf \"%.1f\", (covered * 100.0) / (missed + covered)\n+          }' \"$BASE_CSV\" | head -1)\n+          BASE_BRANCHES=$(awk -F',' 'NR>1 && $1==\"Jackson-core\" {\n+            missed=$6; covered=$7;\n+            if (missed + covered > 0) printf \"%.1f\", (covered * 100.0) / (missed + covered)\n+          }' \"$BASE_CSV\" | head -1)\n+\n+          if [ -n \"$BASE_COVERAGE\" ] && [ -n \"$BASE_BRANCHES\" ]; then\n+            # Calculate deltas\n+            COV_DELTA=$(awk -v curr=\"$COVERAGE\" -v base=\"$BASE_COVERAGE\" 'BEGIN { printf \"%.1f\", curr - base }')\n+            BR_DELTA=$(awk -v curr=\"$BRANCHES\" -v base=\"$BASE_BRANCHES\" 'BEGIN { printf \"%.1f\", curr - base }')\n+\n+            # Format delta strings with + or - signs\n+            if awk -v delta=\"$COV_DELTA\" 'BEGIN { exit (delta >= 0) ? 0 : 1 }'; then\n+              COV_DELTA_STR=\"+${COV_DELTA}%\"\n+              COV_DELTA_EMOJI=\"\uD83D\uDCC8\"\n+            else\n+              COV_DELTA_STR=\"${COV_DELTA}%\"\n+              COV_DELTA_EMOJI=\"\uD83D\uDCC9\"\n+            fi\n+\n+            if awk -v delta=\"$BR_DELTA\" 'BEGIN { exit (delta >= 0) ? 0 : 1 }'; then\n+              BR_DELTA_STR=\"+${BR_DELTA}%\"\n+              BR_DELTA_EMOJI=\"\uD83D\uDCC8\"\n+            else\n+              BR_DELTA_STR=\"${BR_DELTA}%\"\n+              BR_DELTA_EMOJI=\"\uD83D\uDCC9\"\n+            fi\n+\n+            HAS_DELTA=true\n+          else\n+            HAS_DELTA=false\n+          fi\n+        else\n+          HAS_DELTA=false\n+        fi\n+\n         # Determine color for coverage badge using awk (more portable than bc)\n         COV_COLOR=$(awk -v cov=\"$COVERAGE\" 'BEGIN {\n           if (cov >= 80) print \"brightgreen\"\n@@ -113,12 +174,22 @@ jobs:\n           else print \"red\"\n         }')\n \n-        COMMENT_BODY=\"## :chart_with_upwards_trend: Overall Code Coverage\n-\n-        | Metric | Coverage |\n+        # Build coverage table with or without deltas\n+        if [ \"$HAS_DELTA\" = \"true\" ]; then\n+          COVERAGE_TABLE=\"| Metric | Coverage | Change |\n+        |--------|----------|--------|\n+        | **Instructions** | ![coverage](https://img.shields.io/badge/coverage-${COVERAGE}%25-${COV_COLOR}) **${COVERAGE}%** | ${COV_DELTA_EMOJI} **${COV_DELTA_STR}** |\n+        | **Branches** | ![branches](https://img.shields.io/badge/branches-${BRANCHES}%25-${BR_COLOR}) **${BRANCHES}%** | ${BR_DELTA_EMOJI} **${BR_DELTA_STR}** |\"\n+        else\n+          COVERAGE_TABLE=\"| Metric | Coverage |\n         |--------|----------|\n         | **Instructions** | ![coverage](https://img.shields.io/badge/coverage-${COVERAGE}%25-${COV_COLOR}) **${COVERAGE}%** |\n-        | **Branches** | ![branches](https://img.shields.io/badge/branches-${BRANCHES}%25-${BR_COLOR}) **${BRANCHES}%** |\n+        | **Branches** | ![branches](https://img.shields.io/badge/branches-${BRANCHES}%25-${BR_COLOR}) **${BRANCHES}%** |\"\n+        fi\n+\n+        COMMENT_BODY=\"## :chart_with_upwards_trend: Overall Code Coverage\n+\n+        $COVERAGE_TABLE\n \n         > Overall project coverage from JaCoCo test results\n \n",
  "test_patch" : "diff --git a/src/test/java/tools/jackson/core/unittest/io/NumberInputTest.java b/src/test/java/tools/jackson/core/unittest/io/NumberInputTest.java\nindex 872890197b..18e6839b5d 100644\n--- a/src/test/java/tools/jackson/core/unittest/io/NumberInputTest.java\n+++ b/src/test/java/tools/jackson/core/unittest/io/NumberInputTest.java\n@@ -143,4 +143,167 @@ void looksLikeValidNumberFalse()\n         assertFalse(NumberInput.looksLikeValidNumber(\"-E\"));\n         assertFalse(NumberInput.looksLikeValidNumber(\"+E\"));\n     }\n+\n+    @Test\n+    void parseIntFromCharArray()\n+    {\n+        // Test parsing integers from char arrays with various lengths\n+        // Single digit\n+        char[] ch1 = \"5\".toCharArray();\n+        assertEquals(5, NumberInput.parseInt(ch1, 0, 1));\n+\n+        // Two digits\n+        char[] ch2 = \"42\".toCharArray();\n+        assertEquals(42, NumberInput.parseInt(ch2, 0, 2));\n+\n+        // Three digits\n+        char[] ch3 = \"123\".toCharArray();\n+        assertEquals(123, NumberInput.parseInt(ch3, 0, 3));\n+\n+        // Four digits\n+        char[] ch4 = \"1234\".toCharArray();\n+        assertEquals(1234, NumberInput.parseInt(ch4, 0, 4));\n+\n+        // Five digits\n+        char[] ch5 = \"12345\".toCharArray();\n+        assertEquals(12345, NumberInput.parseInt(ch5, 0, 5));\n+\n+        // Six digits\n+        char[] ch6 = \"123456\".toCharArray();\n+        assertEquals(123456, NumberInput.parseInt(ch6, 0, 6));\n+\n+        // Seven digits\n+        char[] ch7 = \"1234567\".toCharArray();\n+        assertEquals(1234567, NumberInput.parseInt(ch7, 0, 7));\n+\n+        // Eight digits\n+        char[] ch8 = \"12345678\".toCharArray();\n+        assertEquals(12345678, NumberInput.parseInt(ch8, 0, 8));\n+\n+        // Nine digits (max for fast path)\n+        char[] ch9 = \"123456789\".toCharArray();\n+        assertEquals(123456789, NumberInput.parseInt(ch9, 0, 9));\n+\n+        // Test with offset\n+        char[] chOffset = \"abc123def\".toCharArray();\n+        assertEquals(123, NumberInput.parseInt(chOffset, 3, 3));\n+\n+        // Test with leading plus sign\n+        char[] chPlus = \"+42\".toCharArray();\n+        assertEquals(42, NumberInput.parseInt(chPlus, 0, 3));\n+    }\n+\n+    @Test\n+    void parseIntFromString()\n+    {\n+        // Positive numbers\n+        assertEquals(0, NumberInput.parseInt(\"0\"));\n+        assertEquals(5, NumberInput.parseInt(\"5\"));\n+        assertEquals(42, NumberInput.parseInt(\"42\"));\n+        assertEquals(123, NumberInput.parseInt(\"123\"));\n+        assertEquals(999999999, NumberInput.parseInt(\"999999999\"));\n+\n+        // Negative numbers\n+        assertEquals(-1, NumberInput.parseInt(\"-1\"));\n+        assertEquals(-42, NumberInput.parseInt(\"-42\"));\n+        assertEquals(-123, NumberInput.parseInt(\"-123\"));\n+        assertEquals(-999999999, NumberInput.parseInt(\"-999999999\"));\n+\n+        // Boundary values\n+        assertEquals(Integer.MAX_VALUE, NumberInput.parseInt(String.valueOf(Integer.MAX_VALUE)));\n+        assertEquals(Integer.MIN_VALUE, NumberInput.parseInt(String.valueOf(Integer.MIN_VALUE)));\n+    }\n+\n+    @Test\n+    void parseLongFromCharArray()\n+    {\n+        // Test 10 digit number\n+        char[] ch10 = \"1234567890\".toCharArray();\n+        assertEquals(1234567890L, NumberInput.parseLong(ch10, 0, 10));\n+\n+        // Test 15 digit number\n+        char[] ch15 = \"123456789012345\".toCharArray();\n+        assertEquals(123456789012345L, NumberInput.parseLong(ch15, 0, 15));\n+\n+        // Test 18 digit number\n+        char[] ch18 = \"123456789012345678\".toCharArray();\n+        assertEquals(123456789012345678L, NumberInput.parseLong(ch18, 0, 18));\n+    }\n+\n+    @Test\n+    void parseLong19Digits()\n+    {\n+        // Test parsing exactly 19 digit numbers\n+        char[] ch19 = \"1234567890123456789\".toCharArray();\n+        assertEquals(1234567890123456789L, NumberInput.parseLong19(ch19, 0, false));\n+        assertEquals(-1234567890123456789L, NumberInput.parseLong19(ch19, 0, true));\n+\n+        // Test with offset\n+        char[] chOffset = \"xxx9223372036854775807\".toCharArray();\n+        assertEquals(9223372036854775807L, NumberInput.parseLong19(chOffset, 3, false));\n+    }\n+\n+    @Test\n+    void parseLongFromString()\n+    {\n+        // Short values (delegates to parseInt)\n+        assertEquals(0L, NumberInput.parseLong(\"0\"));\n+        assertEquals(123L, NumberInput.parseLong(\"123\"));\n+        assertEquals(-456L, NumberInput.parseLong(\"-456\"));\n+\n+        // Long values\n+        assertEquals(12345678901L, NumberInput.parseLong(\"12345678901\"));\n+        assertEquals(-12345678901L, NumberInput.parseLong(\"-12345678901\"));\n+\n+        // Boundary values\n+        assertEquals(Long.MAX_VALUE, NumberInput.parseLong(String.valueOf(Long.MAX_VALUE)));\n+        assertEquals(Long.MIN_VALUE, NumberInput.parseLong(String.valueOf(Long.MIN_VALUE)));\n+    }\n+\n+    @Test\n+    void inLongRangeFromCharArray()\n+    {\n+        // Values clearly in range\n+        char[] small = \"12345\".toCharArray();\n+        assertTrue(NumberInput.inLongRange(small, 0, 5, false));\n+        assertTrue(NumberInput.inLongRange(small, 0, 5, true));\n+\n+        // Boundary testing - Long.MAX_VALUE = 9223372036854775807 (19 digits)\n+        char[] maxLong = \"9223372036854775807\".toCharArray();\n+        assertTrue(NumberInput.inLongRange(maxLong, 0, 19, false));\n+\n+        // Just above Long.MAX_VALUE\n+        char[] aboveMax = \"9223372036854775808\".toCharArray();\n+        assertFalse(NumberInput.inLongRange(aboveMax, 0, 19, false));\n+\n+        // Long.MIN_VALUE = -9223372036854775808 (19 digits without sign)\n+        char[] minLong = \"9223372036854775808\".toCharArray();\n+        assertTrue(NumberInput.inLongRange(minLong, 0, 19, true));\n+\n+        // Just above Long.MIN_VALUE magnitude\n+        char[] aboveMin = \"9223372036854775809\".toCharArray();\n+        assertFalse(NumberInput.inLongRange(aboveMin, 0, 19, true));\n+\n+        // 20 digits - always too large\n+        char[] tooLong = \"12345678901234567890\".toCharArray();\n+        assertFalse(NumberInput.inLongRange(tooLong, 0, 20, false));\n+    }\n+\n+    @Test\n+    void inLongRangeFromString()\n+    {\n+        // Values clearly in range\n+        assertTrue(NumberInput.inLongRange(\"12345\", false));\n+        assertTrue(NumberInput.inLongRange(\"12345\", true));\n+\n+        // Boundary testing\n+        assertTrue(NumberInput.inLongRange(\"9223372036854775807\", false));\n+        assertFalse(NumberInput.inLongRange(\"9223372036854775808\", false));\n+\n+        assertTrue(NumberInput.inLongRange(\"9223372036854775808\", true));\n+        assertFalse(NumberInput.inLongRange(\"9223372036854775809\", true));\n+\n+        // Too many digits\n+        assertFalse(NumberInput.inLongRange(\"12345678901234567890\", false));\n+    }\n }\n",
  "problem_statement" : "Add test coverage slightly, fix Code Coverage delta calc, upload\n\nAdds some test coverage, but more importantly, improves upon: https://github.com/FasterXML/jackson-core/pull/1522 (unit test code coverage)",
  "hints_text" : null,
  "created_at" : "Thu Dec 11 20:22:47 CET 2025",
  "version" : null,
  "FAIL_TO_PASS" : [ "NumberInputTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=NumberInputTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 1523,
  "metadata" : null
}, {
  "instance_id" : "FasterXML-jackson-core-PR-1520",
  "repo" : "FasterXML/jackson-core",
  "base_commit" : "74bc600bdf336d219d411a79a2839617b73beeef",
  "patch" : "diff --git a/release-notes/VERSION b/release-notes/VERSION\nindex 59da1c3f89..8ef2842504 100644\n--- a/release-notes/VERSION\n+++ b/release-notes/VERSION\n@@ -19,6 +19,12 @@ JSON library.\n \n -\n \n+3.0.4 (not yet released)\n+\n+#1516: `UTF8StreamJsonParser` sometimes may cause `ArrayIndexOutOfBoundsException`\n+ (reported by @haihai514)\n+ (fix by @cowtowncoder, w/ Claude code)\n+\n 3.0.3 (28-Nov-2025)\n \n #1418: `TokenFilter#includeEmptyArray()` causes an error in some cases where\ndiff --git a/src/main/java/tools/jackson/core/json/UTF8StreamJsonParser.java b/src/main/java/tools/jackson/core/json/UTF8StreamJsonParser.java\nindex 0c4073a20c..967c746e98 100644\n--- a/src/main/java/tools/jackson/core/json/UTF8StreamJsonParser.java\n+++ b/src/main/java/tools/jackson/core/json/UTF8StreamJsonParser.java\n@@ -1568,6 +1568,10 @@ protected final int _matchLongName(PropertyNameMatcher matcher, int qptr,\n         int qlen = 3;\n \n         while ((qptr + 4) <= _inputEnd) {\n+            // [core#1516]: Need to check buffer space BEFORE any writes in this iteration\n+            if (qlen >= _quadBuffer.length) {\n+                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n+            }\n             int i = input[qptr++] & 0xFF;\n             if (codes[i] != 0) {\n                 if (i != INT_QUOTE) {\n@@ -1611,10 +1615,7 @@ protected final int _matchLongName(PropertyNameMatcher matcher, int qptr,\n                 _quadPtr = qptr;\n                 return matcher.matchByQuad(_quadBuffer, qlen);\n             }\n-            // Nope, no end in sight. Need to grow quad array etc\n-            if (qlen >= _quadBuffer.length) {\n-                _quadBuffer = growArrayBy(_quadBuffer, qlen);\n-            }\n+            // Nope, no end in sight.\n             _quadBuffer[qlen++] = q;\n             q = i;\n         }\n",
  "test_patch" : "diff --git a/src/test/java/tools/jackson/core/unittest/read/LongName1516Test.java b/src/test/java/tools/jackson/core/unittest/read/LongName1516Test.java\nnew file mode 100644\nindex 0000000000..211ea297cd\n--- /dev/null\n+++ b/src/test/java/tools/jackson/core/unittest/read/LongName1516Test.java\n@@ -0,0 +1,289 @@\n+package tools.jackson.core.unittest.read;\n+\n+import java.util.List;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import tools.jackson.core.JsonParser;\n+import tools.jackson.core.JsonToken;\n+import tools.jackson.core.json.JsonFactory;\n+import tools.jackson.core.sym.PropertyNameMatcher;\n+import tools.jackson.core.unittest.*;\n+import tools.jackson.core.util.Named;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+/**\n+ * Reproduction test for:\n+ * <a href=\"https://github.com/FasterXML/jackson-core/issues/1516\">Issue #1516</a>\n+ * <p>\n+ * Buffer overflow bug in {@code UTF8StreamJsonParser._matchLongName()} that causes\n+ * {@code ArrayIndexOutOfBoundsException} when parsing JSON with long names\n+ * (longer than 64 characters).\n+ */\n+public class LongName1516Test\n+    extends JacksonCoreTestBase\n+{\n+    /**\n+     * Test for the exact case mentioned in issue #1516:\n+     * A 65-character name should not cause ArrayIndexOutOfBoundsException\n+     */\n+    @Test\n+    void longName65Characters() throws Exception\n+    {\n+        _testLongName65Characters(MODE_READER);\n+        _testLongName65Characters(MODE_INPUT_STREAM);\n+        _testLongName65Characters(MODE_INPUT_STREAM_THROTTLED);\n+        _testLongName65Characters(MODE_DATA_INPUT);\n+    }\n+\n+    private void _testLongName65Characters(int mode) throws Exception\n+    {\n+        // 65 character name as mentioned in the issue\n+        String longName = \"01234567890123456789012345678901234567890123456789012345678901234\";\n+        assertEquals(65, longName.length(), \"Name should be exactly 65 characters\");\n+\n+        String json = \"{\\\"a\\\": \\\"123\\\", \\\"\" + longName + \"\\\": \\\"value\\\"}\";\n+\n+        try (JsonParser p = createParser(mode, json)) {\n+            assertToken(JsonToken.START_OBJECT, p.nextToken());\n+    \n+            // First property\n+            assertToken(JsonToken.PROPERTY_NAME, p.nextToken());\n+            assertEquals(\"a\", p.currentName());\n+            assertToken(JsonToken.VALUE_STRING, p.nextToken());\n+            assertEquals(\"123\", p.getString());\n+    \n+            // Second property with long name - this triggers the bug in 1516\n+            assertToken(JsonToken.PROPERTY_NAME, p.nextToken());\n+            assertEquals(longName, p.currentName());\n+            assertToken(JsonToken.VALUE_STRING, p.nextToken());\n+            assertEquals(\"value\", p.getString());\n+    \n+            assertToken(JsonToken.END_OBJECT, p.nextToken());\n+        }\n+    }\n+\n+    /**\n+     * Test various long name lengths to verify buffer expansion works correctly\n+     */\n+    @Test\n+    void longNamesVariousLengths() throws Exception\n+    {\n+        _testLongNamesVariousLengths(MODE_READER);\n+        _testLongNamesVariousLengths(MODE_INPUT_STREAM);\n+        _testLongNamesVariousLengths(MODE_INPUT_STREAM_THROTTLED);\n+        _testLongNamesVariousLengths(MODE_DATA_INPUT);\n+    }\n+\n+    private void _testLongNamesVariousLengths(int mode) throws Exception\n+    {\n+        // Test names of various lengths that could trigger buffer boundary issues\n+        int[] lengths = { 60, 64, 65, 70, 80, 100, 128, 200 };\n+\n+        for (int len : lengths) {\n+            StringBuilder nameB = new StringBuilder(len);\n+            for (int i = 0; i < len; i++) {\n+                nameB.append((char)('0' + (i % 10)));\n+            }\n+\n+            String name = nameB.toString();\n+            String json = \"{\\\"\" + name + \"\\\": 42}\";\n+\n+            try (JsonParser p = createParser(mode, json)) {\n+                assertToken(JsonToken.START_OBJECT, p.nextToken());\n+                assertToken(JsonToken.PROPERTY_NAME, p.nextToken());\n+                assertEquals(name, p.currentName(),\n+                    \"Failed for name length: \" + len);\n+                assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());\n+                assertEquals(42, p.getIntValue());\n+                assertToken(JsonToken.END_OBJECT, p.nextToken());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Test multiple long names in the same document\n+     */\n+    @Test\n+    void multipleLongNames() throws Exception\n+    {\n+        _testMultipleLongNames(MODE_READER);\n+        _testMultipleLongNames(MODE_INPUT_STREAM);\n+        _testMultipleLongNames(MODE_INPUT_STREAM_THROTTLED);\n+        _testMultipleLongNames(MODE_DATA_INPUT);\n+    }\n+\n+    private void _testMultipleLongNames(int mode) throws Exception\n+    {\n+        // Create multiple 65+ character names\n+        String name1 = \"field1_\" + \"x\".repeat(65);\n+        String name2 = \"field2_\" + \"y\".repeat(70);\n+        String name3 = \"field3_\" + \"z\".repeat(80);\n+\n+        String json = \"{\\\"\" + name1 + \"\\\": 1, \\\"\" + name2 + \"\\\": 2, \\\"\" + name3 + \"\\\": 3}\";\n+\n+        JsonParser p = createParser(mode, json);\n+\n+        assertToken(JsonToken.START_OBJECT, p.nextToken());\n+\n+        assertToken(JsonToken.PROPERTY_NAME, p.nextToken());\n+        assertEquals(name1, p.currentName());\n+        assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());\n+        assertEquals(1, p.getIntValue());\n+\n+        assertToken(JsonToken.PROPERTY_NAME, p.nextToken());\n+        assertEquals(name2, p.currentName());\n+        assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());\n+        assertEquals(2, p.getIntValue());\n+\n+        assertToken(JsonToken.PROPERTY_NAME, p.nextToken());\n+        assertEquals(name3, p.currentName());\n+        assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());\n+        assertEquals(3, p.getIntValue());\n+\n+        assertToken(JsonToken.END_OBJECT, p.nextToken());\n+        p.close();\n+    }\n+\n+    /**\n+     * Test long names with UTF-8 multi-byte characters\n+     */\n+    @Test\n+    void longNamesWithUTF8() throws Exception\n+    {\n+        _testLongNamesWithUTF8(MODE_READER);\n+        _testLongNamesWithUTF8(MODE_INPUT_STREAM);\n+        _testLongNamesWithUTF8(MODE_INPUT_STREAM_THROTTLED);\n+        _testLongNamesWithUTF8(MODE_DATA_INPUT);\n+    }\n+\n+    private void _testLongNamesWithUTF8(int mode) throws Exception\n+    {\n+        // 65+ character name with UTF-8 characters\n+        String name = \"field_\\u00E9\\u00F1\\u00FC_\" + \"a\".repeat(60);\n+        assertTrue(name.length() >= 65, \"Name should be at least 65 characters\");\n+\n+        String json = \"{\\\"\" + name + \"\\\": \\\"test\\\"}\";\n+\n+        // Convert to UTF-8 bytes\n+        byte[] jsonBytes = utf8Bytes(json);\n+\n+        try (JsonParser p = createParser(mode, jsonBytes)) {\n+            assertToken(JsonToken.START_OBJECT, p.nextToken());\n+            assertToken(JsonToken.PROPERTY_NAME, p.nextToken());\n+            assertEquals(name, p.currentName());\n+            assertToken(JsonToken.VALUE_STRING, p.nextToken());\n+            assertEquals(\"test\", p.getString());\n+            assertToken(JsonToken.END_OBJECT, p.nextToken());\n+        }\n+    }\n+\n+    /**\n+     * Test using PropertyNameMatcher with long names (65 characters)\n+     * This is the code path that triggers the bug in _matchLongName()\n+     */\n+    @Test\n+    void longNameWithMatcher65Chars() throws Exception\n+    {\n+        _testLongNameWithMatcher65Chars(MODE_READER);\n+        _testLongNameWithMatcher65Chars(MODE_INPUT_STREAM);\n+        _testLongNameWithMatcher65Chars(MODE_INPUT_STREAM_THROTTLED);\n+        _testLongNameWithMatcher65Chars(MODE_DATA_INPUT);\n+    }\n+\n+    private void _testLongNameWithMatcher65Chars(int mode) throws Exception\n+    {\n+        JsonFactory f = newStreamFactory();\n+\n+        // 65 character name as mentioned in the issue\n+        String longName = \"01234567890123456789012345678901234567890123456789012345678901234\";\n+        assertEquals(65, longName.length(), \"Name should be exactly 65 characters\");\n+\n+        String json = \"{\\\"a\\\": \\\"123\\\", \\\"\" + longName + \"\\\": \\\"value\\\"}\";\n+\n+        // Create matcher with both names\n+        PropertyNameMatcher matcher = f.constructNameMatcher(\n+            List.of(Named.fromString(\"a\"), Named.fromString(longName)),\n+            false);\n+\n+        try (JsonParser p = createParser(f, mode, json)) {\n+            assertToken(JsonToken.START_OBJECT, p.nextToken());\n+    \n+            assertEquals(0, p.nextNameMatch(matcher));\n+            assertToken(JsonToken.PROPERTY_NAME, p.currentToken());\n+            assertEquals(\"a\", p.currentName());\n+            assertToken(JsonToken.VALUE_STRING, p.nextToken());\n+            assertEquals(\"123\", p.getString());\n+    \n+            // Second property with long name - this should trigger the bug in _matchLongName()\n+            assertEquals(1, p.nextNameMatch(matcher));\n+            assertToken(JsonToken.PROPERTY_NAME, p.currentToken());\n+            assertEquals(longName, p.currentName());\n+            assertToken(JsonToken.VALUE_STRING, p.nextToken());\n+            assertEquals(\"value\", p.getString());\n+    \n+            assertToken(JsonToken.END_OBJECT, p.nextToken());\n+        }\n+    }\n+\n+    /**\n+     * Test using PropertyNameMatcher with multiple long names of various lengths\n+     */\n+    @Test\n+    void multipleNamesWithMatcher() throws Exception\n+    {\n+        _testMultipleNamesWithMatcher(MODE_READER);\n+        _testMultipleNamesWithMatcher(MODE_INPUT_STREAM);\n+        _testMultipleNamesWithMatcher(MODE_INPUT_STREAM_THROTTLED);\n+        _testMultipleNamesWithMatcher(MODE_DATA_INPUT);\n+    }\n+\n+    private void _testMultipleNamesWithMatcher(int mode) throws Exception\n+    {\n+        JsonFactory f = newStreamFactory();\n+\n+        // Names of different lengths, including 65+ characters\n+        String field1 = \"shortField\";\n+        String field2 = \"field64chars_\" + \"x\".repeat(52); // 64 chars\n+        String field3 = \"field65chars_\" + \"y\".repeat(52); // 65 chars\n+        String field4 = \"field80chars_\" + \"z\".repeat(67); // 80 chars\n+\n+        String json = \"{\\\"\" + field1 + \"\\\": 1, \\\"\" + field2 + \"\\\": 2, \\\"\"\n+                     + field3 + \"\\\": 3, \\\"\" + field4 + \"\\\": 4}\";\n+\n+        PropertyNameMatcher matcher = f.constructNameMatcher(\n+            List.of(Named.fromString(field1), Named.fromString(field2),\n+                   Named.fromString(field3), Named.fromString(field4)),\n+            false);\n+\n+        try (JsonParser p = createParser(f, mode, json)) {\n+            assertToken(JsonToken.START_OBJECT, p.nextToken());\n+    \n+            assertEquals(0, p.nextNameMatch(matcher));\n+            assertEquals(field1, p.currentName());\n+            assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());\n+            assertEquals(1, p.getIntValue());\n+    \n+            // Name 2 (64 chars)\n+            assertEquals(1, p.nextNameMatch(matcher));\n+            assertEquals(field2, p.currentName());\n+            assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());\n+            assertEquals(2, p.getIntValue());\n+    \n+            // Name 3 (65 chars) - triggers buffer boundary\n+            assertEquals(2, p.nextNameMatch(matcher));\n+            assertEquals(field3, p.currentName());\n+            assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());\n+            assertEquals(3, p.getIntValue());\n+    \n+            // Name 4 (80 chars) - should also work\n+            assertEquals(3, p.nextNameMatch(matcher));\n+            assertEquals(field4, p.currentName());\n+            assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());\n+            assertEquals(4, p.getIntValue());\n+    \n+            assertToken(JsonToken.END_OBJECT, p.nextToken());\n+        }\n+    }\n+}\n",
  "problem_statement" : "Fix #1519: ArrayIndexOutOfBoundsException for UTF8StreamJsonParser\n\nSecond PR with right target branch.",
  "hints_text" : null,
  "created_at" : "Thu Dec 11 19:07:03 CET 2025",
  "version" : null,
  "FAIL_TO_PASS" : [ "LongName1516Test" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=LongName1516Test",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 1520,
  "metadata" : null
}, {
  "instance_id" : "FasterXML-jackson-core-PR-1509",
  "repo" : "FasterXML/jackson-core",
  "base_commit" : "20e09976fb1a28ce2b46eb2ff890001bb7178a1a",
  "patch" : "diff --git a/release-notes/VERSION-2.x b/release-notes/VERSION-2.x\nindex 950b7b209d..152b6c3a7c 100644\n--- a/release-notes/VERSION-2.x\n+++ b/release-notes/VERSION-2.x\n@@ -23,6 +23,9 @@ a pure JSON library.\n  (fix by @cowtowncoder, w/ Claude code)\n #1180: `JsonLocation` off for unrecognized tokens\n (fix by @cowtowncoder, w/ Claude code)\n+#1418: `TokenFilter#includeEmptyArray()` causes an error in some cases where an object element is filtered\n+ (reported by @21Joakim)\n+ (fix by @cowtowncoder, w/ Claude code)\n #1470: Add method `copyCurrentStructureExact()` to `JsonGenerator`\n  (contributed by Lars H)\n #1477: Add `JsonGenerator.has(StreamWriteCapability)` convenience method\ndiff --git a/src/main/java/com/fasterxml/jackson/core/filter/FilteringParserDelegate.java b/src/main/java/com/fasterxml/jackson/core/filter/FilteringParserDelegate.java\nindex 1d81b8cfef..b54dc7f42b 100644\n--- a/src/main/java/com/fasterxml/jackson/core/filter/FilteringParserDelegate.java\n+++ b/src/main/java/com/fasterxml/jackson/core/filter/FilteringParserDelegate.java\n@@ -653,10 +653,13 @@ protected final JsonToken _nextToken2() throws IOException\n                     boolean returnEnd = _headContext.isStartHandled();\n                     f = _headContext.getFilter();\n                     if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {\n-                        boolean includeEmpty = f.includeEmptyArray(_headContext.hasCurrentIndex());\n                         f.filterFinishArray();\n-                        if (includeEmpty) {\n-                            return _nextBuffered(_headContext);\n+                        if (!returnEnd) {\n+                            boolean includeEmpty = f.includeEmptyArray(_headContext.hasCurrentIndex());\n+                            if (includeEmpty) {\n+                                _headContext._needToHandleName = false;\n+                                return _nextBuffered(_headContext);\n+                            }\n                         }\n                     }\n                     _headContext = _headContext.getParent();\n@@ -671,11 +674,15 @@ protected final JsonToken _nextToken2() throws IOException\n                     boolean returnEnd = _headContext.isStartHandled();\n                     f = _headContext.getFilter();\n                     if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {\n-                        boolean includeEmpty = f.includeEmptyObject(_headContext.hasCurrentName());\n                         f.filterFinishObject();\n-                        if (includeEmpty) {\n-                            return _nextBuffered(_headContext);\n-                        }                    }\n+                        if (!returnEnd) {\n+                            boolean includeEmpty = f.includeEmptyObject(_headContext.hasCurrentName());\n+                            if (includeEmpty) {\n+                                _headContext._needToHandleName = false;\n+                                return _nextBuffered(_headContext);\n+                            }\n+                        }\n+                    }\n                     _headContext = _headContext.getParent();\n                     _itemFilter = _headContext.getFilter();\n                     if (returnEnd) {\n@@ -819,15 +826,19 @@ protected final JsonToken _nextTokenWithBuffering(final TokenFilterContext buffR\n                     // Unlike with other loops, here we know that content was NOT\n                     // included (won't get this far otherwise)\n                     f = _headContext.getFilter();\n+                    boolean gotEnd = (_headContext == buffRoot);\n+                    boolean returnEnd = gotEnd && _headContext.isStartHandled();\n+\n                     if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {\n-                        boolean includeEmpty = f.includeEmptyArray(_headContext.hasCurrentIndex());\n                         f.filterFinishArray();\n-                        if (includeEmpty) {\n-                            return _nextBuffered(buffRoot);\n+                        if (!returnEnd) {\n+                            boolean includeEmpty = f.includeEmptyArray(_headContext.hasCurrentIndex());\n+                            if (includeEmpty) {\n+                                _headContext._needToHandleName = false;\n+                                return _nextBuffered(buffRoot);\n+                            }\n                         }\n                     }\n-                    boolean gotEnd = (_headContext == buffRoot);\n-                    boolean returnEnd = gotEnd && _headContext.isStartHandled();\n \n                     _headContext = _headContext.getParent();\n                     _itemFilter = _headContext.getFilter();\n@@ -845,19 +856,19 @@ protected final JsonToken _nextTokenWithBuffering(final TokenFilterContext buffR\n                 // Unlike with other loops, here we know that content was NOT\n                 // included (won't get this far otherwise)\n                 f = _headContext.getFilter();\n+                boolean gotEnd = (_headContext == buffRoot);\n+                boolean returnEnd = gotEnd && _headContext.isStartHandled();\n+\n                 if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {\n-                    boolean includeEmpty = f.includeEmptyObject(_headContext.hasCurrentName());\n                     f.filterFinishObject();\n-                    if (includeEmpty) {\n-                        _headContext._currentName = _headContext._parent == null\n-                                ? null\n-                                : _headContext._parent._currentName;\n-                        _headContext._needToHandleName = false;\n-                        return _nextBuffered(buffRoot);\n+                    if (!returnEnd) {\n+                        boolean includeEmpty = f.includeEmptyObject(_headContext.hasCurrentName());\n+                        if (includeEmpty) {\n+                            _headContext._needToHandleName = false;\n+                            return _nextBuffered(buffRoot);\n+                        }\n                     }\n                 }\n-                boolean gotEnd = (_headContext == buffRoot);\n-                boolean returnEnd = gotEnd && _headContext.isStartHandled();\n \n                 _headContext = _headContext.getParent();\n                 _itemFilter = _headContext.getFilter();\ndiff --git a/src/main/java/com/fasterxml/jackson/core/filter/TokenFilter.java b/src/main/java/com/fasterxml/jackson/core/filter/TokenFilter.java\nindex e48339ebfb..8335561ae5 100644\n--- a/src/main/java/com/fasterxml/jackson/core/filter/TokenFilter.java\n+++ b/src/main/java/com/fasterxml/jackson/core/filter/TokenFilter.java\n@@ -58,7 +58,7 @@ protected TokenFilter() { }\n \n     /*\n     /**********************************************************************\n-    /* API, structured values\n+    /* API, structured values: parser and generator\n     /**********************************************************************\n      */\n \n@@ -222,6 +222,42 @@ public TokenFilter includeRootValue(int index) {\n         return this;\n     }\n \n+    /**\n+     * Call made to verify whether leaf-level empty Array value\n+     * should be included in filtered input or output or not.\n+     *<p>\n+     * The default implementation returns {@code false} to exclude\n+     * empty Arrays from input/output.\n+     *\n+     * @param contentsFiltered True if Array had contents but they were\n+     *   filtered out (NOT included); false if we had actual empty Array.\n+     *\n+     * @return True if value is to be included; false if not\n+     *\n+     * @since 2.14\n+     */\n+    public boolean includeEmptyArray(boolean contentsFiltered) {\n+        return false;\n+    }\n+\n+    /**\n+     * Call made to verify whether leaf-level empty Object value\n+     * should be included in filtered input or output or not.\n+     *<p>\n+     * The default implementation returns {@code false} to exclude\n+     * empty Arrays from input/output.\n+     *\n+     * @param contentsFiltered True if Object had contents but they were\n+     *   filtered out (NOT included); false if we had actual empty Object.\n+     *\n+     * @return True if value is to be included; false if not\n+     *\n+     * @since 2.14\n+     */\n+    public boolean includeEmptyObject(boolean contentsFiltered) {\n+        return false;\n+    }\n+\n     /*\n     /**********************************************************************\n     /* API, scalar values (being read)\n@@ -256,7 +292,7 @@ public boolean includeValue(JsonParser p) throws IOException {\n     /**\n      * Call made to verify whether leaf-level\n      * boolean value\n-     * should be included in output or not.\n+     * should be included in output (written) or not.\n      *\n      * @param value Value to check\n      *\n@@ -269,7 +305,7 @@ public boolean includeBoolean(boolean value) {\n     /**\n      * Call made to verify whether leaf-level\n      * null value\n-     * should be included in output or not.\n+     * should be included in output (written) or not.\n      *\n      * @return True if ({@code null}) value is to be included; false if not\n      */\n@@ -280,7 +316,7 @@ public boolean includeNull() {\n     /**\n      * Call made to verify whether leaf-level\n      * String value\n-     * should be included in output or not.\n+     * should be included in output (written) or not.\n      *\n      * @param value Value to check\n      *\n@@ -293,7 +329,7 @@ public boolean includeString(String value) {\n     /**\n      * Call made to verify whether leaf-level\n      * \"streaming\" String value\n-     * should be included in output or not.\n+     * should be included in output (written) or not.\n      *<p>\n      * NOTE: note that any reads from passed in {@code Reader} may lead\n      * to actual loss of content to write; typically method should NOT\n@@ -313,7 +349,7 @@ public boolean includeString(java.io.Reader r, int maxLen) {\n     /**\n      * Call made to verify whether leaf-level\n      * <code>int</code> value\n-     * should be included in output or not.\n+     * should be included in output (written) or not.\n      *\n      * NOTE: also called for `short`, `byte`\n      *\n@@ -328,7 +364,7 @@ public boolean includeNumber(int value) {\n     /**\n      * Call made to verify whether leaf-level\n      * <code>long</code> value\n-     * should be included in output or not.\n+     * should be included in output (written) or not.\n      *\n      * @param value Value to check\n      *\n@@ -341,7 +377,7 @@ public boolean includeNumber(long value) {\n     /**\n      * Call made to verify whether leaf-level\n      * <code>float</code> value\n-     * should be included in output or not.\n+     * should be included in output (written) or not.\n      *\n      * @param value Value to check\n      *\n@@ -354,7 +390,7 @@ public boolean includeNumber(float value) {\n     /**\n      * Call made to verify whether leaf-level\n      * <code>double</code> value\n-     * should be included in output or not.\n+     * should be included in output (written) or not.\n      *\n      * @param value Value to check\n      *\n@@ -367,7 +403,7 @@ public boolean includeNumber(double value) {\n     /**\n      * Call made to verify whether leaf-level\n      * {@link BigDecimal} value\n-     * should be included in output or not.\n+     * should be included in output (written) or not.\n      *\n      * @param value Value to check\n      *\n@@ -380,7 +416,7 @@ public boolean includeNumber(BigDecimal value) {\n     /**\n      * Call made to verify whether leaf-level\n      * {@link BigInteger} value\n-     * should be included in output or not.\n+     * should be included in output (written) or not.\n      *\n      * @param value Value to check\n      *\n@@ -393,7 +429,7 @@ public boolean includeNumber(BigInteger value) {\n     /**\n      * Call made to verify whether leaf-level\n      * Binary value\n-     * should be included in output or not.\n+     * should be included in output (written) or not.\n      *<p>\n      * NOTE: no binary payload passed; assumption is this won't be of much use.\n      *\n@@ -406,7 +442,7 @@ public boolean includeBinary() {\n     /**\n      * Call made to verify whether leaf-level\n      * raw (pre-encoded, not quoted by generator) value\n-     * should be included in output or not.\n+     * should be included in output (written) or not.\n      *<p>\n      * NOTE: value itself not passed since it may come on multiple forms\n      * and is unlikely to be of much use in determining inclusion\n@@ -421,7 +457,7 @@ public boolean includeRawValue() {\n     /**\n      * Call made to verify whether leaf-level\n      * embedded (Opaque) value\n-     * should be included in output or not.\n+     * should be included in output (written) or not.\n      *\n      * @param value Value to check\n      *\n@@ -431,36 +467,6 @@ public boolean includeEmbeddedValue(Object value) {\n         return _includeScalar();\n     }\n \n-    /**\n-     * Call made to verify whether leaf-level empty Array value\n-     * should be included in output or not.\n-     *\n-     * @param contentsFiltered True if Array had contents but they were\n-     *   filtered out (NOT included); false if we had actual empty Array.\n-     *\n-     * @return True if value is to be included; false if not\n-     *\n-     * @since 2.14\n-     */\n-    public boolean includeEmptyArray(boolean contentsFiltered) {\n-        return false;\n-    }\n-\n-    /**\n-     * Call made to verify whether leaf-level empty Object value\n-     * should be included in output or not.\n-     *\n-     * @param contentsFiltered True if Object had contents but they were\n-     *   filtered out (NOT included); false if we had actual empty Object.\n-     *\n-     * @return True if value is to be included; false if not\n-     *\n-     * @since 2.14\n-     */\n-    public boolean includeEmptyObject(boolean contentsFiltered) {\n-        return false;\n-    }\n-\n     /*\n     /**********************************************************************\n     /* Overrides\n",
  "test_patch" : "diff --git a/src/test/java/com/fasterxml/jackson/core/tofix/ParserFilterEmpty1418Test.java b/src/test/java/com/fasterxml/jackson/core/tofix/ParserFilterEmpty1418Test.java\nindex 4aa345c430..db16949d7b 100644\n--- a/src/test/java/com/fasterxml/jackson/core/tofix/ParserFilterEmpty1418Test.java\n+++ b/src/test/java/com/fasterxml/jackson/core/tofix/ParserFilterEmpty1418Test.java\n@@ -6,7 +6,6 @@\n import com.fasterxml.jackson.core.filter.FilteringParserDelegate;\n import com.fasterxml.jackson.core.filter.TokenFilter;\n import com.fasterxml.jackson.core.filter.TokenFilter.Inclusion;\n-import com.fasterxml.jackson.core.testutil.failure.JacksonTestFailureExpected;\n \n import static org.junit.jupiter.api.Assertions.assertEquals;\n import static org.junit.jupiter.api.Assertions.assertNull;\n@@ -16,7 +15,7 @@ class ParserFilterEmpty1418Test extends JUnit5TestBase\n {\n     // Custom TokenFilter that only includes the \"one\" property\n     // and returns true for includeEmptyArray\n-    static class OnePropertyFilter extends TokenFilter {\n+    static class OnePropertyFilter1418Orig extends TokenFilter {\n         @Override\n         public TokenFilter includeProperty(String name) {\n             if (\"one\".equals(name)) {\n@@ -31,87 +30,81 @@ public boolean includeEmptyArray(boolean contentsFiltered) {\n         }\n     }\n \n+    // And then Filter like it was probably intended\n+    static class OnePropertyFilter1418Fixed extends TokenFilter {\n+        @Override\n+        public TokenFilter includeProperty(String name) {\n+            if (\"one\".equals(name)) {\n+                return this;\n+            }\n+            return null;\n+        }\n+\n+        @Override\n+        public boolean includeEmptyObject(boolean contentsFiltered) {\n+            return true;\n+        }\n+    }\n+\n     /*\n     /**********************************************************************\n-    /* Test methods\n+    /* Test methods, original\n     /**********************************************************************\n      */\n \n     private final JsonFactory JSON_F = newStreamFactory();\n \n-    // [core#1418]: case #1: failing\n-    @JacksonTestFailureExpected\n+    // [core#1418]: case #1\n     @Test\n     void filterArrayWithObjectsEndingWithFilteredProperty1() throws Exception\n     {\n         final String json = \"[{\\\"one\\\":1},{\\\"two\\\":2}]\";\n         JsonParser p0 = _createParser(JSON_F, json);\n         JsonParser p = new FilteringParserDelegate(p0,\n-                new OnePropertyFilter(),\n+                new OnePropertyFilter1418Orig(),\n                 Inclusion.INCLUDE_ALL_AND_PATH,\n                 true // multipleMatches\n         );\n \n-        // Expected output: [{\"one\":1},{}]\n+        // Expected output: [{\"one\":1}]\n         assertToken(JsonToken.START_ARRAY, p.nextToken());\n-        assertToken(JsonToken.START_OBJECT, p.nextToken());\n-        assertToken(JsonToken.FIELD_NAME, p.nextToken());\n-        assertEquals(\"one\", p.currentName());\n-        assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());\n-        assertEquals(1, p.getIntValue());\n-        assertToken(JsonToken.END_OBJECT, p.nextToken());\n-\n-        // Second object has no \"one\" property, should be empty object\n-        assertToken(JsonToken.START_OBJECT, p.nextToken());\n-        assertToken(JsonToken.END_OBJECT, p.nextToken());\n-\n+        _assertOneObject(p);\n+        // Second object has no \"one\" property, should be filtered out\n         assertToken(JsonToken.END_ARRAY, p.nextToken());\n         assertNull(p.nextToken());\n         p.close();\n     }\n \n-    // [core#1418]: case #2: passing\n+    // [core#1418]: case #2\n     @Test\n     void filterArrayWithObjectsEndingWithFilteredProperty2() throws Exception\n     {\n         final String json = \"[{\\\"one\\\":1},{\\\"one\\\":1,\\\"two\\\":2}]\";\n         JsonParser p0 = _createParser(JSON_F, json);\n         JsonParser p = new FilteringParserDelegate(p0,\n-                new OnePropertyFilter(),\n+                new OnePropertyFilter1418Orig(),\n                 Inclusion.INCLUDE_ALL_AND_PATH,\n                 true // multipleMatches\n         );\n \n         // Expected output: [{\"one\":1},{\"one\":1}]\n         assertToken(JsonToken.START_ARRAY, p.nextToken());\n-        assertToken(JsonToken.START_OBJECT, p.nextToken());\n-        assertToken(JsonToken.FIELD_NAME, p.nextToken());\n-        assertEquals(\"one\", p.currentName());\n-        assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());\n-        assertEquals(1, p.getIntValue());\n-        assertToken(JsonToken.END_OBJECT, p.nextToken());\n-\n-        // Second object has \"one\" property\n-        assertToken(JsonToken.START_OBJECT, p.nextToken());\n-        assertToken(JsonToken.FIELD_NAME, p.nextToken());\n-        assertEquals(\"one\", p.currentName());\n-        assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());\n-        assertEquals(1, p.getIntValue());\n-        assertToken(JsonToken.END_OBJECT, p.nextToken());\n+        _assertOneObject(p);\n+        _assertOneObject(p);\n \n         assertToken(JsonToken.END_ARRAY, p.nextToken());\n         assertNull(p.nextToken());\n         p.close();\n     }\n \n-    // [core#1418]: case #3: passing\n+    // [core#1418]: case #3\n     @Test\n     void filterArrayWithObjectsEndingWithFilteredProperty3() throws Exception\n     {\n         final String json = \"[{\\\"one\\\":1},{\\\"one\\\":1,\\\"two\\\":2},{\\\"one\\\":1}]\";\n         JsonParser p0 = _createParser(JSON_F, json);\n         JsonParser p = new FilteringParserDelegate(p0,\n-                new OnePropertyFilter(),\n+                new OnePropertyFilter1418Orig(),\n                 Inclusion.INCLUDE_ALL_AND_PATH,\n                 true // multipleMatches\n         );\n@@ -119,35 +112,129 @@ void filterArrayWithObjectsEndingWithFilteredProperty3() throws Exception\n         // Expected output: [{\"one\":1},{\"one\":1},{\"one\":1}]\n         assertToken(JsonToken.START_ARRAY, p.nextToken());\n \n-        // First object\n-        assertToken(JsonToken.START_OBJECT, p.nextToken());\n-        assertToken(JsonToken.FIELD_NAME, p.nextToken());\n-        assertEquals(\"one\", p.currentName());\n-        assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());\n-        assertEquals(1, p.getIntValue());\n-        assertToken(JsonToken.END_OBJECT, p.nextToken());\n+        _assertOneObject(p);\n+        _assertOneObject(p);\n+        _assertOneObject(p);\n \n-        // Second object\n-        assertToken(JsonToken.START_OBJECT, p.nextToken());\n-        assertToken(JsonToken.FIELD_NAME, p.nextToken());\n-        assertEquals(\"one\", p.currentName());\n-        assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());\n-        assertEquals(1, p.getIntValue());\n-        assertToken(JsonToken.END_OBJECT, p.nextToken());\n+        assertToken(JsonToken.END_ARRAY, p.nextToken());\n+        assertNull(p.nextToken());\n+        p.close();\n+    }\n \n-        // Third object\n-        assertToken(JsonToken.START_OBJECT, p.nextToken());\n-        assertToken(JsonToken.FIELD_NAME, p.nextToken());\n-        assertEquals(\"one\", p.currentName());\n-        assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());\n-        assertEquals(1, p.getIntValue());\n-        assertToken(JsonToken.END_OBJECT, p.nextToken());\n+    // One additional test, for excluding all properties\n+    @Test\n+    void filterWithEmptyArray() throws Exception\n+    {\n+        final String json = \"[{\\\"two\\\":2},{\\\"three\\\":3}]\";\n+        JsonParser p0 = _createParser(JSON_F, json);\n+        JsonParser p = new FilteringParserDelegate(p0,\n+                new OnePropertyFilter1418Orig(),\n+                Inclusion.INCLUDE_ALL_AND_PATH,\n+                true // multipleMatches\n+        );\n+\n+        // Expected output: []\n+        assertToken(JsonToken.START_ARRAY, p.nextToken());\n+        assertToken(JsonToken.END_ARRAY, p.nextToken());\n+        assertNull(p.nextToken());\n+        p.close();\n+    }\n+    \n+    /*\n+    /**********************************************************************\n+    /* Test methods, with corrected \"empty Object\" filtering\n+    /**********************************************************************\n+     */\n+    \n+    // [core#1418]: case #1 / corrected\n+    @Test\n+    void filterArray1Corrected() throws Exception\n+    {\n+        final String json = \"[{\\\"one\\\":1},{\\\"two\\\":2}]\";\n+        JsonParser p0 = _createParser(JSON_F, json);\n+        JsonParser p = new FilteringParserDelegate(p0,\n+                new OnePropertyFilter1418Fixed(),\n+                Inclusion.INCLUDE_ALL_AND_PATH,\n+                true // multipleMatches\n+        );\n+\n+        // Expected output: [{\"one\":1}]\n+        assertToken(JsonToken.START_ARRAY, p.nextToken());\n+        _assertOneObject(p);\n+        // Second object has no \"one\" property, should be included as empty\n+        _assertEmptyObject(p);\n+        assertToken(JsonToken.END_ARRAY, p.nextToken());\n+        assertNull(p.nextToken());\n+        p.close();\n+    }\n+\n+    // [core#1418]: case #2 / corrected\n+    @Test\n+    void filterArray2Corrected() throws Exception\n+    {\n+        final String json = \"[{\\\"one\\\":1},{\\\"one\\\":1,\\\"two\\\":2}]\";\n+        JsonParser p0 = _createParser(JSON_F, json);\n+        JsonParser p = new FilteringParserDelegate(p0,\n+                new OnePropertyFilter1418Fixed(),\n+                Inclusion.INCLUDE_ALL_AND_PATH,\n+                true // multipleMatches\n+        );\n+\n+        // Expected output: [{\"one\":1},{\"one\":1}]\n+        assertToken(JsonToken.START_ARRAY, p.nextToken());\n+        _assertOneObject(p);\n+        _assertOneObject(p);\n+\n+        assertToken(JsonToken.END_ARRAY, p.nextToken());\n+        assertNull(p.nextToken());\n+        p.close();\n+    }\n+\n+    // [core#1418]: case #3 / corrected\n+    @Test\n+    void filterArray3Corrected() throws Exception\n+    {\n+        final String json = \"[{\\\"one\\\":1},{\\\"one\\\":1,\\\"two\\\":2},{\\\"one\\\":1}]\";\n+        JsonParser p0 = _createParser(JSON_F, json);\n+        JsonParser p = new FilteringParserDelegate(p0,\n+                new OnePropertyFilter1418Fixed(),\n+                Inclusion.INCLUDE_ALL_AND_PATH,\n+                true // multipleMatches\n+        );\n+\n+        // Expected output: [{\"one\":1},{\"one\":1},{\"one\":1}]\n+        assertToken(JsonToken.START_ARRAY, p.nextToken());\n+\n+        _assertOneObject(p);\n+        _assertOneObject(p);\n+        _assertOneObject(p);\n \n         assertToken(JsonToken.END_ARRAY, p.nextToken());\n         assertNull(p.nextToken());\n         p.close();\n     }\n \n+    // Case #4, extra\n+    @Test\n+    void filterArray4Corrected() throws Exception\n+    {\n+        final String json = \"[{\\\"two\\\":2},{\\\"three\\\":3}]\";\n+        JsonParser p0 = _createParser(JSON_F, json);\n+        JsonParser p = new FilteringParserDelegate(p0,\n+                new OnePropertyFilter1418Fixed(),\n+                Inclusion.INCLUDE_ALL_AND_PATH,\n+                true // multipleMatches\n+        );\n+\n+        // Expected output: [{},{}]\n+        assertToken(JsonToken.START_ARRAY, p.nextToken());\n+        _assertEmptyObject(p);\n+        _assertEmptyObject(p);\n+        assertToken(JsonToken.END_ARRAY, p.nextToken());\n+        assertNull(p.nextToken());\n+        p.close();\n+    }\n+    \n     /*\n     /**********************************************************************\n     /* Helper methods\n@@ -157,4 +244,18 @@ void filterArrayWithObjectsEndingWithFilteredProperty3() throws Exception\n     private JsonParser _createParser(TokenStreamFactory f, String json) throws Exception {\n         return f.createParser(json);\n     }\n+\n+    private void _assertOneObject(JsonParser p) throws Exception {\n+        assertToken(JsonToken.START_OBJECT, p.nextToken());\n+        assertToken(JsonToken.FIELD_NAME, p.nextToken());\n+        assertEquals(\"one\", p.currentName());\n+        assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());\n+        assertEquals(1, p.getIntValue());\n+        assertToken(JsonToken.END_OBJECT, p.nextToken());\n+    }\n+\n+    private void _assertEmptyObject(JsonParser p) throws Exception {\n+        assertToken(JsonToken.START_OBJECT, p.nextToken());\n+        assertToken(JsonToken.END_OBJECT, p.nextToken());\n+    }\n }\n",
  "problem_statement" : "In the following example scenario I want to only include the property `one` inside of the objects in the array and always include the array regardless if it is empty or not, but instead I am met with an exception in some cases where the objects inside of the array are also filtered (both partially and fully).\n\nI tested a couple of different inputs to try and get a better idea of when the issue occurs, seemingly after the first element has been included in the array any object which ends with a filtered property will cause it to error\n\nI tested it with both jackson `2.18.3` and `2.19.0-rc2` (the stack traces are from `2.19.0-rc2`).\n\nThese cause an exception (each of them results in a different exception)\n* `[{\"one\":1},{\"two\":2}]`\n* `[{\"one\":1},{\"one\":1,\"two\":2}]`\n* `[{\"one\":1},{\"one\":1,\"two\":2},{\"one\":1}]`\n\nThese work as expected\n* `[{\"two\":2}]`\n* `[{\"two\":2},{\"two\":2}]`\n* `[{\"two\":2},{\"two\":2},{\"one\":1}]`\n* `[{\"one\":1}]`\n* `[{\"one\":1},{\"one\":1}]`\n* `[{\"one\":1},{\"two\":2,\"one\":1}]`\n* `[{\"one\":1},{\"two\":2,\"one\":1},{\"one\":1}]`\n\nSome additional info\n* When we instead return `false` in `includeEmptyArray` everything works as expected\n* The same errors occur if we were to wrap the array in another object, like `{\"list\":[{\"one\":1},{\"two\":2}]}`, and change the `includeProperty` to `name.equals(\"list\") || name.equals(\"one\")`\n\nHere's the code I used to test\n```java\npublic static class CustomTokenFilter extends TokenFilter {\n\t\n\t@Override\n\tpublic TokenFilter includeProperty(String name) {\n\t\tif(name.equals(\"one\")) {\n\t\t\treturn this;\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n\t\n\t@Override\n\tpublic boolean includeEmptyArray(boolean contentsFiltered) {\n\t\treturn true;\n\t}\n}\n\npublic static void main(String[] args) throws IOException {\n\tJsonMapper mapper = new JsonMapper();\n\tTokenFilter filter = new CustomTokenFilter();\n\n\tString content = \"[{\\\"one\\\":1},{\\\"two\\\":2}]\";\n\ttry(JsonParser parser = new FilteringParserDelegate(mapper.createParser(content), filter, Inclusion.INCLUDE_ALL_AND_PATH, true)) {\n\t\tSystem.out.println(parser.readValueAsTree().toString());\n\t}\n}\n```\n\n# Stack Traces\n`[{\"one\":1},{\"two\":2}]` results in\n```\nException in thread \"main\" com.fasterxml.jackson.core.JsonParseException: Internal error: failed to locate expected buffered tokens\n at [Source: REDACTED (`StreamReadFeature.INCLUDE_SOURCE_IN_LOCATION` disabled); line: 1, column: 22]\n\tat com.fasterxml.jackson.core.JsonParser._constructError(JsonParser.java:2590)\n\tat com.fasterxml.jackson.core.filter.FilteringParserDelegate._nextBuffered(FilteringParserDelegate.java:937)\n\tat com.fasterxml.jackson.core.filter.FilteringParserDelegate._nextToken2(FilteringParserDelegate.java:659)\n\tat com.fasterxml.jackson.core.filter.FilteringParserDelegate.nextToken(FilteringParserDelegate.java:557)\n\tat com.fasterxml.jackson.databind.deser.std.BaseNodeDeserializer._deserializeContainerNoRecursion(JsonNodeDeserializer.java:608)\n\tat com.fasterxml.jackson.databind.deser.std.JsonNodeDeserializer.deserialize(JsonNodeDeserializer.java:103)\n\tat com.fasterxml.jackson.databind.deser.std.JsonNodeDeserializer.deserialize(JsonNodeDeserializer.java:24)\n\tat com.fasterxml.jackson.databind.deser.DefaultDeserializationContext.readRootValue(DefaultDeserializationContext.java:342)\n\tat com.fasterxml.jackson.databind.ObjectMapper._readValue(ObjectMapper.java:4944)\n\tat com.fasterxml.jackson.databind.ObjectMapper.readTree(ObjectMapper.java:3165)\n\tat com.fasterxml.jackson.core.JsonParser.readValueAsTree(JsonParser.java:2564)\n```\n\n`[{\"one\":1},{\"one\":1,\"two\":2}]` results in\n```\nException in thread \"main\" com.fasterxml.jackson.databind.exc.MismatchedInputException: Unexpected end-of-input when trying read value of type `com.fasterxml.jackson.databind.JsonNode`\n at [Source: REDACTED (`StreamReadFeature.INCLUDE_SOURCE_IN_LOCATION` disabled); line: 1, column: 29]\n\tat com.fasterxml.jackson.databind.exc.MismatchedInputException.from(MismatchedInputException.java:59)\n\tat com.fasterxml.jackson.databind.DeserializationContext.reportInputMismatch(DeserializationContext.java:1794)\n\tat com.fasterxml.jackson.databind.DeserializationContext.handleUnexpectedToken(DeserializationContext.java:1568)\n\tat com.fasterxml.jackson.databind.DeserializationContext.handleUnexpectedToken(DeserializationContext.java:1473)\n\tat com.fasterxml.jackson.databind.deser.std.BaseNodeDeserializer._deserializeRareScalar(JsonNodeDeserializer.java:701)\n\tat com.fasterxml.jackson.databind.deser.std.BaseNodeDeserializer._deserializeContainerNoRecursion(JsonNodeDeserializer.java:644)\n\tat com.fasterxml.jackson.databind.deser.std.JsonNodeDeserializer.deserialize(JsonNodeDeserializer.java:103)\n\tat com.fasterxml.jackson.databind.deser.std.JsonNodeDeserializer.deserialize(JsonNodeDeserializer.java:24)\n\tat com.fasterxml.jackson.databind.deser.DefaultDeserializationContext.readRootValue(DefaultDeserializationContext.java:342)\n\tat com.fasterxml.jackson.databind.ObjectMapper._readValue(ObjectMapper.java:4944)\n\tat com.fasterxml.jackson.databind.ObjectMapper.readTree(ObjectMapper.java:3165)\n\tat com.fasterxml.jackson.core.JsonParser.readValueAsTree(JsonParser.java:2564)\n```\n\n`[{\"one\":1},{\"one\":1,\"two\":2},{\"one\":1}]` results in\n```\nException in thread \"main\" com.fasterxml.jackson.databind.exc.MismatchedInputException: Cannot deserialize value of type `com.fasterxml.jackson.databind.JsonNode` from Object value (token `JsonToken.FIELD_NAME`)\n at [Source: REDACTED (`StreamReadFeature.INCLUDE_SOURCE_IN_LOCATION` disabled); line: 1, column: 37]\n\tat com.fasterxml.jackson.databind.exc.MismatchedInputException.from(MismatchedInputException.java:59)\n\tat com.fasterxml.jackson.databind.DeserializationContext.reportInputMismatch(DeserializationContext.java:1794)\n\tat com.fasterxml.jackson.databind.DeserializationContext.handleUnexpectedToken(DeserializationContext.java:1568)\n\tat com.fasterxml.jackson.databind.DeserializationContext.handleUnexpectedToken(DeserializationContext.java:1473)\n\tat com.fasterxml.jackson.databind.deser.std.BaseNodeDeserializer._deserializeRareScalar(JsonNodeDeserializer.java:701)\n\tat com.fasterxml.jackson.databind.deser.std.BaseNodeDeserializer._deserializeContainerNoRecursion(JsonNodeDeserializer.java:644)\n\tat com.fasterxml.jackson.databind.deser.std.JsonNodeDeserializer.deserialize(JsonNodeDeserializer.java:103)\n\tat com.fasterxml.jackson.databind.deser.std.JsonNodeDeserializer.deserialize(JsonNodeDeserializer.java:24)\n\tat com.fasterxml.jackson.databind.deser.DefaultDeserializationContext.readRootValue(DefaultDeserializationContext.java:342)\n\tat com.fasterxml.jackson.databind.ObjectMapper._readValue(ObjectMapper.java:4944)\n\tat com.fasterxml.jackson.databind.ObjectMapper.readTree(ObjectMapper.java:3165)\n\tat com.fasterxml.jackson.core.JsonParser.readValueAsTree(JsonParser.java:2564)\n```",
  "hints_text" : null,
  "created_at" : "Sun Nov 16 00:20:18 CET 2025",
  "version" : null,
  "FAIL_TO_PASS" : [ "ParserFilterEmpty1418Test" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=ParserFilterEmpty1418Test",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : 1418,
  "pull_number" : 1509,
  "metadata" : null
}, {
  "instance_id" : "FasterXML-jackson-core-PR-1508",
  "repo" : "FasterXML/jackson-core",
  "base_commit" : "d09a49dedb78f2dda46913d6e1704d8346ade75d",
  "patch" : "diff --git a/release-notes/VERSION b/release-notes/VERSION\nindex e4e5c1899a..dea75215f7 100644\n--- a/release-notes/VERSION\n+++ b/release-notes/VERSION\n@@ -17,6 +17,9 @@ JSON library.\n \n 3.1.0 (not yet released)\n \n+#784: Optional leading plus sign not included in textual value of any\n+  integral nor all floating-point numbers\n+ (fix by @cowtowncoder, w/ Claude code)\n #1506: Non-blocking parser parses numbers eagerly; does not report error\n   with missing space\n  (fix by @cowtowncoder, w/ Claude code)\ndiff --git a/src/main/java/tools/jackson/core/json/ReaderBasedJsonParser.java b/src/main/java/tools/jackson/core/json/ReaderBasedJsonParser.java\nindex 6008368dc8..cfb5c681ac 100644\n--- a/src/main/java/tools/jackson/core/json/ReaderBasedJsonParser.java\n+++ b/src/main/java/tools/jackson/core/json/ReaderBasedJsonParser.java\n@@ -773,7 +773,7 @@ public final JsonToken nextToken() throws JacksonException\n             }\n             break;\n         case '.': // [core#61]]\n-            t = _parseFloatThatStartsWithPeriod(false);\n+            t = _parseFloatThatStartsWithPeriod();\n             break;\n         case '0':\n         case '1':\n@@ -974,7 +974,7 @@ public String nextName() throws JacksonException\n             }\n             break;\n         case '.': // [core#61]]\n-            t = _parseFloatThatStartsWithPeriod(false);\n+            t = _parseFloatThatStartsWithPeriod();\n             break;\n         case '0':\n         case '1':\n@@ -1053,7 +1053,7 @@ private final void _isNextTokenNameYes(int i) throws JacksonException\n             }\n             return;\n         case '.': // [core#61]]\n-            _nextToken = _parseFloatThatStartsWithPeriod(false);\n+            _nextToken = _parseFloatThatStartsWithPeriod();\n             return;\n         case '0':\n         case '1':\n@@ -1098,7 +1098,7 @@ protected boolean _isNextTokenNameMaybe(int i, String nameToMatch) throws Jackso\n             }\n             break;\n         case '.': // [core#61]\n-            t = _parseFloatThatStartsWithPeriod(false);\n+            t = _parseFloatThatStartsWithPeriod();\n             break;\n         case '0':\n         case '1':\n@@ -1167,7 +1167,7 @@ private final JsonToken _nextTokenNotInObject(int i) throws JacksonException\n              * and could be indicated by a more specific error message.\n              */\n         case '.': // [core#61]]\n-            return _updateToken(_parseFloatThatStartsWithPeriod(false));\n+            return _updateToken(_parseFloatThatStartsWithPeriod());\n         case '0':\n         case '1':\n         case '2':\n@@ -1309,25 +1309,18 @@ public final Boolean nextBooleanValue() throws JacksonException\n     /**********************************************************************\n      */\n \n-\n-    protected final JsonToken _parseFloatThatStartsWithPeriod(final boolean neg)\n+    // NOTE: number starts with '.' character WITHOUT leading sign\n+    // \n+    // @since 3.1\n+    protected final JsonToken _parseFloatThatStartsWithPeriod()\n         throws JacksonException\n     {\n         // [core#611]: allow optionally leading decimal point\n         if (!isEnabled(JsonReadFeature.ALLOW_LEADING_DECIMAL_POINT_FOR_NUMBERS)) {\n             return _handleOddValue('.');\n         }\n-        // 26-Jun-2022, tatu: At this point it is assumed that the whole input is\n-        //    within input buffer so we can \"rewind\" not just one but two characters\n-        //    (leading sign, period) within same buffer. Caller must ensure this is\n-        //    the case.\n-        //    Little bit suspicious of code paths that would go to \"_parseNumber2(...)\"\n-        // 27-Jun-2022, tatu: [core#784] would add plus here too but not yet\n-        int startPtr = _inputPtr - 1;\n-        if (neg) {\n-            --startPtr;\n-        }\n-        return _parseFloat(INT_PERIOD, startPtr, _inputPtr, neg, 0);\n+        int startPtr = _inputPtr - 1; // include the '.'\n+        return _parseFloat(INT_PERIOD, startPtr, _inputPtr, false, 0);\n     }\n \n     /**\n@@ -1409,14 +1402,14 @@ protected final JsonToken _parseUnsignedNumber(int ch) throws JacksonException\n     private final JsonToken _parseFloat(int ch, int startPtr, int ptr, boolean neg, int intLen)\n         throws JacksonException\n     {\n-        final int inputLen = _inputEnd;\n+        final int inputEnd = _inputEnd;\n         int fractLen = 0;\n \n         // And then see if we get other parts\n         if (ch == '.') { // yes, fraction\n             fract_loop:\n             while (true) {\n-                if (ptr >= inputLen) {\n+                if (ptr >= inputEnd) {\n                     return _parseNumber2(neg, startPtr);\n                 }\n                 ch = _inputBuffer[ptr++];\n@@ -1434,14 +1427,14 @@ private final JsonToken _parseFloat(int ch, int startPtr, int ptr, boolean neg,\n         }\n         int expLen = 0;\n         if ((ch | 0x20) == INT_e) { // ~ 'eE' and/or exponent\n-            if (ptr >= inputLen) {\n+            if (ptr >= inputEnd) {\n                 _inputPtr = startPtr;\n                 return _parseNumber2(neg, startPtr);\n             }\n             // Sign indicator?\n             ch = _inputBuffer[ptr++];\n             if (ch == INT_MINUS || ch == INT_PLUS) { // yup, skip for now\n-                if (ptr >= inputLen) {\n+                if (ptr >= inputEnd) {\n                     _inputPtr = startPtr;\n                     return _parseNumber2(neg, startPtr);\n                 }\n@@ -1449,7 +1442,7 @@ private final JsonToken _parseFloat(int ch, int startPtr, int ptr, boolean neg,\n             }\n             while (ch <= INT_9 && ch >= INT_0) {\n                 ++expLen;\n-                if (ptr >= inputLen) {\n+                if (ptr >= inputEnd) {\n                     _inputPtr = startPtr;\n                     return _parseNumber2(neg, startPtr);\n                 }\n@@ -1475,9 +1468,8 @@ private final JsonToken _parseFloat(int ch, int startPtr, int ptr, boolean neg,\n     private final JsonToken _parseSignedNumber(final boolean negative) throws JacksonException\n     {\n         int ptr = _inputPtr;\n-        // 26-Jun-2022, tatu: We always have a sign; positive should be allowed as deviation\n-        //      But unfortunately that won't yet work\n-        int startPtr = negative ? ptr-1 : ptr; // to include sign/digit already read\n+        // [core#784]: Include sign character ('+' or '-') in textual representation\n+        int startPtr = ptr - 1; // to include sign already read\n         final int inputEnd = _inputEnd;\n \n         if (ptr >= inputEnd) {\n@@ -1488,7 +1480,11 @@ private final JsonToken _parseSignedNumber(final boolean negative) throws Jackso\n         if (ch > INT_9 || ch < INT_0) {\n             _inputPtr = ptr;\n             if (ch == INT_PERIOD) {\n-                return _parseFloatThatStartsWithPeriod(negative);\n+                // [core#611]: allow optionally leading decimal point\n+                if (!isEnabled(JsonReadFeature.ALLOW_LEADING_DECIMAL_POINT_FOR_NUMBERS)) {\n+                    return _handleOddValue('.');\n+                }\n+                return _parseFloat(INT_PERIOD, startPtr, _inputPtr, negative, 0);\n             }\n             return _handleInvalidNumberStart(ch, negative, true);\n         }\n@@ -1543,13 +1539,16 @@ private final JsonToken _parseSignedNumber(final boolean negative) throws Jackso\n      */\n     private final JsonToken _parseNumber2(boolean neg, int startPtr) throws JacksonException\n     {\n-        _inputPtr = neg ? (startPtr+1) : startPtr;\n+        // Check if there's a sign character at startPtr\n+        boolean hasSign = neg || ((startPtr < _inputEnd)\n+                && _inputBuffer[startPtr] == '+');\n+        _inputPtr = hasSign ? (startPtr + 1) : startPtr;\n         char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n         int outPtr = 0;\n \n         // Need to prepend sign?\n-        if (neg) {\n-            outBuf[outPtr++] = '-';\n+        if (hasSign) {\n+            outBuf[outPtr++] = neg ? '-' : '+'; // Include actual sign ('+' or '-')\n         }\n \n         // This is the place to do leading-zero check(s) too:\ndiff --git a/src/main/java/tools/jackson/core/json/UTF8DataInputJsonParser.java b/src/main/java/tools/jackson/core/json/UTF8DataInputJsonParser.java\nindex ea04e46d92..ded194e558 100644\n--- a/src/main/java/tools/jackson/core/json/UTF8DataInputJsonParser.java\n+++ b/src/main/java/tools/jackson/core/json/UTF8DataInputJsonParser.java\n@@ -988,9 +988,9 @@ protected final JsonToken _parseFloatThatStartsWithPeriod(final boolean neg,\n         }\n         final char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n         int outPtr = 0;\n-        // 27-Jun-2022, tatu: [core#784] would add plus here too but not yet\n-        if (neg) {\n-            outBuf[outPtr++] = '-';\n+        // [core#784]: Include sign character ('+' or '-') in textual representation\n+        if (hasSign) {\n+            outBuf[outPtr++] = neg ? '-' : '+';\n         }\n         return _parseFloat(outBuf, outPtr, INT_PERIOD, neg, 0);\n     }\n@@ -1080,10 +1080,8 @@ private final JsonToken _parseSignedNumber(boolean negative) throws IOException\n         char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n         int outPtr = 0;\n \n-        if (negative) {\n-            // Need to prepend sign?\n-            outBuf[outPtr++] = '-';\n-        }\n+        // [core#784]: Include sign character ('+' or '-') in textual representation\n+        outBuf[outPtr++] = negative ? '-' : '+';\n         int c = _inputData.readUnsignedByte();\n         outBuf[outPtr++] = (char) c;\n         // Note: must be followed by a digit\ndiff --git a/src/main/java/tools/jackson/core/json/UTF8StreamJsonParser.java b/src/main/java/tools/jackson/core/json/UTF8StreamJsonParser.java\nindex 0c4073a20c..074c8d083c 100644\n--- a/src/main/java/tools/jackson/core/json/UTF8StreamJsonParser.java\n+++ b/src/main/java/tools/jackson/core/json/UTF8StreamJsonParser.java\n@@ -1760,9 +1760,9 @@ protected final JsonToken _parseFloatThatStartsWithPeriod(final boolean neg,\n         }\n         final char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n         int outPtr = 0;\n-        // 27-Jun-2022, tatu: [core#784] would add plus here too but not yet\n-        if (neg) {\n-            outBuf[outPtr++] = '-';\n+        // [core#784]: Include sign character ('+' or '-') in textual representation\n+        if (hasSign) {\n+            outBuf[outPtr++] = neg ? '-' : '+';\n         }\n         return _parseFloat(outBuf, outPtr, INT_PERIOD, neg, 0);\n     }\n@@ -1834,10 +1834,8 @@ private final JsonToken _parseSignedNumber(boolean negative) throws JacksonExcep\n         char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n         int outPtr = 0;\n \n-        if (negative) {\n-            // Need to prepend sign?\n-            outBuf[outPtr++] = '-';\n-        }\n+        // [core#784]: Include sign character ('+' or '-') in textual representation\n+        outBuf[outPtr++] = negative ? '-' : '+';\n         // Must have something after sign too\n         if (_inputPtr >= _inputEnd) {\n             _loadMoreGuaranteed();\n",
  "test_patch" : "diff --git a/src/test/java/tools/jackson/core/unittest/read/NonStandardLeadingPlusSign784Test.java b/src/test/java/tools/jackson/core/unittest/read/NonStandardLeadingPlusSign784Test.java\nnew file mode 100644\nindex 0000000000..90684bfeb2\n--- /dev/null\n+++ b/src/test/java/tools/jackson/core/unittest/read/NonStandardLeadingPlusSign784Test.java\n@@ -0,0 +1,57 @@\n+package tools.jackson.core.unittest.read;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import tools.jackson.core.JsonParser;\n+import tools.jackson.core.JsonToken;\n+import tools.jackson.core.json.JsonFactory;\n+import tools.jackson.core.json.JsonReadFeature;\n+import tools.jackson.core.unittest.JacksonCoreTestBase;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+/**\n+ * Test to reproduce issue #784: Leading Plus Sign Inconsistency\n+ */\n+class NonStandardLeadingPlusSign784Test extends JacksonCoreTestBase\n+{\n+    private final JsonFactory JSON_F = JsonFactory.builder()\n+            .enable(JsonReadFeature.ALLOW_LEADING_PLUS_SIGN_FOR_NUMBERS)\n+            .enable(JsonReadFeature.ALLOW_LEADING_DECIMAL_POINT_FOR_NUMBERS)\n+            .build();\n+\n+    @Test\n+    void testLeadingPlusSignConsistency() throws Exception {\n+        // Test various number formats with leading plus sign\n+        // [core#784]: All should consistently INCLUDE the '+' sign in getText()/getString()\n+        _testNumber(\"+125\", JsonToken.VALUE_NUMBER_INT);\n+        _testNumber(\"+0.125\", JsonToken.VALUE_NUMBER_FLOAT);\n+        _testNumber(\"+1.25e2\", JsonToken.VALUE_NUMBER_FLOAT);\n+        _testNumber(\"+125.0\", JsonToken.VALUE_NUMBER_FLOAT);\n+        _testNumber(\"+0\", JsonToken.VALUE_NUMBER_INT);\n+        _testNumber(\"+1\", JsonToken.VALUE_NUMBER_INT);\n+\n+        // Special case: numbers starting with decimal point (issue #784)\n+        _testNumber(\"+.125\", JsonToken.VALUE_NUMBER_FLOAT);\n+        _testNumber(\"+.5\", JsonToken.VALUE_NUMBER_FLOAT);\n+        _testNumber(\"+.0\", JsonToken.VALUE_NUMBER_FLOAT);\n+\n+        // With exponents\n+        _testNumber(\"+1e2\", JsonToken.VALUE_NUMBER_FLOAT);\n+        _testNumber(\"+1e+2\", JsonToken.VALUE_NUMBER_FLOAT);\n+        _testNumber(\"+1e-2\", JsonToken.VALUE_NUMBER_FLOAT);\n+    }\n+\n+    private void _testNumber(String numberString, JsonToken expectedToken) throws Exception {\n+        String input = \" \" + numberString + \" \";\n+        for (int mode : ALL_MODES) {\n+            try (JsonParser p = createParser(JSON_F, mode, input)) {\n+                assertToken(expectedToken, p.nextToken());\n+                String text = p.getString();\n+                assertEquals(numberString, text,\n+                    \"getText() returned wrong value for number: \" + numberString + \" in mode \" + mode +\n+                    \" - got: '\" + text + \"'\");\n+            }\n+        }\n+    }\n+}\ndiff --git a/src/test/java/tools/jackson/core/unittest/read/NonStandardNumberParsingTest.java b/src/test/java/tools/jackson/core/unittest/read/NonStandardNumberParsingTest.java\nindex 1bc5ed762a..e57609276b 100644\n--- a/src/test/java/tools/jackson/core/unittest/read/NonStandardNumberParsingTest.java\n+++ b/src/test/java/tools/jackson/core/unittest/read/NonStandardNumberParsingTest.java\n@@ -263,19 +263,22 @@ private void _testLeadingPlusSignInDecimalAllowed(JsonFactory f, int mode)\n             assertEquals(JsonToken.VALUE_NUMBER_INT, p.nextToken());\n             assertEquals(125.0, p.getValueAsDouble());\n             assertEquals(\"125\", p.getDecimalValue().toString());\n-            assertEquals(\"125\", p.getString());\n+            // [core#784]: Leading plus sign should be included in textual representation\n+            assertEquals(\"+125\", p.getString());\n         }\n         try (JsonParser p = createParser(f, mode, \" +0.125 \")) {\n             assertEquals(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());\n             assertEquals(0.125, p.getValueAsDouble());\n             assertEquals(\"0.125\", p.getDecimalValue().toString());\n-            assertEquals(\"0.125\", p.getString());\n+            // [core#784]: Leading plus sign should be included in textual representation\n+            assertEquals(\"+0.125\", p.getString());\n         }\n         try (JsonParser p = createParser(f, mode, \" +.125 \")) {\n             assertEquals(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());\n             assertEquals(0.125, p.getValueAsDouble());\n             assertEquals(\"0.125\", p.getDecimalValue().toString());\n-            assertEquals(\".125\", p.getString());\n+            // [core#784]: Leading plus sign should be included in textual representation\n+            assertEquals(\"+.125\", p.getString());\n         }\n     }\n \n",
  "problem_statement" : "Implementation of #774 is mostly complete, but there is one minor inconsistency: whereas leading plus sign -- if (and only if) enabled as non-standard feature -- is retained for some floating-point numbers  when accessing token with `JsonParser.getText()` (and related), it is not retained for any of integral numbers (nor all FPs).\r\n\r\nThe underlying problem to solve is that of assumptions based on there only ever being a leading minus sign in `TextBuffer` (or shared input buffer): something that made sense before allowing non-standard leading plus.\r\n",
  "hints_text" : null,
  "created_at" : "Fri Nov 07 04:25:01 CET 2025",
  "version" : null,
  "FAIL_TO_PASS" : [ "NonStandardLeadingPlusSign784Test", "NonStandardNumberParsingTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=NonStandardLeadingPlusSign784Test,NonStandardNumberParsingTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : 784,
  "pull_number" : 1508,
  "metadata" : null
}, {
  "instance_id" : "FasterXML-jackson-core-PR-1507",
  "repo" : "FasterXML/jackson-core",
  "base_commit" : "1da649709a55315d6073c3b005dcd0d0f1c64f5c",
  "patch" : "diff --git a/release-notes/VERSION b/release-notes/VERSION\nindex c6911ff797..e4e5c1899a 100644\n--- a/release-notes/VERSION\n+++ b/release-notes/VERSION\n@@ -17,7 +17,9 @@ JSON library.\n \n 3.1.0 (not yet released)\n \n--\n+#1506: Non-blocking parser parses numbers eagerly; does not report error\n+  with missing space\n+ (fix by @cowtowncoder, w/ Claude code)\n \n 3.0.2 (not yet released)\n \ndiff --git a/src/main/java/tools/jackson/core/json/async/NonBlockingUtf8JsonParserBase.java b/src/main/java/tools/jackson/core/json/async/NonBlockingUtf8JsonParserBase.java\nindex d9e410f80c..bcfc09ade1 100644\n--- a/src/main/java/tools/jackson/core/json/async/NonBlockingUtf8JsonParserBase.java\n+++ b/src/main/java/tools/jackson/core/json/async/NonBlockingUtf8JsonParserBase.java\n@@ -1688,6 +1688,7 @@ protected JsonToken _finishNumberLeadingPosNegZeroes(final boolean negative) thr\n \n     protected JsonToken _finishNumberIntegralPart(char[] outBuf, int outPtr) throws JacksonException {\n         int negMod = _numberNegative ? -1 : 0;\n+        int ch;\n \n         while (true) {\n             if (_inputPtr >= _inputEnd) {\n@@ -1695,7 +1696,7 @@ protected JsonToken _finishNumberIntegralPart(char[] outBuf, int outPtr) throws\n                 _textBuffer.setCurrentLength(outPtr);\n                 return _updateTokenToNA();\n             }\n-            int ch = getByteFromBuffer(_inputPtr) & 0xFF;\n+            ch = getByteFromBuffer(_inputPtr) & 0xFF;\n             if (ch < INT_0) {\n                 if (ch == INT_PERIOD) {\n                     _intLength = outPtr+negMod;\n@@ -1722,6 +1723,10 @@ protected JsonToken _finishNumberIntegralPart(char[] outBuf, int outPtr) throws\n         }\n         _intLength = outPtr+negMod;\n         _textBuffer.setCurrentLength(outPtr);\n+        // As per #105, need separating space between root values; check here\n+        if (_streamReadContext.inRoot()) {\n+            _verifyRootSpace(ch);\n+        }\n         return _valueComplete(JsonToken.VALUE_NUMBER_INT);\n     }\n \n@@ -1810,6 +1815,10 @@ protected JsonToken _startFloat(char[] outBuf, int outPtr, int ch) throws Jackso\n         _textBuffer.setCurrentLength(outPtr);\n         // negative, int-length, fract-length already set, so...\n         _expLength = expLen;\n+        // As per #105, need separating space between root values; check here\n+        if (_streamReadContext.inRoot()) {\n+            _verifyRootSpace(ch);\n+        }\n         return _valueComplete(JsonToken.VALUE_NUMBER_FLOAT);\n     }\n \n@@ -1836,6 +1845,12 @@ protected JsonToken _finishFloatFraction() throws JacksonException\n                 }\n                 ch = getNextSignedByteFromBuffer();\n             } else if ((ch | 0x22) == 'f') { // ~ fFdD\n+                // For root level, better to report missing space error\n+                if (_streamReadContext.inRoot()) {\n+                    ch &= 0xFF;\n+                    --_inputPtr; // push back so _verifyRootSpace can handle it\n+                    _reportMissingRootWS(ch);\n+                }\n                 _reportUnexpectedNumberChar(ch, \"JSON does not support parsing numbers that have 'f' or 'd' suffixes\");\n             } else if (ch == INT_PERIOD) {\n                 _reportUnexpectedNumberChar(ch, \"Cannot parse number with more than one decimal point\");\n@@ -1871,6 +1886,10 @@ protected JsonToken _finishFloatFraction() throws JacksonException\n         _textBuffer.setCurrentLength(outPtr);\n         // negative, int-length, fract-length already set, so...\n         _expLength = 0;\n+        // As per #105, need separating space between root values; check here\n+        if (_streamReadContext.inRoot()) {\n+            _verifyRootSpace(ch);\n+        }\n         return _valueComplete(JsonToken.VALUE_NUMBER_FLOAT);\n     }\n \n@@ -1916,6 +1935,10 @@ protected JsonToken _finishFloatExponent(boolean checkSign, int ch) throws Jacks\n         _textBuffer.setCurrentLength(outPtr);\n         // negative, int-length, fract-length already set, so...\n         _expLength = expLen;\n+        // As per #105, need separating space between root values; check here\n+        if (_streamReadContext.inRoot()) {\n+            _verifyRootSpace(ch);\n+        }\n         return _valueComplete(JsonToken.VALUE_NUMBER_FLOAT);\n     }\n \n@@ -3004,6 +3027,36 @@ private final int _decodeUTF8_4(int c, int d, int e, int f) throws JacksonExcept\n         return ((c << 6) | (f & 0x3F)) - 0x10000;\n     }\n \n+    /**\n+     * Method called to verify that a root-level value is followed by a space\n+     * token (or EOF).\n+     *<p>\n+     * NOTE: caller MUST ensure there is at least one character available;\n+     * and that input pointer is AT given char (not past)\n+     *\n+     * @param ch Character after number value\n+     *\n+     * @throws JacksonException for decoding problems (invalid white space)\n+     */\n+    private final void _verifyRootSpace(int ch) throws JacksonException\n+    {\n+        // caller had not yet advanced, so advance now\n+        ++_inputPtr;\n+        switch (ch) {\n+        case ' ':\n+        case '\\t':\n+            return;\n+        case '\\r':\n+            --_inputPtr;\n+            return;\n+        case '\\n':\n+            ++_currInputRow;\n+            _currInputRowStart = _inputPtr;\n+            return;\n+        }\n+        _reportMissingRootWS(ch);\n+    }\n+\n     /*\n     /**********************************************************************\n     /* Internal methods, other\n",
  "test_patch" : "diff --git a/src/test/java/module-info.java b/src/test/java/module-info.java\nindex 89677a12ba..788d61d9d6 100644\n--- a/src/test/java/module-info.java\n+++ b/src/test/java/module-info.java\n@@ -6,11 +6,12 @@\n     requires org.assertj.core;\n     requires org.junit.jupiter.api;\n     requires org.junit.jupiter.params;\n+    requires org.junit.platform.commons; // Needed for JUnit reflection access?\n \n     // Requires Main jar for tests\n     requires tools.jackson.core;\n \n-    // Exports/opens a small set of Classes for downstream Jackson components\n+    // Exports/opens test utility packages\n     exports tools.jackson.core.unittest.testutil;\n     exports tools.jackson.core.unittest.testutil.failure;\n     opens tools.jackson.core.unittest.testutil;\ndiff --git a/src/test/java/tools/jackson/core/unittest/tofix/async/AsyncTokenRootErrorTest.java b/src/test/java/tools/jackson/core/unittest/json/async/AsyncParserRootToken1506Test.java\nsimilarity index 91%\nrename from src/test/java/tools/jackson/core/unittest/tofix/async/AsyncTokenRootErrorTest.java\nrename to src/test/java/tools/jackson/core/unittest/json/async/AsyncParserRootToken1506Test.java\nindex 20780c05ec..f08f03b5f1 100644\n--- a/src/test/java/tools/jackson/core/unittest/tofix/async/AsyncTokenRootErrorTest.java\n+++ b/src/test/java/tools/jackson/core/unittest/json/async/AsyncParserRootToken1506Test.java\n@@ -1,4 +1,4 @@\n-package tools.jackson.core.unittest.tofix.async;\n+package tools.jackson.core.unittest.json.async;\n \n import org.junit.jupiter.api.Test;\n \n@@ -7,11 +7,11 @@\n import tools.jackson.core.json.JsonFactory;\n import tools.jackson.core.unittest.async.AsyncTestBase;\n import tools.jackson.core.unittest.testutil.AsyncReaderWrapper;\n-import tools.jackson.core.unittest.testutil.failure.JacksonTestFailureExpected;\n \n import static org.junit.jupiter.api.Assertions.fail;\n \n-class AsyncTokenRootErrorTest extends AsyncTestBase\n+// [core#1506] Async parser: invalid root-level tokens not reported properly\n+class AsyncParserRootToken1506Test extends AsyncTestBase\n {\n     private final JsonFactory JSON_F = newStreamFactory();\n \n@@ -53,7 +53,6 @@ private void _doTestInvalidKeyword(String value)\n         }\n     }\n     \n-    @JacksonTestFailureExpected\n     @Test\n     void mangledRootInts() throws Exception\n     {\n@@ -65,7 +64,6 @@ void mangledRootInts() throws Exception\n         }\n     }\n \n-    @JacksonTestFailureExpected\n     @Test\n     void mangledRootFloats() throws Exception\n     {\ndiff --git a/src/test/java/tools/jackson/core/unittest/tofix/async/AsyncTokenNonRootErrorTest.java b/src/test/java/tools/jackson/core/unittest/tofix/async/AsyncParserNonRootTokenTest.java\nsimilarity index 98%\nrename from src/test/java/tools/jackson/core/unittest/tofix/async/AsyncTokenNonRootErrorTest.java\nrename to src/test/java/tools/jackson/core/unittest/tofix/async/AsyncParserNonRootTokenTest.java\nindex d373cea908..aa291e6935 100644\n--- a/src/test/java/tools/jackson/core/unittest/tofix/async/AsyncTokenNonRootErrorTest.java\n+++ b/src/test/java/tools/jackson/core/unittest/tofix/async/AsyncParserNonRootTokenTest.java\n@@ -11,7 +11,7 @@\n \n import static org.junit.jupiter.api.Assertions.fail;\n \n-class AsyncTokenNonRootErrorTest extends AsyncTestBase\n+class AsyncParserNonRootTokenTest extends AsyncTestBase\n {\n     private final JsonFactory JSON_F = newStreamFactory();\n \n",
  "problem_statement" : "(note: same as #105 but for non-blocking (\"async\") parser)\n\nIf you give input like:\n\n```\n123true\n```\n\nnon-blocking parser will first successfully parse integer 123, and then boolean `true`. This should instead result in a parse exception.\n\nSame for \n\n```\n1.5false\n```\n",
  "hints_text" : null,
  "created_at" : "Fri Nov 07 02:34:09 CET 2025",
  "version" : null,
  "FAIL_TO_PASS" : [ "AsyncTokenNonRootErrorTest", "AsyncParserNonRootTokenTest", "AsyncParserRootToken1506Test", "module-info", "AsyncTokenRootErrorTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=AsyncTokenNonRootErrorTest,AsyncParserNonRootTokenTest,AsyncParserRootToken1506Test,module-info,AsyncTokenRootErrorTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : 1506,
  "pull_number" : 1507,
  "metadata" : null
}, {
  "instance_id" : "FasterXML-jackson-core-PR-1505",
  "repo" : "FasterXML/jackson-core",
  "base_commit" : "8fa89c628c79f15e4fa6d6240e67e8d1bdef2f88",
  "patch" : "diff --git a/pom.xml b/pom.xml\nindex 5f952ce69b..21c73a2e1f 100644\n--- a/pom.xml\n+++ b/pom.xml\n@@ -138,7 +138,6 @@ tools.jackson.core.*;version=${project.version}\n       <plugin>\n         <groupId>org.apache.maven.plugins</groupId>\n         <artifactId>maven-failsafe-plugin</artifactId>\n-        <version>${version.plugin.surefire}</version>\n         <configuration>\n           <includes>\n             <include>**/*IT.java</include>\ndiff --git a/src/main/java/module-info.java b/src/main/java/module-info.java\nindex 4480ec5aaf..db110119fc 100644\n--- a/src/main/java/module-info.java\n+++ b/src/main/java/module-info.java\n@@ -18,19 +18,8 @@\n     exports tools.jackson.core.util;\n \n     // But opens only for unit test suite; as well as some extra exports\n-    opens tools.jackson.core to tools.jackson.core.testutil;\n-    opens tools.jackson.core.async to tools.jackson.core.testutil;\n-    opens tools.jackson.core.base to tools.jackson.core.testutil;\n-    opens tools.jackson.core.exc to tools.jackson.core.testutil;\n-    opens tools.jackson.core.filter to tools.jackson.core.testutil;\n-    opens tools.jackson.core.io to tools.jackson.core.testutil;\n-    exports tools.jackson.core.io.schubfach to tools.jackson.core.testutil;\n-    opens tools.jackson.core.json to tools.jackson.core.testutil;\n-    opens tools.jackson.core.json.async to tools.jackson.core.testutil;\n-    opens tools.jackson.core.sym to tools.jackson.core.testutil;\n-    opens tools.jackson.core.tree to tools.jackson.core.testutil;\n-    opens tools.jackson.core.type to tools.jackson.core.testutil;\n-    opens tools.jackson.core.util to tools.jackson.core.testutil;\n+    exports tools.jackson.core.io.schubfach to tools.jackson.core.unittest;\n+    opens tools.jackson.core.json to tools.jackson.core.unittest;\n \n     provides tools.jackson.core.TokenStreamFactory with\n         tools.jackson.core.json.JsonFactory;\n",
  "test_patch" : "diff --git a/src/test/java/module-info.java b/src/test/java/module-info.java\nindex 47e16dba17..89677a12ba 100644\n--- a/src/test/java/module-info.java\n+++ b/src/test/java/module-info.java\n@@ -1,6 +1,6 @@\n // jackson-core test Module descriptor: used both for tests and to\n // to produce \"test-jar\" for other Jackson components to use\n-module tools.jackson.core.testutil\n+module tools.jackson.core.unittest\n {\n     // Additional test lib/framework dependencies\n     requires org.assertj.core;\n@@ -11,10 +11,10 @@\n     requires tools.jackson.core;\n \n     // Exports/opens a small set of Classes for downstream Jackson components\n-    exports tools.jackson.core.testutil;\n-    exports tools.jackson.core.testutil.failure;\n-    opens tools.jackson.core.testutil;\n-    opens tools.jackson.core.testutil.failure;\n+    exports tools.jackson.core.unittest.testutil;\n+    exports tools.jackson.core.unittest.testutil.failure;\n+    opens tools.jackson.core.unittest.testutil;\n+    opens tools.jackson.core.unittest.testutil.failure;\n \n     // Additional test opens for Unit tests\n \ndiff --git a/src/test/java/tools/jackson/core/unittest/JacksonCoreTestBase.java b/src/test/java/tools/jackson/core/unittest/JacksonCoreTestBase.java\nindex 0afba59e3a..3a5618e2a8 100644\n--- a/src/test/java/tools/jackson/core/unittest/JacksonCoreTestBase.java\n+++ b/src/test/java/tools/jackson/core/unittest/JacksonCoreTestBase.java\n@@ -10,10 +10,10 @@\n import tools.jackson.core.TokenStreamFactory;\n import tools.jackson.core.json.JsonFactory;\n import tools.jackson.core.json.JsonFactoryBuilder;\n-import tools.jackson.core.testutil.JacksonTestUtilBase;\n-import tools.jackson.core.testutil.MockDataInput;\n-import tools.jackson.core.testutil.ThrottledInputStream;\n-import tools.jackson.core.testutil.ThrottledReader;\n+import tools.jackson.core.unittest.testutil.JacksonTestUtilBase;\n+import tools.jackson.core.unittest.testutil.MockDataInput;\n+import tools.jackson.core.unittest.testutil.ThrottledInputStream;\n+import tools.jackson.core.unittest.testutil.ThrottledReader;\n \n /**\n  * Base class for Jackson-core unit tests, using JUnit 5.\ndiff --git a/src/test/java/tools/jackson/core/unittest/async/AsyncTestBase.java b/src/test/java/tools/jackson/core/unittest/async/AsyncTestBase.java\nindex 5c95e1d1d6..d216da2f98 100644\n--- a/src/test/java/tools/jackson/core/unittest/async/AsyncTestBase.java\n+++ b/src/test/java/tools/jackson/core/unittest/async/AsyncTestBase.java\n@@ -5,10 +5,10 @@\n import tools.jackson.core.ObjectReadContext;\n import tools.jackson.core.TokenStreamFactory;\n import tools.jackson.core.json.JsonFactory;\n-import tools.jackson.core.testutil.AsyncReaderWrapper;\n-import tools.jackson.core.testutil.AsyncReaderWrapperForByteArray;\n-import tools.jackson.core.testutil.AsyncReaderWrapperForByteBuffer;\n import tools.jackson.core.unittest.*;\n+import tools.jackson.core.unittest.testutil.AsyncReaderWrapper;\n+import tools.jackson.core.unittest.testutil.AsyncReaderWrapperForByteArray;\n+import tools.jackson.core.unittest.testutil.AsyncReaderWrapperForByteBuffer;\n \n public abstract class AsyncTestBase extends JacksonCoreTestBase\n {\ndiff --git a/src/test/java/tools/jackson/core/unittest/base64/Base64GenerationTest.java b/src/test/java/tools/jackson/core/unittest/base64/Base64GenerationTest.java\nindex f1521d82db..833fbbc04a 100644\n--- a/src/test/java/tools/jackson/core/unittest/base64/Base64GenerationTest.java\n+++ b/src/test/java/tools/jackson/core/unittest/base64/Base64GenerationTest.java\n@@ -13,8 +13,8 @@\n import tools.jackson.core.ObjectReadContext;\n import tools.jackson.core.ObjectWriteContext;\n import tools.jackson.core.json.JsonFactory;\n-import tools.jackson.core.testutil.ThrottledInputStream;\n import tools.jackson.core.unittest.*;\n+import tools.jackson.core.unittest.testutil.ThrottledInputStream;\n \n import static org.junit.jupiter.api.Assertions.assertEquals;\n \ndiff --git a/src/test/java/tools/jackson/core/unittest/constraints/LargeDocReadTest.java b/src/test/java/tools/jackson/core/unittest/constraints/LargeDocReadTest.java\nindex bfd7c6f37f..4e34492906 100644\n--- a/src/test/java/tools/jackson/core/unittest/constraints/LargeDocReadTest.java\n+++ b/src/test/java/tools/jackson/core/unittest/constraints/LargeDocReadTest.java\n@@ -8,8 +8,8 @@\n import tools.jackson.core.StreamReadConstraints;\n import tools.jackson.core.exc.StreamConstraintsException;\n import tools.jackson.core.json.JsonFactory;\n-import tools.jackson.core.testutil.AsyncReaderWrapper;\n import tools.jackson.core.unittest.async.AsyncTestBase;\n+import tools.jackson.core.unittest.testutil.AsyncReaderWrapper;\n \n import static org.junit.jupiter.api.Assertions.assertEquals;\n import static org.junit.jupiter.api.Assertions.fail;\ndiff --git a/src/test/java/tools/jackson/core/unittest/fuzz/Fuzz32208UTF32ParseTest.java b/src/test/java/tools/jackson/core/unittest/fuzz/Fuzz32208UTF32ParseTest.java\nindex 927f7abc7e..41cd190048 100644\n--- a/src/test/java/tools/jackson/core/unittest/fuzz/Fuzz32208UTF32ParseTest.java\n+++ b/src/test/java/tools/jackson/core/unittest/fuzz/Fuzz32208UTF32ParseTest.java\n@@ -12,8 +12,8 @@\n import tools.jackson.core.exc.JacksonIOException;\n import tools.jackson.core.io.UTF32Reader;\n import tools.jackson.core.json.JsonFactory;\n-import tools.jackson.core.testutil.ThrottledInputStream;\n import tools.jackson.core.unittest.*;\n+import tools.jackson.core.unittest.testutil.ThrottledInputStream;\n \n import static org.junit.jupiter.api.Assertions.fail;\n \ndiff --git a/src/test/java/tools/jackson/core/unittest/fuzz/Fuzz52688ParseTest.java b/src/test/java/tools/jackson/core/unittest/fuzz/Fuzz52688ParseTest.java\nindex c1bb496f66..5104680f3a 100644\n--- a/src/test/java/tools/jackson/core/unittest/fuzz/Fuzz52688ParseTest.java\n+++ b/src/test/java/tools/jackson/core/unittest/fuzz/Fuzz52688ParseTest.java\n@@ -10,8 +10,8 @@\n import tools.jackson.core.ObjectReadContext;\n import tools.jackson.core.exc.StreamReadException;\n import tools.jackson.core.json.JsonFactory;\n-import tools.jackson.core.testutil.ThrottledInputStream;\n import tools.jackson.core.unittest.*;\n+import tools.jackson.core.unittest.testutil.ThrottledInputStream;\n \n import static org.junit.jupiter.api.Assertions.assertEquals;\n import static org.junit.jupiter.api.Assertions.fail;\ndiff --git a/src/test/java/tools/jackson/core/unittest/json/JsonParserClosedCaseTest.java b/src/test/java/tools/jackson/core/unittest/json/JsonParserClosedCaseTest.java\nindex 50e1eb634c..f846b52443 100644\n--- a/src/test/java/tools/jackson/core/unittest/json/JsonParserClosedCaseTest.java\n+++ b/src/test/java/tools/jackson/core/unittest/json/JsonParserClosedCaseTest.java\n@@ -12,8 +12,8 @@\n import tools.jackson.core.*;\n import tools.jackson.core.io.SerializedString;\n import tools.jackson.core.json.JsonFactory;\n-import tools.jackson.core.testutil.MockDataInput;\n import tools.jackson.core.unittest.JacksonCoreTestBase;\n+import tools.jackson.core.unittest.testutil.MockDataInput;\n \n import static org.junit.jupiter.api.Assertions.assertFalse;\n import static org.junit.jupiter.api.Assertions.assertNull;\ndiff --git a/src/test/java/tools/jackson/core/unittest/json/async/AsyncBinaryParseTest.java b/src/test/java/tools/jackson/core/unittest/json/async/AsyncBinaryParseTest.java\nindex 502ad00373..13143c0681 100644\n--- a/src/test/java/tools/jackson/core/unittest/json/async/AsyncBinaryParseTest.java\n+++ b/src/test/java/tools/jackson/core/unittest/json/async/AsyncBinaryParseTest.java\n@@ -8,8 +8,8 @@\n import tools.jackson.core.JsonToken;\n import tools.jackson.core.ObjectWriteContext;\n import tools.jackson.core.json.JsonFactory;\n-import tools.jackson.core.testutil.AsyncReaderWrapper;\n import tools.jackson.core.unittest.async.AsyncTestBase;\n+import tools.jackson.core.unittest.testutil.AsyncReaderWrapper;\n \n import static org.junit.jupiter.api.Assertions.*;\n \ndiff --git a/src/test/java/tools/jackson/core/unittest/json/async/AsyncCharEscapingTest.java b/src/test/java/tools/jackson/core/unittest/json/async/AsyncCharEscapingTest.java\nindex 91dd728126..f6fe22fbe9 100644\n--- a/src/test/java/tools/jackson/core/unittest/json/async/AsyncCharEscapingTest.java\n+++ b/src/test/java/tools/jackson/core/unittest/json/async/AsyncCharEscapingTest.java\n@@ -5,8 +5,8 @@\n import tools.jackson.core.JsonToken;\n import tools.jackson.core.exc.StreamReadException;\n import tools.jackson.core.json.JsonFactory;\n-import tools.jackson.core.testutil.AsyncReaderWrapper;\n import tools.jackson.core.unittest.async.AsyncTestBase;\n+import tools.jackson.core.unittest.testutil.AsyncReaderWrapper;\n \n import static org.junit.jupiter.api.Assertions.assertEquals;\n import static org.junit.jupiter.api.Assertions.fail;\ndiff --git a/src/test/java/tools/jackson/core/unittest/json/async/AsyncCommentParsingTest.java b/src/test/java/tools/jackson/core/unittest/json/async/AsyncCommentParsingTest.java\nindex e9ef9e41bb..d5e3cd1b1d 100644\n--- a/src/test/java/tools/jackson/core/unittest/json/async/AsyncCommentParsingTest.java\n+++ b/src/test/java/tools/jackson/core/unittest/json/async/AsyncCommentParsingTest.java\n@@ -8,8 +8,8 @@\n import tools.jackson.core.exc.StreamReadException;\n import tools.jackson.core.json.JsonFactory;\n import tools.jackson.core.json.JsonReadFeature;\n-import tools.jackson.core.testutil.AsyncReaderWrapper;\n import tools.jackson.core.unittest.async.AsyncTestBase;\n+import tools.jackson.core.unittest.testutil.AsyncReaderWrapper;\n \n import static org.junit.jupiter.api.Assertions.*;\n \ndiff --git a/src/test/java/tools/jackson/core/unittest/json/async/AsyncConcurrencyByteBufferTest.java b/src/test/java/tools/jackson/core/unittest/json/async/AsyncConcurrencyByteBufferTest.java\nindex ea3bb7a8e5..033944711d 100644\n--- a/src/test/java/tools/jackson/core/unittest/json/async/AsyncConcurrencyByteBufferTest.java\n+++ b/src/test/java/tools/jackson/core/unittest/json/async/AsyncConcurrencyByteBufferTest.java\n@@ -2,7 +2,7 @@\n \n import java.io.IOException;\n \n-import tools.jackson.core.testutil.AsyncReaderWrapper;\n+import tools.jackson.core.unittest.testutil.AsyncReaderWrapper;\n \n public class AsyncConcurrencyByteBufferTest extends AsyncConcurrencyTest {\n \ndiff --git a/src/test/java/tools/jackson/core/unittest/json/async/AsyncConcurrencyTest.java b/src/test/java/tools/jackson/core/unittest/json/async/AsyncConcurrencyTest.java\nindex 3f62ad83fa..b12ef60a38 100644\n--- a/src/test/java/tools/jackson/core/unittest/json/async/AsyncConcurrencyTest.java\n+++ b/src/test/java/tools/jackson/core/unittest/json/async/AsyncConcurrencyTest.java\n@@ -10,8 +10,8 @@\n \n import tools.jackson.core.JsonToken;\n import tools.jackson.core.json.JsonFactory;\n-import tools.jackson.core.testutil.AsyncReaderWrapper;\n import tools.jackson.core.unittest.async.AsyncTestBase;\n+import tools.jackson.core.unittest.testutil.AsyncReaderWrapper;\n \n import static org.junit.jupiter.api.Assertions.fail;\n \ndiff --git a/src/test/java/tools/jackson/core/unittest/json/async/AsyncInvalidCharsTest.java b/src/test/java/tools/jackson/core/unittest/json/async/AsyncInvalidCharsTest.java\nindex 88253e7a83..ff6bc34c12 100644\n--- a/src/test/java/tools/jackson/core/unittest/json/async/AsyncInvalidCharsTest.java\n+++ b/src/test/java/tools/jackson/core/unittest/json/async/AsyncInvalidCharsTest.java\n@@ -8,8 +8,8 @@\n import tools.jackson.core.TokenStreamLocation;\n import tools.jackson.core.exc.StreamReadException;\n import tools.jackson.core.json.JsonFactory;\n-import tools.jackson.core.testutil.AsyncReaderWrapper;\n import tools.jackson.core.unittest.async.AsyncTestBase;\n+import tools.jackson.core.unittest.testutil.AsyncReaderWrapper;\n \n import static org.junit.jupiter.api.Assertions.assertEquals;\n import static org.junit.jupiter.api.Assertions.fail;\ndiff --git a/src/test/java/tools/jackson/core/unittest/json/async/AsyncMissingValuesInArrayTest.java b/src/test/java/tools/jackson/core/unittest/json/async/AsyncMissingValuesInArrayTest.java\nindex 2a26692473..61df2e5760 100644\n--- a/src/test/java/tools/jackson/core/unittest/json/async/AsyncMissingValuesInArrayTest.java\n+++ b/src/test/java/tools/jackson/core/unittest/json/async/AsyncMissingValuesInArrayTest.java\n@@ -10,8 +10,8 @@\n import tools.jackson.core.json.JsonFactory;\n import tools.jackson.core.json.JsonFactoryBuilder;\n import tools.jackson.core.json.JsonReadFeature;\n-import tools.jackson.core.testutil.AsyncReaderWrapper;\n import tools.jackson.core.unittest.async.AsyncTestBase;\n+import tools.jackson.core.unittest.testutil.AsyncReaderWrapper;\n \n import static org.junit.jupiter.api.Assertions.*;\n \ndiff --git a/src/test/java/tools/jackson/core/unittest/json/async/AsyncMissingValuesInObjectTest.java b/src/test/java/tools/jackson/core/unittest/json/async/AsyncMissingValuesInObjectTest.java\nindex f61550f9f6..91189ce9bc 100644\n--- a/src/test/java/tools/jackson/core/unittest/json/async/AsyncMissingValuesInObjectTest.java\n+++ b/src/test/java/tools/jackson/core/unittest/json/async/AsyncMissingValuesInObjectTest.java\n@@ -10,8 +10,8 @@\n import tools.jackson.core.json.JsonFactory;\n import tools.jackson.core.json.JsonFactoryBuilder;\n import tools.jackson.core.json.JsonReadFeature;\n-import tools.jackson.core.testutil.AsyncReaderWrapper;\n import tools.jackson.core.unittest.async.AsyncTestBase;\n+import tools.jackson.core.unittest.testutil.AsyncReaderWrapper;\n \n import static org.junit.jupiter.api.Assertions.*;\n \ndiff --git a/src/test/java/tools/jackson/core/unittest/json/async/AsyncNaNHandlingTest.java b/src/test/java/tools/jackson/core/unittest/json/async/AsyncNaNHandlingTest.java\nindex c807ba8412..9dfccc0dae 100644\n--- a/src/test/java/tools/jackson/core/unittest/json/async/AsyncNaNHandlingTest.java\n+++ b/src/test/java/tools/jackson/core/unittest/json/async/AsyncNaNHandlingTest.java\n@@ -7,8 +7,8 @@\n import tools.jackson.core.JsonToken;\n import tools.jackson.core.json.JsonFactory;\n import tools.jackson.core.json.JsonReadFeature;\n-import tools.jackson.core.testutil.AsyncReaderWrapper;\n import tools.jackson.core.unittest.async.AsyncTestBase;\n+import tools.jackson.core.unittest.testutil.AsyncReaderWrapper;\n \n import static org.junit.jupiter.api.Assertions.*;\n \ndiff --git a/src/test/java/tools/jackson/core/unittest/json/async/AsyncNonStandardNumberParsingTest.java b/src/test/java/tools/jackson/core/unittest/json/async/AsyncNonStandardNumberParsingTest.java\nindex 9cd669aa01..4a01fabf9f 100644\n--- a/src/test/java/tools/jackson/core/unittest/json/async/AsyncNonStandardNumberParsingTest.java\n+++ b/src/test/java/tools/jackson/core/unittest/json/async/AsyncNonStandardNumberParsingTest.java\n@@ -8,8 +8,8 @@\n import tools.jackson.core.exc.StreamReadException;\n import tools.jackson.core.json.JsonFactory;\n import tools.jackson.core.json.JsonReadFeature;\n-import tools.jackson.core.testutil.AsyncReaderWrapper;\n import tools.jackson.core.unittest.async.AsyncTestBase;\n+import tools.jackson.core.unittest.testutil.AsyncReaderWrapper;\n \n import static org.junit.jupiter.api.Assertions.assertEquals;\n import static org.junit.jupiter.api.Assertions.fail;\ndiff --git a/src/test/java/tools/jackson/core/unittest/json/async/AsyncNonStdNumberHandlingTest.java b/src/test/java/tools/jackson/core/unittest/json/async/AsyncNonStdNumberHandlingTest.java\nindex b7973581bb..ff73f82a3c 100644\n--- a/src/test/java/tools/jackson/core/unittest/json/async/AsyncNonStdNumberHandlingTest.java\n+++ b/src/test/java/tools/jackson/core/unittest/json/async/AsyncNonStdNumberHandlingTest.java\n@@ -6,8 +6,8 @@\n import tools.jackson.core.exc.StreamReadException;\n import tools.jackson.core.json.JsonFactory;\n import tools.jackson.core.json.JsonReadFeature;\n-import tools.jackson.core.testutil.AsyncReaderWrapper;\n import tools.jackson.core.unittest.async.AsyncTestBase;\n+import tools.jackson.core.unittest.testutil.AsyncReaderWrapper;\n \n import static org.junit.jupiter.api.Assertions.*;\n \ndiff --git a/src/test/java/tools/jackson/core/unittest/json/async/AsyncNonStdParsingTest.java b/src/test/java/tools/jackson/core/unittest/json/async/AsyncNonStdParsingTest.java\nindex 4df3c5d23f..a022ff1d97 100644\n--- a/src/test/java/tools/jackson/core/unittest/json/async/AsyncNonStdParsingTest.java\n+++ b/src/test/java/tools/jackson/core/unittest/json/async/AsyncNonStdParsingTest.java\n@@ -6,9 +6,8 @@\n import tools.jackson.core.exc.StreamReadException;\n import tools.jackson.core.json.JsonFactory;\n import tools.jackson.core.json.JsonReadFeature;\n-import tools.jackson.core.testutil.AsyncReaderWrapper;\n-\n import tools.jackson.core.unittest.async.AsyncTestBase;\n+import tools.jackson.core.unittest.testutil.AsyncReaderWrapper;\n \n import static org.junit.jupiter.api.Assertions.assertEquals;\n import static org.junit.jupiter.api.Assertions.fail;\ndiff --git a/src/test/java/tools/jackson/core/unittest/json/async/AsyncNumberCoercionTest.java b/src/test/java/tools/jackson/core/unittest/json/async/AsyncNumberCoercionTest.java\nindex d34d63d81e..80b8cff7c7 100644\n--- a/src/test/java/tools/jackson/core/unittest/json/async/AsyncNumberCoercionTest.java\n+++ b/src/test/java/tools/jackson/core/unittest/json/async/AsyncNumberCoercionTest.java\n@@ -10,8 +10,8 @@\n import tools.jackson.core.JsonToken;\n import tools.jackson.core.exc.InputCoercionException;\n import tools.jackson.core.json.JsonFactory;\n-import tools.jackson.core.testutil.AsyncReaderWrapper;\n import tools.jackson.core.unittest.async.AsyncTestBase;\n+import tools.jackson.core.unittest.testutil.AsyncReaderWrapper;\n \n import static org.junit.jupiter.api.Assertions.assertEquals;\n import static org.junit.jupiter.api.Assertions.fail;\ndiff --git a/src/test/java/tools/jackson/core/unittest/json/async/AsyncNumberDeferredReadTest.java b/src/test/java/tools/jackson/core/unittest/json/async/AsyncNumberDeferredReadTest.java\nindex 3e5ba2e1ca..9287d1aa84 100644\n--- a/src/test/java/tools/jackson/core/unittest/json/async/AsyncNumberDeferredReadTest.java\n+++ b/src/test/java/tools/jackson/core/unittest/json/async/AsyncNumberDeferredReadTest.java\n@@ -9,8 +9,8 @@\n import tools.jackson.core.JsonToken;\n import tools.jackson.core.JsonParser.NumberType;\n import tools.jackson.core.json.JsonFactory;\n-import tools.jackson.core.testutil.AsyncReaderWrapper;\n import tools.jackson.core.unittest.async.AsyncTestBase;\n+import tools.jackson.core.unittest.testutil.AsyncReaderWrapper;\n \n import static org.junit.jupiter.api.Assertions.assertEquals;\n import static org.junit.jupiter.api.Assertions.assertNull;\ndiff --git a/src/test/java/tools/jackson/core/unittest/json/async/AsyncParserNamesTest.java b/src/test/java/tools/jackson/core/unittest/json/async/AsyncParserNamesTest.java\nindex 4077f9e3bf..04802b12a6 100644\n--- a/src/test/java/tools/jackson/core/unittest/json/async/AsyncParserNamesTest.java\n+++ b/src/test/java/tools/jackson/core/unittest/json/async/AsyncParserNamesTest.java\n@@ -10,8 +10,8 @@\n import tools.jackson.core.json.JsonFactory;\n import tools.jackson.core.json.async.NonBlockingJsonParserBase;\n import tools.jackson.core.sym.ByteQuadsCanonicalizer;\n-import tools.jackson.core.testutil.AsyncReaderWrapper;\n import tools.jackson.core.unittest.async.AsyncTestBase;\n+import tools.jackson.core.unittest.testutil.AsyncReaderWrapper;\n \n import static org.junit.jupiter.api.Assertions.*;\n \ndiff --git a/src/test/java/tools/jackson/core/unittest/json/async/AsyncPointerFromContext563Test.java b/src/test/java/tools/jackson/core/unittest/json/async/AsyncPointerFromContext563Test.java\nindex 9286f7de77..9e9af8685e 100644\n--- a/src/test/java/tools/jackson/core/unittest/json/async/AsyncPointerFromContext563Test.java\n+++ b/src/test/java/tools/jackson/core/unittest/json/async/AsyncPointerFromContext563Test.java\n@@ -5,8 +5,8 @@\n import tools.jackson.core.JsonPointer;\n import tools.jackson.core.JsonToken;\n import tools.jackson.core.json.JsonFactory;\n-import tools.jackson.core.testutil.AsyncReaderWrapper;\n import tools.jackson.core.unittest.async.AsyncTestBase;\n+import tools.jackson.core.unittest.testutil.AsyncReaderWrapper;\n \n import static org.junit.jupiter.api.Assertions.*;\n \ndiff --git a/src/test/java/tools/jackson/core/unittest/json/async/AsyncPropertyNamesTest.java b/src/test/java/tools/jackson/core/unittest/json/async/AsyncPropertyNamesTest.java\nindex bbb1e207cd..1118f2b279 100644\n--- a/src/test/java/tools/jackson/core/unittest/json/async/AsyncPropertyNamesTest.java\n+++ b/src/test/java/tools/jackson/core/unittest/json/async/AsyncPropertyNamesTest.java\n@@ -8,8 +8,8 @@\n import tools.jackson.core.TokenStreamLocation;\n import tools.jackson.core.json.JsonFactory;\n import tools.jackson.core.json.JsonReadFeature;\n-import tools.jackson.core.testutil.AsyncReaderWrapper;\n import tools.jackson.core.unittest.async.AsyncTestBase;\n+import tools.jackson.core.unittest.testutil.AsyncReaderWrapper;\n \n import static org.junit.jupiter.api.Assertions.assertEquals;\n import static org.junit.jupiter.api.Assertions.assertNull;\ndiff --git a/src/test/java/tools/jackson/core/unittest/json/async/AsyncRootNumbersTest.java b/src/test/java/tools/jackson/core/unittest/json/async/AsyncRootNumbersTest.java\nindex add275a99e..85b28307d4 100644\n--- a/src/test/java/tools/jackson/core/unittest/json/async/AsyncRootNumbersTest.java\n+++ b/src/test/java/tools/jackson/core/unittest/json/async/AsyncRootNumbersTest.java\n@@ -6,8 +6,8 @@\n \n import tools.jackson.core.JsonToken;\n import tools.jackson.core.json.JsonFactory;\n-import tools.jackson.core.testutil.AsyncReaderWrapper;\n import tools.jackson.core.unittest.async.AsyncTestBase;\n+import tools.jackson.core.unittest.testutil.AsyncReaderWrapper;\n \n import static org.junit.jupiter.api.Assertions.*;\n \ndiff --git a/src/test/java/tools/jackson/core/unittest/json/async/AsyncRootValuesTest.java b/src/test/java/tools/jackson/core/unittest/json/async/AsyncRootValuesTest.java\nindex a629753e0b..d7a4695841 100644\n--- a/src/test/java/tools/jackson/core/unittest/json/async/AsyncRootValuesTest.java\n+++ b/src/test/java/tools/jackson/core/unittest/json/async/AsyncRootValuesTest.java\n@@ -7,8 +7,8 @@\n \n import tools.jackson.core.JsonToken;\n import tools.jackson.core.json.JsonFactory;\n-import tools.jackson.core.testutil.AsyncReaderWrapper;\n import tools.jackson.core.unittest.async.AsyncTestBase;\n+import tools.jackson.core.unittest.testutil.AsyncReaderWrapper;\n \n import static org.junit.jupiter.api.Assertions.*;\n \ndiff --git a/src/test/java/tools/jackson/core/unittest/json/async/AsyncScalarArrayTest.java b/src/test/java/tools/jackson/core/unittest/json/async/AsyncScalarArrayTest.java\nindex 39092d5f69..b5b46dc1b8 100644\n--- a/src/test/java/tools/jackson/core/unittest/json/async/AsyncScalarArrayTest.java\n+++ b/src/test/java/tools/jackson/core/unittest/json/async/AsyncScalarArrayTest.java\n@@ -11,8 +11,8 @@\n import tools.jackson.core.ObjectWriteContext;\n import tools.jackson.core.JsonParser.NumberType;\n import tools.jackson.core.json.JsonFactory;\n-import tools.jackson.core.testutil.AsyncReaderWrapper;\n import tools.jackson.core.unittest.async.AsyncTestBase;\n+import tools.jackson.core.unittest.testutil.AsyncReaderWrapper;\n \n import static org.junit.jupiter.api.Assertions.*;\n \ndiff --git a/src/test/java/tools/jackson/core/unittest/json/async/AsyncScopeMatchingTest.java b/src/test/java/tools/jackson/core/unittest/json/async/AsyncScopeMatchingTest.java\nindex e7ddbf3b45..490b27deb0 100644\n--- a/src/test/java/tools/jackson/core/unittest/json/async/AsyncScopeMatchingTest.java\n+++ b/src/test/java/tools/jackson/core/unittest/json/async/AsyncScopeMatchingTest.java\n@@ -5,8 +5,8 @@\n import tools.jackson.core.JsonToken;\n import tools.jackson.core.exc.StreamReadException;\n import tools.jackson.core.json.JsonFactory;\n-import tools.jackson.core.testutil.AsyncReaderWrapper;\n import tools.jackson.core.unittest.async.AsyncTestBase;\n+import tools.jackson.core.unittest.testutil.AsyncReaderWrapper;\n \n import static org.junit.jupiter.api.Assertions.assertEquals;\n import static org.junit.jupiter.api.Assertions.fail;\ndiff --git a/src/test/java/tools/jackson/core/unittest/json/async/AsyncSimpleNestedTest.java b/src/test/java/tools/jackson/core/unittest/json/async/AsyncSimpleNestedTest.java\nindex 2f734a664c..997a789f2f 100644\n--- a/src/test/java/tools/jackson/core/unittest/json/async/AsyncSimpleNestedTest.java\n+++ b/src/test/java/tools/jackson/core/unittest/json/async/AsyncSimpleNestedTest.java\n@@ -5,8 +5,8 @@\n import tools.jackson.core.JsonToken;\n import tools.jackson.core.exc.StreamReadException;\n import tools.jackson.core.json.JsonFactory;\n-import tools.jackson.core.testutil.AsyncReaderWrapper;\n import tools.jackson.core.unittest.async.AsyncTestBase;\n+import tools.jackson.core.unittest.testutil.AsyncReaderWrapper;\n \n import static org.junit.jupiter.api.Assertions.*;\n \ndiff --git a/src/test/java/tools/jackson/core/unittest/json/async/AsyncSimpleObjectTest.java b/src/test/java/tools/jackson/core/unittest/json/async/AsyncSimpleObjectTest.java\nindex aaf903721f..caf4dd0c4c 100644\n--- a/src/test/java/tools/jackson/core/unittest/json/async/AsyncSimpleObjectTest.java\n+++ b/src/test/java/tools/jackson/core/unittest/json/async/AsyncSimpleObjectTest.java\n@@ -12,8 +12,8 @@\n import tools.jackson.core.exc.InputCoercionException;\n import tools.jackson.core.exc.StreamReadException;\n import tools.jackson.core.json.JsonFactory;\n-import tools.jackson.core.testutil.AsyncReaderWrapper;\n import tools.jackson.core.unittest.async.AsyncTestBase;\n+import tools.jackson.core.unittest.testutil.AsyncReaderWrapper;\n \n import static org.junit.jupiter.api.Assertions.*;\n \ndiff --git a/src/test/java/tools/jackson/core/unittest/json/async/AsyncStringArrayTest.java b/src/test/java/tools/jackson/core/unittest/json/async/AsyncStringArrayTest.java\nindex 891021efe9..a2578addc5 100644\n--- a/src/test/java/tools/jackson/core/unittest/json/async/AsyncStringArrayTest.java\n+++ b/src/test/java/tools/jackson/core/unittest/json/async/AsyncStringArrayTest.java\n@@ -11,8 +11,8 @@\n import tools.jackson.core.ObjectWriteContext;\n import tools.jackson.core.StreamReadConstraints;\n import tools.jackson.core.json.JsonFactory;\n-import tools.jackson.core.testutil.AsyncReaderWrapper;\n import tools.jackson.core.unittest.async.AsyncTestBase;\n+import tools.jackson.core.unittest.testutil.AsyncReaderWrapper;\n \n import static org.junit.jupiter.api.Assertions.*;\n \ndiff --git a/src/test/java/tools/jackson/core/unittest/json/async/AsyncStringObjectTest.java b/src/test/java/tools/jackson/core/unittest/json/async/AsyncStringObjectTest.java\nindex 2007e58a61..14bd6c1602 100644\n--- a/src/test/java/tools/jackson/core/unittest/json/async/AsyncStringObjectTest.java\n+++ b/src/test/java/tools/jackson/core/unittest/json/async/AsyncStringObjectTest.java\n@@ -6,8 +6,8 @@\n \n import tools.jackson.core.JsonToken;\n import tools.jackson.core.json.JsonFactory;\n-import tools.jackson.core.testutil.AsyncReaderWrapper;\n import tools.jackson.core.unittest.async.AsyncTestBase;\n+import tools.jackson.core.unittest.testutil.AsyncReaderWrapper;\n \n import static org.junit.jupiter.api.Assertions.*;\n \ndiff --git a/src/test/java/tools/jackson/core/unittest/json/async/AsyncUnicodeHandlingTest.java b/src/test/java/tools/jackson/core/unittest/json/async/AsyncUnicodeHandlingTest.java\nindex 7dc58e329a..c0d97151ad 100644\n--- a/src/test/java/tools/jackson/core/unittest/json/async/AsyncUnicodeHandlingTest.java\n+++ b/src/test/java/tools/jackson/core/unittest/json/async/AsyncUnicodeHandlingTest.java\n@@ -6,8 +6,8 @@\n \n import tools.jackson.core.JsonToken;\n import tools.jackson.core.json.JsonFactory;\n-import tools.jackson.core.testutil.AsyncReaderWrapper;\n import tools.jackson.core.unittest.async.AsyncTestBase;\n+import tools.jackson.core.unittest.testutil.AsyncReaderWrapper;\n \n import static org.junit.jupiter.api.Assertions.assertEquals;\n import static org.junit.jupiter.api.Assertions.assertNull;\ndiff --git a/src/test/java/tools/jackson/core/unittest/json/async/ConfigTest.java b/src/test/java/tools/jackson/core/unittest/json/async/ConfigTest.java\nindex c1c356f4fc..8884c90d99 100644\n--- a/src/test/java/tools/jackson/core/unittest/json/async/ConfigTest.java\n+++ b/src/test/java/tools/jackson/core/unittest/json/async/ConfigTest.java\n@@ -7,8 +7,8 @@\n import tools.jackson.core.JsonParser;\n import tools.jackson.core.JsonToken;\n import tools.jackson.core.json.JsonFactory;\n-import tools.jackson.core.testutil.AsyncReaderWrapper;\n import tools.jackson.core.unittest.async.AsyncTestBase;\n+import tools.jackson.core.unittest.testutil.AsyncReaderWrapper;\n \n import static org.junit.jupiter.api.Assertions.*;\n \ndiff --git a/src/test/java/tools/jackson/core/unittest/read/SimpleParserTest.java b/src/test/java/tools/jackson/core/unittest/read/SimpleParserTest.java\nindex 298581c980..30fc75231e 100644\n--- a/src/test/java/tools/jackson/core/unittest/read/SimpleParserTest.java\n+++ b/src/test/java/tools/jackson/core/unittest/read/SimpleParserTest.java\n@@ -15,8 +15,8 @@\n import tools.jackson.core.TokenStreamLocation;\n import tools.jackson.core.exc.StreamReadException;\n import tools.jackson.core.json.JsonFactory;\n-import tools.jackson.core.testutil.MockDataInput;\n import tools.jackson.core.unittest.*;\n+import tools.jackson.core.unittest.testutil.MockDataInput;\n import tools.jackson.core.util.JsonParserDelegate;\n \n import static org.junit.jupiter.api.Assertions.*;\ndiff --git a/src/test/java/tools/jackson/core/testutil/AsyncReaderWrapper.java b/src/test/java/tools/jackson/core/unittest/testutil/AsyncReaderWrapper.java\nsimilarity index 98%\nrename from src/test/java/tools/jackson/core/testutil/AsyncReaderWrapper.java\nrename to src/test/java/tools/jackson/core/unittest/testutil/AsyncReaderWrapper.java\nindex 49786ae693..a40415e800 100644\n--- a/src/test/java/tools/jackson/core/testutil/AsyncReaderWrapper.java\n+++ b/src/test/java/tools/jackson/core/unittest/testutil/AsyncReaderWrapper.java\n@@ -1,4 +1,4 @@\n-package tools.jackson.core.testutil;\n+package tools.jackson.core.unittest.testutil;\n \n import java.io.StringWriter;\n import java.math.BigDecimal;\ndiff --git a/src/test/java/tools/jackson/core/testutil/AsyncReaderWrapperForByteArray.java b/src/test/java/tools/jackson/core/unittest/testutil/AsyncReaderWrapperForByteArray.java\nsimilarity index 97%\nrename from src/test/java/tools/jackson/core/testutil/AsyncReaderWrapperForByteArray.java\nrename to src/test/java/tools/jackson/core/unittest/testutil/AsyncReaderWrapperForByteArray.java\nindex 22f93ce938..2acccc9050 100644\n--- a/src/test/java/tools/jackson/core/testutil/AsyncReaderWrapperForByteArray.java\n+++ b/src/test/java/tools/jackson/core/unittest/testutil/AsyncReaderWrapperForByteArray.java\n@@ -1,4 +1,4 @@\n-package tools.jackson.core.testutil;\n+package tools.jackson.core.unittest.testutil;\n \n import tools.jackson.core.JsonParser;\n import tools.jackson.core.JsonToken;\ndiff --git a/src/test/java/tools/jackson/core/testutil/AsyncReaderWrapperForByteBuffer.java b/src/test/java/tools/jackson/core/unittest/testutil/AsyncReaderWrapperForByteBuffer.java\nsimilarity index 97%\nrename from src/test/java/tools/jackson/core/testutil/AsyncReaderWrapperForByteBuffer.java\nrename to src/test/java/tools/jackson/core/unittest/testutil/AsyncReaderWrapperForByteBuffer.java\nindex 68d1528daa..dbf562d59e 100644\n--- a/src/test/java/tools/jackson/core/testutil/AsyncReaderWrapperForByteBuffer.java\n+++ b/src/test/java/tools/jackson/core/unittest/testutil/AsyncReaderWrapperForByteBuffer.java\n@@ -1,4 +1,4 @@\n-package tools.jackson.core.testutil;\n+package tools.jackson.core.unittest.testutil;\n \n import java.nio.ByteBuffer;\n \ndiff --git a/src/test/java/tools/jackson/core/testutil/ByteOutputStreamForTesting.java b/src/test/java/tools/jackson/core/unittest/testutil/ByteOutputStreamForTesting.java\nsimilarity index 93%\nrename from src/test/java/tools/jackson/core/testutil/ByteOutputStreamForTesting.java\nrename to src/test/java/tools/jackson/core/unittest/testutil/ByteOutputStreamForTesting.java\nindex 6d07ccd7fe..eb47a3a3b9 100644\n--- a/src/test/java/tools/jackson/core/testutil/ByteOutputStreamForTesting.java\n+++ b/src/test/java/tools/jackson/core/unittest/testutil/ByteOutputStreamForTesting.java\n@@ -1,4 +1,4 @@\n-package tools.jackson.core.testutil;\n+package tools.jackson.core.unittest.testutil;\n \n import java.io.ByteArrayOutputStream;\n import java.io.IOException;\ndiff --git a/src/test/java/tools/jackson/core/testutil/JacksonTestUtilBase.java b/src/test/java/tools/jackson/core/unittest/testutil/JacksonTestUtilBase.java\nsimilarity index 99%\nrename from src/test/java/tools/jackson/core/testutil/JacksonTestUtilBase.java\nrename to src/test/java/tools/jackson/core/unittest/testutil/JacksonTestUtilBase.java\nindex 38f00a69ab..b0537ef842 100644\n--- a/src/test/java/tools/jackson/core/testutil/JacksonTestUtilBase.java\n+++ b/src/test/java/tools/jackson/core/unittest/testutil/JacksonTestUtilBase.java\n@@ -1,4 +1,4 @@\n-package tools.jackson.core.testutil;\n+package tools.jackson.core.unittest.testutil;\n \n import static org.junit.jupiter.api.Assertions.assertEquals;\n import static org.junit.jupiter.api.Assertions.fail;\ndiff --git a/src/test/java/tools/jackson/core/testutil/MockDataInput.java b/src/test/java/tools/jackson/core/unittest/testutil/MockDataInput.java\nsimilarity index 98%\nrename from src/test/java/tools/jackson/core/testutil/MockDataInput.java\nrename to src/test/java/tools/jackson/core/unittest/testutil/MockDataInput.java\nindex 8302138b27..b50a5ab7af 100644\n--- a/src/test/java/tools/jackson/core/testutil/MockDataInput.java\n+++ b/src/test/java/tools/jackson/core/unittest/testutil/MockDataInput.java\n@@ -1,4 +1,4 @@\n-package tools.jackson.core.testutil;\n+package tools.jackson.core.unittest.testutil;\n \n import java.io.*;\n import java.nio.charset.StandardCharsets;\ndiff --git a/src/test/java/tools/jackson/core/testutil/StringWriterForTesting.java b/src/test/java/tools/jackson/core/unittest/testutil/StringWriterForTesting.java\nsimilarity index 92%\nrename from src/test/java/tools/jackson/core/testutil/StringWriterForTesting.java\nrename to src/test/java/tools/jackson/core/unittest/testutil/StringWriterForTesting.java\nindex 63d1850d06..1aa9671da1 100644\n--- a/src/test/java/tools/jackson/core/testutil/StringWriterForTesting.java\n+++ b/src/test/java/tools/jackson/core/unittest/testutil/StringWriterForTesting.java\n@@ -1,4 +1,4 @@\n-package tools.jackson.core.testutil;\n+package tools.jackson.core.unittest.testutil;\n \n import java.io.IOException;\n import java.io.StringWriter;\ndiff --git a/src/test/java/tools/jackson/core/testutil/ThrottledInputStream.java b/src/test/java/tools/jackson/core/unittest/testutil/ThrottledInputStream.java\nsimilarity index 94%\nrename from src/test/java/tools/jackson/core/testutil/ThrottledInputStream.java\nrename to src/test/java/tools/jackson/core/unittest/testutil/ThrottledInputStream.java\nindex 345f6d4e2b..5e984ca0f3 100644\n--- a/src/test/java/tools/jackson/core/testutil/ThrottledInputStream.java\n+++ b/src/test/java/tools/jackson/core/unittest/testutil/ThrottledInputStream.java\n@@ -1,4 +1,4 @@\n-package tools.jackson.core.testutil;\n+package tools.jackson.core.unittest.testutil;\n \n import java.io.ByteArrayInputStream;\n import java.io.FilterInputStream;\ndiff --git a/src/test/java/tools/jackson/core/testutil/ThrottledReader.java b/src/test/java/tools/jackson/core/unittest/testutil/ThrottledReader.java\nsimilarity index 93%\nrename from src/test/java/tools/jackson/core/testutil/ThrottledReader.java\nrename to src/test/java/tools/jackson/core/unittest/testutil/ThrottledReader.java\nindex 4ea3a8756c..265c474091 100644\n--- a/src/test/java/tools/jackson/core/testutil/ThrottledReader.java\n+++ b/src/test/java/tools/jackson/core/unittest/testutil/ThrottledReader.java\n@@ -1,4 +1,4 @@\n-package tools.jackson.core.testutil;\n+package tools.jackson.core.unittest.testutil;\n \n import java.io.*;\n \ndiff --git a/src/test/java/tools/jackson/core/testutil/failure/ExpectedPassingTestCasePredicate.java b/src/test/java/tools/jackson/core/unittest/testutil/failure/ExpectedPassingTestCasePredicate.java\nsimilarity index 85%\nrename from src/test/java/tools/jackson/core/testutil/failure/ExpectedPassingTestCasePredicate.java\nrename to src/test/java/tools/jackson/core/unittest/testutil/failure/ExpectedPassingTestCasePredicate.java\nindex 292d5fd5ec..caa60bbc67 100644\n--- a/src/test/java/tools/jackson/core/testutil/failure/ExpectedPassingTestCasePredicate.java\n+++ b/src/test/java/tools/jackson/core/unittest/testutil/failure/ExpectedPassingTestCasePredicate.java\n@@ -1,4 +1,4 @@\n-package tools.jackson.core.testutil.failure;\n+package tools.jackson.core.unittest.testutil.failure;\n \n import java.util.List;\n \ndiff --git a/src/test/java/tools/jackson/core/testutil/failure/JacksonTestFailureExpected.java b/src/test/java/tools/jackson/core/unittest/testutil/failure/JacksonTestFailureExpected.java\nsimilarity index 96%\nrename from src/test/java/tools/jackson/core/testutil/failure/JacksonTestFailureExpected.java\nrename to src/test/java/tools/jackson/core/unittest/testutil/failure/JacksonTestFailureExpected.java\nindex 3eed0d4511..7704d93a4e 100644\n--- a/src/test/java/tools/jackson/core/testutil/failure/JacksonTestFailureExpected.java\n+++ b/src/test/java/tools/jackson/core/unittest/testutil/failure/JacksonTestFailureExpected.java\n@@ -1,4 +1,4 @@\n-package tools.jackson.core.testutil.failure;\n+package tools.jackson.core.unittest.testutil.failure;\n \n import java.lang.annotation.ElementType;\n import java.lang.annotation.Retention;\ndiff --git a/src/test/java/tools/jackson/core/testutil/failure/JacksonTestFailureExpectedInterceptor.java b/src/test/java/tools/jackson/core/unittest/testutil/failure/JacksonTestFailureExpectedInterceptor.java\nsimilarity index 98%\nrename from src/test/java/tools/jackson/core/testutil/failure/JacksonTestFailureExpectedInterceptor.java\nrename to src/test/java/tools/jackson/core/unittest/testutil/failure/JacksonTestFailureExpectedInterceptor.java\nindex 85309eb7b0..2063575484 100644\n--- a/src/test/java/tools/jackson/core/testutil/failure/JacksonTestFailureExpectedInterceptor.java\n+++ b/src/test/java/tools/jackson/core/unittest/testutil/failure/JacksonTestFailureExpectedInterceptor.java\n@@ -1,4 +1,4 @@\n-package tools.jackson.core.testutil.failure;\n+package tools.jackson.core.unittest.testutil.failure;\n \n import java.lang.reflect.Method;\n \ndiff --git a/src/test/java/tools/jackson/core/testutil/failure/JacksonTestShouldFailException.java b/src/test/java/tools/jackson/core/unittest/testutil/failure/JacksonTestShouldFailException.java\nsimilarity index 88%\nrename from src/test/java/tools/jackson/core/testutil/failure/JacksonTestShouldFailException.java\nrename to src/test/java/tools/jackson/core/unittest/testutil/failure/JacksonTestShouldFailException.java\nindex 760e5eb611..850dec1e9e 100644\n--- a/src/test/java/tools/jackson/core/testutil/failure/JacksonTestShouldFailException.java\n+++ b/src/test/java/tools/jackson/core/unittest/testutil/failure/JacksonTestShouldFailException.java\n@@ -1,4 +1,4 @@\n-package tools.jackson.core.testutil.failure;\n+package tools.jackson.core.unittest.testutil.failure;\n \n /**\n  * Exception used to alert that a test is passing, but should be failing.\ndiff --git a/src/test/java/tools/jackson/core/unittest/tofix/ParserErrorHandling105Test.java b/src/test/java/tools/jackson/core/unittest/tofix/ParserErrorHandling105Test.java\nindex 6a4ade90d9..6a37eaa0cd 100644\n--- a/src/test/java/tools/jackson/core/unittest/tofix/ParserErrorHandling105Test.java\n+++ b/src/test/java/tools/jackson/core/unittest/tofix/ParserErrorHandling105Test.java\n@@ -5,7 +5,7 @@\n import tools.jackson.core.JsonParser;\n import tools.jackson.core.JsonToken;\n import tools.jackson.core.exc.StreamReadException;\n-import tools.jackson.core.testutil.failure.JacksonTestFailureExpected;\n+import tools.jackson.core.unittest.testutil.failure.JacksonTestFailureExpected;\n \n import static org.junit.jupiter.api.Assertions.fail;\n \ndiff --git a/src/test/java/tools/jackson/core/unittest/tofix/ParserErrorHandling679Test.java b/src/test/java/tools/jackson/core/unittest/tofix/ParserErrorHandling679Test.java\nindex 33631a9a8d..b69abf4ed2 100644\n--- a/src/test/java/tools/jackson/core/unittest/tofix/ParserErrorHandling679Test.java\n+++ b/src/test/java/tools/jackson/core/unittest/tofix/ParserErrorHandling679Test.java\n@@ -5,7 +5,7 @@\n import tools.jackson.core.JsonParser;\n import tools.jackson.core.JsonToken;\n import tools.jackson.core.exc.StreamReadException;\n-import tools.jackson.core.testutil.failure.JacksonTestFailureExpected;\n+import tools.jackson.core.unittest.testutil.failure.JacksonTestFailureExpected;\n \n import static org.junit.jupiter.api.Assertions.assertEquals;\n import static org.junit.jupiter.api.Assertions.fail;\ndiff --git a/src/test/java/tools/jackson/core/unittest/tofix/ParserFilterEmpty1418Test.java b/src/test/java/tools/jackson/core/unittest/tofix/ParserFilterEmpty1418Test.java\nindex fcd6c1721f..2054e795cb 100644\n--- a/src/test/java/tools/jackson/core/unittest/tofix/ParserFilterEmpty1418Test.java\n+++ b/src/test/java/tools/jackson/core/unittest/tofix/ParserFilterEmpty1418Test.java\n@@ -7,8 +7,8 @@\n import tools.jackson.core.filter.TokenFilter;\n import tools.jackson.core.filter.TokenFilter.Inclusion;\n import tools.jackson.core.json.JsonFactory;\n-import tools.jackson.core.testutil.failure.JacksonTestFailureExpected;\n import tools.jackson.core.unittest.JacksonCoreTestBase;\n+import tools.jackson.core.unittest.testutil.failure.JacksonTestFailureExpected;\n \n import static org.junit.jupiter.api.Assertions.assertEquals;\n import static org.junit.jupiter.api.Assertions.assertNull;\ndiff --git a/src/test/java/tools/jackson/core/unittest/tofix/async/AsyncTokenNonRootErrorTest.java b/src/test/java/tools/jackson/core/unittest/tofix/async/AsyncTokenNonRootErrorTest.java\nindex 9c0d5f376f..d373cea908 100644\n--- a/src/test/java/tools/jackson/core/unittest/tofix/async/AsyncTokenNonRootErrorTest.java\n+++ b/src/test/java/tools/jackson/core/unittest/tofix/async/AsyncTokenNonRootErrorTest.java\n@@ -5,9 +5,9 @@\n import tools.jackson.core.JsonToken;\n import tools.jackson.core.exc.StreamReadException;\n import tools.jackson.core.json.JsonFactory;\n-import tools.jackson.core.testutil.AsyncReaderWrapper;\n-import tools.jackson.core.testutil.failure.JacksonTestFailureExpected;\n import tools.jackson.core.unittest.async.AsyncTestBase;\n+import tools.jackson.core.unittest.testutil.AsyncReaderWrapper;\n+import tools.jackson.core.unittest.testutil.failure.JacksonTestFailureExpected;\n \n import static org.junit.jupiter.api.Assertions.fail;\n \ndiff --git a/src/test/java/tools/jackson/core/unittest/tofix/async/AsyncTokenRootErrorTest.java b/src/test/java/tools/jackson/core/unittest/tofix/async/AsyncTokenRootErrorTest.java\nindex 039374223f..20780c05ec 100644\n--- a/src/test/java/tools/jackson/core/unittest/tofix/async/AsyncTokenRootErrorTest.java\n+++ b/src/test/java/tools/jackson/core/unittest/tofix/async/AsyncTokenRootErrorTest.java\n@@ -5,9 +5,9 @@\n import tools.jackson.core.JsonToken;\n import tools.jackson.core.exc.StreamReadException;\n import tools.jackson.core.json.JsonFactory;\n-import tools.jackson.core.testutil.AsyncReaderWrapper;\n-import tools.jackson.core.testutil.failure.JacksonTestFailureExpected;\n import tools.jackson.core.unittest.async.AsyncTestBase;\n+import tools.jackson.core.unittest.testutil.AsyncReaderWrapper;\n+import tools.jackson.core.unittest.testutil.failure.JacksonTestFailureExpected;\n \n import static org.junit.jupiter.api.Assertions.fail;\n \ndiff --git a/src/test/java/tools/jackson/core/unittest/write/GeneratorCloseTest.java b/src/test/java/tools/jackson/core/unittest/write/GeneratorCloseTest.java\nindex 4f663d68fb..a46ad43b70 100644\n--- a/src/test/java/tools/jackson/core/unittest/write/GeneratorCloseTest.java\n+++ b/src/test/java/tools/jackson/core/unittest/write/GeneratorCloseTest.java\n@@ -10,9 +10,9 @@\n import tools.jackson.core.ObjectWriteContext;\n import tools.jackson.core.StreamWriteFeature;\n import tools.jackson.core.json.JsonFactory;\n-import tools.jackson.core.testutil.ByteOutputStreamForTesting;\n-import tools.jackson.core.testutil.StringWriterForTesting;\n import tools.jackson.core.unittest.*;\n+import tools.jackson.core.unittest.testutil.ByteOutputStreamForTesting;\n+import tools.jackson.core.unittest.testutil.StringWriterForTesting;\n \n import static org.junit.jupiter.api.Assertions.*;\n \n",
  "problem_statement" : "Major test package refactoring to try to fix JPMS issues",
  "hints_text" : null,
  "created_at" : "Fri Nov 07 01:45:05 CET 2025",
  "version" : null,
  "FAIL_TO_PASS" : [ "AsyncReaderWrapper", "AsyncConcurrencyTest", "StringWriterForTesting", "AsyncPropertyNamesTest", "AsyncNonStandardNumberParsingTest", "AsyncCommentParsingTest", "AsyncInvalidCharsTest", "JacksonTestFailureExpected", "AsyncRootNumbersTest", "AsyncReaderWrapperForByteArray", "ThrottledReader", "ParserFilterEmpty1418Test", "AsyncRootValuesTest", "MockDataInput", "JsonParserClosedCaseTest", "AsyncConcurrencyByteBufferTest", "GeneratorCloseTest", "AsyncNaNHandlingTest", "JacksonCoreTestBase", "ParserErrorHandling679Test", "AsyncNumberDeferredReadTest", "AsyncPointerFromContext563Test", "JacksonTestFailureExpectedInterceptor", "AsyncParserNamesTest", "AsyncSimpleObjectTest", "LargeDocReadTest", "Base64GenerationTest", "AsyncCharEscapingTest", "AsyncStringObjectTest", "AsyncBinaryParseTest", "ByteOutputStreamForTesting", "Fuzz32208UTF32ParseTest", "AsyncTokenRootErrorTest", "AsyncScopeMatchingTest", "ExpectedPassingTestCasePredicate", "AsyncUnicodeHandlingTest", "Fuzz52688ParseTest", "AsyncReaderWrapperForByteBuffer", "AsyncNonStdNumberHandlingTest", "AsyncNonStdParsingTest", "SimpleParserTest", "JacksonTestShouldFailException", "AsyncStringArrayTest", "AsyncTestBase", "AsyncScalarArrayTest", "AsyncNumberCoercionTest", "ParserErrorHandling105Test", "AsyncMissingValuesInObjectTest", "AsyncTokenNonRootErrorTest", "AsyncMissingValuesInArrayTest", "JacksonTestUtilBase", "module-info", "AsyncSimpleNestedTest", "ConfigTest", "ThrottledInputStream" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=AsyncReaderWrapper,AsyncConcurrencyTest,StringWriterForTesting,AsyncPropertyNamesTest,AsyncNonStandardNumberParsingTest,AsyncCommentParsingTest,AsyncInvalidCharsTest,JacksonTestFailureExpected,AsyncRootNumbersTest,AsyncReaderWrapperForByteArray,ThrottledReader,ParserFilterEmpty1418Test,AsyncRootValuesTest,MockDataInput,JsonParserClosedCaseTest,AsyncConcurrencyByteBufferTest,GeneratorCloseTest,AsyncNaNHandlingTest,JacksonCoreTestBase,ParserErrorHandling679Test,AsyncNumberDeferredReadTest,AsyncPointerFromContext563Test,JacksonTestFailureExpectedInterceptor,AsyncParserNamesTest,AsyncSimpleObjectTest,LargeDocReadTest,Base64GenerationTest,AsyncCharEscapingTest,AsyncStringObjectTest,AsyncBinaryParseTest,ByteOutputStreamForTesting,Fuzz32208UTF32ParseTest,AsyncTokenRootErrorTest,AsyncScopeMatchingTest,ExpectedPassingTestCasePredicate,AsyncUnicodeHandlingTest,Fuzz52688ParseTest,AsyncReaderWrapperForByteBuffer,AsyncNonStdNumberHandlingTest,AsyncNonStdParsingTest,SimpleParserTest,JacksonTestShouldFailException,AsyncStringArrayTest,AsyncTestBase,AsyncScalarArrayTest,AsyncNumberCoercionTest,ParserErrorHandling105Test,AsyncMissingValuesInObjectTest,AsyncTokenNonRootErrorTest,AsyncMissingValuesInArrayTest,JacksonTestUtilBase,module-info,AsyncSimpleNestedTest,ConfigTest,ThrottledInputStream",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 1505,
  "metadata" : null
}, {
  "instance_id" : "FasterXML-jackson-core-PR-1503",
  "repo" : "FasterXML/jackson-core",
  "base_commit" : "262d9e58f458961c212e7d5bb9d71dc85685ccff",
  "patch" : "diff --git a/pom.xml b/pom.xml\nindex f312b27ec3..5f952ce69b 100644\n--- a/pom.xml\n+++ b/pom.xml\n@@ -133,6 +133,27 @@ tools.jackson.core.*;version=${project.version}\n           <redirectTestOutputToFile>${surefire.redirectTestOutputToFile}</redirectTestOutputToFile>\n         </configuration>\n       </plugin>\n+\n+      <!-- Integration tests (run after packaging to verify shaded JAR) -->\n+      <plugin>\n+        <groupId>org.apache.maven.plugins</groupId>\n+        <artifactId>maven-failsafe-plugin</artifactId>\n+        <version>${version.plugin.surefire}</version>\n+        <configuration>\n+          <includes>\n+            <include>**/*IT.java</include>\n+          </includes>\n+        </configuration>\n+        <executions>\n+          <execution>\n+            <goals>\n+              <goal>integration-test</goal>\n+              <goal>verify</goal>\n+            </goals>\n+          </execution>\n+        </executions>\n+      </plugin>\n+\n       <plugin> <!-- default settings are fine, just need to enable here -->\n         <groupId>com.google.code.maven-replacer-plugin</groupId>\n         <artifactId>replacer</artifactId>\n",
  "test_patch" : "diff --git a/src/test/java/module-info.java b/src/test/java/module-info.java\nindex 248346c294..47e16dba17 100644\n--- a/src/test/java/module-info.java\n+++ b/src/test/java/module-info.java\n@@ -16,7 +16,7 @@\n     opens tools.jackson.core.testutil;\n     opens tools.jackson.core.testutil.failure;\n \n-    // Additional test opens for JUnit tests\n+    // Additional test opens for Unit tests\n \n     opens tools.jackson.core.unittest;\n     opens tools.jackson.core.unittest.async;\n@@ -39,4 +39,7 @@\n     opens tools.jackson.core.unittest.type;\n     opens tools.jackson.core.unittest.util;\n     opens tools.jackson.core.unittest.write;\n+\n+    // Additional test opens for ITs\n+    opens tools.jackson.core.it;\n }\ndiff --git a/src/test/java/tools/jackson/core/it/FastDoubleParserShadingIT.java b/src/test/java/tools/jackson/core/it/FastDoubleParserShadingIT.java\nnew file mode 100644\nindex 0000000000..b1dccf0d8f\n--- /dev/null\n+++ b/src/test/java/tools/jackson/core/it/FastDoubleParserShadingIT.java\n@@ -0,0 +1,158 @@\n+package tools.jackson.core.it;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.InputStream;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarInputStream;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+/**\n+ * Integration test for [core#1498]: FastDoubleParser classes must be properly\n+ * shaded in the Jackson JAR to prevent {@code NoClassDefFoundError} when\n+ * Jackson's JAR loads before the FastDoubleParser JAR on the classpath.\n+ * <p>\n+ * This test verifies the packaged JAR to ensure that:\n+ * <ul>\n+ * <li>No unshaded {@code ch.randelshofer.fastdoubleparser} classes exist in base package</li>\n+ * <li>Multi-version JAR entries (JDK 17, 21, 22, 23+) have properly shaded paths</li>\n+ * <li>All FastDoubleParser classes are relocated to {@code tools.jackson.core.internal.shaded.fdp}</li>\n+ * </ul>\n+ *\n+ * @see <a href=\"https://github.com/FasterXML/jackson-core/issues/1498\">[core#1498]</a>\n+ */\n+public class FastDoubleParserShadingIT\n+{\n+    private static final String UNSHADED_PACKAGE_PREFIX = \"ch/randelshofer/fastdoubleparser/\";\n+    private static final String SHADED_PACKAGE_PREFIX = \"tools/jackson/core/internal/shaded/fdp/\";\n+\n+    /**\n+     * Test that verifies no unshaded FastDoubleParser classes exist in the\n+     * Jackson JAR, including in multi-version JAR directories.\n+     */\n+    @Test\n+    public void verifyNoUnshadedFDPClasses() throws Exception\n+    {\n+        File jarFile = findJacksonCoreJar();\n+\n+        assertNotNull(jarFile, \"Could not locate jackson-core JAR file\");\n+        assertTrue(jarFile.exists(), \"JAR file does not exist: \" + jarFile);\n+        assertTrue(jarFile.isFile(), \"Not a file: \" + jarFile);\n+\n+        // Parse the JAR to check for unshaded classes\n+        List<String> unshadedClasses = new ArrayList<>();\n+        List<String> shadedClasses = new ArrayList<>();\n+        List<String> multiVersionUnshadedClasses = new ArrayList<>();\n+        List<String> multiVersionShadedClasses = new ArrayList<>();\n+\n+        try (InputStream is = new FileInputStream(jarFile);\n+             JarInputStream jarStream = new JarInputStream(is)) {\n+\n+            JarEntry entry;\n+            while ((entry = jarStream.getNextJarEntry()) != null) {\n+                String entryName = entry.getName();\n+\n+                // Check for unshaded classes in base location\n+                if (entryName.startsWith(UNSHADED_PACKAGE_PREFIX) && entryName.endsWith(\".class\")) {\n+                    unshadedClasses.add(entryName);\n+                }\n+\n+                // Check for unshaded classes in multi-version JAR directories\n+                // Pattern: META-INF/versions/{version}/ch/randelshofer/fastdoubleparser/...\n+                if (entryName.startsWith(\"META-INF/versions/\") &&\n+                    entryName.contains(\"/\" + UNSHADED_PACKAGE_PREFIX) &&\n+                    entryName.endsWith(\".class\")) {\n+                    multiVersionUnshadedClasses.add(entryName);\n+                }\n+\n+                // Track properly shaded classes for verification\n+                if (entryName.startsWith(SHADED_PACKAGE_PREFIX) && entryName.endsWith(\".class\")) {\n+                    shadedClasses.add(entryName);\n+                }\n+\n+                // Also check multi-version shaded classes\n+                if (entryName.startsWith(\"META-INF/versions/\") &&\n+                    entryName.contains(\"/\" + SHADED_PACKAGE_PREFIX) &&\n+                    entryName.endsWith(\".class\")) {\n+                    multiVersionShadedClasses.add(entryName);\n+                }\n+            }\n+        }\n+\n+        // Report findings for debugging\n+        System.out.println(\"=== FastDoubleParser Shading Verification Report ===\");\n+        System.out.println(\"JAR: \" + jarFile.getName());\n+        System.out.println(\"Shaded classes found: \" + shadedClasses.size());\n+        System.out.println(\"Multi-version shaded classes found: \" + multiVersionShadedClasses.size());\n+\n+        if (!shadedClasses.isEmpty()) {\n+            System.out.println(\"\\nShaded classes (sample):\");\n+            shadedClasses.stream().limit(5).forEach(name -> System.out.println(\"   \" + name));\n+        }\n+\n+        if (!multiVersionShadedClasses.isEmpty()) {\n+            System.out.println(\"\\nMulti-version shaded classes:\");\n+            multiVersionShadedClasses.forEach(name -> System.out.println(\"   \" + name));\n+        }\n+\n+        // Verify no unshaded classes exist in base location\n+        if (!unshadedClasses.isEmpty()) {\n+            System.err.println(\"\\n FAILED: Found unshaded FastDoubleParser classes in base location:\");\n+            unshadedClasses.forEach(name -> System.err.println(\"   \" + name));\n+            fail(\"Found \" + unshadedClasses.size() + \" unshaded FastDoubleParser classes in base location. \" +\n+                 \"These should be shaded to '\" + SHADED_PACKAGE_PREFIX + \"'\");\n+        }\n+\n+        // Verify no unshaded classes exist in multi-version directories\n+        if (!multiVersionUnshadedClasses.isEmpty()) {\n+            System.err.println(\"\\n FAILED: Found unshaded FastDoubleParser classes in multi-version JAR:\");\n+            multiVersionUnshadedClasses.forEach(name -> System.err.println(\"   \" + name));\n+            fail(\"Found \" + multiVersionUnshadedClasses.size() + \" unshaded FastDoubleParser classes \" +\n+                 \"in multi-version JAR directories. These should be shaded to '\" + SHADED_PACKAGE_PREFIX + \"'\");\n+        }\n+\n+        // Verify that shaded classes DO exist (sanity check that shading happened)\n+        assertFalse(shadedClasses.isEmpty(),\n+            \"No shaded FastDoubleParser classes found. Expected classes under '\" +\n+            SHADED_PACKAGE_PREFIX + \"'. Shading may have failed.\");\n+\n+        // Additional verification: check that expected core classes are present\n+        assertTrue(shadedClasses.stream()\n+            .anyMatch(name -> name.contains(\"FastIntegerMath\") || name.contains(\"FastDoubleMath\")),\n+            \"Expected to find core FastDoubleParser classes like FastIntegerMath or FastDoubleMath\");\n+\n+        System.out.println(\"\\n All FastDoubleParser classes are properly shaded!\");\n+        System.out.println(\"=====================================================\");\n+    }\n+\n+    /**\n+     * Finds the jackson-core JAR file in the target directory.\n+     */\n+    private File findJacksonCoreJar() {\n+        // Look in target directory for the built JAR\n+        File targetDir = new File(\"target\");\n+        if (!targetDir.exists() || !targetDir.isDirectory()) {\n+            return null;\n+        }\n+\n+        // Find JAR files matching jackson-core pattern\n+        File[] jarFiles = targetDir.listFiles((dir, name) ->\n+            name.startsWith(\"jackson-core-\") &&\n+            name.endsWith(\".jar\") &&\n+            !name.contains(\"sources\") &&\n+            !name.contains(\"javadoc\") &&\n+            !name.contains(\"tests\"));\n+\n+        if (jarFiles == null || jarFiles.length == 0) {\n+            return null;\n+        }\n+\n+        // Return the first matching JAR (there should only be one)\n+        return jarFiles[0];\n+    }\n+}\n",
  "problem_statement" : "We have a project that has FastDoubleParser (`ch.randelshofer:fastdoubleparser:2.0.1`) as a dependency.\n\nAfter an upgrade of another dependency transitively brought in Jackson 3.0.1, we saw the following error in our application:\n\n```\njava.lang.NoClassDefFoundError: ch/randelshofer/fastdoubleparser/FastIntegerMath (wrong name: tools/jackson/core/internal/shaded/fdp/FastIntegerMath)\n  at java.base/java.lang.ClassLoader.defineClass1(Native Method)\n  at java.base/java.lang.ClassLoader.defineClass(Unknown Source)\n  at java.base/java.security.SecureClassLoader.defineClass(Unknown Source)\n  at java.base/jdk.internal.loader.BuiltinClassLoader.defineClass(Unknown Source)\n  at java.base/jdk.internal.loader.BuiltinClassLoader.findClassOnClassPathOrNull(Unknown Source)\n  at java.base/jdk.internal.loader.BuiltinClassLoader.loadClassOrNull(Unknown Source)\n  at java.base/jdk.internal.loader.BuiltinClassLoader.loadClass(Unknown Source)\n  at java.base/java.lang.ClassLoader.loadClass(Unknown Source)\n  at ch.randelshofer.fastdoubleparser.FastDoubleMath.tryDecToDoubleWithFastAlgorithm(FastDoubleMath.java:891)\n  at ch.randelshofer.fastdoubleparser.FastDoubleMath.tryDecFloatToDoubleTruncated(FastDoubleMath.java:795)\n  at ch.randelshofer.fastdoubleparser.JavaDoubleBitsFromCharSequence.valueOfFloatLiteral(JavaDoubleBitsFromCharSequence.java:38)\n  at ch.randelshofer.fastdoubleparser.AbstractJavaFloatingPointBitsFromCharSequence.parseDecFloatLiteral(AbstractJavaFloatingPointBitsFromCharSequence.java:184)\n  at ch.randelshofer.fastdoubleparser.AbstractJavaFloatingPointBitsFromCharSequence.parseFloatingPointLiteral(AbstractJavaFloatingPointBitsFromCharSequence.java:238)\n  at ch.randelshofer.fastdoubleparser.JavaDoubleParser.parseDouble(JavaDoubleParser.java:190)\n  at ch.randelshofer.fastdoubleparser.JavaDoubleParser.parseDouble(JavaDoubleParser.java:174)\n  at (our code)\n```\n\nI investigated the error and found out that `ch/randelshofer/fastdoubleparser/FastIntegerMath.class` appears on our classpath twice:\n* the correct version inside `fastdoubleparser-2.0.1.jar`,\n* and another version inside `jackson-core-3.0.1.jar`, which apparently was intended to be shaded, but still appears in the JAR under the original qualified name.\n\nBecause of this, if the Jackson JAR appears on the classpath before the FastDoubleParser JAR, FastDoubleParser fails.",
  "hints_text" : null,
  "created_at" : "Fri Nov 07 00:27:17 CET 2025",
  "version" : null,
  "FAIL_TO_PASS" : [ "FastDoubleParserShadingIT", "module-info" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=FastDoubleParserShadingIT,module-info",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : 1498,
  "pull_number" : 1503,
  "metadata" : null
}, {
  "instance_id" : "FasterXML-jackson-core-PR-1495",
  "repo" : "FasterXML/jackson-core",
  "base_commit" : "1c1914c48634f0301195f280c789c5419d871f15",
  "patch" : "diff --git a/release-notes/VERSION-2.x b/release-notes/VERSION-2.x\nindex fb1250819c..69ade83d46 100644\n--- a/release-notes/VERSION-2.x\n+++ b/release-notes/VERSION-2.x\n@@ -18,8 +18,11 @@ a pure JSON library.\n \n #363: UTF-8 decoding should fail on Surrogate characters (0xD800 - 0xDFFF)\n  (fix by @cowtowncoder, w/ Claude code)\n-#1180: `JsonLocation` off for unrecognized tokens\n+#708: `FilteringParserDelegate` cannot deserialize empty list\n+ (reported by @xiazuojie)\n  (fix by @cowtowncoder, w/ Claude code)\n+#1180: `JsonLocation` off for unrecognized tokens\n+(fix by @cowtowncoder, w/ Claude code)\n #1470: Add method `copyCurrentStructureExact()` to `JsonGenerator`\n  (contributed by Lars H)\n #1477: Add `JsonGenerator.has(StreamWriteCapability)` convenience method\ndiff --git a/src/main/java/com/fasterxml/jackson/core/filter/FilteringParserDelegate.java b/src/main/java/com/fasterxml/jackson/core/filter/FilteringParserDelegate.java\nindex 41c2dde40a..1d81b8cfef 100644\n--- a/src/main/java/com/fasterxml/jackson/core/filter/FilteringParserDelegate.java\n+++ b/src/main/java/com/fasterxml/jackson/core/filter/FilteringParserDelegate.java\n@@ -671,7 +671,7 @@ protected final JsonToken _nextToken2() throws IOException\n                     boolean returnEnd = _headContext.isStartHandled();\n                     f = _headContext.getFilter();\n                     if ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {\n-                        boolean includeEmpty = f.includeEmptyArray(_headContext.hasCurrentName());\n+                        boolean includeEmpty = f.includeEmptyObject(_headContext.hasCurrentName());\n                         f.filterFinishObject();\n                         if (includeEmpty) {\n                             return _nextBuffered(_headContext);\n",
  "test_patch" : "diff --git a/src/test/java/com/fasterxml/jackson/core/tofix/ParserFilterEmpty708Test.java b/src/test/java/com/fasterxml/jackson/core/filter/ParserFilterEmpty708Test.java\nsimilarity index 83%\nrename from src/test/java/com/fasterxml/jackson/core/tofix/ParserFilterEmpty708Test.java\nrename to src/test/java/com/fasterxml/jackson/core/filter/ParserFilterEmpty708Test.java\nindex 26ef49bc8e..cfb0357f32 100644\n--- a/src/test/java/com/fasterxml/jackson/core/tofix/ParserFilterEmpty708Test.java\n+++ b/src/test/java/com/fasterxml/jackson/core/filter/ParserFilterEmpty708Test.java\n@@ -1,12 +1,9 @@\n-package com.fasterxml.jackson.core.tofix;\n+package com.fasterxml.jackson.core.filter;\n \n import org.junit.jupiter.api.Test;\n \n import com.fasterxml.jackson.core.*;\n-import com.fasterxml.jackson.core.filter.FilteringParserDelegate;\n-import com.fasterxml.jackson.core.filter.TokenFilter;\n import com.fasterxml.jackson.core.filter.TokenFilter.Inclusion;\n-import com.fasterxml.jackson.core.testutil.failure.JacksonTestFailureExpected;\n \n import static org.junit.jupiter.api.Assertions.assertNull;\n \n@@ -17,7 +14,17 @@ class ParserFilterEmpty708Test extends JUnit5TestBase\n     static class IncludeAllFilter extends TokenFilter {\n         @Override\n         public TokenFilter includeProperty(String name) {\n-            return this;\n+            return TokenFilter.INCLUDE_ALL;\n+        }\n+\n+        @Override\n+        public boolean includeEmptyArray(boolean contentsFiltered) {\n+            return true;\n+        }\n+\n+        @Override\n+        public boolean includeEmptyObject(boolean contentsFiltered) {\n+            return true;\n         }\n     }\n \n@@ -30,12 +37,10 @@ public TokenFilter includeProperty(String name) {\n     private final JsonFactory JSON_F = newStreamFactory();\n \n     // [core#708]\n-    @JacksonTestFailureExpected\n     @Test\n     void emptyArray() throws Exception\n     {\n         final String json = \"[ ]\";\n-        // should become: {\"value\":12}\n         JsonParser p0 = _createParser(JSON_F, json);\n         JsonParser p = new FilteringParserDelegate(p0,\n                 new IncludeAllFilter(),\n@@ -50,12 +55,10 @@ void emptyArray() throws Exception\n     }\n \n     // [core#708]\n-    @JacksonTestFailureExpected\n     @Test\n     void emptyObject() throws Exception\n     {\n         final String json = \"{ }\";\n-        // should become: {\"value\":12}\n         JsonParser p0 = _createParser(JSON_F, json);\n         JsonParser p = new FilteringParserDelegate(p0,\n                 new IncludeAllFilter(),\n",
  "problem_statement" : "This is a follow up issue of https://github.com/FasterXML/jackson-core/issues/700 .\r\n\r\nIf using FilteringParserDelegate to filter out a part of json, it throws the following exception when the input json is an empty list (\"[]\").\r\n\r\n```\r\ncom.fasterxml.jackson.databind.exc.MismatchedInputException: No content to map due to end-of-input\r\n at [Source: (byte[])\"[]\"; line: 1, column: 2]\r\n\r\n\tat com.fasterxml.jackson.databind.exc.MismatchedInputException.from(MismatchedInputException.java:59)\r\n\tat com.fasterxml.jackson.databind.ObjectMapper._initForReading(ObjectMapper.java:4688)\r\n\tat com.fasterxml.jackson.databind.ObjectMapper._readValue(ObjectMapper.java:4561)\r\n\tat com.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:2823)\r\n\tat com.alibaba.dapr.serialization.json.FilteringParserDelegateTest.testFilteringParserDelegateWithEmptyList(FilteringParserDelegateTest.java:36)\r\n```\r\nTest case:\r\n```java\r\npackage com.alibaba.dapr.serialization.json;\r\n\r\nimport com.fasterxml.jackson.core.JsonParser;\r\nimport com.fasterxml.jackson.core.filter.FilteringParserDelegate;\r\nimport com.fasterxml.jackson.core.filter.TokenFilter;\r\nimport com.fasterxml.jackson.core.type.TypeReference;\r\nimport com.fasterxml.jackson.databind.ObjectMapper;\r\nimport org.junit.Test;\r\n\r\nimport java.io.IOException;\r\nimport java.nio.charset.StandardCharsets;\r\nimport java.util.List;\r\nimport java.util.Map;\r\n\r\nimport static org.junit.Assert.assertTrue;\r\n\r\npublic class FilteringParserDelegateTest {\r\n    @Test\r\n    public void testFilteringParserDelegateWithEmptyList() throws IOException {\r\n        ObjectMapper mapper = new ObjectMapper();\r\n        final TokenFilter tokenFilter = new TokenFilter() {\r\n            @Override\r\n            public TokenFilter includeProperty(String name) {\r\n                if (\"@type\".equals(name)) {\r\n                    return null;\r\n                }\r\n                return INCLUDE_ALL;\r\n            }\r\n        };\r\n\r\n        byte[] content = \"[]\".getBytes(StandardCharsets.UTF_8);\r\n\r\n        JsonParser jp = mapper.createParser(content);\r\n        JsonParser jsonParser = new FilteringParserDelegate(jp, tokenFilter, TokenFilter.Inclusion.INCLUDE_ALL_AND_PATH, true);\r\n\r\n        List<Map<String, String>> a = mapper.readValue(jsonParser, new TypeReference<List<Map<String, String>>>() {});\r\n        assertTrue(a.isEmpty());\r\n    }\r\n}\r\n\r\n```\r\nJackson version: 2.12.3",
  "hints_text" : null,
  "created_at" : "Mon Nov 03 02:49:53 CET 2025",
  "version" : null,
  "FAIL_TO_PASS" : [ "ParserFilterEmpty708Test" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=ParserFilterEmpty708Test",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : 708,
  "pull_number" : 1495,
  "metadata" : null
}, {
  "instance_id" : "FasterXML-jackson-core-PR-1494",
  "repo" : "FasterXML/jackson-core",
  "base_commit" : "873d4109cbef914f3ed450719c2ebe6b15df9250",
  "patch" : "diff --git a/release-notes/VERSION-2.x b/release-notes/VERSION-2.x\nindex 6e6a33c1af..fb1250819c 100644\n--- a/release-notes/VERSION-2.x\n+++ b/release-notes/VERSION-2.x\n@@ -16,6 +16,8 @@ a pure JSON library.\n \n 2.21.0 (not yet released)\n \n+#363: UTF-8 decoding should fail on Surrogate characters (0xD800 - 0xDFFF)\n+ (fix by @cowtowncoder, w/ Claude code)\n #1180: `JsonLocation` off for unrecognized tokens\n  (fix by @cowtowncoder, w/ Claude code)\n #1470: Add method `copyCurrentStructureExact()` to `JsonGenerator`\ndiff --git a/src/main/java/com/fasterxml/jackson/core/base/ParserMinimalBase.java b/src/main/java/com/fasterxml/jackson/core/base/ParserMinimalBase.java\nindex b77030557c..d052248a99 100644\n--- a/src/main/java/com/fasterxml/jackson/core/base/ParserMinimalBase.java\n+++ b/src/main/java/com/fasterxml/jackson/core/base/ParserMinimalBase.java\n@@ -767,6 +767,22 @@ protected <T> T _reportUnexpectedNumberChar(int ch, String comment) throws JsonP\n     protected void reportUnexpectedNumberChar(int ch, String comment) throws JsonParseException {\n         _reportUnexpectedNumberChar(ch, comment);\n     }\n+\n+    /**\n+     * Method called to throw an exception for invalid UTF-8 surrogate character: case\n+     * where a surrogate character (between U+D800 and U+DFFF) is decoded from UTF-8\n+     * bytes (but NOT from JSON entity!)\n+     *\n+     * @param ch Character code (int) that is invalid surrogate\n+     *\n+     * @throws JsonParseException Exception that describes problem with UTF-8 surrogate\n+     *\n+     * @since 2.21\n+     */\n+    protected void _reportInvalidUTF8Surrogate(int ch) throws JsonParseException {\n+        throw _constructReadException(\n+                \"Invalid UTF-8: Illegal surrogate character 0x\"+Integer.toHexString(ch));\n+    }\n     \n     protected void _throwInvalidSpace(int i) throws JsonParseException {\n         char c = (char) i;\ndiff --git a/src/main/java/com/fasterxml/jackson/core/json/UTF8DataInputJsonParser.java b/src/main/java/com/fasterxml/jackson/core/json/UTF8DataInputJsonParser.java\nindex fad4a661fc..76f64ca72c 100644\n--- a/src/main/java/com/fasterxml/jackson/core/json/UTF8DataInputJsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/UTF8DataInputJsonParser.java\n@@ -1859,7 +1859,12 @@ private final String addName(int[] quads, int qlen, int lastQuadBytes)\n                         _reportInvalidOther(ch2);\n                     }\n                     ch = (ch << 6) | (ch2 & 0x3F);\n-                    if (needed > 2) { // 4 bytes? (need surrogates on output)\n+                    // [jackson-core#363]: Surrogates (0xD800 - 0xDFFF) are illegal in UTF-8 for 3-byte sequences\n+                    if (needed == 2) {\n+                        if (ch >= 0xD800 && ch <= 0xDFFF) {\n+                            _reportInvalidUTF8Surrogate(ch);\n+                        }\n+                    } else { // 4 bytes? (need surrogates on output)\n                         ch2 = quads[ix >> 2];\n                         byteIx = (ix & 3);\n                         ch2 = (ch2 >> ((3 - byteIx) << 3));\n@@ -2678,6 +2683,10 @@ private final int _decodeUtf8_3(int c1) throws IOException\n             _reportInvalidOther(d & 0xFF);\n         }\n         c = (c << 6) | (d & 0x3F);\n+        // [jackson-core#363]: Surrogates (0xD800 - 0xDFFF) are illegal in UTF-8\n+        if (c >= 0xD800 && c <= 0xDFFF) {\n+            _reportInvalidUTF8Surrogate(c);\n+        }\n         return c;\n     }\n \ndiff --git a/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java b/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\nindex 70e78362e0..d1f9382d07 100644\n--- a/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\n@@ -2407,7 +2407,12 @@ private final String addName(int[] quads, int qlen, int lastQuadBytes)\n                         _reportInvalidOther(ch2);\n                     }\n                     ch = (ch << 6) | (ch2 & 0x3F);\n-                    if (needed > 2) { // 4 bytes? (need surrogates on output)\n+                    // [jackson-core#363]: Surrogates (0xD800 - 0xDFFF) are illegal in UTF-8 for 3-byte sequences\n+                    if (needed == 2) {\n+                        if (ch >= 0xD800 && ch <= 0xDFFF) {\n+                            _reportInvalidUTF8Surrogate(ch);\n+                        }\n+                    } else { // 4 bytes? (need surrogates on output)\n                         ch2 = quads[ix >> 2];\n                         byteIx = (ix & 3);\n                         ch2 = (ch2 >> ((3 - byteIx) << 3));\n@@ -3481,6 +3486,10 @@ private final int _decodeUtf8_3(int c1) throws IOException\n             _reportInvalidOther(d & 0xFF, _inputPtr);\n         }\n         c = (c << 6) | (d & 0x3F);\n+        // [jackson-core#363]: Surrogates (0xD800 - 0xDFFF) are illegal in UTF-8\n+        if (c >= 0xD800 && c <= 0xDFFF) {\n+            _reportInvalidUTF8Surrogate(c);\n+        }\n         return c;\n     }\n \n@@ -3497,6 +3506,10 @@ private final int _decodeUtf8_3fast(int c1) throws IOException\n             _reportInvalidOther(d & 0xFF, _inputPtr);\n         }\n         c = (c << 6) | (d & 0x3F);\n+        // [jackson-core#363]: Surrogates (0xD800 - 0xDFFF) are illegal in UTF-8\n+        if (c >= 0xD800 && c <= 0xDFFF) {\n+            _reportInvalidUTF8Surrogate(c);\n+        }\n         return c;\n     }\n \ndiff --git a/src/main/java/com/fasterxml/jackson/core/json/async/NonBlockingJsonParserBase.java b/src/main/java/com/fasterxml/jackson/core/json/async/NonBlockingJsonParserBase.java\nindex e8cb680fd9..974008da20 100644\n--- a/src/main/java/com/fasterxml/jackson/core/json/async/NonBlockingJsonParserBase.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/async/NonBlockingJsonParserBase.java\n@@ -768,7 +768,12 @@ protected final String _addName(int[] quads, int qlen, int lastQuadBytes)\n                         _reportInvalidOther(ch2);\n                     }\n                     ch = (ch << 6) | (ch2 & 0x3F);\n-                    if (needed > 2) { // 4 bytes? (need surrogates on output)\n+                    // [jackson-core#363]: Surrogates (0xD800 - 0xDFFF) are illegal in UTF-8 for 3-byte sequences\n+                    if (needed == 2) {\n+                        if (ch >= 0xD800 && ch <= 0xDFFF) {\n+                            _reportInvalidUTF8Surrogate(ch);\n+                        }\n+                    } else { // 4 bytes? (need surrogates on output)\n                         ch2 = quads[ix >> 2];\n                         byteIx = (ix & 3);\n                         ch2 = (ch2 >> ((3 - byteIx) << 3));\ndiff --git a/src/main/java/com/fasterxml/jackson/core/json/async/NonBlockingUtf8JsonParserBase.java b/src/main/java/com/fasterxml/jackson/core/json/async/NonBlockingUtf8JsonParserBase.java\nindex 00c9f27153..fceb3734bf 100644\n--- a/src/main/java/com/fasterxml/jackson/core/json/async/NonBlockingUtf8JsonParserBase.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/async/NonBlockingUtf8JsonParserBase.java\n@@ -2828,7 +2828,12 @@ private final boolean _decodeSplitUTF8_3(int prev, int prevCount, int next)\n         if ((next & 0xC0) != 0x080) {\n             _reportInvalidOther(next & 0xFF, _inputPtr);\n         }\n-        _textBuffer.append((char) ((prev << 6) | (next & 0x3F)));\n+        int c = (prev << 6) | (next & 0x3F);\n+        // [jackson-core#363]: Surrogates (0xD800 - 0xDFFF) are illegal in UTF-8\n+        if (c >= 0xD800 && c <= 0xDFFF) {\n+            _reportInvalidUTF8Surrogate(c);\n+        }\n+        _textBuffer.append((char) c);\n         return true;\n     }\n \n@@ -2974,7 +2979,12 @@ private final int _decodeUTF8_3(int c, int d, int e) throws IOException\n         if ((e & 0xC0) != 0x080) {\n             _reportInvalidOther(e & 0xFF, _inputPtr);\n         }\n-        return (c << 6) | (e & 0x3F);\n+        c = (c << 6) | (e & 0x3F);\n+        // [jackson-core#363]: Surrogates (0xD800 - 0xDFFF) are illegal in UTF-8\n+        if (c >= 0xD800 && c <= 0xDFFF) {\n+            _reportInvalidUTF8Surrogate(c);\n+        }\n+        return c;\n     }\n \n     // @return Character value <b>minus 0x10000</c>; this so that caller\n",
  "test_patch" : "diff --git a/src/test/java/com/fasterxml/jackson/core/read/UTF8SurrogateValidation363Test.java b/src/test/java/com/fasterxml/jackson/core/read/UTF8SurrogateValidation363Test.java\nnew file mode 100644\nindex 0000000000..97256dd562\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/core/read/UTF8SurrogateValidation363Test.java\n@@ -0,0 +1,194 @@\n+package com.fasterxml.jackson.core.read;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.exc.StreamReadException;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * Tests for [jackson-core#363]: UTF-8 parser should reject 3-byte UTF-8 sequences\n+ * that encode surrogate code points (U+D800 to U+DFFF), which are illegal in UTF-8.\n+ */\n+class UTF8SurrogateValidation363Test extends JUnit5TestBase\n+{\n+    private final JsonFactory FACTORY = newStreamFactory();\n+\n+    /**\n+     * Test that parser rejects 3-byte UTF-8 sequence encoding U+D800 (start of surrogate range).\n+     * In UTF-8, U+D800 would be encoded as: ED A0 80\n+     */\n+    @Test\n+    void rejectSurrogateD800InString() throws Exception\n+    {\n+        // JSON: {\"value\":\"X\"}\n+        // where X is the invalid 3-byte sequence ED A0 80 (U+D800)\n+        byte[] doc = new byte[] {\n+            '{', '\"', 'v', 'a', 'l', 'u', 'e', '\"', ':',\n+            '\"',\n+            (byte) 0xED, (byte) 0xA0, (byte) 0x80, // Invalid: U+D800 surrogate\n+            '\"',\n+            '}'\n+        };\n+\n+        try (JsonParser p = FACTORY.createParser(doc)) {\n+            assertToken(JsonToken.START_OBJECT, p.nextToken());\n+            assertToken(JsonToken.FIELD_NAME, p.nextToken());\n+            assertEquals(\"value\", p.currentName());\n+\n+            // This should fail when trying to read the string value\n+            assertToken(JsonToken.VALUE_STRING, p.nextToken());\n+            p.getText(); // Actual parsing happens here  (lazy parsing)\n+            fail(\"Should have thrown an exception for surrogate code point in UTF-8\");\n+        } catch (StreamReadException e) {\n+            verifyException(e, \"Invalid UTF-8\");\n+        }\n+    }\n+\n+    /**\n+     * Test that parser rejects 3-byte UTF-8 sequence encoding U+DFFF (end of surrogate range).\n+     * In UTF-8, U+DFFF would be encoded as: ED BF BF\n+     */\n+    @Test\n+    void rejectSurrogateDFFFInString() throws Exception\n+    {\n+        // JSON: {\"value\":\"X\"}\n+        // where X is the invalid 3-byte sequence ED BF BF (U+DFFF)\n+        byte[] doc = new byte[] {\n+            '{', '\"', 'v', 'a', 'l', 'u', 'e', '\"', ':',\n+            '\"',\n+            (byte) 0xED, (byte) 0xBF, (byte) 0xBF, // Invalid: U+DFFF surrogate\n+            '\"',\n+            '}'\n+        };\n+\n+        try (JsonParser p = FACTORY.createParser(doc)) {\n+            assertToken(JsonToken.START_OBJECT, p.nextToken());\n+            assertToken(JsonToken.FIELD_NAME, p.nextToken());\n+            assertEquals(\"value\", p.currentName());\n+\n+            // This should fail when trying to read the string value\n+            assertToken(JsonToken.VALUE_STRING, p.nextToken());\n+            p.getText(); // Actual parsing happens here  (lazy parsing)\n+            fail(\"Should have thrown an exception for surrogate code point in UTF-8\");\n+        } catch (StreamReadException e) {\n+            verifyException(e, \"Invalid UTF-8\");\n+        }\n+    }\n+\n+    /**\n+     * Test that parser rejects 3-byte UTF-8 sequence encoding U+DABC (middle of surrogate range).\n+     * In UTF-8, U+DABC would be encoded as: ED AA BC\n+     */\n+    @Test\n+    void rejectSurrogateMiddleInString() throws Exception\n+    {\n+        // JSON: {\"value\":\"X\"}\n+        // where X is the invalid 3-byte sequence ED AA BC (U+DABC)\n+        byte[] doc = new byte[] {\n+            '{', '\"', 'v', 'a', 'l', 'u', 'e', '\"', ':',\n+            '\"',\n+            (byte) 0xED, (byte) 0xAA, (byte) 0xBC, // Invalid: U+DABC surrogate\n+            '\"',\n+            '}'\n+        };\n+\n+        try (JsonParser p = FACTORY.createParser(doc)) {\n+            assertToken(JsonToken.START_OBJECT, p.nextToken());\n+            assertToken(JsonToken.FIELD_NAME, p.nextToken());\n+            assertEquals(\"value\", p.currentName());\n+\n+            // This should fail when trying to read the string value\n+            assertToken(JsonToken.VALUE_STRING, p.nextToken());\n+            p.getText(); // Actual parsing happens here  (lazy parsing)\n+            fail(\"Should have thrown an exception for surrogate code point in UTF-8\");\n+        } catch (StreamReadException e) {\n+            verifyException(e, \"Invalid UTF-8\");\n+        }\n+    }\n+\n+    /**\n+     * Test that parser rejects surrogate in field name as well.\n+     */\n+    @Test\n+    void rejectSurrogateInFieldName() throws Exception\n+    {\n+        // JSON: {\"X\":\"value\"}\n+        // where X is the invalid 3-byte sequence ED A0 80 (U+D800)\n+        byte[] doc = new byte[] {\n+            '{', '\"',\n+            (byte) 0xED, (byte) 0xA0, (byte) 0x80, // Invalid: U+D800 surrogate\n+            '\"', ':', '\"', 'v', 'a', 'l', 'u', 'e', '\"',\n+            '}'\n+        };\n+\n+        try (JsonParser p = FACTORY.createParser(doc)) {\n+            assertToken(JsonToken.START_OBJECT, p.nextToken());\n+\n+            // This should fail when trying to read the field name\n+            // (no lazy parsing for names)\n+            assertToken(JsonToken.FIELD_NAME, p.nextToken());\n+            fail(\"Should have thrown an exception for surrogate code point in UTF-8\");\n+        } catch (StreamReadException e) {\n+            verifyException(e, \"Invalid UTF-8\");\n+        }\n+    }\n+\n+    /**\n+     * Sanity check: valid 3-byte UTF-8 sequences just before surrogate range should work.\n+     * U+D7FF is the last valid code point before the surrogate range.\n+     * In UTF-8: ED 9F BF\n+     */\n+    @Test\n+    void acceptValidBeforeSurrogateRange() throws Exception\n+    {\n+        // JSON: {\"value\":\"X\"}\n+        // where X is the valid 3-byte sequence ED 9F BF (U+D7FF)\n+        byte[] doc = new byte[] {\n+            '{', '\"', 'v', 'a', 'l', 'u', 'e', '\"', ':',\n+            '\"',\n+            (byte) 0xED, (byte) 0x9F, (byte) 0xBF, // Valid: U+D7FF (just before surrogates)\n+            '\"',\n+            '}'\n+        };\n+\n+        try (JsonParser p = FACTORY.createParser(doc)) {\n+            assertToken(JsonToken.START_OBJECT, p.nextToken());\n+            assertToken(JsonToken.FIELD_NAME, p.nextToken());\n+            assertEquals(\"value\", p.currentName());\n+            assertToken(JsonToken.VALUE_STRING, p.nextToken());\n+            assertEquals(\"\\uD7FF\", p.getText());\n+            assertToken(JsonToken.END_OBJECT, p.nextToken());\n+        }\n+    }\n+\n+    /**\n+     * Sanity check: valid 3-byte UTF-8 sequences just after surrogate range should work.\n+     * U+E000 is the first valid code point after the surrogate range.\n+     * In UTF-8: EE 80 80\n+     */\n+    @Test\n+    void acceptValidAfterSurrogateRange() throws Exception\n+    {\n+        // JSON: {\"value\":\"X\"}\n+        // where X is the valid 3-byte sequence EE 80 80 (U+E000)\n+        byte[] doc = new byte[] {\n+            '{', '\"', 'v', 'a', 'l', 'u', 'e', '\"', ':',\n+            '\"',\n+            (byte) 0xEE, (byte) 0x80, (byte) 0x80, // Valid: U+E000 (just after surrogates)\n+            '\"',\n+            '}'\n+        };\n+\n+        try (JsonParser p = FACTORY.createParser(doc)) {\n+            assertToken(JsonToken.START_OBJECT, p.nextToken());\n+            assertToken(JsonToken.FIELD_NAME, p.nextToken());\n+            assertEquals(\"value\", p.currentName());\n+            assertToken(JsonToken.VALUE_STRING, p.nextToken());\n+            assertEquals(\"\\uE000\", p.getText());\n+            assertToken(JsonToken.END_OBJECT, p.nextToken());\n+        }\n+    }\n+}\n",
  "problem_statement" : "See https://github.com/FasterXML/jackson-dataformats-binary/pull/65 for background: it looks like UTF-8 json parser is not checking for case of 3-byte character being surrogate: I think it should.\r\n(although there is still the whole issue of why JSON escapes may be used in such a way...).\r\n",
  "hints_text" : null,
  "created_at" : "Sun Nov 02 04:14:48 CET 2025",
  "version" : null,
  "FAIL_TO_PASS" : [ "UTF8SurrogateValidation363Test" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=UTF8SurrogateValidation363Test",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : 363,
  "pull_number" : 1494,
  "metadata" : null
}, {
  "instance_id" : "FasterXML-jackson-core-PR-1492",
  "repo" : "FasterXML/jackson-core",
  "base_commit" : "bac78c0f1d6c48f7aef7858951e0a65676fe4a32",
  "patch" : "diff --git a/release-notes/VERSION b/release-notes/VERSION\nindex 89f51d08d5..1c65ae2f4b 100644\n--- a/release-notes/VERSION\n+++ b/release-notes/VERSION\n@@ -15,6 +15,15 @@ JSON library.\n === Releases ===\n ------------------------------------------------------------------------\n \n+3.1.0 (not yet released)\n+\n+-\n+\n+3.0.2 (not yet released)\n+\n+#1491: Mismatched property name for byte-backed `JsonParser.nextNameMatch(PropertyNameMatcher)`\n+ (fix by @cowtowncoder, w/ Claude code)\n+\n 3.0.1 (21-Oct-2025)\n \n No changes since 3.0.0\ndiff --git a/src/main/java/tools/jackson/core/json/UTF8StreamJsonParser.java b/src/main/java/tools/jackson/core/json/UTF8StreamJsonParser.java\nindex bfdccd8b07..5e140e91f8 100644\n--- a/src/main/java/tools/jackson/core/json/UTF8StreamJsonParser.java\n+++ b/src/main/java/tools/jackson/core/json/UTF8StreamJsonParser.java\n@@ -1573,6 +1573,8 @@ protected final int _matchLongName(PropertyNameMatcher matcher, int qptr,\n                 if (i != INT_QUOTE) {\n                     return -1;\n                 }\n+                // [core#1491]: Need to include partial quad in matching\n+                _quadBuffer[qlen++] = q;\n                 _quadPtr = qptr;\n                 return matcher.matchByQuad(_quadBuffer, qlen);\n             }\n@@ -1582,8 +1584,10 @@ protected final int _matchLongName(PropertyNameMatcher matcher, int qptr,\n                 if (i != INT_QUOTE) {\n                     return -1;\n                 }\n-//                q = _padLastQuadNoCheck(q, (-1 << 8));\n-                break;\n+                // [core#1491]: Need to include partial quad in matching\n+                _quadBuffer[qlen++] = q;\n+                _quadPtr = qptr;\n+                return matcher.matchByQuad(_quadBuffer, qlen);\n             }\n             q = (q << 8) | i;\n             i = input[qptr++] & 0xFF;\n@@ -1591,8 +1595,10 @@ protected final int _matchLongName(PropertyNameMatcher matcher, int qptr,\n                 if (i != INT_QUOTE) {\n                     return -1;\n                 }\n-//                q = _padLastQuadNoCheck(q, (-1 << 16));\n-                break;\n+                // [core#1491]: Need to include partial quad in matching\n+                _quadBuffer[qlen++] = q;\n+                _quadPtr = qptr;\n+                return matcher.matchByQuad(_quadBuffer, qlen);\n             }\n             q = (q << 8) | i;\n             i = input[qptr++] & 0xFF;\n@@ -1600,8 +1606,10 @@ protected final int _matchLongName(PropertyNameMatcher matcher, int qptr,\n                 if (i != INT_QUOTE) {\n                     return -1;\n                 }\n-//                q = _padLastQuadNoCheck(q, (-1 << 24));\n-                break;\n+                // [core#1491]: Need to include partial quad in matching\n+                _quadBuffer[qlen++] = q;\n+                _quadPtr = qptr;\n+                return matcher.matchByQuad(_quadBuffer, qlen);\n             }\n             // Nope, no end in sight. Need to grow quad array etc\n             if (qlen >= _quadBuffer.length) {\n",
  "test_patch" : "diff --git a/src/test/java/tools/jackson/core/unittest/sym/BinaryNameMatcherTest.java b/src/test/java/tools/jackson/core/unittest/sym/BinaryNameMatcherTest.java\nindex 6e595242dd..efe44abf84 100644\n--- a/src/test/java/tools/jackson/core/unittest/sym/BinaryNameMatcherTest.java\n+++ b/src/test/java/tools/jackson/core/unittest/sym/BinaryNameMatcherTest.java\n@@ -19,6 +19,8 @@ public void testSmallMatching()\n         // First small (1 - 4)\n         _testMatching(\"single\");\n         _testMatching(\"1\", \"2a\");\n+        //[core#1491]\n+        _testMatching(\"aaaabbbbcccc\", \"aaaabbbbcccc2\");\n         _testMatching(\"first\", \"secondlong\", \"3rd\");\n     }\n \ndiff --git a/src/test/java/tools/jackson/core/unittest/sym/PropertyNameMatcher1491Test.java b/src/test/java/tools/jackson/core/unittest/sym/PropertyNameMatcher1491Test.java\nnew file mode 100644\nindex 0000000000..465847ce3c\n--- /dev/null\n+++ b/src/test/java/tools/jackson/core/unittest/sym/PropertyNameMatcher1491Test.java\n@@ -0,0 +1,140 @@\n+package tools.jackson.core.unittest.sym;\n+\n+import java.util.List;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import tools.jackson.core.*;\n+import tools.jackson.core.io.SerializedString;\n+import tools.jackson.core.json.JsonFactory;\n+import tools.jackson.core.sym.PropertyNameMatcher;\n+import tools.jackson.core.util.Named;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+// [core#1491]: PropertyNameMatcher collision\n+public class PropertyNameMatcher1491Test\n+    extends tools.jackson.core.unittest.JacksonCoreTestBase\n+{\n+    // Occurs with min of 12 chars (multiples of 4, 16 works).\n+    // Choice of first N does not matter, nor last (13th);\n+    // All of below show failure\n+    \n+    private final static String KEY_1 = \"aaaabbbbcccc\";\n+    private final static String KEY_2 = \"aaaabbbbcccc2\";\n+//    private final String KEY_1 = \"a234b234c234\";\n+//    private final String KEY_2 = \"a234b234c234x\";\n+//    private final String KEY_1 = \"a234b234c234dXYZ\";\n+//    private final String KEY_2 = \"a234b234c234dXYZ0\";\n+\n+    \n+    private final static Named NAMED_1 = Named.fromString(KEY_1);\n+    private final static Named NAMED_2 = Named.fromString(KEY_2);\n+\n+    private final static String DOC_1491 = \"\"\"\n+{\n+\"%s\": \"v3\",\n+\"%s\": \"v4\"\n+}\n+\"\"\".formatted(KEY_1, KEY_2);\n+\n+    @Test\n+    void test1491ViaRegularParserBytes() throws Exception {\n+        _testViaRegularParser(MODE_INPUT_STREAM);\n+        _testViaRegularParser(MODE_INPUT_STREAM_THROTTLED);\n+    }\n+\n+    @Test\n+    void test1491ViaRegularParserChars() throws Exception {\n+        _testViaRegularParser(MODE_READER);\n+    }\n+\n+    private void _testViaRegularParser(int mode) throws Exception\n+    {\n+        // First, regular reads\n+        try (JsonParser p = createParser(mode, DOC_1491)) {\n+            assertToken(JsonToken.START_OBJECT, p.nextToken());\n+            assertToken(JsonToken.PROPERTY_NAME, p.nextToken());\n+            assertEquals(KEY_1, p.currentName());\n+            assertToken(JsonToken.VALUE_STRING, p.nextToken());\n+            assertEquals(\"v3\", p.getString());\n+            assertToken(JsonToken.PROPERTY_NAME, p.nextToken());\n+            assertEquals(KEY_2, p.currentName());\n+            assertToken(JsonToken.VALUE_STRING, p.nextToken());\n+            assertEquals(\"v4\", p.getString());\n+            assertToken(JsonToken.END_OBJECT, p.nextToken());\n+        }\n+\n+        // Then, nextName() variants\n+        try (JsonParser p = createParser(mode, DOC_1491)) {\n+            assertToken(JsonToken.START_OBJECT, p.nextToken());\n+            assertTrue(p.nextName(new SerializedString(KEY_1)));\n+            assertToken(JsonToken.PROPERTY_NAME, p.currentToken());\n+            assertEquals(KEY_1, p.currentName());\n+            assertToken(JsonToken.VALUE_STRING, p.nextToken());\n+            assertEquals(\"v3\", p.getString());\n+            assertTrue(p.nextName(new SerializedString(KEY_2)));\n+            assertToken(JsonToken.PROPERTY_NAME, p.currentToken());\n+            assertEquals(KEY_2, p.currentName());\n+            assertToken(JsonToken.VALUE_STRING, p.nextToken());\n+            assertEquals(\"v4\", p.getString());\n+            assertToken(JsonToken.END_OBJECT, p.nextToken());\n+        }\n+\n+        try (JsonParser p = createParser(mode, DOC_1491)) {\n+            assertToken(JsonToken.START_OBJECT, p.nextToken());\n+            // try wrong match\n+            assertFalse(p.nextName(new SerializedString(KEY_2)));\n+            assertToken(JsonToken.PROPERTY_NAME, p.currentToken());\n+            assertEquals(KEY_1, p.currentName());\n+            assertToken(JsonToken.VALUE_STRING, p.nextToken());\n+            assertEquals(\"v3\", p.getString());\n+            assertFalse(p.nextName(new SerializedString(KEY_1)));\n+            assertToken(JsonToken.PROPERTY_NAME, p.currentToken());\n+            assertEquals(KEY_2, p.currentName());\n+            assertToken(JsonToken.VALUE_STRING, p.nextToken());\n+            assertEquals(\"v4\", p.getString());\n+            assertToken(JsonToken.END_OBJECT, p.nextToken());\n+        }\n+    }\n+\n+    @Test\n+    void test1491ViaMatcherBytes() throws Exception {\n+        JsonFactory f = newStreamFactory();\n+        _testViaMatcher(f, MODE_INPUT_STREAM);\n+        _testViaMatcher(f, MODE_INPUT_STREAM_THROTTLED);\n+    }\n+\n+    @Test\n+    void test1491ViaMatcherChar() throws Exception {\n+        JsonFactory f = newStreamFactory();\n+        _testViaMatcher(f, MODE_READER);\n+    }\n+\n+    private void _testViaMatcher(JsonFactory f, int mode) throws Exception\n+    {\n+        PropertyNameMatcher matcher = f.constructNameMatcher(List.of(NAMED_1, NAMED_2),\n+                false);\n+\n+        try (JsonParser p = createParser(mode, DOC_1491)) {\n+            assertToken(JsonToken.START_OBJECT, p.nextToken());\n+\n+            assertEquals(0, p.nextNameMatch(matcher));\n+            assertToken(JsonToken.PROPERTY_NAME, p.currentToken());\n+            assertEquals(KEY_1, p.currentName());\n+\n+            assertToken(JsonToken.VALUE_STRING, p.nextToken());\n+            assertEquals(\"v3\", p.getString());\n+\n+            assertEquals(1, p.nextNameMatch(matcher));\n+            assertToken(JsonToken.PROPERTY_NAME, p.currentToken());\n+            assertEquals(KEY_2, p.currentName());\n+\n+            assertToken(JsonToken.VALUE_STRING, p.nextToken());\n+            assertEquals(\"v4\", p.getString());\n+            assertToken(JsonToken.END_OBJECT, p.nextToken());\n+        }\n+    }\n+}\n",
  "problem_statement" : "(note: created based on https://github.com/FasterXML/jackson-databind/issues/5372)\n\nLooks like following JSON can produce property name mismatch:\n\n```\n            {\n              \"aaaabbbbcccc\": \"v3\",\n              \"aaaabbbbcccc2\": \"v4\"\n            }\n```\n\nvia byte-based streaming (UTF8) parser.\n\nSince the original test is on databind, it is unclear on which codepath: either regular canonicalizing parser, or with `PropertyNameMatcher` (new in 3.0) -- my guess is latter.\n\nRegardless, need to figure it out: so start with test to reproduce.\n",
  "hints_text" : null,
  "created_at" : "Fri Oct 31 18:11:24 CET 2025",
  "version" : null,
  "FAIL_TO_PASS" : [ "BinaryNameMatcherTest", "PropertyNameMatcher1491Test" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=BinaryNameMatcherTest,PropertyNameMatcher1491Test",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : 1491,
  "pull_number" : 1492,
  "metadata" : null
}, {
  "instance_id" : "FasterXML-jackson-core-PR-1490",
  "repo" : "FasterXML/jackson-core",
  "base_commit" : "c1a2db99ffd539a6a1ce645c3714ed234767c925",
  "patch" : "diff --git a/release-notes/VERSION-2.x b/release-notes/VERSION-2.x\nindex 403601a119..6e6a33c1af 100644\n--- a/release-notes/VERSION-2.x\n+++ b/release-notes/VERSION-2.x\n@@ -16,6 +16,8 @@ a pure JSON library.\n \n 2.21.0 (not yet released)\n \n+#1180: `JsonLocation` off for unrecognized tokens\n+ (fix by @cowtowncoder, w/ Claude code)\n #1470: Add method `copyCurrentStructureExact()` to `JsonGenerator`\n  (contributed by Lars H)\n #1477: Add `JsonGenerator.has(StreamWriteCapability)` convenience method\ndiff --git a/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java b/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\nindex ce8e94421f..cfa01ead57 100644\n--- a/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\n@@ -3001,6 +3001,13 @@ protected void _reportInvalidToken(String matchedPart, String msg) throws IOExce\n          * regular Java identifier character rules. It's just a heuristic,\n          * nothing fancy here.\n          */\n+        // [core#1180]: Construct JsonLocation at token start BEFORE _loadMore() may change buffer state\n+        final int tokenStartPtr = _inputPtr - matchedPart.length();\n+        final int col = tokenStartPtr - _currInputRowStart + 1; // 1-based\n+        final JsonLocation loc = new JsonLocation(_contentReference(),\n+                -1L, _currInputProcessed + tokenStartPtr,\n+                _currInputRow, col);\n+\n         StringBuilder sb = new StringBuilder(matchedPart);\n         while ((_inputPtr < _inputEnd) || _loadMore()) {\n             char c = _inputBuffer[_inputPtr];\n@@ -3014,7 +3021,8 @@ protected void _reportInvalidToken(String matchedPart, String msg) throws IOExce\n                 break;\n             }\n         }\n-        _reportError(\"Unrecognized token '%s': was expecting %s\", sb, msg);\n+        final String fullMsg = String.format(\"Unrecognized token '%s': was expecting %s\", sb, msg);\n+        throw _constructReadException(fullMsg, loc);\n     }\n \n     /*\ndiff --git a/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java b/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\nindex d5b521a421..70e78362e0 100644\n--- a/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java\n@@ -3641,6 +3641,13 @@ protected void _reportInvalidToken(String matchedPart, String msg) throws IOExce\n          * regular Java identifier character rules. It's just a heuristic,\n          * nothing fancy here (nor fast).\n          */\n+        // [core#1180]: Construct JsonLocation at token start BEFORE _loadMore() may change buffer state\n+        final int tokenStartPtr = _inputPtr - matchedPart.length();\n+        final int col = tokenStartPtr - _currInputRowStart + 1; // 1-based\n+        final JsonLocation loc = new JsonLocation(_contentReference(),\n+                _currInputProcessed + tokenStartPtr, -1L, // bytes, chars\n+                _currInputRow, col);\n+\n         StringBuilder sb = new StringBuilder(matchedPart);\n         while ((_inputPtr < _inputEnd) || _loadMore()) {\n             int i = _inputBuffer[_inputPtr++];\n@@ -3659,7 +3666,8 @@ protected void _reportInvalidToken(String matchedPart, String msg) throws IOExce\n                 break;\n             }\n         }\n-        _reportError(\"Unrecognized token '%s': was expecting %s\", sb, msg);\n+        final String fullMsg = String.format(\"Unrecognized token '%s': was expecting %s\", sb, msg);\n+        throw _constructReadException(fullMsg, loc);\n     }\n \n     protected void _reportInvalidChar(int c) throws JsonParseException\ndiff --git a/src/main/java/com/fasterxml/jackson/core/json/async/NonBlockingUtf8JsonParserBase.java b/src/main/java/com/fasterxml/jackson/core/json/async/NonBlockingUtf8JsonParserBase.java\nindex 5cb3e90cbb..00c9f27153 100644\n--- a/src/main/java/com/fasterxml/jackson/core/json/async/NonBlockingUtf8JsonParserBase.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/async/NonBlockingUtf8JsonParserBase.java\n@@ -1262,10 +1262,11 @@ protected JsonToken _finishErrorTokenWithEOF() throws IOException\n \n     protected JsonToken _reportErrorToken(String actualToken) throws IOException\n     {\n+        // [core#1180]: Report error at token start, not current position\n         // !!! TODO: Include non-standard ones if enabled\n-        _reportError(\"Unrecognized token '%s': was expecting %s\", _textBuffer.contentsAsString(),\n-                _validJsonTokenList());\n-        return JsonToken.NOT_AVAILABLE; // never gets here\n+        final String fullMsg = String.format(\"Unrecognized token '%s': was expecting %s\",\n+                _textBuffer.contentsAsString(), _validJsonTokenList());\n+        throw _constructReadException(fullMsg, currentTokenLocation());\n     }\n \n     /*\n",
  "test_patch" : "diff --git a/src/test/java/com/fasterxml/jackson/core/ErrorReportConfigurationTest.java b/src/test/java/com/fasterxml/jackson/core/ErrorReportConfigurationTest.java\nindex 6d1ba78608..3f7695fc7a 100644\n--- a/src/test/java/com/fasterxml/jackson/core/ErrorReportConfigurationTest.java\n+++ b/src/test/java/com/fasterxml/jackson/core/ErrorReportConfigurationTest.java\n@@ -177,28 +177,32 @@ void withJsonFactory() throws Exception\n     void expectedTokenLengthWithConfigurations()\n             throws Exception\n     {\n+        // [core#1180]: After fix, error location points to token start (position 7 in \"{\\\"key\\\":aaa...\")\n+        // not to the end of consumed token, so all cases now report same offset\n+        final int tokenStartOffset = 7;\n+\n         // default\n-        _verifyErrorTokenLength(263,\n+        _verifyErrorTokenLength(tokenStartOffset,\n                 ErrorReportConfiguration.builder().build());\n         // default\n-        _verifyErrorTokenLength(263,\n+        _verifyErrorTokenLength(tokenStartOffset,\n                 ErrorReportConfiguration.defaults());\n         // shorter\n-        _verifyErrorTokenLength(63,\n+        _verifyErrorTokenLength(tokenStartOffset,\n                 ErrorReportConfiguration.builder()\n                         .maxErrorTokenLength(DEFAULT_ERROR_LENGTH - 200).build());\n-        // longer \n-        _verifyErrorTokenLength(463,\n+        // longer\n+        _verifyErrorTokenLength(tokenStartOffset,\n                 ErrorReportConfiguration.builder()\n                         .maxErrorTokenLength(DEFAULT_ERROR_LENGTH + 200).build());\n         // zero\n-        _verifyErrorTokenLength(9,\n+        _verifyErrorTokenLength(tokenStartOffset,\n                 ErrorReportConfiguration.builder()\n                         .maxErrorTokenLength(0).build());\n \n         // negative value fails\n         try {\n-            _verifyErrorTokenLength(9,\n+            _verifyErrorTokenLength(tokenStartOffset,\n                     ErrorReportConfiguration.builder()\n                             .maxErrorTokenLength(-1).build());\n         } catch (IllegalArgumentException e) {\n@@ -208,8 +212,9 @@ void expectedTokenLengthWithConfigurations()\n         }\n         // null is not allowed, throws NPE\n         try {\n-            _verifyErrorTokenLength(263,\n+            _verifyErrorTokenLength(tokenStartOffset,\n                     null);\n+            fail(\"Should not reach here as exception is expected\");\n         } catch (NullPointerException e) {\n             // no-op\n         }\ndiff --git a/src/test/java/com/fasterxml/jackson/core/ExceptionsTest.java b/src/test/java/com/fasterxml/jackson/core/ExceptionsTest.java\nindex 5cd9d89d59..6ecd284e29 100644\n--- a/src/test/java/com/fasterxml/jackson/core/ExceptionsTest.java\n+++ b/src/test/java/com/fasterxml/jackson/core/ExceptionsTest.java\n@@ -146,20 +146,19 @@ void contentSnippetWithOffset() throws Exception\n         final int len = json.length() - start;\n \n         p = jsonF.createParser(jsonB, start, len);\n-        // for byte-based, will be after character that follows token:\n-        // (and alas cannot be easily fixed)\n-        _testContentSnippetWithOffset(p, 9, \"(byte[])\\\"[broken]\\n\\\"\");\n+        // [core#1180]: error location now points to start of invalid token\n+        _testContentSnippetWithOffset(p, 2, \"(byte[])\\\"[broken]\\n\\\"\");\n         p.close();\n \n         final char[] jsonC = json.toCharArray();\n         p = jsonF.createParser(jsonC, start, len);\n-        // for char-based we get true offset at end of token\n-        _testContentSnippetWithOffset(p, 8, \"(char[])\\\"[broken]\\n\\\"\");\n+        // [core#1180]: error location now points to start of invalid token\n+        _testContentSnippetWithOffset(p, 2, \"(char[])\\\"[broken]\\n\\\"\");\n         p.close();\n \n         p = jsonF.createParser(json.substring(start));\n-        // for char-based we get true offset at end of token\n-        _testContentSnippetWithOffset(p, 8, \"(String)\\\"[broken]\\n\\\"\");\n+        // [core#1180]: error location now points to start of invalid token\n+        _testContentSnippetWithOffset(p, 2, \"(String)\\\"[broken]\\n\\\"\");\n         p.close();\n     }\n \ndiff --git a/src/test/java/com/fasterxml/jackson/core/tofix/LocationOfError1180Test.java b/src/test/java/com/fasterxml/jackson/core/read/loc/LocationOfError1180Test.java\nsimilarity index 78%\nrename from src/test/java/com/fasterxml/jackson/core/tofix/LocationOfError1180Test.java\nrename to src/test/java/com/fasterxml/jackson/core/read/loc/LocationOfError1180Test.java\nindex 6f64f99a91..1c28794687 100644\n--- a/src/test/java/com/fasterxml/jackson/core/tofix/LocationOfError1180Test.java\n+++ b/src/test/java/com/fasterxml/jackson/core/read/loc/LocationOfError1180Test.java\n@@ -1,9 +1,8 @@\n-package com.fasterxml.jackson.core.tofix;\n+package com.fasterxml.jackson.core.read.loc;\n \n import java.nio.charset.StandardCharsets;\n import java.util.Arrays;\n import java.util.List;\n-import java.util.Objects;\n import java.util.stream.Stream;\n \n import org.junit.jupiter.params.ParameterizedTest;\n@@ -13,10 +12,7 @@\n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.core.async.ByteArrayFeeder;\n import com.fasterxml.jackson.core.exc.StreamReadException;\n-import com.fasterxml.jackson.core.testutil.failure.ExpectedPassingTestCasePredicate;\n-import com.fasterxml.jackson.core.testutil.failure.JacksonTestFailureExpected;\n \n-import static com.fasterxml.jackson.core.JUnit5TestBase.a2q;\n import static org.junit.jupiter.api.Assertions.*;\n \n /**\n@@ -90,40 +86,31 @@ public JsonParser createParser(String input) throws Exception\n         new InvalidJson(\n             \"Incorrect case for false literal\",\n             \"{\\\"isThisValidJson\\\": FALSE}\",\n-            24,\n-            24,\n+            20,  // byte offset: 'F' starts at position 20\n+            20,  // char offset: 'F' starts at position 20\n             1,\n-            25\n+            21   // column: 1-indexed, so position 20 = column 21\n         ),\n         new InvalidJson(\n             \"Incorrect case for true literal\",\n             \"{\\\"shouldYouAvoidWritingJsonLikeThis\\\": TRUE}\",\n-            41,\n-            41,\n+            38,  // byte offset: 'T' starts at position 38\n+            38,  // char offset: 'T' starts at position 38\n             1,\n-            42\n+            39   // column: 1-indexed, so position 38 = column 39\n         ),\n         new InvalidJson(\n             \"Incorrect case for null literal\",\n             \"{\\\"licensePlate\\\": NULL}\",\n-            20,\n-            20,\n+            17,  // byte offset: 'N' starts at position 17\n+            17,  // char offset: 'N' starts at position 17\n             1,\n-            21\n-        ),\n-        // NOTE: to be removed, eventually\n-        new InvalidJson(\n-            \"Invalid JSON with raw unicode character\",\n-            // javac will parse the 3-byte unicode control sequence, it will be passed to the parser as a raw unicode character\n-            a2q(\"{'validJson':'\\u274c','right', 'here'}\"),\n-            26,\n-            24,\n-            1,\n-            25\n+            18   // column: 1-indexed, so position 17 = column 18\n         )\n+        // NOTE: Unicode test case removed - it tests a different error path (\"Unexpected character\"\n+        // vs \"Unrecognized token\") and has additional complexities with multi-byte UTF-8\n     );\n \n-    @JacksonTestFailureExpected(expectedPassingTestCasePredicate = ShouldPredicate1180Test.class)\n     @ParameterizedTest\n     @MethodSource(\"_generateTestData\")\n     void parserBackendWithInvalidJson(ParserVariant variant, InvalidJson invalidJson)\n@@ -145,7 +132,15 @@ void parserBackendWithInvalidJson(ParserVariant variant, InvalidJson invalidJson\n \n             if (variant.supportsByteOffset)\n             {\n-                assertEquals(invalidJson.byteOffset, location.getByteOffset(), \"Incorrect byte offset (for '\"+msg+\"')\");\n+                // [core#1180]: Async parser may be off by 1 due to when token start position is captured\n+                if (variant == ParserVariant.ASYNC) {\n+                    long actual = location.getByteOffset();\n+                    assertTrue(actual == invalidJson.byteOffset || actual == invalidJson.byteOffset + 1,\n+                            String.format(\"Byte offset should be %d or %d but was %d (for '%s')\",\n+                                    invalidJson.byteOffset, invalidJson.byteOffset + 1, actual, msg));\n+                } else {\n+                    assertEquals(invalidJson.byteOffset, location.getByteOffset(), \"Incorrect byte offset (for '\"+msg+\"')\");\n+                }\n             }\n             if (variant.supportsCharOffset)\n             {\n@@ -199,18 +194,4 @@ public String toString()\n         public final int lineNr;\n         public final int columnNr;\n     }\n-\n-    public static class ShouldPredicate1180Test\n-            implements ExpectedPassingTestCasePredicate\n-    {\n-        @Override\n-        public boolean shouldPass(List<Object> arguments) {\n-            if (arguments.get(0) == ParserVariant.CHAR_ARRAY\n-                && Objects.equals(((InvalidJson) (arguments.get(1)))._name, \"Invalid JSON with raw unicode character\")\n-            ) {\n-                return true;\n-            }\n-            return false;\n-        }\n-    }\n }\n",
  "problem_statement" : "(note: follow up to remaining case from #1173)\r\n\r\nLooks like `JsonLocation` reported for input like:\r\n\r\n```\r\n{\"isThisValidJson\": FALSE}\r\n```\r\n\r\nis off so that reported position of error is at the end of `FALSE` token, instead of the beginning (first character of unrecognized token).\r\n",
  "hints_text" : null,
  "created_at" : "Wed Oct 29 18:56:45 CET 2025",
  "version" : null,
  "FAIL_TO_PASS" : [ "ExceptionsTest", "LocationOfError1180Test", "ErrorReportConfigurationTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=ExceptionsTest,LocationOfError1180Test,ErrorReportConfigurationTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : 1180,
  "pull_number" : 1490,
  "metadata" : null
}, {
  "instance_id" : "FasterXML-jackson-core-PR-1486",
  "repo" : "FasterXML/jackson-core",
  "base_commit" : "4f23c31d363f491cab277d18a04d457b6bfbd472",
  "patch" : "diff --git a/src/main/java/tools/jackson/core/util/TextBuffer.java b/src/main/java/tools/jackson/core/util/TextBuffer.java\nindex c907776ae3..ce82dcb56d 100644\n--- a/src/main/java/tools/jackson/core/util/TextBuffer.java\n+++ b/src/main/java/tools/jackson/core/util/TextBuffer.java\n@@ -322,6 +322,58 @@ public void resetWithString(String value) throws JacksonException\n         _currentSize = 0;\n     }\n \n+    /**\n+     * Init method called to reset buffer with contents of given ASCII byte array.\n+     * Used to reduce JDK overhead in post-JDK8 world\n+     * where {@code String} uses {@code byte[]} internally.\n+     *\n+     * @since 3.1\n+     */\n+    public String resetWithASCII(byte[] buffer, int offset, int len) throws JacksonException\n+    {\n+        _inputBuffer = null;\n+        _inputStart = -1;\n+        _inputLen = 0;\n+\n+        validateStringLength(len);\n+        // NOTE: we know it's US-Ascii, validated: ISO-8859-1 is a superset that maps without checks\n+        String str = new String(buffer, offset, len, java.nio.charset.StandardCharsets.ISO_8859_1);\n+        _resultString = str;\n+        _resultArray = null;\n+\n+        if (_hasSegments) {\n+            clearSegments();\n+        }\n+        _currentSize = 0;\n+        return str;\n+    }\n+\n+    /**\n+     * Init method called to reset buffer with contents of given UTF-8 byte array.\n+     * Used to reduce JDK overhead in post-JDK8 world\n+     * where {@code String} uses {@code byte[]} internally.\n+     *\n+     * @since 3.1\n+     */\n+    public String resetWithUTF8(byte[] buffer, int offset, int len) throws JacksonException\n+    {\n+        _inputBuffer = null;\n+        _inputStart = -1;\n+        _inputLen = 0;\n+\n+        validateStringLength(len);\n+        // NOTE: could be ASCII, Latin-1; we know it's UTF-8, though\n+        String str = new String(buffer, offset, len, java.nio.charset.StandardCharsets.UTF_8);\n+        _resultString = str;\n+        _resultArray = null;\n+\n+        if (_hasSegments) {\n+            clearSegments();\n+        }\n+        _currentSize = 0;\n+        return str;\n+    }\n+\n     /**\n      * Method for accessing the currently active (last) content segment\n      * without changing state of the buffer\n",
  "test_patch" : "diff --git a/src/test/java/tools/jackson/core/unittest/util/TextBufferTest.java b/src/test/java/tools/jackson/core/unittest/util/TextBufferTest.java\nindex b44a1c26eb..0c0450cd55 100644\n--- a/src/test/java/tools/jackson/core/unittest/util/TextBufferTest.java\n+++ b/src/test/java/tools/jackson/core/unittest/util/TextBufferTest.java\n@@ -1,6 +1,7 @@\n package tools.jackson.core.unittest.util;\n \n import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n \n import org.junit.jupiter.api.Test;\n \n@@ -197,6 +198,30 @@ void resetWithString() throws Exception {\n         assertEquals(0, textBuffer.getTextOffset());\n     }\n \n+    // 3.1\n+    @Test\n+    void resetWithAsciiBytes() throws Exception {\n+        BufferRecycler bufferRecycler = new BufferRecycler();\n+        TextBuffer textBuffer = new TextBuffer(bufferRecycler);\n+\n+        assertEquals(\"abc\", textBuffer.resetWithASCII(new byte[] { 'a', 'b', 'c' }, 0, 3));\n+        assertEquals(0, textBuffer.getTextOffset());\n+        assertEquals(\"abc\", textBuffer.contentsAsString());\n+    }\n+\n+    // 3.1\n+    @Test\n+    void resetWithUTF8Bytes() throws Exception {\n+        BufferRecycler bufferRecycler = new BufferRecycler();\n+        TextBuffer textBuffer = new TextBuffer(bufferRecycler);\n+\n+        final String UTF8_STR = \"\\u00E9\\u00E8\\u00E0\"; // \"\"\n+        final byte[] BYTES = UTF8_STR.getBytes(StandardCharsets.UTF_8);\n+        assertEquals(6, BYTES.length);\n+        assertEquals(UTF8_STR, textBuffer.resetWithUTF8(BYTES, 0, BYTES.length));\n+        assertEquals(UTF8_STR, textBuffer.contentsAsString());\n+    }\n+\n     @Test\n     void getCurrentSegmentSizeResetWith() {\n         TextBuffer textBuffer = new TextBuffer(null);\n",
  "problem_statement" : "Add 2 new reset methods in TextBuffer to support from-bytes String construction",
  "hints_text" : null,
  "created_at" : "Sun Oct 26 04:08:28 CET 2025",
  "version" : null,
  "FAIL_TO_PASS" : [ "TextBufferTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=TextBufferTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 1486,
  "metadata" : null
}, {
  "instance_id" : "FasterXML-jackson-core-PR-1481",
  "repo" : "FasterXML/jackson-core",
  "base_commit" : "c2e2fcead1d3d1ddb119c1ad769161675e9036b2",
  "patch" : "diff --git a/release-notes/VERSION b/release-notes/VERSION\nindex ce5ac63f74..2dc53d9fbd 100644\n--- a/release-notes/VERSION\n+++ b/release-notes/VERSION\n@@ -15,6 +15,10 @@ JSON library.\n === Releases ===\n ------------------------------------------------------------------------\n \n+3.0.0 (not yet released)\n+\n+#1480: Add `JsonGenerator.getPrettyPrinter()`\n+\n 3.0.0-rc10 (19-Sep-2025)\n \n No changes since 3.0.0-rc9\ndiff --git a/src/main/java/tools/jackson/core/JsonGenerator.java b/src/main/java/tools/jackson/core/JsonGenerator.java\nindex 036dc73bab..8954a447c6 100644\n--- a/src/main/java/tools/jackson/core/JsonGenerator.java\n+++ b/src/main/java/tools/jackson/core/JsonGenerator.java\n@@ -254,6 +254,22 @@ public StreamWriteConstraints streamWriteConstraints() {\n      */\n     public JsonGenerator setCharacterEscapes(CharacterEscapes esc) { return this; }\n \n+    /**\n+     * Accessfor for object that handles pretty-printing (usually additional white space to make\n+     * results more human-readable) during output. If {@code null}, no pretty-printing is\n+     * done.\n+     * <p>\n+     * NOTE: this may be {@link PrettyPrinter} that {@link TokenStreamFactory} was\n+     * configured with (if stateless), OR an instance created via\n+     * {@link tools.jackson.core.util.Instantiatable#createInstance()} (if\n+     * stateful). Either way, it is per-generator instance.\n+     *\n+     * @return Pretty printer used by this generator, if any; {@code null} if none\n+     *\n+     * @since 3.0\n+     */\n+    public abstract PrettyPrinter getPrettyPrinter();\n+\n     /*\n     /**********************************************************************\n     /* Public API, capability introspection methods\ndiff --git a/src/main/java/tools/jackson/core/json/JsonGeneratorBase.java b/src/main/java/tools/jackson/core/json/JsonGeneratorBase.java\nindex bcbea45d7e..4938d90d99 100644\n--- a/src/main/java/tools/jackson/core/json/JsonGeneratorBase.java\n+++ b/src/main/java/tools/jackson/core/json/JsonGeneratorBase.java\n@@ -80,11 +80,18 @@ public abstract class JsonGeneratorBase extends GeneratorBase\n      */\n \n     /**\n-     * Object that handles pretty-printing (usually additional\n-     * white space to make results more human-readable) during\n-     * output. If null, no pretty-printing is done.\n+     * Object that handles pretty-printing (usually additional white space to make\n+     * results more human-readable) during output. If {@code null}, no pretty-printing is\n+     * done.\n+     * <p>\n+     * NOTE: this may be {@link PrettyPrinter} that {@link TokenStreamFactory} was\n+     * configured with (if stateless), OR an instance created via\n+     * {@link tools.jackson.core.util.Instantiatable#createInstance()} (if\n+     * stateful). Either way, it is per-generator instance.\n+     *<p>\n+     * NOTE: in Jackson 2.x this field was called {@code _cfgPrettyPrinter}.\n      */\n-    protected final PrettyPrinter _cfgPrettyPrinter;\n+    protected final PrettyPrinter _prettyPrinter;\n \n     /**\n      * Separator to use, if any, between root-level values.\n@@ -146,7 +153,7 @@ protected JsonGeneratorBase(ObjectWriteContext writeCtxt, IOContext ioCtxt,\n         _cfgWriteHexUppercase = JsonWriteFeature.WRITE_HEX_UPPER_CASE.enabledIn(formatWriteFeatures);\n         _rootValueSeparator = rootValueSeparator;\n \n-        _cfgPrettyPrinter = pp;\n+        _prettyPrinter = pp;\n \n         final DupDetector dups = StreamWriteFeature.STRICT_DUPLICATE_DETECTION.enabledIn(streamWriteFeatures)\n                 ? DupDetector.rootDetector(this) : null;\n@@ -206,6 +213,11 @@ public CharacterEscapes getCharacterEscapes() {\n         return _characterEscapes;\n     }\n \n+    @Override\n+    public PrettyPrinter getPrettyPrinter() {\n+        return _prettyPrinter;\n+    }\n+\n     /*\n     /**********************************************************************\n     /* Overridden output state handling methods\n@@ -266,20 +278,20 @@ protected void _verifyPrettyValueWrite(String typeMsg, int status) throws Jackso\n         // If we have a pretty printer, it knows what to do:\n         switch (status) {\n         case JsonWriteContext.STATUS_OK_AFTER_COMMA: // array\n-            _cfgPrettyPrinter.writeArrayValueSeparator(this);\n+            _prettyPrinter.writeArrayValueSeparator(this);\n             break;\n         case JsonWriteContext.STATUS_OK_AFTER_COLON:\n-            _cfgPrettyPrinter.writeObjectNameValueSeparator(this);\n+            _prettyPrinter.writeObjectNameValueSeparator(this);\n             break;\n         case JsonWriteContext.STATUS_OK_AFTER_SPACE:\n-            _cfgPrettyPrinter.writeRootValueSeparator(this);\n+            _prettyPrinter.writeRootValueSeparator(this);\n             break;\n         case JsonWriteContext.STATUS_OK_AS_IS:\n             // First entry, but of which context?\n             if (_streamWriteContext.inArray()) {\n-                _cfgPrettyPrinter.beforeArrayValues(this);\n+                _prettyPrinter.beforeArrayValues(this);\n             } else if (_streamWriteContext.inObject()) {\n-                _cfgPrettyPrinter.beforeObjectEntries(this);\n+                _prettyPrinter.beforeObjectEntries(this);\n             }\n             break;\n         case JsonWriteContext.STATUS_EXPECT_NAME:\ndiff --git a/src/main/java/tools/jackson/core/json/UTF8JsonGenerator.java b/src/main/java/tools/jackson/core/json/UTF8JsonGenerator.java\nindex 39fcf2d19c..e3198dbe97 100644\n--- a/src/main/java/tools/jackson/core/json/UTF8JsonGenerator.java\n+++ b/src/main/java/tools/jackson/core/json/UTF8JsonGenerator.java\n@@ -198,7 +198,7 @@ public int streamWriteOutputBuffered() {\n     @Override\n     public JsonGenerator writeName(String name)  throws JacksonException\n     {\n-        if (_cfgPrettyPrinter != null) {\n+        if (_prettyPrinter != null) {\n             _writePPName(name);\n             return this;\n         }\n@@ -246,7 +246,7 @@ public JsonGenerator writeName(String name)  throws JacksonException\n     @Override\n     public JsonGenerator writeName(SerializableString name) throws JacksonException\n     {\n-        if (_cfgPrettyPrinter != null) {\n+        if (_prettyPrinter != null) {\n             _writePPName(name);\n             return this;\n         }\n@@ -302,8 +302,8 @@ public JsonGenerator writeStartArray() throws JacksonException\n         _verifyValueWrite(\"start an array\");\n         _streamWriteContext = _streamWriteContext.createChildArrayContext(null);\n         streamWriteConstraints().validateNestingDepth(_streamWriteContext.getNestingDepth());\n-        if (_cfgPrettyPrinter != null) {\n-            _cfgPrettyPrinter.writeStartArray(this);\n+        if (_prettyPrinter != null) {\n+            _prettyPrinter.writeStartArray(this);\n         } else {\n             if (_outputTail >= _outputEnd) {\n                 _flushBuffer();\n@@ -319,8 +319,8 @@ public JsonGenerator writeStartArray(Object forValue) throws JacksonException\n         _verifyValueWrite(\"start an array\");\n         _streamWriteContext = _streamWriteContext.createChildArrayContext(forValue);\n         streamWriteConstraints().validateNestingDepth(_streamWriteContext.getNestingDepth());\n-        if (_cfgPrettyPrinter != null) {\n-            _cfgPrettyPrinter.writeStartArray(this);\n+        if (_prettyPrinter != null) {\n+            _prettyPrinter.writeStartArray(this);\n         } else {\n             if (_outputTail >= _outputEnd) {\n                 _flushBuffer();\n@@ -336,8 +336,8 @@ public JsonGenerator writeStartArray(Object forValue, int len) throws JacksonExc\n         _verifyValueWrite(\"start an array\");\n         _streamWriteContext = _streamWriteContext.createChildArrayContext(forValue);\n         streamWriteConstraints().validateNestingDepth(_streamWriteContext.getNestingDepth());\n-        if (_cfgPrettyPrinter != null) {\n-            _cfgPrettyPrinter.writeStartArray(this);\n+        if (_prettyPrinter != null) {\n+            _prettyPrinter.writeStartArray(this);\n         } else {\n             if (_outputTail >= _outputEnd) {\n                 _flushBuffer();\n@@ -353,8 +353,8 @@ public JsonGenerator writeEndArray() throws JacksonException\n         if (!_streamWriteContext.inArray()) {\n             _reportError(\"Current context not Array but \"+_streamWriteContext.typeDesc());\n         }\n-        if (_cfgPrettyPrinter != null) {\n-            _cfgPrettyPrinter.writeEndArray(this, _streamWriteContext.getEntryCount());\n+        if (_prettyPrinter != null) {\n+            _prettyPrinter.writeEndArray(this, _streamWriteContext.getEntryCount());\n         } else {\n             if (_outputTail >= _outputEnd) {\n                 _flushBuffer();\n@@ -371,8 +371,8 @@ public JsonGenerator writeStartObject() throws JacksonException\n         _verifyValueWrite(\"start an object\");\n         _streamWriteContext = _streamWriteContext.createChildObjectContext(null);\n         streamWriteConstraints().validateNestingDepth(_streamWriteContext.getNestingDepth());\n-        if (_cfgPrettyPrinter != null) {\n-            _cfgPrettyPrinter.writeStartObject(this);\n+        if (_prettyPrinter != null) {\n+            _prettyPrinter.writeStartObject(this);\n         } else {\n             if (_outputTail >= _outputEnd) {\n                 _flushBuffer();\n@@ -389,8 +389,8 @@ public JsonGenerator writeStartObject(Object forValue) throws JacksonException\n         JsonWriteContext ctxt = _streamWriteContext.createChildObjectContext(forValue);\n         streamWriteConstraints().validateNestingDepth(ctxt.getNestingDepth());\n         _streamWriteContext = ctxt;\n-        if (_cfgPrettyPrinter != null) {\n-            _cfgPrettyPrinter.writeStartObject(this);\n+        if (_prettyPrinter != null) {\n+            _prettyPrinter.writeStartObject(this);\n         } else {\n             if (_outputTail >= _outputEnd) {\n                 _flushBuffer();\n@@ -407,8 +407,8 @@ public JsonGenerator writeStartObject(Object forValue, int size) throws JacksonE\n         JsonWriteContext ctxt = _streamWriteContext.createChildObjectContext(forValue);\n         streamWriteConstraints().validateNestingDepth(ctxt.getNestingDepth());\n         _streamWriteContext = ctxt;\n-        if (_cfgPrettyPrinter != null) {\n-            _cfgPrettyPrinter.writeStartObject(this);\n+        if (_prettyPrinter != null) {\n+            _prettyPrinter.writeStartObject(this);\n         } else {\n             if (_outputTail >= _outputEnd) {\n                 _flushBuffer();\n@@ -424,8 +424,8 @@ public JsonGenerator writeEndObject() throws JacksonException\n         if (!_streamWriteContext.inObject()) {\n             _reportError(\"Current context not Object but \"+_streamWriteContext.typeDesc());\n         }\n-        if (_cfgPrettyPrinter != null) {\n-            _cfgPrettyPrinter.writeEndObject(this, _streamWriteContext.getEntryCount());\n+        if (_prettyPrinter != null) {\n+            _prettyPrinter.writeEndObject(this, _streamWriteContext.getEntryCount());\n         } else {\n             if (_outputTail >= _outputEnd) {\n                 _flushBuffer();\n@@ -445,9 +445,9 @@ protected final void _writePPName(String name) throws JacksonException\n             _reportError(\"Cannot write a property name, expecting a value\");\n         }\n         if ((status == JsonWriteContext.STATUS_OK_AFTER_COMMA)) {\n-            _cfgPrettyPrinter.writeObjectEntrySeparator(this);\n+            _prettyPrinter.writeObjectEntrySeparator(this);\n         } else {\n-            _cfgPrettyPrinter.beforeObjectEntries(this);\n+            _prettyPrinter.beforeObjectEntries(this);\n         }\n         if (_cfgUnqNames) {\n             _writeStringSegments(name, false);\n@@ -485,9 +485,9 @@ protected final void _writePPName(SerializableString name) throws JacksonExcepti\n             _reportError(\"Cannot write a property name, expecting a value\");\n         }\n         if (status == JsonWriteContext.STATUS_OK_AFTER_COMMA) {\n-            _cfgPrettyPrinter.writeObjectEntrySeparator(this);\n+            _prettyPrinter.writeObjectEntrySeparator(this);\n         } else {\n-            _cfgPrettyPrinter.beforeObjectEntries(this);\n+            _prettyPrinter.beforeObjectEntries(this);\n         }\n \n         final boolean addQuotes = !_cfgUnqNames; // standard\n@@ -1189,7 +1189,7 @@ public JsonGenerator writeNull() throws JacksonException\n     protected final void _verifyValueWrite(String typeMsg) throws JacksonException\n     {\n         final int status = _streamWriteContext.writeValue();\n-        if (_cfgPrettyPrinter != null) {\n+        if (_prettyPrinter != null) {\n             // Otherwise, pretty printer knows what to do...\n             _verifyPrettyValueWrite(typeMsg, status);\n             return;\ndiff --git a/src/main/java/tools/jackson/core/json/WriterBasedJsonGenerator.java b/src/main/java/tools/jackson/core/json/WriterBasedJsonGenerator.java\nindex f6d5581e72..d942948854 100644\n--- a/src/main/java/tools/jackson/core/json/WriterBasedJsonGenerator.java\n+++ b/src/main/java/tools/jackson/core/json/WriterBasedJsonGenerator.java\n@@ -169,7 +169,7 @@ public JsonGenerator writeName(SerializableString name) throws JacksonException\n \n     protected final void _writeName(String name, boolean commaBefore) throws JacksonException\n     {\n-        if (_cfgPrettyPrinter != null) {\n+        if (_prettyPrinter != null) {\n             _writePPName(name, commaBefore);\n             return;\n         }\n@@ -198,7 +198,7 @@ protected final void _writeName(String name, boolean commaBefore) throws Jackson\n \n     protected final void _writeName(SerializableString name, boolean commaBefore) throws JacksonException\n     {\n-        if (_cfgPrettyPrinter != null) {\n+        if (_prettyPrinter != null) {\n             _writePPName(name, commaBefore);\n             return;\n         }\n@@ -253,8 +253,8 @@ public JsonGenerator writeStartArray() throws JacksonException\n         _verifyValueWrite(\"start an array\");\n         _streamWriteContext = _streamWriteContext.createChildArrayContext(null);\n         streamWriteConstraints().validateNestingDepth(_streamWriteContext.getNestingDepth());\n-        if (_cfgPrettyPrinter != null) {\n-            _cfgPrettyPrinter.writeStartArray(this);\n+        if (_prettyPrinter != null) {\n+            _prettyPrinter.writeStartArray(this);\n         } else {\n             if (_outputTail >= _outputEnd) {\n                 _flushBuffer();\n@@ -270,8 +270,8 @@ public JsonGenerator writeStartArray(Object forValue) throws JacksonException\n         _verifyValueWrite(\"start an array\");\n         _streamWriteContext = _streamWriteContext.createChildArrayContext(forValue);\n         streamWriteConstraints().validateNestingDepth(_streamWriteContext.getNestingDepth());\n-        if (_cfgPrettyPrinter != null) {\n-            _cfgPrettyPrinter.writeStartArray(this);\n+        if (_prettyPrinter != null) {\n+            _prettyPrinter.writeStartArray(this);\n         } else {\n             if (_outputTail >= _outputEnd) {\n                 _flushBuffer();\n@@ -287,8 +287,8 @@ public JsonGenerator writeStartArray(Object forValue, int len) throws JacksonExc\n         _verifyValueWrite(\"start an array\");\n         _streamWriteContext = _streamWriteContext.createChildArrayContext(forValue);\n         streamWriteConstraints().validateNestingDepth(_streamWriteContext.getNestingDepth());\n-        if (_cfgPrettyPrinter != null) {\n-            _cfgPrettyPrinter.writeStartArray(this);\n+        if (_prettyPrinter != null) {\n+            _prettyPrinter.writeStartArray(this);\n         } else {\n             if (_outputTail >= _outputEnd) {\n                 _flushBuffer();\n@@ -304,8 +304,8 @@ public JsonGenerator writeEndArray() throws JacksonException\n         if (!_streamWriteContext.inArray()) {\n             _reportError(\"Current context not Array but \"+_streamWriteContext.typeDesc());\n         }\n-        if (_cfgPrettyPrinter != null) {\n-            _cfgPrettyPrinter.writeEndArray(this, _streamWriteContext.getEntryCount());\n+        if (_prettyPrinter != null) {\n+            _prettyPrinter.writeEndArray(this, _streamWriteContext.getEntryCount());\n         } else {\n             if (_outputTail >= _outputEnd) {\n                 _flushBuffer();\n@@ -322,8 +322,8 @@ public JsonGenerator writeStartObject() throws JacksonException\n         _verifyValueWrite(\"start an object\");\n         _streamWriteContext = _streamWriteContext.createChildObjectContext(null);\n         streamWriteConstraints().validateNestingDepth(_streamWriteContext.getNestingDepth());\n-        if (_cfgPrettyPrinter != null) {\n-            _cfgPrettyPrinter.writeStartObject(this);\n+        if (_prettyPrinter != null) {\n+            _prettyPrinter.writeStartObject(this);\n         } else {\n             if (_outputTail >= _outputEnd) {\n                 _flushBuffer();\n@@ -340,8 +340,8 @@ public JsonGenerator writeStartObject(Object forValue) throws JacksonException\n         JsonWriteContext ctxt = _streamWriteContext.createChildObjectContext(forValue);\n         streamWriteConstraints().validateNestingDepth(ctxt.getNestingDepth());\n         _streamWriteContext = ctxt;\n-        if (_cfgPrettyPrinter != null) {\n-            _cfgPrettyPrinter.writeStartObject(this);\n+        if (_prettyPrinter != null) {\n+            _prettyPrinter.writeStartObject(this);\n         } else {\n             if (_outputTail >= _outputEnd) {\n                 _flushBuffer();\n@@ -358,8 +358,8 @@ public JsonGenerator writeStartObject(Object forValue, int size) throws JacksonE\n         JsonWriteContext ctxt = _streamWriteContext.createChildObjectContext(forValue);\n         streamWriteConstraints().validateNestingDepth(ctxt.getNestingDepth());\n         _streamWriteContext = ctxt;\n-        if (_cfgPrettyPrinter != null) {\n-            _cfgPrettyPrinter.writeStartObject(this);\n+        if (_prettyPrinter != null) {\n+            _prettyPrinter.writeStartObject(this);\n         } else {\n             if (_outputTail >= _outputEnd) {\n                 _flushBuffer();\n@@ -375,8 +375,8 @@ public JsonGenerator writeEndObject() throws JacksonException\n         if (!_streamWriteContext.inObject()) {\n             _reportError(\"Current context not Object but \"+_streamWriteContext.typeDesc());\n         }\n-        if (_cfgPrettyPrinter != null) {\n-            _cfgPrettyPrinter.writeEndObject(this, _streamWriteContext.getEntryCount());\n+        if (_prettyPrinter != null) {\n+            _prettyPrinter.writeEndObject(this, _streamWriteContext.getEntryCount());\n         } else {\n             if (_outputTail >= _outputEnd) {\n                 _flushBuffer();\n@@ -392,9 +392,9 @@ public JsonGenerator writeEndObject() throws JacksonException\n     protected final void _writePPName(String name, boolean commaBefore) throws JacksonException\n     {\n         if (commaBefore) {\n-            _cfgPrettyPrinter.writeObjectEntrySeparator(this);\n+            _prettyPrinter.writeObjectEntrySeparator(this);\n         } else {\n-            _cfgPrettyPrinter.beforeObjectEntries(this);\n+            _prettyPrinter.beforeObjectEntries(this);\n         }\n \n         if (_cfgUnqNames) {// non-standard, omit quotes\n@@ -415,9 +415,9 @@ protected final void _writePPName(String name, boolean commaBefore) throws Jacks\n     protected final void _writePPName(SerializableString name, boolean commaBefore) throws JacksonException\n     {\n         if (commaBefore) {\n-            _cfgPrettyPrinter.writeObjectEntrySeparator(this);\n+            _prettyPrinter.writeObjectEntrySeparator(this);\n         } else {\n-            _cfgPrettyPrinter.beforeObjectEntries(this);\n+            _prettyPrinter.beforeObjectEntries(this);\n         }\n         final char[] quoted = name.asQuotedChars();\n         if (_cfgUnqNames) {// non-standard, omit quotes\n@@ -996,7 +996,7 @@ public JsonGenerator writeNull() throws JacksonException {\n     protected final void _verifyValueWrite(String typeMsg) throws JacksonException\n     {\n         final int status = _streamWriteContext.writeValue();\n-        if (_cfgPrettyPrinter != null) {\n+        if (_prettyPrinter != null) {\n             // Otherwise, pretty printer knows what to do...\n             _verifyPrettyValueWrite(typeMsg, status);\n             return;\ndiff --git a/src/main/java/tools/jackson/core/util/JsonGeneratorDelegate.java b/src/main/java/tools/jackson/core/util/JsonGeneratorDelegate.java\nindex 8f360ace1f..1547fe841e 100644\n--- a/src/main/java/tools/jackson/core/util/JsonGeneratorDelegate.java\n+++ b/src/main/java/tools/jackson/core/util/JsonGeneratorDelegate.java\n@@ -118,6 +118,9 @@ public JsonGenerator configure(StreamWriteFeature f, boolean state) {\n     @Override\n     public CharacterEscapes getCharacterEscapes() {  return delegate.getCharacterEscapes(); }\n \n+    @Override\n+    public PrettyPrinter getPrettyPrinter() { return delegate.getPrettyPrinter(); }\n+\n     /*\n     /**********************************************************************\n     /* Public API, write methods, structural\n",
  "test_patch" : "diff --git a/src/test/java/tools/jackson/core/unittest/util/DefaultIndenterTest.java b/src/test/java/tools/jackson/core/unittest/util/DefaultIndenterTest.java\nindex e4a2c7daaf..dbb81f86d1 100644\n--- a/src/test/java/tools/jackson/core/unittest/util/DefaultIndenterTest.java\n+++ b/src/test/java/tools/jackson/core/unittest/util/DefaultIndenterTest.java\n@@ -9,31 +9,29 @@\n /**\n  * Unit tests for class {@link DefaultIndenter}.\n  *\n- * @date 2017-07-31\n  * @see DefaultIndenter\n- **/\n-class DefaultIndenterTest {\n-\n+ */\n+class DefaultIndenterTest\n+{\n     @Test\n     void withLinefeed() {\n-    DefaultIndenter defaultIndenter = new DefaultIndenter();\n-    DefaultIndenter defaultIndenterTwo = defaultIndenter.withLinefeed(\"-XG'#x\");\n-    DefaultIndenter defaultIndenterThree = defaultIndenterTwo.withLinefeed(\"-XG'#x\");\n+        DefaultIndenter defaultIndenter = new DefaultIndenter();\n+        DefaultIndenter defaultIndenterTwo = defaultIndenter.withLinefeed(\"-XG'#x\");\n+        DefaultIndenter defaultIndenterThree = defaultIndenterTwo.withLinefeed(\"-XG'#x\");\n \n-    assertEquals(\"-XG'#x\", defaultIndenterThree.getEol());\n-    assertNotSame(defaultIndenterThree, defaultIndenter);\n-    assertSame(defaultIndenterThree, defaultIndenterTwo);\n-  }\n+        assertEquals(\"-XG'#x\", defaultIndenterThree.getEol());\n+        assertNotSame(defaultIndenterThree, defaultIndenter);\n+        assertSame(defaultIndenterThree, defaultIndenterTwo);\n+    }\n \n     @Test\n     void withIndent() {\n-    DefaultIndenter defaultIndenter = new DefaultIndenter();\n-    DefaultIndenter defaultIndenterTwo = defaultIndenter.withIndent(\"9Qh/6,~n\");\n-    DefaultIndenter defaultIndenterThree = defaultIndenterTwo.withIndent(\"9Qh/6,~n\");\n-\n-    assertEquals(System.lineSeparator(), defaultIndenterThree.getEol());\n-    assertNotSame(defaultIndenterThree, defaultIndenter);\n-    assertSame(defaultIndenterThree, defaultIndenterTwo);\n+        DefaultIndenter defaultIndenter = new DefaultIndenter();\n+        DefaultIndenter defaultIndenterTwo = defaultIndenter.withIndent(\"9Qh/6,~n\");\n+        DefaultIndenter defaultIndenterThree = defaultIndenterTwo.withIndent(\"9Qh/6,~n\");\n+    \n+        assertEquals(System.lineSeparator(), defaultIndenterThree.getEol());\n+        assertNotSame(defaultIndenterThree, defaultIndenter);\n+        assertSame(defaultIndenterThree, defaultIndenterTwo);\n   }\n-\n-}\n\\ No newline at end of file\n+}\ndiff --git a/src/test/java/tools/jackson/core/unittest/write/PrettyPrinterTest.java b/src/test/java/tools/jackson/core/unittest/write/PrettyPrinterTest.java\nindex e344a048ff..492ff95c13 100644\n--- a/src/test/java/tools/jackson/core/unittest/write/PrettyPrinterTest.java\n+++ b/src/test/java/tools/jackson/core/unittest/write/PrettyPrinterTest.java\n@@ -11,8 +11,7 @@\n import tools.jackson.core.util.*;\n import tools.jackson.core.util.Separators.Spacing;\n \n-import static org.junit.jupiter.api.Assertions.assertEquals;\n-import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.*;\n \n /**\n  * Set of basic unit tests for verifying that indenting\n@@ -43,7 +42,7 @@ public void writeEndArray(JsonGenerator jg, int nrOfValues)\n     /**********************************************************\n      */\n \n-    private final JsonFactory JSON_F = sharedStreamFactory();\n+    private final JsonFactory JSON_F = newStreamFactory();\n \n     @Test\n     void objectCount() throws Exception\n@@ -111,13 +110,18 @@ void arrayCount() throws Exception\n     @Test\n     void simpleDocWithMinimal() throws Exception\n     {\n+        final PrettyPrinter MINIMAL = new MinimalPrettyPrinter();\n         StringWriter sw = new StringWriter();\n         // first with standard minimal\n         ObjectWriteContext ppContext = new ObjectWriteContext.Base() {\n             @Override\n-            public PrettyPrinter getPrettyPrinter() { return new MinimalPrettyPrinter(); }\n+            public PrettyPrinter getPrettyPrinter() { return MINIMAL; }\n         };\n         JsonGenerator gen = JSON_F.createGenerator(ppContext, sw);\n+\n+        // Verify instance uses stateless PP\n+        assertSame(MINIMAL, gen.getPrettyPrinter());\n+\n         String docStr = _verifyPrettyPrinter(gen, sw);\n         // which should have no linefeeds, tabs\n         assertEquals(-1, docStr.indexOf('\\n'));\n@@ -130,9 +134,9 @@ public PrettyPrinter getPrettyPrinter() {\n                 return new MinimalPrettyPrinter() {\n                     @Override\n                     // use TAB between array values\n-                    public void beforeArrayValues(JsonGenerator jg)\n+                    public void beforeArrayValues(JsonGenerator g)\n                     {\n-                        jg.writeRaw(\"\\t\");\n+                        g.writeRaw(\"\\t\");\n                     }\n                 };\n             }\n@@ -264,6 +268,28 @@ public PrettyPrinter getPrettyPrinter() {\n         assertEquals(EXPECTED_CUSTOM_SEPARATORS_WITH_PP_WITHOUT_SPACES, sw.toString());\n     }\n \n+    // [core#1480]: access to configured/actual PrettyPrinter\n+    @Test\n+    void accessToPrettyPrinterInUse() throws Exception\n+    {\n+        // By default, no pretty-printer\n+        try (JsonGenerator gen = JSON_F.createGenerator(ObjectWriteContext.empty(),\n+                new StringWriter())) {\n+            assertNull(gen.getPrettyPrinter());\n+        }\n+\n+        // But we can configure Default PP\n+        final PrettyPrinter DEFAULT_PP = new DefaultPrettyPrinter();\n+        try (JsonGenerator gen = JSON_F.createGenerator(objectWriteContext(DEFAULT_PP),\n+                new StringWriter())) {\n+            PrettyPrinter pp = gen.getPrettyPrinter();\n+            assertNotNull(pp);\n+            // Note: stateful, new instance created by our OWC\n+            assertEquals(DEFAULT_PP.getClass(), pp.getClass());\n+            assertNotSame(DEFAULT_PP, pp);\n+        }    \n+    }\n+\n     /*\n     /**********************************************************\n     /* Helper methods\n@@ -325,23 +351,30 @@ private void _writeTestDocument(JsonGenerator gen) throws IOException {\n         gen.close();\n     }\n \n-    protected String _generateRoot(TokenStreamFactory f, final PrettyPrinter pp) throws IOException\n+    protected String _generateRoot(TokenStreamFactory f, PrettyPrinter pp) throws IOException\n     {\n         StringWriter sw = new StringWriter();\n-        ObjectWriteContext ppContext = new ObjectWriteContext.Base() {\n+        try (JsonGenerator gen = f.createGenerator(objectWriteContext(pp), sw)) {\n+            gen.writeStartObject();\n+            gen.writeEndObject();\n+            gen.writeStartObject();\n+            gen.writeEndObject();\n+            gen.writeStartArray();\n+            gen.writeEndArray();\n+        }\n+        return sw.toString();\n+    }\n+\n+    protected ObjectWriteContext objectWriteContext(final PrettyPrinter pp) {\n+        return new ObjectWriteContext.Base() {\n+            @SuppressWarnings(\"unchecked\")\n             @Override\n             public PrettyPrinter getPrettyPrinter() {\n+                if (pp instanceof Instantiatable) {\n+                    return ((Instantiatable<PrettyPrinter>) pp).createInstance();\n+                }\n                 return pp;\n             }\n         };\n-        JsonGenerator gen = f.createGenerator(ppContext, sw);\n-        gen.writeStartObject();\n-        gen.writeEndObject();\n-        gen.writeStartObject();\n-        gen.writeEndObject();\n-        gen.writeStartArray();\n-        gen.writeEndArray();\n-        gen.close();\n-        return sw.toString();\n     }\n }\n",
  "problem_statement" : "(note: offshoot of https://github.com/FasterXML/jackson-databind/issues/5331)\n\nLooks like an accessor would be needed to get reference to the active `PrettyPrinter` a generator instance is using (if any).\n\nAt first let's only target 3.0(.0) -- implementation must differ a bit between 2.x and 3.x anyway; so if we decide to backport (in 2.21) we can do that separately.\n",
  "hints_text" : null,
  "created_at" : "Fri Oct 03 19:38:44 CEST 2025",
  "version" : null,
  "FAIL_TO_PASS" : [ "PrettyPrinterTest", "DefaultIndenterTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=PrettyPrinterTest,DefaultIndenterTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : 1480,
  "pull_number" : 1481,
  "metadata" : null
}, {
  "instance_id" : "FasterXML-jackson-core-PR-1478",
  "repo" : "FasterXML/jackson-core",
  "base_commit" : "2629fb05e4f9d9a31a696681465341e1683f7cd6",
  "patch" : "diff --git a/release-notes/VERSION-2.x b/release-notes/VERSION-2.x\nindex b1a1841ca4..22dbb09638 100644\n--- a/release-notes/VERSION-2.x\n+++ b/release-notes/VERSION-2.x\n@@ -18,6 +18,7 @@ a pure JSON library.\n \n #1470: Add method `copyCurrentStructureExact()` to `JsonGenerator`\n  (contributed by Lars H)\n+#1477: Add `JsonGenerator.has(StreamWriteCapability)` convenience method\n \n 2.20.1 (not yet released)\n \ndiff --git a/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java b/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java\nindex 5a4950dc3b..d5121a3364 100644\n--- a/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java\n@@ -920,6 +920,19 @@ public JacksonFeatureSet<StreamWriteCapability> getWriteCapabilities() {\n         return DEFAULT_WRITE_CAPABILITIES;\n     }\n \n+    /**\n+     * Accessor for checking whether this generator has specified capability.\n+     * Short-hand for:\n+     * {@code return getWriteCapabilities().isEnabled(capability); }\n+     *\n+     * @param capability Capability to check\n+     *\n+     * @return True if this generator has specified capability; false if not\n+     */\n+    public boolean has(StreamWriteCapability capability) {\n+        return getWriteCapabilities().isEnabled(capability);\n+    }\n+\n     /*\n     /**********************************************************************\n     /* Public API, write methods, structural\ndiff --git a/src/main/java/com/fasterxml/jackson/core/json/JsonGeneratorImpl.java b/src/main/java/com/fasterxml/jackson/core/json/JsonGeneratorImpl.java\nindex 04288ced6b..80f9bcdafd 100644\n--- a/src/main/java/com/fasterxml/jackson/core/json/JsonGeneratorImpl.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/JsonGeneratorImpl.java\n@@ -234,6 +234,11 @@ public JacksonFeatureSet<StreamWriteCapability> getWriteCapabilities() {\n         return JSON_WRITE_CAPABILITIES;\n     }\n \n+    @Override\n+    public boolean has(StreamWriteCapability capability) {\n+        return JSON_WRITE_CAPABILITIES.isEnabled(capability);\n+    }\n+\n     /*\n     /**********************************************************\n     /* Shared helper methods\ndiff --git a/src/main/java/com/fasterxml/jackson/core/util/JsonGeneratorDelegate.java b/src/main/java/com/fasterxml/jackson/core/util/JsonGeneratorDelegate.java\nindex 4703bf3665..ab1159151b 100644\n--- a/src/main/java/com/fasterxml/jackson/core/util/JsonGeneratorDelegate.java\n+++ b/src/main/java/com/fasterxml/jackson/core/util/JsonGeneratorDelegate.java\n@@ -103,6 +103,9 @@ public JacksonFeatureSet<StreamWriteCapability> getWriteCapabilities() {\n         return delegate.getWriteCapabilities();\n     }\n \n+    @Override\n+    public boolean has(StreamWriteCapability capability) { return delegate.has(capability); }\n+\n     /*\n     /**********************************************************************\n     /* Public API, configuration\n",
  "test_patch" : "diff --git a/src/test/java/com/fasterxml/jackson/core/write/GeneratorMiscTest.java b/src/test/java/com/fasterxml/jackson/core/write/GeneratorMiscTest.java\nindex 5e723d01fb..3fc54521e8 100644\n--- a/src/test/java/com/fasterxml/jackson/core/write/GeneratorMiscTest.java\n+++ b/src/test/java/com/fasterxml/jackson/core/write/GeneratorMiscTest.java\n@@ -268,4 +268,18 @@ void asEmbedded() throws Exception\n             verifyException(e, \"No native support for\");\n         }\n     }\n+\n+    @Test\n+    void capabilitiesAccess() throws Exception {\n+        try (JsonGenerator g = JSON_F.createGenerator(new StringWriter())) {\n+            assertFalse(g.getWriteCapabilities().isEnabled(StreamWriteCapability.CAN_WRITE_BINARY_NATIVELY));\n+            assertFalse(g.has(StreamWriteCapability.CAN_WRITE_BINARY_NATIVELY));\n+            assertTrue(g.has(StreamWriteCapability.CAN_WRITE_FORMATTED_NUMBERS));\n+        }\n+        try (JsonGenerator g = JSON_F.createGenerator(new ByteArrayOutputStream())) {\n+            assertFalse(g.getWriteCapabilities().isEnabled(StreamWriteCapability.CAN_WRITE_BINARY_NATIVELY));\n+            assertFalse(g.has(StreamWriteCapability.CAN_WRITE_BINARY_NATIVELY));\n+            assertFalse(g.has(StreamWriteCapability.CAN_WRITE_BINARY_NATIVELY));\n+        }\n+    }\n }\n",
  "problem_statement" : "`JsonGenerator` has method `getWriteCapabilities()` for getting all supported `StreamWriteCapability` instances.\nBut it'd be convenient to have simpler alternative too.",
  "hints_text" : null,
  "created_at" : "Fri Sep 26 01:28:33 CEST 2025",
  "version" : null,
  "FAIL_TO_PASS" : [ "GeneratorMiscTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=GeneratorMiscTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : 1477,
  "pull_number" : 1478,
  "metadata" : null
}, {
  "instance_id" : "FasterXML-jackson-core-PR-1474",
  "repo" : "FasterXML/jackson-core",
  "base_commit" : "4975a1e7a2057520e2a995848a6f91f5f7939588",
  "patch" : "diff --git a/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java b/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java\nindex b96e9003d0..dbef52e3d4 100644\n--- a/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java\n@@ -1344,6 +1344,11 @@ private final void _writeStringSegments(String text, boolean addQuotes) throws I\n \n         while (left > 0) {\n             int len = Math.min(_outputMaxContiguous, left);\n+            // [core#1473]: avoid splitting surrogates between two segments.\n+            // if len == 1 (edge case) don't apply to avoid infinite loop\n+            if (len > 1 && _isStartOfSurrogatePair(text.charAt(offset + len-1))) {\n+                --len;\n+            }\n             if ((_outputTail + len) > _outputEnd) { // caller must ensure enough space\n                 _flushBuffer();\n             }\n@@ -1370,6 +1375,11 @@ private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) t\n     {\n         do {\n             int len = Math.min(_outputMaxContiguous, totalLen);\n+            // [core#1473]: avoid splitting surrogates between two segments.\n+            // if len == 1 (edge case) don't apply to avoid infinite loop\n+            if (len > 1 && _isStartOfSurrogatePair(cbuf[offset + len-1])) {\n+                --len;\n+            }\n             if ((_outputTail + len) > _outputEnd) { // caller must ensure enough space\n                 _flushBuffer();\n             }\n@@ -1383,6 +1393,11 @@ private final void _writeStringSegments(String text, int offset, int totalLen) t\n     {\n         do {\n             int len = Math.min(_outputMaxContiguous, totalLen);\n+            // [core#1473]: avoid splitting surrogates between two segments.\n+            // if len == 1 (edge case) don't apply to avoid infinite loop\n+            if (len > 1 && _isStartOfSurrogatePair(text.charAt(offset + len-1))) {\n+                --len;\n+            }\n             if ((_outputTail + len) > _outputEnd) { // caller must ensure enough space\n                 _flushBuffer();\n             }\n@@ -1869,6 +1884,11 @@ private final void _writeUTF8Segments(byte[] utf8, int offset, int totalLen)\n     {\n         do {\n             int len = Math.min(_outputMaxContiguous, totalLen);\n+            // [core#1473]: avoid splitting surrogates between two segments.\n+            // if len == 1 (edge case) don't apply to avoid infinite loop\n+            if (len > 1 && _isStartOfSurrogatePair(utf8[offset + len-1])) {\n+                --len;\n+            }\n             _writeUTF8Segment(utf8, offset, len);\n             offset += len;\n             totalLen -= len;\n",
  "test_patch" : "diff --git a/src/test/java/com/fasterxml/jackson/core/write/SurrogateWrite223Test.java b/src/test/java/com/fasterxml/jackson/core/write/SurrogateWrite223Test.java\nindex 180e3db352..efbc553524 100644\n--- a/src/test/java/com/fasterxml/jackson/core/write/SurrogateWrite223Test.java\n+++ b/src/test/java/com/fasterxml/jackson/core/write/SurrogateWrite223Test.java\n@@ -3,6 +3,7 @@\n import java.io.ByteArrayOutputStream;\n import java.io.StringWriter;\n import java.io.Writer;\n+import java.nio.charset.StandardCharsets;\n \n import org.junit.jupiter.api.Test;\n \n@@ -17,6 +18,10 @@ class SurrogateWrite223Test extends JUnit5TestBase\n {\n     private final JsonFactory DEFAULT_JSON_F = newStreamFactory();\n \n+    private final JsonFactory SURROGATE_COMBINING_JSON_F = JsonFactory.builder()\n+            .enable(JsonWriteFeature.COMBINE_UNICODE_SURROGATES_IN_UTF8)\n+            .build();\n+\n     // for [core#223]\n     @Test\n     void surrogatesDefaultSetting() throws Exception {\n@@ -35,9 +40,7 @@ void surrogatesByteBacked() throws Exception\n \n         out = new ByteArrayOutputStream();\n \n-        JsonFactory f = JsonFactory.builder()\n-                .enable(JsonWriteFeature.COMBINE_UNICODE_SURROGATES_IN_UTF8)\n-                .build();\n+        JsonFactory f = SURROGATE_COMBINING_JSON_F;\n         g = f.createGenerator(out);\n         g.writeStartArray();\n         g.writeString(toQuote);\n@@ -96,9 +99,7 @@ void surrogatesCharBacked() throws Exception\n     //https://github.com/FasterXML/jackson-core/issues/1359\n     @Test\n     void checkNonSurrogates() throws Exception {\n-        JsonFactory f = JsonFactory.builder()\n-                .enable(JsonWriteFeature.COMBINE_UNICODE_SURROGATES_IN_UTF8)\n-                .build();\n+        JsonFactory f = SURROGATE_COMBINING_JSON_F;\n         ByteArrayOutputStream out = new ByteArrayOutputStream();\n         try (JsonGenerator gen = f.createGenerator(out)) {\n             gen.writeStartObject();\n@@ -126,9 +127,7 @@ void checkNonSurrogates() throws Exception {\n \n     @Test\n     void checkSurrogateWithCharacterEscapes() throws Exception {\n-        JsonFactory f = JsonFactory.builder()\n-                .enable(JsonWriteFeature.COMBINE_UNICODE_SURROGATES_IN_UTF8)\n-                .build();\n+        JsonFactory f = SURROGATE_COMBINING_JSON_F;\n         f.setCharacterEscapes(JsonpCharacterEscapes.instance());\n         ByteArrayOutputStream out = new ByteArrayOutputStream();\n         try (JsonGenerator gen = f.createGenerator(out)) {\n@@ -140,4 +139,37 @@ void checkSurrogateWithCharacterEscapes() throws Exception {\n         String json = out.toString(\"UTF-8\");\n         assertEquals(\"{\\\"test_emoji\\\":\\\"\\uD83D\\uDE0A\\\"}\", json);\n     }\n+\n+    //https://github.com/FasterXML/jackson-core/issues/1473\n+    @Test\n+    void surrogateCharSplitInTwoSegments() throws Exception\n+    {\n+        // UTF8JsonGenerator must avoid splitting surrogate chars\n+        // into separate segments. We want to test the third segment\n+        // split to make sure indexes, offsets, etc are all correct.\n+        // By default, segments split in every 1000 chars.\n+        // Thus, we need a string with length 2001 where the surrogate is\n+        // at 2000 and 2001 positions.\n+        int count = 1999;\n+        char[] chars = new char[count];\n+        java.util.Arrays.fill(chars, 'x');\n+        String base = new String(chars);\n+\n+        final String VALUE = base + \"\\uD83E\\uDEE1\";\n+\n+        ByteArrayOutputStream bb = new ByteArrayOutputStream();\n+        try (JsonGenerator g = SURROGATE_COMBINING_JSON_F.createGenerator(bb)) {\n+            g.enable(JsonGenerator.Feature.COMBINE_UNICODE_SURROGATES_IN_UTF8);\n+    \n+            g.writeStartArray();\n+            g.writeString(VALUE);\n+            g.writeEndArray();\n+        }\n+\n+        String result = new String(bb.toByteArray(), StandardCharsets.UTF_8);\n+\n+        // +2 and -2 to remove array and quotes: result should contain [\"xxxx....\uD83E\uDEE1\"]\n+        // \"\\uD83E\\uDEE1\" is the combined surrogate form of the emoji\n+        assertEquals(\"\\uD83E\\uDEE1\", result.substring(count+2, result.length()-2));\n+    }\n }\n",
  "problem_statement" : "Fixes the segment logic from splitting surrogates in half and not encoding correctly\n\nBasically, the `combineSurrogates` logic doesn't run when the two characters of a surrogate are exactly at the end of one segment and the beginning of another.\r\n\r\n\r\nFixes https://github.com/FasterXML/jackson-core/issues/1473",
  "hints_text" : null,
  "created_at" : "Tue Sep 16 23:45:10 CEST 2025",
  "version" : null,
  "FAIL_TO_PASS" : [ "SurrogateWrite223Test" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=SurrogateWrite223Test",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 1474,
  "metadata" : null
}, {
  "instance_id" : "FasterXML-jackson-core-PR-1470",
  "repo" : "FasterXML/jackson-core",
  "base_commit" : "367777c00d73dfa718ae4763b7333c501ff0117a",
  "patch" : "diff --git a/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java b/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java\nindex bc14c6c06a..5a4950dc3b 100644\n--- a/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java\n@@ -2690,6 +2690,46 @@ public void copyCurrentStructure(JsonParser p) throws IOException\n         }\n     }\n \n+    /**\n+     * Same as {@link #copyCurrentStructure} with the exception that copying of numeric\n+     * values tries to avoid any conversion losses; in particular for floating-point\n+     * numbers. This usually matters when transcoding from textual format like JSON\n+     * to a binary format.\n+     * See {@link #_copyCurrentFloatValueExact} for details.\n+     *\n+     * @param p Parser that points to the value to copy\n+     *\n+     * @throws IOException if there is either an underlying I/O problem or encoding\n+     *    issue at format layer\n+     *\n+     * @since 2.21\n+     */\n+    public void copyCurrentStructureExact(JsonParser p) throws IOException\n+    {\n+        JsonToken t = p.currentToken();\n+        // Let's handle field-name separately first\n+        int id = (t == null) ? ID_NOT_AVAILABLE : t.id();\n+        if (id == ID_FIELD_NAME) {\n+            writeFieldName(p.currentName());\n+            t = p.nextToken();\n+            id = (t == null) ? ID_NOT_AVAILABLE : t.id();\n+            // fall-through to copy the associated value\n+        }\n+        switch (id) {\n+        case ID_START_OBJECT:\n+            writeStartObject();\n+            _copyCurrentContentsExact(p);\n+            return;\n+        case ID_START_ARRAY:\n+            writeStartArray();\n+            _copyCurrentContentsExact(p);\n+            return;\n+\n+        default:\n+            copyCurrentEventExact(p);\n+        }\n+    }\n+\n     // @since 2.10\n     protected void _copyCurrentContents(JsonParser p) throws IOException\n     {\n@@ -2753,6 +2793,69 @@ protected void _copyCurrentContents(JsonParser p) throws IOException\n         }\n     }\n \n+    // @since 2.21\n+    protected void _copyCurrentContentsExact(JsonParser p) throws IOException\n+    {\n+        int depth = 1;\n+        JsonToken t;\n+\n+        // Mostly copied from `copyCurrentEventExact()`, but with added nesting counts\n+        while ((t = p.nextToken()) != null) {\n+            switch (t.id()) {\n+            case ID_FIELD_NAME:\n+                writeFieldName(p.currentName());\n+                break;\n+\n+            case ID_START_ARRAY:\n+                writeStartArray();\n+                ++depth;\n+                break;\n+\n+            case ID_START_OBJECT:\n+                writeStartObject();\n+                ++depth;\n+                break;\n+\n+            case ID_END_ARRAY:\n+                writeEndArray();\n+                if (--depth == 0) {\n+                    return;\n+                }\n+                break;\n+            case ID_END_OBJECT:\n+                writeEndObject();\n+                if (--depth == 0) {\n+                    return;\n+                }\n+                break;\n+\n+            case ID_STRING:\n+                _copyCurrentStringValue(p);\n+                break;\n+            case ID_NUMBER_INT:\n+                _copyCurrentIntValue(p);\n+                break;\n+            case ID_NUMBER_FLOAT:\n+                _copyCurrentFloatValueExact(p);\n+                break;\n+            case ID_TRUE:\n+                writeBoolean(true);\n+                break;\n+            case ID_FALSE:\n+                writeBoolean(false);\n+                break;\n+            case ID_NULL:\n+                writeNull();\n+                break;\n+            case ID_EMBEDDED_OBJECT:\n+                writeObject(p.getEmbeddedObject());\n+                break;\n+            default:\n+                throw new IllegalStateException(\"Internal error: unknown current token, \"+t);\n+            }\n+        }\n+    }\n+\n     /**\n      * Method for copying current {@link JsonToken#VALUE_NUMBER_FLOAT} value;\n      * overridable by format backend implementations.\n",
  "test_patch" : "diff --git a/src/test/java/com/fasterxml/jackson/core/write/GeneratorCopyTest.java b/src/test/java/com/fasterxml/jackson/core/write/GeneratorCopyTest.java\nindex 356fbfd77c..66514bfc86 100644\n--- a/src/test/java/com/fasterxml/jackson/core/write/GeneratorCopyTest.java\n+++ b/src/test/java/com/fasterxml/jackson/core/write/GeneratorCopyTest.java\n@@ -100,4 +100,39 @@ void copyObjectTokens()\n         gen.close();\n         assertEquals(\"{\\\"a\\\":1}\", sw.toString());\n     }\n+\n+    @Test\n+    void copyNumericTokensExactly()\n+            throws Exception\n+    {\n+        JsonFactory jf = JSON_F;\n+        final String DOC = a2q(\"{ 'a':0.123456789123456789123456789, 'b':[\" +\n+            \"{ 'c' : null, 'd' : 0.123456789123456789123456789 }] }\");\n+        try(JsonParser jp = jf.createParser(new StringReader(DOC))) {\n+            StringWriter sw = new StringWriter();\n+            try (JsonGenerator gen = jf.createGenerator(sw)) {\n+                assertToken(JsonToken.START_OBJECT, jp.nextToken());\n+                gen.copyCurrentStructureExact(jp);\n+                // which will advance parser to matching end Object\n+                assertToken(JsonToken.END_OBJECT, jp.currentToken());\n+            }\n+\n+            assertEquals(\n+                a2q(\"{'a':0.123456789123456789123456789,'b':[\" +\n+                    \"{'c':null,'d':0.123456789123456789123456789}]}\"),\n+                sw.toString()\n+            );\n+        }\n+\n+        try(JsonParser jp = jf.createParser(new StringReader(\"0.123456789123456789123456789\"))) {\n+            StringWriter sw = new StringWriter();\n+            try (JsonGenerator gen = jf.createGenerator(sw)) {\n+                assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken());\n+                gen.copyCurrentStructureExact(jp);\n+                assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.currentToken());\n+            }\n+\n+            assertEquals(\"0.123456789123456789123456789\", sw.toString());\n+        }\n+    }\n }\n",
  "problem_statement" : "Add method `copyCurrentStructureExact()` to `JsonGenerator`\n\nfollows the format of copyCurrentEvent/copyCurrentEventExact",
  "hints_text" : null,
  "created_at" : "Tue Sep 09 12:08:44 CEST 2025",
  "version" : null,
  "FAIL_TO_PASS" : [ "GeneratorCopyTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=GeneratorCopyTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 1470,
  "metadata" : null
}, {
  "instance_id" : "FasterXML-jackson-core-PR-1466",
  "repo" : "FasterXML/jackson-core",
  "base_commit" : "2f6a1af4f722156bc15c0345561a19a7300d47b3",
  "patch" : "diff --git a/release-notes/VERSION b/release-notes/VERSION\nindex 15220d70e8..63ded907fd 100644\n--- a/release-notes/VERSION\n+++ b/release-notes/VERSION\n@@ -15,6 +15,8 @@ JSON library.\n === Releases ===\n ------------------------------------------------------------------------\n \n+#1463: Remove `URL` taking factory methods of `JsonFactory` (3.0)\n+\n 3.0.0-rc8 (13-Aug-2025)\n \n * REVERT #1200: Change `JsonWriteFeature.ESCAPE_FORWARD_SLASHES` default\ndiff --git a/src/main/java/tools/jackson/core/TokenStreamFactory.java b/src/main/java/tools/jackson/core/TokenStreamFactory.java\nindex d6890e66fa..9623927e12 100644\n--- a/src/main/java/tools/jackson/core/TokenStreamFactory.java\n+++ b/src/main/java/tools/jackson/core/TokenStreamFactory.java\n@@ -626,32 +626,6 @@ public abstract JsonParser createParser(ObjectReadContext readCtxt,\n     public abstract JsonParser createParser(ObjectReadContext readCtxt,\n             Path p) throws JacksonException;\n \n-    /**\n-     * Method for constructing JSON parser instance to decode\n-     * contents of resource reference by given URL.\n-     *\n-     *<p>\n-     * Encoding is auto-detected from contents according to JSON\n-     * specification recommended mechanism. Json specification\n-     * supports only UTF-8, UTF-16 and UTF-32 as valid encodings,\n-     * so auto-detection implemented only for this charsets.\n-     * For other charsets use {@link #createParser(java.io.Reader)}.\n-     *<p>\n-     * Underlying input stream (needed for reading contents)\n-     * will be <b>owned</b> (and managed, i.e. closed as need be) by\n-     * the parser, since caller has no access to it.\n-     *\n-     * @param readCtxt Object read context to use\n-     * @param url URL pointing to resource that contains content to parse\n-     *\n-     * @return Parser constructed\n-     *\n-     * @throws JacksonException If parser construction or initialization fails\n-     */\n-    @Deprecated // since 3.0\n-    public abstract JsonParser createParser(ObjectReadContext readCtxt,\n-            URL url) throws JacksonException;\n-\n     /**\n      * Method for constructing JSON parser instance to parse\n      * the contents accessed via specified input stream.\n@@ -791,19 +765,6 @@ public JsonParser createParser(File f) throws JacksonException {\n         return createParser(ObjectReadContext.empty(), f);\n     }\n \n-    /**\n-     * @param src Resource that contains content to parse\n-     * @return Parser constructed\n-     *\n-     * @throws JacksonException If parser construction or initialization fails\n-     *\n-     * @deprecated Since 3.0 use {@link #createParser(ObjectReadContext,java.net.URL)}\n-     */\n-    @Deprecated\n-    public JsonParser createParser(URL src) throws JacksonException {\n-        return createParser(ObjectReadContext.empty(), src);\n-    }\n-\n     /**\n      * @param in InputStream to use for reading content to parse\n      * @return Parser constructed\n@@ -1318,7 +1279,10 @@ protected OutputStream _createDataOutputWrapper(DataOutput out) {\n      * @return InputStream constructed for given {@link URL}\n      *\n      * @throws JacksonException If there is a problem accessing content from specified {@link URL}\n+     *\n+     * @deprecated Since 3.0\n      */\n+    @Deprecated // since 3.0\n     protected InputStream _optimizedStreamFromURL(URL url) throws JacksonException {\n         if (\"file\".equals(url.getProtocol())) {\n             /* Cannot do this if the path refers\ndiff --git a/src/main/java/tools/jackson/core/base/BinaryTSFactory.java b/src/main/java/tools/jackson/core/base/BinaryTSFactory.java\nindex c2e49f1a4b..b425b056e7 100644\n--- a/src/main/java/tools/jackson/core/base/BinaryTSFactory.java\n+++ b/src/main/java/tools/jackson/core/base/BinaryTSFactory.java\n@@ -1,7 +1,6 @@\n package tools.jackson.core.base;\n \n import java.io.*;\n-import java.net.URL;\n import java.nio.file.Path;\n \n import tools.jackson.core.*;\n@@ -87,18 +86,6 @@ public JsonParser createParser(ObjectReadContext readCtxt,\n                 _decorate(ioCtxt, _pathInputStream(p)));\n     }\n \n-    @Deprecated // since 3.0\n-    @Override\n-    public JsonParser createParser(ObjectReadContext readCtxt,\n-            URL url) throws JacksonException\n-    {\n-        // true, since we create InputStream from URL\n-        IOContext ioCtxt = _createContext(_createContentReference(url), true);\n-        InputStream in = _optimizedStreamFromURL(url);\n-        return _createParser(readCtxt, ioCtxt,\n-                _decorate(ioCtxt, in));\n-    }\n-\n     @Override\n     public JsonParser createParser(ObjectReadContext readCtxt, InputStream in) throws JacksonException {\n         IOContext ioCtxt = _createContext(_createContentReference(in), false);\ndiff --git a/src/main/java/tools/jackson/core/base/TextualTSFactory.java b/src/main/java/tools/jackson/core/base/TextualTSFactory.java\nindex 69950b5b9d..d6f90242b0 100644\n--- a/src/main/java/tools/jackson/core/base/TextualTSFactory.java\n+++ b/src/main/java/tools/jackson/core/base/TextualTSFactory.java\n@@ -1,7 +1,6 @@\n package tools.jackson.core.base;\n \n import java.io.*;\n-import java.net.URL;\n import java.nio.file.Path;\n \n import tools.jackson.core.*;\n@@ -109,17 +108,6 @@ public JsonParser createParser(ObjectReadContext readCtxt, Path p)\n                 _decorate(ioCtxt, _pathInputStream(p)));\n     }\n \n-    @Deprecated // since 3.0\n-    @Override\n-    public JsonParser createParser(ObjectReadContext readCtxt, URL url)\n-        throws JacksonException\n-    {\n-        // true, since we create InputStream from URL\n-        IOContext ioCtxt = _createContext(_createContentReference(url), true);\n-        return _createParser(readCtxt, ioCtxt,\n-                _decorate(ioCtxt, _optimizedStreamFromURL(url)));\n-    }\n-\n     @Override\n     public JsonParser createParser(ObjectReadContext readCtxt, InputStream in)\n         throws JacksonException\n",
  "test_patch" : "diff --git a/src/test/java/tools/jackson/core/unittest/json/InputStreamInitTest.java b/src/test/java/tools/jackson/core/unittest/json/InputStreamInitTest.java\nindex 1742d8c641..ecd3afc512 100644\n--- a/src/test/java/tools/jackson/core/unittest/json/InputStreamInitTest.java\n+++ b/src/test/java/tools/jackson/core/unittest/json/InputStreamInitTest.java\n@@ -60,20 +60,4 @@ void forFile() throws Exception\n         assertNotNull(jsonF.lastStream);\n         assertTrue(jsonF.lastStream.closed);\n     }\n-\n-    @SuppressWarnings(\"deprecation\")\n-    @Test\n-    void forURL() throws Exception\n-    {\n-        final FailingJsonFactory jsonF = new FailingJsonFactory();\n-        try {\n-            /*JsonParser p =*/ jsonF.createParser(ObjectReadContext.empty(),\n-                    new URL(\"http://localhost:80/\"));\n-            fail(\"Should not pass\");\n-        } catch (Exception e) {\n-            verifyException(e, \"Will not read\");\n-        }\n-        assertNotNull(jsonF.lastStream);\n-        assertTrue(jsonF.lastStream.closed);\n-    }\n }\ndiff --git a/src/test/java/tools/jackson/core/unittest/json/JsonFactoryTest.java b/src/test/java/tools/jackson/core/unittest/json/JsonFactoryTest.java\nindex d13568127e..d385f3c573 100644\n--- a/src/test/java/tools/jackson/core/unittest/json/JsonFactoryTest.java\n+++ b/src/test/java/tools/jackson/core/unittest/json/JsonFactoryTest.java\n@@ -108,13 +108,6 @@ public void testJsonWithFiles() throws Exception\n         assertNull(p.nextToken());\n         p.close();\n \n-        // Then via URL:\n-        p = f.createParser(ObjectReadContext.empty(), file.toURI().toURL());\n-        assertToken(JsonToken.START_OBJECT, p.nextToken());\n-        assertToken(JsonToken.END_OBJECT, p.nextToken());\n-        assertNull(p.nextToken());\n-        p.close();\n-\n         // ok, delete once we are done\n         file.delete();\n     }\n@@ -273,17 +266,6 @@ public void test_createParser_Path() throws Exception\n         assertEquals(jsonParser.nextStringValue(), \"value\");\n     }\n \n-    @Test\n-    public void test_createParser_Url() throws Exception\n-    {\n-        Path path = Files.createTempFile(\"\", \"\");\n-        Files.write(path, \"\\\"value\\\"\".getBytes(StandardCharsets.UTF_8));\n-        JsonParser jsonParser = new JsonFactory()\n-                .createParser(ObjectReadContext.empty(), path.toUri().toURL());\n-\n-        assertEquals(jsonParser.nextStringValue(), \"value\");\n-    }\n-\n     @Test\n     public void test_createParser_Reader() throws Exception\n     {\ndiff --git a/src/test/java/tools/jackson/core/unittest/read/SimpleParserTest.java b/src/test/java/tools/jackson/core/unittest/read/SimpleParserTest.java\nindex 897352409b..298581c980 100644\n--- a/src/test/java/tools/jackson/core/unittest/read/SimpleParserTest.java\n+++ b/src/test/java/tools/jackson/core/unittest/read/SimpleParserTest.java\n@@ -1,7 +1,6 @@\n package tools.jackson.core.unittest.read;\n \n import java.io.*;\n-import java.net.URL;\n import java.nio.charset.StandardCharsets;\n import java.util.*;\n \n@@ -497,23 +496,6 @@ void utf8BOMHandling() throws Exception\n         p.close();\n     }\n \n-    // [core#48]\n-    @SuppressWarnings(\"deprecation\")\n-    @Test\n-    void spacesInURL() throws Exception\n-    {\n-        File f = File.createTempFile(\"pre fix&stuff\", \".txt\");\n-        BufferedWriter w = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(f), \"UTF-8\"));\n-        w.write(\"{ }\");\n-        w.close();\n-        URL url = f.toURI().toURL();\n-\n-        JsonParser p = JSON_FACTORY.createParser(ObjectReadContext.empty(), url);\n-        assertToken(JsonToken.START_OBJECT, p.nextToken());\n-        assertToken(JsonToken.END_OBJECT, p.nextToken());\n-        p.close();\n-    }\n-\n     @Test\n     void getValueAsTextBytes() throws Exception\n     {\n",
  "problem_statement" : "(note: continuation of #1462)\n\nAssuming #1462 is done and we have time, let's remove now-deprecated method(s):\n\n```\n    public abstract JsonParser createParser(URL url);\n```\n\nfrom Jackson 3.0.\n\n\n",
  "hints_text" : null,
  "created_at" : "Wed Aug 20 03:02:58 CEST 2025",
  "version" : null,
  "FAIL_TO_PASS" : [ "SimpleParserTest", "InputStreamInitTest", "JsonFactoryTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=SimpleParserTest,InputStreamInitTest,JsonFactoryTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : 1463,
  "pull_number" : 1466,
  "metadata" : null
}, {
  "instance_id" : "FasterXML-jackson-core-PR-1460",
  "repo" : "FasterXML/jackson-core",
  "base_commit" : "d61c80a6c0afea7d4e273d0603021189ecca1cf4",
  "patch" : "diff --git a/release-notes/VERSION b/release-notes/VERSION\nindex 7a3d3d9ff5..3a7765c103 100644\n--- a/release-notes/VERSION\n+++ b/release-notes/VERSION\n@@ -15,12 +15,16 @@ JSON library.\n === Releases ===\n ------------------------------------------------------------------------\n \n-3.0.0-rc7 (08-Aug-2025)\n+3.0.0-rc8 (not yet released)\n \n * REVERT #1200: Change `JsonWriteFeature.ESCAPE_FORWARD_SLASHES` default\n   to `true` for 3.0\n  (that is, default remains `false` same as in 2.x)\n \n+3.0.0-rc7 (08-Aug-2025)\n+\n+No changes since 3.0.0-rc6\n+\n 3.0.0-rc6 (18-Jul-2025)\n \n #1434: Change `JsonParser.getNumberType()` to return `null` instead of\ndiff --git a/src/main/java/tools/jackson/core/io/CharTypes.java b/src/main/java/tools/jackson/core/io/CharTypes.java\nindex f47706c7ac..a7dd80ceaf 100644\n--- a/src/main/java/tools/jackson/core/io/CharTypes.java\n+++ b/src/main/java/tools/jackson/core/io/CharTypes.java\n@@ -24,10 +24,9 @@ public final class CharTypes\n      */\n     protected final static int[] sInputCodes;\n     static {\n-        /* 96 would do for most cases (backslash is ASCII 94)\n-         * but if we want to do lookups by raw bytes it's better\n-         * to have full table\n-         */\n+        // 96 would do for most cases (backslash is ASCII 94)\n+        // but if we want to do lookups by raw bytes it's better\n+        // to have full table\n         final int[] table = new int[256];\n         // Control chars and non-space white space are not allowed unquoted\n         for (int i = 0; i < 32; ++i) {\n@@ -217,13 +216,13 @@ public final class CharTypes\n      * Value of 0 means \"no escaping\"; other positive values that value is character\n      * to use after backslash; and negative values that generic (backslash - u)\n      * escaping is to be used.\n-     *<p>\n-     * NOTE: as of Jackson 3.0, forward slash ({@code \"/\"}) is escaped by default.\n      *\n      * @return 128-entry {@code int[]} that contains escape definitions\n      */\n     public static int[] get7BitOutputEscapes() {\n-        return get7BitOutputEscapes('\"', true);\n+        // 11-Aug-2025, tatu: Note! 3.x still defaults to NOT escaping forward slash\n+        //   by defeault\n+        return get7BitOutputEscapes('\"', false);\n     }\n \n     /**\ndiff --git a/src/main/java/tools/jackson/core/json/JsonWriteFeature.java b/src/main/java/tools/jackson/core/json/JsonWriteFeature.java\nindex 39c5ec7a3e..e400be36cc 100644\n--- a/src/main/java/tools/jackson/core/json/JsonWriteFeature.java\n+++ b/src/main/java/tools/jackson/core/json/JsonWriteFeature.java\n@@ -64,7 +64,7 @@ public enum JsonWriteFeature\n      * <p>\n      * Feature is disabled by default.\n      */\n-    ESCAPE_FORWARD_SLASHES(true),\n+    ESCAPE_FORWARD_SLASHES(false),\n \n     /**\n      * Feature that specifies that all characters beyond 7-bit ASCII\n",
  "test_patch" : "diff --git a/src/test/java/tools/jackson/core/unittest/io/TestJsonStringEncoder.java b/src/test/java/tools/jackson/core/unittest/io/TestJsonStringEncoder.java\nindex 03c1612b99..f06873c319 100644\n--- a/src/test/java/tools/jackson/core/unittest/io/TestJsonStringEncoder.java\n+++ b/src/test/java/tools/jackson/core/unittest/io/TestJsonStringEncoder.java\n@@ -83,22 +83,27 @@ void quoteAsUTF8() throws Exception\n         // In this case, let's actually use existing JsonGenerator to produce expected values\n         JsonFactory f = new JsonFactory();\n         JsonStringEncoder encoder = new JsonStringEncoder();\n-        int[] lengths = new int[] {\n-            5, 19, 200, 7000, 21000, 37000\n-        };\n-        for (int length : lengths) {\n-            String str = generateRandom(length);\n-            StringWriter sw = new StringWriter(length*2);\n-            JsonGenerator jgen = f.createGenerator(ObjectWriteContext.empty(), sw);\n-            jgen.writeString(str);\n-            jgen.close();\n-            String encoded = sw.toString();\n-            // ok, except need to remove surrounding quotes\n-            encoded = encoded.substring(1, encoded.length() - 1);\n-            byte[] expected = encoded.getBytes(\"UTF-8\");\n-            byte[] actual = encoder.quoteAsUTF8(str);\n-            assertArrayEquals(expected, actual);\n+        for (int length : new int[] {\n+                5, 19, 200, 7000, 21000, 37000\n+            }) {\n+            _quoteAsUTF8(f, encoder, length);\n+        }\n+    }\n+\n+    private void _quoteAsUTF8(JsonFactory f, JsonStringEncoder encoder, int length) throws Exception\n+    {\n+        String str = generateRandom(length);\n+        StringWriter sw = new StringWriter(length*2);\n+        try (JsonGenerator g = f.createGenerator(ObjectWriteContext.empty(), sw)) {\n+            g.writeString(str);\n         }\n+        String encoded = sw.toString();\n+        // ok, except need to remove surrounding quotes\n+        encoded = encoded.substring(1, encoded.length() - 1);\n+        byte[] expected = encoded.getBytes(\"UTF-8\");\n+        byte[] actual = encoder.quoteAsUTF8(str);\n+        assertArrayEquals(expected, actual,\n+                \"For content length \"+length);\n     }\n \n     @Test\ndiff --git a/src/test/java/tools/jackson/core/unittest/write/JsonWriteFeatureEscapeForwardSlashTest.java b/src/test/java/tools/jackson/core/unittest/write/JsonWriteFeatureEscapeForwardSlashTest.java\nindex cf59a55820..8bc35b67a4 100644\n--- a/src/test/java/tools/jackson/core/unittest/write/JsonWriteFeatureEscapeForwardSlashTest.java\n+++ b/src/test/java/tools/jackson/core/unittest/write/JsonWriteFeatureEscapeForwardSlashTest.java\n@@ -11,21 +11,22 @@\n import tools.jackson.core.json.JsonWriteFeature;\n \n import static org.junit.jupiter.api.Assertions.assertEquals;\n-import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n \n class JsonWriteFeatureEscapeForwardSlashTest\n {\n     @Test\n     public void testDefaultSettings() {\n         JsonFactory jsonF = new JsonFactory();\n-        assertTrue(jsonF.isEnabled(JsonWriteFeature.ESCAPE_FORWARD_SLASHES));\n+        // 11-Aug-2025, tatu: [core#1200] was reverted, so...\n+        assertFalse(jsonF.isEnabled(JsonWriteFeature.ESCAPE_FORWARD_SLASHES));\n         try (JsonGeneratorBase g = (JsonGeneratorBase) jsonF.createGenerator(ObjectWriteContext.empty(),\n                 new StringWriter())) {\n-            assertTrue(g.isEnabled(JsonWriteFeature.ESCAPE_FORWARD_SLASHES));\n+            assertFalse(g.isEnabled(JsonWriteFeature.ESCAPE_FORWARD_SLASHES));\n         }\n         try (JsonGeneratorBase g = (JsonGeneratorBase) jsonF.createGenerator(ObjectWriteContext.empty(),\n                 new ByteArrayOutputStream())) {\n-            assertTrue(g.isEnabled(JsonWriteFeature.ESCAPE_FORWARD_SLASHES));\n+            assertFalse(g.isEnabled(JsonWriteFeature.ESCAPE_FORWARD_SLASHES));\n         }\n     }\n \n",
  "problem_statement" : "(follow-up to #507)\r\n\r\nNow that we have added ability to easily force escaping of `/` let's make that default for Jackson 3.0 stream writers.\r\n\r\n",
  "hints_text" : null,
  "created_at" : "Mon Aug 11 17:52:51 CEST 2025",
  "version" : null,
  "FAIL_TO_PASS" : [ "JsonWriteFeatureEscapeForwardSlashTest", "TestJsonStringEncoder" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=JsonWriteFeatureEscapeForwardSlashTest,TestJsonStringEncoder",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : 1200,
  "pull_number" : 1460,
  "metadata" : null
}, {
  "instance_id" : "FasterXML-jackson-core-PR-1442",
  "repo" : "FasterXML/jackson-core",
  "base_commit" : "c20ac86571ef9665ece2bad49ec37ae910ec95e9",
  "patch" : "diff --git a/release-notes/VERSION-2.x b/release-notes/VERSION-2.x\nindex a09df6ffdd..5494b07f44 100644\n--- a/release-notes/VERSION-2.x\n+++ b/release-notes/VERSION-2.x\n@@ -17,6 +17,7 @@ a pure JSON library.\n 2.20.0 (not yet released)\n \n #1438: `ParserBase.close()` does not clear `_currToken`\n+#1441: Add `StreamReadFeature.CLEAR_CURRENT_TOKEN_ON_CLOSE` (default: true)\n - Generate SBOMs [JSTEP-14]\n \n 2.19.1 (not yet released)\ndiff --git a/src/main/java/com/fasterxml/jackson/core/JsonParser.java b/src/main/java/com/fasterxml/jackson/core/JsonParser.java\nindex 9870a76265..0a77096488 100644\n--- a/src/main/java/com/fasterxml/jackson/core/JsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonParser.java\n@@ -405,9 +405,15 @@ public enum Feature {\n           *\n           * @since 2.15\n           */\n-          USE_FAST_BIG_NUMBER_PARSER(false)\n+         USE_FAST_BIG_NUMBER_PARSER(false),\n \n-         ;\n+         /**\n+          * See {@link StreamReadFeature#CLEAR_CURRENT_TOKEN_ON_CLOSE}.\n+          *\n+          * @since 2.20\n+          */\n+         CLEAR_CURRENT_TOKEN_ON_CLOSE(true)\n+        ;\n \n         /**\n          * Whether feature is enabled or disabled by default.\ndiff --git a/src/main/java/com/fasterxml/jackson/core/StreamReadFeature.java b/src/main/java/com/fasterxml/jackson/core/StreamReadFeature.java\nindex 354c3634d2..65e63d4fa6 100644\n--- a/src/main/java/com/fasterxml/jackson/core/StreamReadFeature.java\n+++ b/src/main/java/com/fasterxml/jackson/core/StreamReadFeature.java\n@@ -111,8 +111,19 @@ public enum StreamReadFeature\n      *\n      * @since 2.15\n      */\n-    USE_FAST_BIG_NUMBER_PARSER(JsonParser.Feature.USE_FAST_BIG_NUMBER_PARSER)\n+    USE_FAST_BIG_NUMBER_PARSER(JsonParser.Feature.USE_FAST_BIG_NUMBER_PARSER),\n \n+    /**\n+     * Feature that determines whether parser will clear \"current token\"\n+     * (accessible via JsonParser#currentToken()) when it is closed (via\n+     * {@link JsonParser#close()}).\n+     *<p>\n+     * Feature is enabled by default.\n+     *\n+     * @since 2.20\n+     */\n+    CLEAR_CURRENT_TOKEN_ON_CLOSE(JsonParser.Feature.CLEAR_CURRENT_TOKEN_ON_CLOSE),\n+    \n     ;\n \n     /**\ndiff --git a/src/main/java/com/fasterxml/jackson/core/base/ParserBase.java b/src/main/java/com/fasterxml/jackson/core/base/ParserBase.java\nindex 3d12d36ff0..4b31a35f77 100644\n--- a/src/main/java/com/fasterxml/jackson/core/base/ParserBase.java\n+++ b/src/main/java/com/fasterxml/jackson/core/base/ParserBase.java\n@@ -404,7 +404,9 @@ public void overrideCurrentName(String name) {\n             _inputPtr = Math.max(_inputPtr, _inputEnd);\n             _closed = true;\n             // 30-May-2025, tatu: was missing before 2.20\n-            _currToken = null;\n+            if (JsonParser.Feature.CLEAR_CURRENT_TOKEN_ON_CLOSE.enabledIn(_features)) {\n+                _currToken = null;\n+            }\n             try {\n                 _closeInput();\n             } finally {\n",
  "test_patch" : "diff --git a/src/test/java/com/fasterxml/jackson/core/json/JsonFactoryTest.java b/src/test/java/com/fasterxml/jackson/core/json/JsonFactoryTest.java\nindex 61ba333578..9bfd1c6468 100644\n--- a/src/test/java/com/fasterxml/jackson/core/json/JsonFactoryTest.java\n+++ b/src/test/java/com/fasterxml/jackson/core/json/JsonFactoryTest.java\n@@ -354,9 +354,9 @@ private void verifyCanonicalizationTestResult(JsonParser parser, boolean canonic\n         if (canonicalize) {\n             assertSame(field1, field2);\n         } else {\n-            // n.b. It's possible that this may flake if a garbage collector with string deduplication\n+            // n.b. It's possible that this may flake if a garbage collector with string de-duplication\n             // enabled is used. Such a failure is unlikely because younger GC generations are typically\n-            // not considered for deduplication due to high churn, but under heavy memory pressure it\n+            // not considered for de-duplication due to high churn, but under heavy memory pressure it\n             // may be possible. I've left this comment in an attempt to simplify investigation in the\n             // off-chance that such flakes eventually occur.\n             assertNotSame(field1, field2);\ndiff --git a/src/test/java/com/fasterxml/jackson/core/json/JsonParserClosedCaseTest.java b/src/test/java/com/fasterxml/jackson/core/json/JsonParserClosedCaseTest.java\nindex be9b762ea6..2a98e8455e 100644\n--- a/src/test/java/com/fasterxml/jackson/core/json/JsonParserClosedCaseTest.java\n+++ b/src/test/java/com/fasterxml/jackson/core/json/JsonParserClosedCaseTest.java\n@@ -5,11 +5,15 @@\n import java.util.Collection;\n import java.util.List;\n \n+import org.junit.jupiter.api.Test;\n import org.junit.jupiter.params.ParameterizedTest;\n import org.junit.jupiter.params.provider.MethodSource;\n \n+import com.fasterxml.jackson.core.JUnit5TestBase;\n import com.fasterxml.jackson.core.JsonFactory;\n import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.core.JsonToken;\n+import com.fasterxml.jackson.core.StreamReadFeature;\n import com.fasterxml.jackson.core.io.SerializedString;\n import com.fasterxml.jackson.core.testsupport.MockDataInput;\n \n@@ -20,7 +24,9 @@\n  * Tests asserts that using closed `JsonParser` doesn't cause ArrayIndexOutOfBoundsException\n  * with `nextXxx()` methods but returns `null` as expected.\n  */\n-public class JsonParserClosedCaseTest {\n+public class JsonParserClosedCaseTest\n+    extends JUnit5TestBase\n+{\n     private static final JsonFactory JSON_F = new JsonFactory();\n \n     JsonParser parser;\n@@ -73,6 +79,49 @@ void nullReturnedOnClosedParserOnNextValue(String parserName, JsonParser parser)\n         assertNull(parser.nextValue());\n     }\n \n+    // [core#1441]: StreamReadFeature.CLEAR_CURRENT_TOKEN_ON_CLOSE\n+    @Test\n+    void clearCurrentTokenOnCloseEnabled() throws Exception {\n+         JsonFactory f = JsonFactory.builder()\n+                 .enable(StreamReadFeature.CLEAR_CURRENT_TOKEN_ON_CLOSE)\n+                 .build();\n+         _clearCurrentTokenOnCloseEnabled(f, MODE_INPUT_STREAM);\n+         _clearCurrentTokenOnCloseEnabled(f, MODE_INPUT_STREAM_THROTTLED);\n+         _clearCurrentTokenOnCloseEnabled(f, MODE_READER);\n+         _clearCurrentTokenOnCloseEnabled(f, MODE_DATA_INPUT);\n+                 \n+    }\n+\n+    @Test\n+    void clearCurrentTokenOnCloseDisabled() throws Exception {\n+         JsonFactory f = JsonFactory.builder()\n+                 .disable(StreamReadFeature.CLEAR_CURRENT_TOKEN_ON_CLOSE)\n+                 .build();\n+         _clearCurrentTokenOnCloseDisabled(f, MODE_INPUT_STREAM);\n+         _clearCurrentTokenOnCloseDisabled(f, MODE_INPUT_STREAM_THROTTLED);\n+         _clearCurrentTokenOnCloseDisabled(f, MODE_READER);\n+         _clearCurrentTokenOnCloseDisabled(f, MODE_DATA_INPUT);\n+                 \n+    }\n+\n+    private void _clearCurrentTokenOnCloseEnabled(JsonFactory f, int mode) throws Exception\n+    {\n+        try (JsonParser p = f.createParser(\"[ 1 ]\")) {\n+            assertToken(JsonToken.START_ARRAY, p.nextToken());\n+            p.close();\n+            assertNull(p.currentToken());\n+        }\n+    }\n+    \n+    private void _clearCurrentTokenOnCloseDisabled(JsonFactory f, int mode) throws Exception\n+    {\n+        try (JsonParser p = f.createParser(\"[ 1 ]\")) {\n+            assertToken(JsonToken.START_ARRAY, p.nextToken());\n+            p.close();\n+            assertToken(JsonToken.START_ARRAY, p.currentToken());\n+        }\n+    }\n+\n     private static Collection<Object[]> closeParsers(JsonParser... parsersToClose) throws IOException {\n         List<Object[]> list = new ArrayList<>();\n         for (JsonParser p : parsersToClose) {\n",
  "problem_statement" : "(follow-up to #1438 )\n\nDue to risks of regression, let's add a `StreamReadFeature` for determining whether `JsonParser.close()` should clear current token information,  accessible via `JsonParser.currentToken()`.\n\nIf enabled (default for 2.20), current token IS cleared (set to `null`); if disabled, it remains as it was at time of `close()`.\n\nDefault planned to be `true` (clear current token) as that seems more intuitive choice; but note that existing (2.19) behavior what `false` will do.\n\nSince this is for 2.20, we have still time to consider choice of default.\n(for 3.0 it should probably be `true`, at any rate).\n",
  "hints_text" : null,
  "created_at" : "Sat May 31 00:40:02 CEST 2025",
  "version" : null,
  "FAIL_TO_PASS" : [ "JsonParserClosedCaseTest", "JsonFactoryTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=JsonParserClosedCaseTest,JsonFactoryTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : 1441,
  "pull_number" : 1442,
  "metadata" : null
}, {
  "instance_id" : "FasterXML-jackson-core-PR-1437",
  "repo" : "FasterXML/jackson-core",
  "base_commit" : "57f851672e159936f19764b840e5635474466dbc",
  "patch" : "diff --git a/release-notes/VERSION b/release-notes/VERSION\nindex 2e45ee5d02..829480ce1f 100644\n--- a/release-notes/VERSION\n+++ b/release-notes/VERSION\n@@ -15,6 +15,9 @@ JSON library.\n === Releases ===\n ------------------------------------------------------------------------\n \n+#1434: Change `JsonParser.getNumberType()` to return `null` instead of\n+  throwing exception in 3.0\n+\n 3.0.0-rc5 (22-May-2025)\n 3.0.0-rc4 (10-May-2025)\n \ndiff --git a/src/main/java/tools/jackson/core/JsonParser.java b/src/main/java/tools/jackson/core/JsonParser.java\nindex 9cdeaae1e5..c105bef0d8 100644\n--- a/src/main/java/tools/jackson/core/JsonParser.java\n+++ b/src/main/java/tools/jackson/core/JsonParser.java\n@@ -1081,6 +1081,8 @@ public int getTextOffset() throws JacksonException {\n      * {@link JsonToken#VALUE_NUMBER_INT} or\n      * {@link JsonToken#VALUE_NUMBER_FLOAT}, returns\n      * one of {@link NumberType} constants; otherwise returns null.\n+     *<p>\n+     * NOTE: in Jackson 2.x, an exception was wrong if called for non-numeric token.\n      *\n      * @return Type of current number, if parser points to numeric token; {@code null} otherwise\n      */\ndiff --git a/src/main/java/tools/jackson/core/base/ParserBase.java b/src/main/java/tools/jackson/core/base/ParserBase.java\nindex f9e736ecba..23dc3327ab 100644\n--- a/src/main/java/tools/jackson/core/base/ParserBase.java\n+++ b/src/main/java/tools/jackson/core/base/ParserBase.java\n@@ -569,6 +569,11 @@ public Object getNumberValueDeferred()\n     public NumberType getNumberType()\n     {\n         if (_numTypesValid == NR_UNKNOWN) {\n+            // 29-May-2025, tatu: [core#1434] Short-circuit for non-numbers\n+            if (_currToken != JsonToken.VALUE_NUMBER_INT\n+                    && _currToken != JsonToken.VALUE_NUMBER_FLOAT) {\n+                 return null;\n+            }\n             _parseNumericValue(NR_UNKNOWN); // will also check event type\n         }\n         if (_currToken == JsonToken.VALUE_NUMBER_INT) {\n",
  "test_patch" : "diff --git a/src/test/java/tools/jackson/core/unittest/read/NumberParsingGetType1433Test.java b/src/test/java/tools/jackson/core/unittest/read/NumberParsingGetType1433Test.java\nindex 60ee8ad5f9..3c7e640580 100644\n--- a/src/test/java/tools/jackson/core/unittest/read/NumberParsingGetType1433Test.java\n+++ b/src/test/java/tools/jackson/core/unittest/read/NumberParsingGetType1433Test.java\n@@ -3,12 +3,10 @@\n import org.junit.jupiter.api.Test;\n \n import tools.jackson.core.*;\n-import tools.jackson.core.exc.StreamReadException;\n import tools.jackson.core.json.JsonFactory;\n \n import static org.junit.jupiter.api.Assertions.assertEquals;\n import static org.junit.jupiter.api.Assertions.assertNull;\n-import static org.junit.jupiter.api.Assertions.fail;\n \n public class NumberParsingGetType1433Test\n     extends tools.jackson.core.unittest.JacksonCoreTestBase\n@@ -68,11 +66,7 @@ private void _getNumberType(int mode) throws Exception\n \n     private void _verifyGetNumberTypeFail(JsonParser p, String token) throws Exception\n     {\n-        try {\n-            p.getNumberType();\n-            fail(\"Should not pass\");\n-        } catch (StreamReadException e) {\n-            verifyException(e, \"Current token (\"+token+\") not numeric, cannot use numeric\");\n-        }\n+        // In 2.x, this would throw an exception; in 3.x it should just return null\n+        assertNull(p.getNumberType());\n     }\n }\n",
  "problem_statement" : "(follow-up to #1433) \n\nSo, although behavior for 2.x is established (and with #1433 will be properly documented), returning `null` seems like slightly nicer option for 3.0. So let's change things to work that way.\n",
  "hints_text" : null,
  "created_at" : "Fri May 30 05:21:25 CEST 2025",
  "version" : null,
  "FAIL_TO_PASS" : [ "NumberParsingGetType1433Test" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=NumberParsingGetType1433Test",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : 1434,
  "pull_number" : 1437,
  "metadata" : null
} ]