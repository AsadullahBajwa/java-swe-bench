[ {
  "instance_id" : "apache-commons-text-PR-735",
  "repo" : "apache/commons-text",
  "base_commit" : "a0b89c079b3af0da7bd6bdc3a8a3421182e14aa4",
  "patch" : "diff --git a/src/main/java/org/apache/commons/text/StrBuilder.java b/src/main/java/org/apache/commons/text/StrBuilder.java\nindex fce069d001..f1df60a2a2 100644\n--- a/src/main/java/org/apache/commons/text/StrBuilder.java\n+++ b/src/main/java/org/apache/commons/text/StrBuilder.java\n@@ -376,7 +376,7 @@ public StrBuilder append(final char[] chars, final int startIndex, final int len\n             return appendNull();\n         }\n         if (startIndex < 0 || startIndex > chars.length) {\n-            throw new StringIndexOutOfBoundsException(\"Invalid startIndex: \" + length);\n+            throw new StringIndexOutOfBoundsException(\"Invalid startIndex: \" + startIndex);\n         }\n         if (length < 0 || startIndex + length > chars.length) {\n             throw new StringIndexOutOfBoundsException(\"Invalid length: \" + length);\ndiff --git a/src/main/java/org/apache/commons/text/TextStringBuilder.java b/src/main/java/org/apache/commons/text/TextStringBuilder.java\nindex b3ea8585f7..2977fa3232 100644\n--- a/src/main/java/org/apache/commons/text/TextStringBuilder.java\n+++ b/src/main/java/org/apache/commons/text/TextStringBuilder.java\n@@ -483,7 +483,7 @@ public TextStringBuilder append(final char[] chars, final int startIndex, final\n             return appendNull();\n         }\n         if (startIndex < 0 || startIndex > chars.length) {\n-            throw new StringIndexOutOfBoundsException(\"Invalid startIndex: \" + length);\n+            throw new StringIndexOutOfBoundsException(\"Invalid startIndex: \" + startIndex);\n         }\n         if (length < 0 || startIndex + length > chars.length) {\n             throw new StringIndexOutOfBoundsException(\"Invalid length: \" + length);\n",
  "test_patch" : "diff --git a/src/test/java/org/apache/commons/text/StrBuilderTest.java b/src/test/java/org/apache/commons/text/StrBuilderTest.java\nindex 6ae331e931..5edfec6fc6 100644\n--- a/src/test/java/org/apache/commons/text/StrBuilderTest.java\n+++ b/src/test/java/org/apache/commons/text/StrBuilderTest.java\n@@ -2017,4 +2017,21 @@ void testTrim() {\n         assertEquals(\"a b c\", sb.trim().toString());\n     }\n \n+    @Test\n+    void testErrorMessageShowsCorrectVariable() {\n+        final StrBuilder sb = new StrBuilder(\"Hello\");\n+        final char[] chars = {'a', 'b', 'c'};\n+\n+        StringIndexOutOfBoundsException ex = assertThrows(\n+                StringIndexOutOfBoundsException.class,\n+                () -> sb.append(chars, 1, 4)\n+        );\n+        assertTrue(ex.getMessage().contains(\"length: 4\"));\n+\n+        ex = assertThrows(\n+                StringIndexOutOfBoundsException.class,\n+                () -> sb.append(chars, 7, 3)\n+        );\n+        assertTrue(ex.getMessage().contains(\"startIndex: 7\"));\n+    }\n }\ndiff --git a/src/test/java/org/apache/commons/text/TextStringBuilderTest.java b/src/test/java/org/apache/commons/text/TextStringBuilderTest.java\nindex 1900c19d68..1efbf25113 100644\n--- a/src/test/java/org/apache/commons/text/TextStringBuilderTest.java\n+++ b/src/test/java/org/apache/commons/text/TextStringBuilderTest.java\n@@ -2393,4 +2393,21 @@ void testWrap_CharArray_Int_Exceptions() {\n         assertThrows(IllegalArgumentException.class, () -> TextStringBuilder.wrap(ArrayUtils.EMPTY_CHAR_ARRAY, 1));\n     }\n \n+    @Test\n+    void testErrorMessageShowsCorrectVariable() {\n+        final TextStringBuilder sb = new TextStringBuilder(\"Hello\");\n+        final char[] chars = {'a', 'b', 'c'};\n+\n+        StringIndexOutOfBoundsException ex = assertThrows(\n+                StringIndexOutOfBoundsException.class,\n+                () -> sb.append(chars, 1, 4)\n+        );\n+        assertTrue(ex.getMessage().contains(\"length: 4\"));\n+\n+        ex = assertThrows(\n+                StringIndexOutOfBoundsException.class,\n+                () -> sb.append(chars, 7, 3)\n+        );\n+        assertTrue(ex.getMessage().contains(\"startIndex: 7\"));\n+    }\n }\n",
  "problem_statement" : "TEXT-239: TextStringBuilder.append(char[], int, int) uses wrong variable in exception message\n\nThis PR fixes [TEXT-239](https://issues.apache.org/jira/browse/TEXT-239) by correcting the exception message in\r\n`TextStringBuilder.append(char[], int, int)` when startIndex is invalid.\r\n\r\nA regression test is included to verify both invalid length and invalid startIndex cases report the correct variable.\r\n\r\n⚠️ The same issue exists in deprecated `StrBuilder` implementations (`commons-text` / `commons-lang`). This PR intentionally limits the change to `TextStringBuilder`",
  "hints_text" : null,
  "created_at" : "Tue Jan 27 17:49:48 CET 2026",
  "version" : null,
  "FAIL_TO_PASS" : [ "TextStringBuilderTest", "StrBuilderTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=TextStringBuilderTest,StrBuilderTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 735,
  "metadata" : null
}, {
  "instance_id" : "apache-commons-text-PR-731",
  "repo" : "apache/commons-text",
  "base_commit" : "b5052c97e84e1c174ec8bfbbb749e33f22917a07",
  "patch" : "diff --git a/src/changes/changes.xml b/src/changes/changes.xml\nindex f8912d2005..9a4b221ebc 100644\n--- a/src/changes/changes.xml\n+++ b/src/changes/changes.xml\n@@ -53,7 +53,7 @@ The <action> type attribute can be add,update,fix,remove.\n     <action type=\"fix\" dev=\"ggregory\" due-to=\"Gary Gregory\">Fix Apache RAT plugin console warnings.</action>\n     <action type=\"fix\" dev=\"ggregory\" due-to=\"Gary Gregory\">Fix site XML to use version 2.0.0 XML schema.</action>\n     <action type=\"fix\" dev=\"ggregory\" due-to=\"Michael Hausegger\">Removed unreachable threshold verification code in src/main/java/org/apache/commons/text/similarity #730.</action>\n-    <action type=\"fix\" dev=\"ggregory\" due-to=\"김민재, Gary Gregory\">Enable secure processing for the XML parser in XmlStringLookup #729.</action>\n+    <action type=\"fix\" dev=\"ggregory\" due-to=\"김민재, Gary Gregory, Piotr Karwasz\">Enable secure processing for the XML parser in XmlStringLookup in case the underlying JAXP implementation doesn't #729.</action>\n     <!-- ADD -->\n     <action type=\"add\" dev=\"ggregory\" due-to=\"Piotr P. Karwasz, Gary Gregory\">Add experimental CycloneDX VEX file #683.</action>\n     <action type=\"add\" dev=\"ggregory\" due-to=\"LorgeN, Gary Gregory\" issue=\"TEXT-235\">Add Damerau-Levenshtein distance #687.</action>\ndiff --git a/src/main/java/org/apache/commons/text/lookup/StringLookupFactory.java b/src/main/java/org/apache/commons/text/lookup/StringLookupFactory.java\nindex 863baa7f34..699b7deab7 100644\n--- a/src/main/java/org/apache/commons/text/lookup/StringLookupFactory.java\n+++ b/src/main/java/org/apache/commons/text/lookup/StringLookupFactory.java\n@@ -1718,15 +1718,14 @@ public StringLookup xmlStringLookup(final Map<String, Boolean> factoryFeatures)\n      * <li>{@code \"com/domain/document.xml:/path/to/node\"}</li>\n      * </ul>\n      * <p>\n-     * Secure processing is enabled by default and can be overridden with the system property {@code \"XmlStringLookup.secure\"} set to {@code false}. The secure\n-     * boolean String parsing follows the syntax defined by {@link Boolean#parseBoolean(String)}.\n+     * Secure processing is enabled by default and can be overridden with this constructor.\n      * </p>\n      * <p>\n      * Using a {@link StringLookup} from the {@link StringLookupFactory} fenced by the current directory ({@code Paths.get(\"\")}):\n      * </p>\n      *\n      * <pre>\n-     * StringLookupFactory.INSTANCE.xmlStringLookup(map, Pathe.get(\"\")).lookup(\"com/domain/document.xml:/path/to/node\");\n+     * StringLookupFactory.INSTANCE.xmlStringLookup(map, Path.get(\"\")).lookup(\"com/domain/document.xml:/path/to/node\");\n      * </pre>\n      * <p>\n      * To use a {@link StringLookup} fenced by the current directory, use:\ndiff --git a/src/main/java/org/apache/commons/text/lookup/XmlStringLookup.java b/src/main/java/org/apache/commons/text/lookup/XmlStringLookup.java\nindex 85747eebc2..ee33441993 100644\n--- a/src/main/java/org/apache/commons/text/lookup/XmlStringLookup.java\n+++ b/src/main/java/org/apache/commons/text/lookup/XmlStringLookup.java\n@@ -30,7 +30,6 @@\n import javax.xml.xpath.XPathFactory;\n \n import org.apache.commons.lang3.StringUtils;\n-import org.apache.commons.lang3.SystemProperties;\n import org.w3c.dom.Document;\n \n /**\n@@ -42,8 +41,7 @@\n  * <li>{@code \"com/domain/document.xml:/path/to/node\"}</li>\n  * </ul>\n  * <p>\n- * Secure processing is enabled by default and can be overridden with the system property {@code \"XmlStringLookup.secure\"} set to {@code false}. The secure\n- * boolean String parsing follows the syntax defined by {@link Boolean#parseBoolean(String)}.\n+ * Secure processing is enabled by default and can be overridden with {@link StringLookupFactory#xmlStringLookup(Map, Path...)}.\n  * </p>\n  *\n  * @since 1.5\n@@ -72,14 +70,13 @@ final class XmlStringLookup extends AbstractPathFencedLookup {\n     }\n \n     /**\n-     * Defines the singleton for this class with secure processing enabled.\n+     * Defines the singleton for this class with secure processing enabled by default.\n+     * <p>\n+     * Secure processing is enabled by default and can be overridden with {@link StringLookupFactory#xmlStringLookup(Map, Path...)}.\n+     * </p>\n      */\n     static final XmlStringLookup INSTANCE = new XmlStringLookup(DEFAULT_XML_FEATURES, DEFAULT_XPATH_FEATURES, (Path[]) null);\n \n-    private static boolean isSecure() {\n-        return SystemProperties.getBoolean(XmlStringLookup.class, \"secure\", () -> true);\n-    }\n-\n     /**\n      * Defines XPath factory features.\n      */\n@@ -113,8 +110,7 @@ private static boolean isSecure() {\n      * <li>{@code \"com/domain/document.xml:/path/to/node\"}</li>\n      * </ul>\n      * <p>\n-     * Secure processing is enabled by default. The secure boolean String parsing follows the syntax defined by {@link Boolean#parseBoolean(String)}. The secure\n-     * value in the key overrides instance settings given in the constructor.\n+     * Secure processing is enabled by default and can be overridden with {@link StringLookupFactory#xmlStringLookup(Map, Path...)}.\n      * </p>\n      *\n      * @param key the key to be looked up, may be null.\n@@ -130,7 +126,6 @@ public String lookup(final String key) {\n         if (keyLen != KEY_PARTS_LEN) {\n             throw IllegalArgumentExceptions.format(\"Bad XML key format '%s'; the expected format is 'DocumentPath:XPath'.\", key);\n         }\n-        final boolean secure = isSecure();\n         final String documentPath = keys[0];\n         final String xpath = StringUtils.substringAfterLast(key, SPLIT_CH);\n         final DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n@@ -138,14 +133,12 @@ public String lookup(final String key) {\n             for (final Entry<String, Boolean> p : xmlFactoryFeatures.entrySet()) {\n                 dbFactory.setFeature(p.getKey(), p.getValue());\n             }\n-            dbFactory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, secure);\n             try (InputStream inputStream = Files.newInputStream(getPath(documentPath))) {\n                 final Document doc = dbFactory.newDocumentBuilder().parse(inputStream);\n                 final XPathFactory xpFactory = XPathFactory.newInstance();\n                 for (final Entry<String, Boolean> p : xPathFactoryFeatures.entrySet()) {\n                     xpFactory.setFeature(p.getKey(), p.getValue());\n                 }\n-                xpFactory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, secure);\n                 return xpFactory.newXPath().evaluate(xpath, doc);\n             }\n         } catch (final Exception e) {\n",
  "test_patch" : "diff --git a/src/test/java/org/apache/commons/text/lookup/XmlStringLookupTest.java b/src/test/java/org/apache/commons/text/lookup/XmlStringLookupTest.java\nindex f0cc50ba96..7327bca7ef 100644\n--- a/src/test/java/org/apache/commons/text/lookup/XmlStringLookupTest.java\n+++ b/src/test/java/org/apache/commons/text/lookup/XmlStringLookupTest.java\n@@ -69,7 +69,6 @@ void testExternalEntityOff() {\n     }\n \n     @Test\n-    @SetSystemProperty(key = \"XmlStringLookup.secure\", value = \"false\")\n     void testExternalEntityOn() {\n         final String key = DOC_DIR + \"document-entity-ref.xml:/document/content\";\n         assertEquals(DATA, new XmlStringLookup(EMPTY_MAP, EMPTY_MAP).apply(key).trim());\n@@ -79,16 +78,14 @@ void testExternalEntityOn() {\n     @Test\n     void testInterpolatorExternalDtdOff() {\n         final StringSubstitutor stringSubstitutor = StringSubstitutor.createInterpolator();\n-        assertThrows(IllegalArgumentException.class, () -> stringSubstitutor.replace(\"${xml:\" + DOC_DIR\n-                + \"document-external-dtd.xml:/document/content}\"));\n+        assertThrows(IllegalArgumentException.class, () -> stringSubstitutor.replace(\"${xml:\" + DOC_DIR + \"document-external-dtd.xml:/document/content}\"));\n     }\n \n     @Test\n-    @SetSystemProperty(key = \"XmlStringLookup.secure\", value = \"false\")\n+    @SetSystemProperty(key = \"javax.xml.accessExternalDTD\", value = \"file\")\n     void testInterpolatorExternalDtdOn() {\n         final StringSubstitutor stringSubstitutor = StringSubstitutor.createInterpolator();\n-        assertEquals(\"This is an external entity.\",\n-                stringSubstitutor.replace(\"${xml:\" + DOC_DIR + \"document-external-dtd.xml:/document/content}\").trim());\n+        assertEquals(\"This is an external entity.\", stringSubstitutor.replace(\"${xml:\" + DOC_DIR + \"document-external-dtd.xml:/document/content}\").trim());\n     }\n \n     @Test\n@@ -98,7 +95,7 @@ void testInterpolatorExternalEntityOff() {\n     }\n \n     @Test\n-    @SetSystemProperty(key = \"XmlStringLookup.secure\", value = \"false\")\n+    @SetSystemProperty(key = \"javax.xml.accessExternalDTD\", value = \"file\")\n     void testInterpolatorExternalEntityOffOverride() {\n         final StringSubstitutor stringSubstitutor = StringSubstitutor.createInterpolator();\n         assertEquals(DATA, stringSubstitutor.replace(\"${xml:\" + DOC_DIR + \"document-entity-ref.xml:/document/content}\").trim());\n@@ -111,11 +108,9 @@ void testInterpolatorExternalEntityOn() {\n     }\n \n     @Test\n-    @SetSystemProperty(key = \"XmlStringLookup.secure\", value = \"true\")\n     void testInterpolatorExternalEntityOnOverride() {\n         final StringSubstitutor stringSubstitutor = StringSubstitutor.createInterpolator();\n-        assertThrows(IllegalArgumentException.class,\n-                () -> stringSubstitutor.replace(\"${xml:\" + DOC_DIR + \"document-entity-ref.xml:/document/content}\"));\n+        assertThrows(IllegalArgumentException.class, () -> stringSubstitutor.replace(\"${xml:\" + DOC_DIR + \"document-entity-ref.xml:/document/content}\"));\n     }\n \n     @Test\n",
  "problem_statement" : "Simplify XML FSP\n\nBefore you push a pull request, review this list:\r\n\r\n- [x] Read the [contribution guidelines](CONTRIBUTING.md) for this project.\r\n- [x] Read the [ASF Generative Tooling Guidance](https://www.apache.org/legal/generative-tooling.html) if you use Artificial Intelligence (AI).\r\n- [ ] I used AI to create any part of, or all of, this pull request.\r\n- [x] Run a successful build using the default [Maven](https://maven.apache.org/) goal with `mvn`; that's `mvn` on the command line by itself.\r\n- [x] Write unit tests that match behavioral changes, where the tests fail if the changes to the runtime are not applied. This may not always be possible, but it is a best practice.\r\n- [x] Write a pull request description that is detailed enough to understand what the pull request does, how, and why.\r\n- [x] Each commit in the pull request should have a meaningful subject line and body. Note that a maintainer may squash commits during the merge process.\r\n",
  "hints_text" : null,
  "created_at" : "Thu Dec 04 15:53:24 CET 2025",
  "version" : null,
  "FAIL_TO_PASS" : [ "XmlStringLookupTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=XmlStringLookupTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 731,
  "metadata" : null
}, {
  "instance_id" : "apache-commons-text-PR-729",
  "repo" : "apache/commons-text",
  "base_commit" : "685da724c45e74d30df08215bb96bbafdeac4ed6",
  "patch" : "diff --git a/src/main/java/org/apache/commons/text/lookup/StringLookupFactory.java b/src/main/java/org/apache/commons/text/lookup/StringLookupFactory.java\nindex 2f163b8e05..f172f58870 100644\n--- a/src/main/java/org/apache/commons/text/lookup/StringLookupFactory.java\n+++ b/src/main/java/org/apache/commons/text/lookup/StringLookupFactory.java\n@@ -30,6 +30,7 @@\n import java.util.function.Function;\n import java.util.function.Supplier;\n \n+import javax.xml.parsers.DocumentBuilderFactory;\n import javax.xml.xpath.XPathFactory;\n \n import org.apache.commons.text.StringSubstitutor;\n@@ -1617,10 +1618,19 @@ public StringLookup xmlEncoderStringLookup() {\n      * if a lookup causes causes a path to resolve outside of these fences. Otherwise, the result is unfenced to preserved behavior from previous versions.\n      * </p>\n      * <p>\n-     * We look up the value for the key in the format \"DocumentPath:XPath\".\n+     * We looks up values in an XML document in the format {@code \"[secure=(true|false):]DocumentPath:XPath\"}.\n      * </p>\n      * <p>\n-     * For example: \"com/domain/document.xml:/path/to/node\".\n+     * For example:\n+     * </p>\n+     * <ul>\n+     * <li>{@code \"com/domain/document.xml:/path/to/node\"}</li>\n+     * <li>{@code \"secure=false:com/domain/document.xml:/path/to/node\"}</li>\n+     * <li>{@code \"secure=true:com/domain/document.xml:/path/to/node\"}</li>\n+     * </ul>\n+     * <p>\n+     * Secure processing is enabled by default. The secure boolean String parsing follows the syntax defined by {@link Boolean#parseBoolean(String)}. The secure\n+     * value in the key overrides instance settings given in the constructor.\n      * </p>\n      * <p>\n      * Using a {@link StringLookup} from the {@link StringLookupFactory}:\n@@ -1644,7 +1654,7 @@ public StringLookup xmlEncoderStringLookup() {\n      * @since 1.5\n      */\n     public StringLookup xmlStringLookup() {\n-        return fences != null ? xmlStringLookup(XmlStringLookup.DEFAULT_FEATURES, fences) : XmlStringLookup.INSTANCE;\n+        return fences != null ? xmlStringLookup(XmlStringLookup.DEFAULT_XPATH_FEATURES, fences) : XmlStringLookup.INSTANCE;\n     }\n \n     /**\n@@ -1654,10 +1664,19 @@ public StringLookup xmlStringLookup() {\n      * if a lookup causes causes a path to resolve outside of these fences. Otherwise, the result is unfenced to preserved behavior from previous versions.\n      * </p>\n      * <p>\n-     * We look up the value for the key in the format {@code \"DocumentPath:XPath\"}.\n+     * We looks up values in an XML document in the format {@code \"[secure=(true|false):]DocumentPath:XPath\"}.\n      * </p>\n      * <p>\n-     * For example: {@code \"com/domain/document.xml:/path/to/node\"}.\n+     * For example:\n+     * </p>\n+     * <ul>\n+     * <li>{@code \"com/domain/document.xml:/path/to/node\"}</li>\n+     * <li>{@code \"secure=false:com/domain/document.xml:/path/to/node\"}</li>\n+     * <li>{@code \"secure=true:com/domain/document.xml:/path/to/node\"}</li>\n+     * </ul>\n+     * <p>\n+     * Secure processing is enabled by default. The secure boolean String parsing follows the syntax defined by {@link Boolean#parseBoolean(String)}. The secure\n+     * value in the key overrides instance settings given in the constructor.\n      * </p>\n      * <p>\n      * Using a {@link StringLookup} from the {@link StringLookupFactory}:\n@@ -1677,13 +1696,14 @@ public StringLookup xmlStringLookup() {\n      * The examples above convert {@code \"com/domain/document.xml:/path/to/node\"} to the value of the XPath in the XML document.\n      * </p>\n      *\n-     * @param xPathFactoryFeatures XPathFactory features to set.\n+     * @param factoryFeatures DocumentBuilderFactory and XPathFactory features to set.\n      * @return An XML StringLookup instance.\n+     * @see DocumentBuilderFactory#setFeature(String, boolean)\n      * @see XPathFactory#setFeature(String, boolean)\n      * @since 1.11.0\n      */\n-    public StringLookup xmlStringLookup(final Map<String, Boolean> xPathFactoryFeatures) {\n-        return xmlStringLookup(xPathFactoryFeatures, fences);\n+    public StringLookup xmlStringLookup(final Map<String, Boolean> factoryFeatures) {\n+        return xmlStringLookup(factoryFeatures, fences);\n     }\n \n     /**\n@@ -1693,10 +1713,19 @@ public StringLookup xmlStringLookup(final Map<String, Boolean> xPathFactoryFeatu\n      * if a lookup causes causes a path to resolve outside of these fences. Otherwise, the result is unfenced to preserved behavior from previous versions.\n      * </p>\n      * <p>\n-     * We look up the value for the key in the format {@code \"DocumentPath:XPath\"}.\n+     * We looks up values in an XML document in the format {@code \"[secure=(true|false):]DocumentPath:XPath\"}.\n      * </p>\n      * <p>\n-     * For example: {@code \"com/domain/document.xml:/path/to/node\"}.\n+     * For example:\n+     * </p>\n+     * <ul>\n+     * <li>{@code \"com/domain/document.xml:/path/to/node\"}</li>\n+     * <li>{@code \"secure=false:com/domain/document.xml:/path/to/node\"}</li>\n+     * <li>{@code \"secure=true:com/domain/document.xml:/path/to/node\"}</li>\n+     * </ul>\n+     * <p>\n+     * Secure processing is enabled by default. The secure boolean String parsing follows the syntax defined by {@link Boolean#parseBoolean(String)}. The secure\n+     * value in the key overrides instance settings given in the constructor.\n      * </p>\n      * <p>\n      * Using a {@link StringLookup} from the {@link StringLookupFactory} fenced by the current directory ({@code Paths.get(\"\")}):\n@@ -1711,10 +1740,8 @@ public StringLookup xmlStringLookup(final Map<String, Boolean> xPathFactoryFeatu\n      *\n      * <pre>\n      * StringLookupFactory.INSTANCE.xmlStringLookup(Paths.get(\"\")).lookup(\"com/domain/document.xml:/path/to/node\");\n-     *\n      * // throws IllegalArgumentException\n      * StringLookupFactory.INSTANCE.xmlStringLookup(Paths.get(\"\")).lookup(\"/rootdir/foo/document.xml:/path/to/node\");\n-     *\n      * // throws IllegalArgumentException\n      * StringLookupFactory.INSTANCE.xmlStringLookup(Paths.get(\"\")).lookup(\"../com/domain/document.xml:/path/to/node\");\n      * </pre>\n@@ -1726,12 +1753,14 @@ public StringLookup xmlStringLookup(final Map<String, Boolean> xPathFactoryFeatu\n      * resolves in a fence.\n      * </p>\n      *\n-     * @param xPathFactoryFeatures XPathFactory features to set.\n-     * @param fences               The fences guarding Path resolution.\n+     * @param factoryFeatures DocumentBuilderFactory and XPathFactory features to set.\n+     * @param fences          The fences guarding Path resolution.\n      * @return An XML StringLookup instance.\n+     * @see DocumentBuilderFactory#setFeature(String, boolean)\n+     * @see XPathFactory#setFeature(String, boolean)\n      * @since 1.12.0\n      */\n-    public StringLookup xmlStringLookup(final Map<String, Boolean> xPathFactoryFeatures, final Path... fences) {\n-        return new XmlStringLookup(xPathFactoryFeatures, fences);\n+    public StringLookup xmlStringLookup(final Map<String, Boolean> factoryFeatures, final Path... fences) {\n+        return new XmlStringLookup(factoryFeatures, factoryFeatures, fences);\n     }\n }\ndiff --git a/src/main/java/org/apache/commons/text/lookup/XmlStringLookup.java b/src/main/java/org/apache/commons/text/lookup/XmlStringLookup.java\nindex a476cc0786..aa873a0088 100644\n--- a/src/main/java/org/apache/commons/text/lookup/XmlStringLookup.java\n+++ b/src/main/java/org/apache/commons/text/lookup/XmlStringLookup.java\n@@ -26,38 +26,60 @@\n import java.util.Objects;\n \n import javax.xml.XMLConstants;\n+import javax.xml.parsers.DocumentBuilderFactory;\n import javax.xml.xpath.XPathFactory;\n \n import org.apache.commons.lang3.StringUtils;\n-import org.xml.sax.InputSource;\n+import org.w3c.dom.Document;\n \n /**\n- * Looks up keys from an XML document.\n+ * Looks up values in an XML document in the format {@code \"[secure=(true|false):]DocumentPath:XPath\"}.\n  * <p>\n- * Looks up the value for a given key in the format \"Document:XPath\".\n+ * For example:\n  * </p>\n+ * <ul>\n+ * <li>{@code \"com/domain/document.xml:/path/to/node\"}</li>\n+ * <li>{@code \"secure=false:com/domain/document.xml:/path/to/node\"}</li>\n+ * <li>{@code \"secure=true:com/domain/document.xml:/path/to/node\"}</li>\n+ * </ul>\n  * <p>\n- * For example: \"com/domain/document.xml:/path/to/node\".\n+ * Secure processing is enabled by default. The secure boolean String parsing follows the syntax defined by {@link Boolean#parseBoolean(String)}. The secure\n+ * value in the key overrides instance settings given in the constructor.\n  * </p>\n  *\n  * @since 1.5\n  */\n final class XmlStringLookup extends AbstractPathFencedLookup {\n \n+    /**\n+     * Minimum number of key parts.\n+     */\n+    private static final int KEY_PARTS_MIN = 2;\n+\n+    /**\n+     * Minimum number of key parts.\n+     */\n+    private static final int KEY_PARTS_MAX = 3;\n+\n     /**\n      * Defines default XPath factory features.\n      */\n-    static final Map<String, Boolean> DEFAULT_FEATURES;\n+    static final Map<String, Boolean> DEFAULT_XPATH_FEATURES;\n \n+    /**\n+     * Defines default XML factory features.\n+     */\n+    static final Map<String, Boolean> DEFAULT_XML_FEATURES;\n     static {\n-        DEFAULT_FEATURES = new HashMap<>(1);\n-        DEFAULT_FEATURES.put(XMLConstants.FEATURE_SECURE_PROCESSING, Boolean.TRUE);\n+        DEFAULT_XPATH_FEATURES = new HashMap<>(1);\n+        DEFAULT_XPATH_FEATURES.put(XMLConstants.FEATURE_SECURE_PROCESSING, Boolean.TRUE);\n+        DEFAULT_XML_FEATURES = new HashMap<>(1);\n+        DEFAULT_XML_FEATURES.put(XMLConstants.FEATURE_SECURE_PROCESSING, Boolean.TRUE);\n     }\n-\n     /**\n-     * Defines the singleton for this class.\n+     * Defines the singleton for this class with secure processing enabled.\n      */\n-    static final XmlStringLookup INSTANCE = new XmlStringLookup(DEFAULT_FEATURES, (Path[]) null);\n+    static final XmlStringLookup INSTANCE = new XmlStringLookup(DEFAULT_XML_FEATURES, DEFAULT_XPATH_FEATURES, (Path[]) null);\n \n     /**\n      * Defines XPath factory features.\n@@ -65,23 +87,40 @@ final class XmlStringLookup extends AbstractPathFencedLookup {\n     private final Map<String, Boolean> xPathFactoryFeatures;\n \n     /**\n-     * No need to build instances for now.\n+     * Defines XML factory features.\n+     */\n+    private final Map<String, Boolean> xmlFactoryFeatures;\n+\n+    /**\n+     * Constructs a new instance.\n      *\n-     * @param xPathFactoryFeatures XPathFactory features to set.\n+     * @param xmlFactoryFeatures   The {@link DocumentBuilderFactory} features to set.\n+     * @param xPathFactoryFeatures The {@link XPathFactory} features to set.\n+     * @see DocumentBuilderFactory#setFeature(String, boolean)\n      * @see XPathFactory#setFeature(String, boolean)\n      */\n-    XmlStringLookup(final Map<String, Boolean> xPathFactoryFeatures, final Path... fences) {\n+    XmlStringLookup(final Map<String, Boolean> xmlFactoryFeatures, final Map<String, Boolean> xPathFactoryFeatures, final Path... fences) {\n         super(fences);\n+        this.xmlFactoryFeatures = Objects.requireNonNull(xmlFactoryFeatures, \"xmlFactoryFeatures\");\n         this.xPathFactoryFeatures = Objects.requireNonNull(xPathFactoryFeatures, \"xPathFfactoryFeatures\");\n     }\n \n     /**\n-     * Looks up the value for the key in the format \"DocumentPath:XPath\".\n+     * Looks up a value for the key in the format {@code \"[secure=(true|false):]DocumentPath:XPath\"}.\n+     * <p>\n+     * For example:\n+     * </p>\n+     * <ul>\n+     * <li>{@code \"com/domain/document.xml:/path/to/node\"}</li>\n+     * <li>{@code \"secure=false:com/domain/document.xml:/path/to/node\"}</li>\n+     * <li>{@code \"secure=true:com/domain/document.xml:/path/to/node\"}</li>\n+     * </ul>\n      * <p>\n-     * For example: \"com/domain/document.xml:/path/to/node\".\n+     * Secure processing is enabled by default. The secure boolean String parsing follows the syntax defined by {@link Boolean#parseBoolean(String)}. The secure\n+     * value in the key overrides instance settings given in the constructor.\n      * </p>\n      *\n-     * @param key the key to be looked up, may be null\n+     * @param key the key to be looked up, may be null.\n      * @return The value associated with the key.\n      */\n     @Override\n@@ -91,22 +130,42 @@ public String lookup(final String key) {\n         }\n         final String[] keys = key.split(SPLIT_STR);\n         final int keyLen = keys.length;\n-        if (keyLen != 2) {\n-            throw IllegalArgumentExceptions.format(\"Bad XML key format [%s]; expected format is DocumentPath:XPath.\",\n-                    key);\n+        if (keyLen != KEY_PARTS_MIN && keyLen != KEY_PARTS_MAX) {\n+            throw IllegalArgumentExceptions.format(\"Bad XML key format '%s'; the expected format is [secure=(true|false):]DocumentPath:XPath.\", key);\n         }\n-        final String documentPath = keys[0];\n-        final String xpath = StringUtils.substringAfter(key, SPLIT_CH);\n-        try (InputStream inputStream = Files.newInputStream(getPath(documentPath))) {\n-            final XPathFactory factory = XPathFactory.newInstance();\n-            for (final Entry<String, Boolean> p : xPathFactoryFeatures.entrySet()) {\n-                factory.setFeature(p.getKey(), p.getValue());\n+        final boolean isKeySecure = keyLen == KEY_PARTS_MAX;\n+        final Boolean secure = isKeySecure ? parseSecureKey(keys, key) : null;\n+        final String documentPath = isKeySecure ? keys[1] : keys[0];\n+        final String xpath = StringUtils.substringAfterLast(key, SPLIT_CH);\n+        final DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();\n+        try {\n+            for (final Entry<String, Boolean> p : xmlFactoryFeatures.entrySet()) {\n+                dbFactory.setFeature(p.getKey(), p.getValue());\n+            }\n+            if (secure != null) {\n+                dbFactory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, secure.booleanValue());\n+            }\n+            try (InputStream inputStream = Files.newInputStream(getPath(documentPath))) {\n+                final Document doc = dbFactory.newDocumentBuilder().parse(inputStream);\n+                final XPathFactory factory = XPathFactory.newInstance();\n+                for (final Entry<String, Boolean> p : xPathFactoryFeatures.entrySet()) {\n+                    factory.setFeature(p.getKey(), p.getValue());\n+                }\n+                if (secure != null) {\n+                    factory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, secure.booleanValue());\n+                }\n+                return factory.newXPath().evaluate(xpath, doc);\n             }\n-            return factory.newXPath().evaluate(xpath, new InputSource(inputStream));\n         } catch (final Exception e) {\n-            throw IllegalArgumentExceptions.format(e, \"Error looking up XML document [%s] and XPath [%s].\",\n-                    documentPath, xpath);\n+            throw new IllegalArgumentException(e);\n         }\n     }\n \n+    private Boolean parseSecureKey(final String[] args, final String key) {\n+        final String[] secParts = args[0].split(\"=\");\n+        if (secParts.length != 2 && !Objects.equals(secParts[0], \"secure\")) {\n+            throw IllegalArgumentExceptions.format(\"Bad XML key format '%s'; the expected format is [secure=(true|false):]DocumentPath:XPath.\", key);\n+        }\n+        return Boolean.valueOf(secParts[1]);\n+    }\n }\ndiff --git a/src/test/resources/org/apache/commons/text/document-entity-ref.xml b/src/test/resources/org/apache/commons/text/document-entity-ref.xml\nnew file mode 100644\nindex 0000000000..bfd3609802\n--- /dev/null\n+++ b/src/test/resources/org/apache/commons/text/document-entity-ref.xml\n@@ -0,0 +1,26 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<!--\n+     Licensed to the Apache Software Foundation (ASF) under one or more\n+     contributor license agreements.  See the NOTICE file distributed with\n+     this work for additional information regarding copyright ownership.\n+     The ASF licenses this file to You under the Apache License, Version 2.0\n+     (the \"License\"); you may not use this file except in compliance with\n+     the License.  You may obtain a copy of the License at\n+\n+          https://www.apache.org/licenses/LICENSE-2.0\n+\n+     Unless required by applicable law or agreed to in writing, software\n+     distributed under the License is distributed on an \"AS IS\" BASIS,\n+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+     See the License for the specific language governing permissions and\n+     limitations under the License.\n+  -->\n+<!DOCTYPE document [\n+  <!ENTITY ext SYSTEM \"src/test/resources/org/apache/commons/text/xml-entity.txt\">\n+]>\n+<document>\n+  <title>Example of an External Entity</title>\n+  <content>\n+    &ext; \n+  </content>\n+</document>\ndiff --git a/src/test/resources/org/apache/commons/text/xml-entity.txt b/src/test/resources/org/apache/commons/text/xml-entity.txt\nnew file mode 100644\nindex 0000000000..4f2fa75854\n--- /dev/null\n+++ b/src/test/resources/org/apache/commons/text/xml-entity.txt\n@@ -0,0 +1,17 @@\n+<!--\n+     Licensed to the Apache Software Foundation (ASF) under one or more\n+     contributor license agreements.  See the NOTICE file distributed with\n+     this work for additional information regarding copyright ownership.\n+     The ASF licenses this file to You under the Apache License, Version 2.0\n+     (the \"License\"); you may not use this file except in compliance with\n+     the License.  You may obtain a copy of the License at\n+\n+          https://www.apache.org/licenses/LICENSE-2.0\n+\n+     Unless required by applicable law or agreed to in writing, software\n+     distributed under the License is distributed on an \"AS IS\" BASIS,\n+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+     See the License for the specific language governing permissions and\n+     limitations under the License.\n+  -->\n+Hello World!\n",
  "test_patch" : "diff --git a/src/test/java/org/apache/commons/text/lookup/StringLookupFactoryTest.java b/src/test/java/org/apache/commons/text/lookup/StringLookupFactoryTest.java\nindex 33897a7493..5ffe49f358 100644\n--- a/src/test/java/org/apache/commons/text/lookup/StringLookupFactoryTest.java\n+++ b/src/test/java/org/apache/commons/text/lookup/StringLookupFactoryTest.java\n@@ -282,4 +282,17 @@ void testXmlStringLookup() {\n         XmlStringLookupTest.assertLookup(stringLookupFactory.xmlStringLookup(features));\n         XmlStringLookupTest.assertLookup(stringLookupFactory.xmlStringLookup(new HashMap<>()));\n     }\n+\n+    @Test\n+    void testXmlStringLookupExternalEntityOff() {\n+        assertThrows(IllegalArgumentException.class,\n+                () -> StringLookupFactory.INSTANCE.xmlStringLookup().apply(XmlStringLookupTest.DOC_DIR + \"document-entity-ref.xml:/document/content\"));\n+    }\n+\n+    @Test\n+    void testXmlStringLookupExternalEntityOn() {\n+        final String key = XmlStringLookupTest.DOC_DIR + \"document-entity-ref.xml:/document/content\";\n+        assertEquals(XmlStringLookupTest.DATA, StringLookupFactory.INSTANCE.xmlStringLookup(XmlStringLookupTest.EMPTY_MAP).apply(key).trim());\n+    }\n+\n }\ndiff --git a/src/test/java/org/apache/commons/text/lookup/XmlStringLookupTest.java b/src/test/java/org/apache/commons/text/lookup/XmlStringLookupTest.java\nindex 40290f0b75..d24c40907e 100644\n--- a/src/test/java/org/apache/commons/text/lookup/XmlStringLookupTest.java\n+++ b/src/test/java/org/apache/commons/text/lookup/XmlStringLookupTest.java\n@@ -26,11 +26,14 @@\n \n import java.nio.file.Path;\n import java.nio.file.Paths;\n+import java.util.Collections;\n import java.util.HashMap;\n+import java.util.Map;\n \n import javax.xml.XMLConstants;\n \n import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.text.StringSubstitutor;\n import org.junit.jupiter.api.Test;\n \n /**\n@@ -38,15 +41,18 @@\n  */\n class XmlStringLookupTest {\n \n+    static final String DATA = \"Hello World!\";\n+    static final Map<String, Boolean> EMPTY_MAP = Collections.emptyMap();\n     private static final Path CURRENT_PATH = Paths.get(StringUtils.EMPTY); // NOT \".\"\n     private static final Path ABSENT_PATH = Paths.get(\"does not exist at all\");\n-    private static final String DOC_RELATIVE = \"src/test/resources/org/apache/commons/text/document.xml\";\n+    static final String DOC_DIR = \"src/test/resources/org/apache/commons/text/\";\n+    private static final String DOC_RELATIVE = DOC_DIR + \"document.xml\";\n     private static final String DOC_ROOT = \"/document.xml\";\n \n     static void assertLookup(final StringLookup xmlStringLookup) {\n         assertNotNull(xmlStringLookup);\n         assertInstanceOf(XmlStringLookup.class, xmlStringLookup);\n-        assertEquals(\"Hello World!\", xmlStringLookup.apply(DOC_RELATIVE + \":/root/path/to/node\"));\n+        assertEquals(DATA, xmlStringLookup.apply(DOC_RELATIVE + \":/root/path/to/node\"));\n         assertNull(xmlStringLookup.apply(null));\n     }\n \n@@ -55,6 +61,44 @@ void testBadXPath() {\n         assertThrows(IllegalArgumentException.class, () -> XmlStringLookup.INSTANCE.apply(\"docName\"));\n     }\n \n+    @Test\n+    void testExternalEntityOff() {\n+        assertThrows(IllegalArgumentException.class,\n+                () -> new XmlStringLookup(XmlStringLookup.DEFAULT_XML_FEATURES, EMPTY_MAP).apply(DOC_DIR + \"document-entity-ref.xml:/document/content\"));\n+    }\n+\n+    @Test\n+    void testExternalEntityOn() {\n+        final String key = DOC_DIR + \"document-entity-ref.xml:/document/content\";\n+        assertEquals(DATA, new XmlStringLookup(EMPTY_MAP, EMPTY_MAP).apply(key).trim());\n+        assertEquals(DATA, new XmlStringLookup(EMPTY_MAP, XmlStringLookup.DEFAULT_XPATH_FEATURES).apply(key).trim());\n+    }\n+\n+    @Test\n+    void testInterpolatorExternalEntityOff() {\n+        final StringSubstitutor stringSubstitutor = StringSubstitutor.createInterpolator();\n+        assertThrows(IllegalArgumentException.class, () -> stringSubstitutor.replace(\"${xml:\" + DOC_DIR + \"document-entity-ref.xml:/document/content}\"));\n+    }\n+\n+    @Test\n+    void testInterpolatorExternalEntityOffOverride() {\n+        final StringSubstitutor stringSubstitutor = StringSubstitutor.createInterpolator();\n+        assertEquals(DATA, stringSubstitutor.replace(\"${xml:secure=false:\" + DOC_DIR + \"document-entity-ref.xml:/document/content}\").trim());\n+    }\n+\n+    @Test\n+    void testInterpolatorExternalEntityOn() {\n+        final StringSubstitutor stringSubstitutor = StringSubstitutor.createInterpolator();\n+        assertThrows(IllegalArgumentException.class, () -> stringSubstitutor.replace(\"${xml:\" + DOC_DIR + \"document-entity-ref.xml:/document/content}\"));\n+    }\n+\n+    @Test\n+    void testInterpolatorExternalEntityOnOverride() {\n+        final StringSubstitutor stringSubstitutor = StringSubstitutor.createInterpolator();\n+        assertThrows(IllegalArgumentException.class,\n+                () -> stringSubstitutor.replace(\"${xml:secure=true:\" + DOC_DIR + \"document-entity-ref.xml:/document/content}\"));\n+    }\n+\n     @Test\n     void testMissingXPath() {\n         assertThrows(IllegalArgumentException.class, () -> XmlStringLookup.INSTANCE.apply(DOC_RELATIVE + \":!JUNK!\"));\n@@ -63,20 +107,20 @@ void testMissingXPath() {\n     @Test\n     void testNoFeatures() {\n         final String xpath = \"/root/path/to/node\";\n-        assertEquals(\"Hello World!\", new XmlStringLookup(new HashMap<>()).apply(DOC_RELATIVE + \":\" + xpath));\n-        assertEquals(\"Hello World!\", new XmlStringLookup(new HashMap<>(), CURRENT_PATH).apply(DOC_RELATIVE + \":\" + xpath));\n-        assertEquals(\"Hello World!\", new XmlStringLookup(new HashMap<>(), CURRENT_PATH, ABSENT_PATH).apply(DOC_RELATIVE + \":\" + xpath));\n-        assertEquals(\"Hello World!\", new XmlStringLookup(new HashMap<>(), ABSENT_PATH, CURRENT_PATH).apply(DOC_RELATIVE + \":\" + xpath));\n-        assertThrows(IllegalArgumentException.class, () -> new XmlStringLookup(new HashMap<>(), ABSENT_PATH).apply(DOC_ROOT + \":\" + xpath));\n-        assertThrows(IllegalArgumentException.class, () -> new XmlStringLookup(new HashMap<>(), CURRENT_PATH).apply(DOC_ROOT + \":\" + xpath));\n-        assertThrows(IllegalArgumentException.class, () -> new XmlStringLookup(new HashMap<>(), ABSENT_PATH, CURRENT_PATH).apply(DOC_ROOT + \":\" + xpath));\n+        assertEquals(DATA, new XmlStringLookup(EMPTY_MAP, EMPTY_MAP).apply(DOC_RELATIVE + \":\" + xpath));\n+        assertEquals(DATA, new XmlStringLookup(EMPTY_MAP, EMPTY_MAP).apply(DOC_RELATIVE + \":\" + xpath));\n+        assertEquals(DATA, new XmlStringLookup(EMPTY_MAP, EMPTY_MAP, CURRENT_PATH, ABSENT_PATH).apply(DOC_RELATIVE + \":\" + xpath));\n+        assertEquals(DATA, new XmlStringLookup(EMPTY_MAP, EMPTY_MAP, ABSENT_PATH, CURRENT_PATH).apply(DOC_RELATIVE + \":\" + xpath));\n+        assertThrows(IllegalArgumentException.class, () -> new XmlStringLookup(EMPTY_MAP, EMPTY_MAP, ABSENT_PATH).apply(DOC_ROOT + \":\" + xpath));\n+        assertThrows(IllegalArgumentException.class, () -> new XmlStringLookup(EMPTY_MAP, EMPTY_MAP, CURRENT_PATH).apply(DOC_ROOT + \":\" + xpath));\n+        assertThrows(IllegalArgumentException.class, () -> new XmlStringLookup(EMPTY_MAP, EMPTY_MAP, ABSENT_PATH, CURRENT_PATH).apply(DOC_ROOT + \":\" + xpath));\n     }\n \n     @Test\n     void testNoFeaturesDefault() {\n         final HashMap<String, Boolean> features = new HashMap<>(1);\n         features.put(XMLConstants.FEATURE_SECURE_PROCESSING, Boolean.TRUE);\n-        assertLookup(new XmlStringLookup(features));\n+        assertLookup(new XmlStringLookup(EMPTY_MAP, features));\n     }\n \n     @Test\n@@ -94,5 +138,4 @@ void testToString() {\n         // does not blow up and gives some kind of string.\n         assertFalse(XmlStringLookup.INSTANCE.toString().isEmpty());\n     }\n-\n }\n",
  "problem_statement" : "Enable secure processing for the XML parser in XmlStringLookup\n\nSecure processing for XPath evaluation is already enabled but doesn't affect XML parsing.\r\n\r\n- [x] Read the [contribution guidelines](CONTRIBUTING.md) for this project.\r\n- [x] Read the [ASF Generative Tooling Guidance](https://www.apache.org/legal/generative-tooling.html) if you use Artificial Intelligence (AI).\r\n- [ ] I used AI to create any part of, or all of, this pull request.\r\n- [x] Run a successful build using the default [Maven](https://maven.apache.org/) goal with `mvn`; that's `mvn` on the command line by itself.\r\n- [x] Write unit tests that match behavioral changes, where the tests fail if the changes to the runtime are not applied. This may not always be possible, but it is a best practice.\r\n- [x] Write a pull request description that is detailed enough to understand what the pull request does, how, and why.\r\n- [x] Each commit in the pull request should have a meaningful subject line and body. Note that a maintainer may squash commits during the merge process.\r\n",
  "hints_text" : null,
  "created_at" : "Mon Dec 01 00:08:27 CET 2025",
  "version" : null,
  "FAIL_TO_PASS" : [ "StringLookupFactoryTest", "XmlStringLookupTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=StringLookupFactoryTest,XmlStringLookupTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 729,
  "metadata" : null
}, {
  "instance_id" : "apache-commons-text-PR-725",
  "repo" : "apache/commons-text",
  "base_commit" : "66bafadc42c722ce8e8f99f318408ba5baca13b8",
  "patch" : "diff --git a/src/changes/changes.xml b/src/changes/changes.xml\nindex ef5abe56ee..e9c6b331a8 100644\n--- a/src/changes/changes.xml\n+++ b/src/changes/changes.xml\n@@ -49,7 +49,7 @@ The <action> type attribute can be add,update,fix,remove.\n     <!-- FIX -->\n     <action type=\"fix\" dev=\"ggregory\" due-to=\"Gary Gregory\">Fix exception message typo in XmlStringLookup.XmlStringLookup(Map, Path...).</action>\n     <action type=\"fix\" dev=\"ggregory\" due-to=\"Pierre Post, Sumit Bera, Alex Herbert, Gary Gregory\" issue=\"TEXT-236\">Inserting at the end of a TextStringBuilder throws a StringIndexOutOfBoundsException.</action>\n-    <action type=\"fix\" dev=\"ggregory\" due-to=\"GMichael Hausegger\">Fix TextStringBuilderTest.testAppendToCharBuffer() to use proper argument type #724.</action>\n+    <action type=\"fix\" dev=\"ggregory\" due-to=\"Michael Hausegger\">Fix TextStringBuilderTest.testAppendToCharBuffer() to use proper argument type #724.</action>\n     <!-- ADD -->\n     <action type=\"add\" dev=\"ggregory\" due-to=\"Piotr P. Karwasz, Gary Gregory\">Add experimental CycloneDX VEX file #683.</action>\n     <action type=\"add\" dev=\"ggregory\" due-to=\"LorgeN, Gary Gregory\" issue=\"TEXT-235\">Add Damerau-Levenshtein distance #687.</action>\n",
  "test_patch" : "diff --git a/src/test/java/org/apache/commons/text/translate/CharSequenceTranslatorTest.java b/src/test/java/org/apache/commons/text/translate/CharSequenceTranslatorTest.java\nnew file mode 100644\nindex 0000000000..8bc38cae71\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/text/translate/CharSequenceTranslatorTest.java\n@@ -0,0 +1,53 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+ package org.apache.commons.text.translate;\n+\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+import java.io.IOException;\n+import java.io.Writer;\n+\n+import org.junit.jupiter.api.Test;\n+\n+\n+class CharSequenceTranslatorTest {\n+\n+    //Used to count translate invocations\n+    private int translateInvocationCounter;\n+\n+    @Test\n+    void testWith() throws IOException {\n+        CharSequenceTranslator charSequenceTranslatorOne = new TestCharSequenceTranslator();\n+        CharSequenceTranslator charSequenceTranslatorTwo = new TestCharSequenceTranslator();\n+        CharSequenceTranslator charSequenceTranslatorThree = new TestCharSequenceTranslator();\n+        CharSequenceTranslator aggregatedTranslator = charSequenceTranslatorOne.with(charSequenceTranslatorTwo, charSequenceTranslatorThree);\n+        aggregatedTranslator.translate(\"\", 0, null);\n+        assertTrue(aggregatedTranslator instanceof AggregateTranslator);\n+        assertEquals(3, translateInvocationCounter);\n+    }\n+\n+    private final class TestCharSequenceTranslator extends CharSequenceTranslator {\n+        @Override\n+        public int translate(final CharSequence input, final int index, final Writer writer) {\n+            translateInvocationCounter++;\n+            return 0;\n+        }\n+\n+    }\n+\n+}\n",
  "problem_statement" : "Added new test for CharSequenceTranslator#with.\n\nAdded new test for CharSequenceTranslator#with.",
  "hints_text" : null,
  "created_at" : "Fri Nov 21 22:54:53 CET 2025",
  "version" : null,
  "FAIL_TO_PASS" : [ "CharSequenceTranslatorTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=CharSequenceTranslatorTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 725,
  "metadata" : null
}, {
  "instance_id" : "apache-commons-text-PR-687",
  "repo" : "apache/commons-text",
  "base_commit" : "5d356fd01d231dd27dd7c38cb98761343d364075",
  "patch" : "diff --git a/src/main/java/org/apache/commons/text/similarity/DamerauLevenshteinDistance.java b/src/main/java/org/apache/commons/text/similarity/DamerauLevenshteinDistance.java\nnew file mode 100644\nindex 0000000000..d7685ebc29\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/text/similarity/DamerauLevenshteinDistance.java\n@@ -0,0 +1,326 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.text.similarity;\n+\n+/**\n+ * An algorithm for measuring the difference between two character sequences using the\n+ * <a href=\"https://en.wikipedia.org/wiki/Damerau%E2%80%93Levenshtein_distance\">Damerau-Levenshtein Distance</a>.\n+ *\n+ * <p>\n+ * This is the number of changes needed to change one sequence into another, where each change is a single character\n+ * modification (deletion, insertion, substitution, or transposition of two adjacent characters).\n+ * </p>\n+ *\n+ * @see <a href=\"https://en.wikipedia.org/wiki/Damerau%E2%80%93Levenshtein_distance\">Damerau-Levenshtein Distance on Wikipedia</a>\n+ * @since 1.15.0\n+ */\n+public class DamerauLevenshteinDistance implements EditDistance<Integer> {\n+\n+    /**\n+     * Utility function to ensure distance is valid according to threshold.\n+     *\n+     * @param distance  The distance value\n+     * @param threshold The threshold value\n+     * @return The distance value, or {@code -1} if distance is greater than threshold\n+     */\n+    private static int clampDistance(final int distance, final int threshold) {\n+        return distance > threshold ? -1 : distance;\n+    }\n+\n+    /**\n+     * Finds the Damerau-Levenshtein distance between two CharSequences if it's less than or equal to a given threshold.\n+     *\n+     * @param left      the first SimilarityInput, must not be null.\n+     * @param right     the second SimilarityInput, must not be null.\n+     * @param threshold the target threshold, must not be negative.\n+     * @return result distance, or -1 if distance exceeds threshold\n+     */\n+    private static <E> int limitedCompare(SimilarityInput<E> left, SimilarityInput<E> right, final int threshold) {\n+        if (left == null || right == null) {\n+            throw new IllegalArgumentException(\"Left/right inputs must not be null\");\n+        }\n+\n+        if (threshold < 0) {\n+            throw new IllegalArgumentException(\"Threshold can not be negative\");\n+        }\n+\n+        // Implementation based on https://en.wikipedia.org/wiki/Damerau%E2%80%93Levenshtein_distance#Optimal_string_alignment_distance\n+\n+        int leftLength = left.length();\n+        int rightLength = right.length();\n+\n+        if (leftLength == 0) {\n+            return clampDistance(rightLength, threshold);\n+        }\n+\n+        if (rightLength == 0) {\n+            return clampDistance(leftLength, threshold);\n+        }\n+\n+        // Inspired by LevenshteinDistance impl; swap the input strings to consume less memory\n+        if (rightLength > leftLength) {\n+            final SimilarityInput<E> tmp = left;\n+            left = right;\n+            right = tmp;\n+            leftLength = rightLength;\n+            rightLength = right.length();\n+        }\n+\n+        // If the difference between the lengths of the strings is greater than the threshold, we must at least do\n+        // threshold operations so we can return early\n+        if (leftLength - rightLength > threshold) {\n+            return -1;\n+        }\n+\n+        // Use three arrays of minimum possible size to reduce memory usage. This avoids having to create a 2D\n+        // array of size leftLength * rightLength\n+        int[] curr = new int[rightLength + 1];\n+        int[] prev = new int[rightLength + 1];\n+        int[] prevPrev = new int[rightLength + 1];\n+        int[] temp; // Temp variable use to shuffle arrays at the end of each iteration\n+\n+        int rightIndex, leftIndex, cost, minCost;\n+\n+        // Changing empty sequence to [0..i] requires i insertions\n+        for (rightIndex = 0; rightIndex <= rightLength; rightIndex++) {\n+            prev[rightIndex] = rightIndex;\n+        }\n+\n+        // Calculate how many operations it takes to change right[0..rightIndex] into left[0..leftIndex]\n+        // For each iteration\n+        //  - curr[i] contains the cost of changing right[0..i] into left[0..leftIndex]\n+        //          (computed in current iteration)\n+        //  - prev[i] contains the cost of changing right[0..i] into left[0..leftIndex - 1]\n+        //          (computed in previous iteration)\n+        //  - prevPrev[i] contains the cost of changing right[0..i] into left[0..leftIndex - 2]\n+        //          (computed in iteration before previous)\n+        for (leftIndex = 1; leftIndex <= leftLength; leftIndex++) {\n+            // For right[0..0] we must insert leftIndex characters, which means the cost is always leftIndex\n+            curr[0] = leftIndex;\n+\n+            minCost = Integer.MAX_VALUE;\n+\n+            for (rightIndex = 1; rightIndex <= rightLength; rightIndex++) {\n+                cost = (left.at(leftIndex - 1) == right.at(rightIndex - 1)) ? 0 : 1;\n+\n+                // Select cheapest operation\n+                curr[rightIndex] = Math.min(\n+                        Math.min(\n+                                prev[rightIndex] + 1, // Delete current character\n+                                curr[rightIndex - 1] + 1 // Insert current character\n+                        ),\n+                        prev[rightIndex - 1] + cost // Replace (or no cost if same character)\n+                );\n+\n+                // Check if adjacent characters are the same -> transpose if cheaper\n+                if (leftIndex > 1\n+                        && rightIndex > 1\n+                        && left.at(leftIndex - 1) == right.at(rightIndex - 2)\n+                        && left.at(leftIndex - 2) == right.at(rightIndex - 1)) {\n+                    // Use cost here, to properly handle two subsequent equal letters\n+                    curr[rightIndex] = Math.min(curr[rightIndex], prevPrev[rightIndex - 2] + cost);\n+                }\n+\n+                minCost = Math.min(curr[rightIndex], minCost);\n+            }\n+\n+            // If there was no total cost for this entire iteration to transform right to left[0..leftIndex], there\n+            // can not be a way to do it below threshold. This is because we have no way to reduce the overall cost\n+            // in later operations.\n+            if (minCost > threshold) {\n+                return -1;\n+            }\n+\n+            // Rotate arrays for next iteration\n+            temp = prevPrev;\n+            prevPrev = prev;\n+            prev = curr;\n+            curr = temp;\n+        }\n+\n+        // Prev contains the value computed in the latest iteration\n+        return clampDistance(prev[rightLength], threshold);\n+    }\n+\n+    /**\n+     * Finds the Damerau-Levenshtein distance between two inputs using optimal string alignment.\n+     *\n+     * @param left  the first CharSequence, must not be null.\n+     * @param right the second CharSequence, must not be null.\n+     * @return result distance.\n+     * @throws IllegalArgumentException if either CharSequence input is {@code null}.\n+     */\n+    private static <E> int unlimitedCompare(SimilarityInput<E> left, SimilarityInput<E> right) {\n+        if (left == null || right == null) {\n+            throw new IllegalArgumentException(\"Left/right inputs must not be null\");\n+        }\n+\n+        /*\n+         * Implementation based on https://en.wikipedia.org/wiki/Damerau%E2%80%93Levenshtein_distance#Optimal_string_alignment_distance\n+         */\n+\n+        int leftLength = left.length();\n+        int rightLength = right.length();\n+\n+        if (leftLength == 0) {\n+            return rightLength;\n+        }\n+\n+        if (rightLength == 0) {\n+            return leftLength;\n+        }\n+\n+        // Inspired by LevenshteinDistance impl; swap the input strings to consume less memory\n+        if (rightLength > leftLength) {\n+            final SimilarityInput<E> tmp = left;\n+            left = right;\n+            right = tmp;\n+            leftLength = rightLength;\n+            rightLength = right.length();\n+        }\n+\n+        // Use three arrays of minimum possible size to reduce memory usage. This avoids having to create a 2D\n+        // array of size leftLength * rightLength\n+        int[] curr = new int[rightLength + 1];\n+        int[] prev = new int[rightLength + 1];\n+        int[] prevPrev = new int[rightLength + 1];\n+        int[] temp; // Temp variable use to shuffle arrays at the end of each iteration\n+\n+        int rightIndex, leftIndex, cost;\n+\n+        // Changing empty sequence to [0..i] requires i insertions\n+        for (rightIndex = 0; rightIndex <= rightLength; rightIndex++) {\n+            prev[rightIndex] = rightIndex;\n+        }\n+\n+        // Calculate how many operations it takes to change right[0..rightIndex] into left[0..leftIndex]\n+        // For each iteration\n+        //  - curr[i] contains the cost of changing right[0..i] into left[0..leftIndex]\n+        //          (computed in current iteration)\n+        //  - prev[i] contains the cost of changing right[0..i] into left[0..leftIndex - 1]\n+        //          (computed in previous iteration)\n+        //  - prevPrev[i] contains the cost of changing right[0..i] into left[0..leftIndex - 2]\n+        //          (computed in iteration before previous)\n+        for (leftIndex = 1; leftIndex <= leftLength; leftIndex++) {\n+            // For right[0..0] we must insert leftIndex characters, which means the cost is always leftIndex\n+            curr[0] = leftIndex;\n+\n+            for (rightIndex = 1; rightIndex <= rightLength; rightIndex++) {\n+                cost = (left.at(leftIndex - 1) == right.at(rightIndex - 1)) ? 0 : 1;\n+\n+                // Select cheapest operation\n+                curr[rightIndex] = Math.min(\n+                        Math.min(\n+                                prev[rightIndex] + 1, // Delete current character\n+                                curr[rightIndex - 1] + 1 // Insert current character\n+                        ),\n+                        prev[rightIndex - 1] + cost // Replace (or no cost if same character)\n+                );\n+\n+                // Check if adjacent characters are the same -> transpose if cheaper\n+                if (leftIndex > 1\n+                        && rightIndex > 1\n+                        && left.at(leftIndex - 1) == right.at(rightIndex - 2)\n+                        && left.at(leftIndex - 2) == right.at(rightIndex - 1)) {\n+                    // Use cost here, to properly handle two subsequent equal letters\n+                    curr[rightIndex] = Math.min(curr[rightIndex], prevPrev[rightIndex - 2] + cost);\n+                }\n+            }\n+\n+            // Rotate arrays for next iteration\n+            temp = prevPrev;\n+            prevPrev = prev;\n+            prev = curr;\n+            curr = temp;\n+        }\n+\n+        // Prev contains the value computed in the latest iteration\n+        return prev[rightLength];\n+    }\n+\n+    /**\n+     * Threshold.\n+     */\n+    private final Integer threshold;\n+\n+    /**\n+     * Constructs a default instance that uses a version of the algorithm that does not use a threshold parameter.\n+     */\n+    public DamerauLevenshteinDistance() {\n+        this(null);\n+    }\n+\n+    /**\n+     * Constructs a new instance. If the threshold is not null, distance calculations will be limited to a maximum length.\n+     * If the threshold is null, the unlimited version of the algorithm will be used.\n+     *\n+     * @param threshold If this is null then distances calculations will not be limited. This may not be negative.\n+     */\n+    public DamerauLevenshteinDistance(final Integer threshold) {\n+        if (threshold != null && threshold < 0) {\n+            throw new IllegalArgumentException(\"Threshold must not be negative\");\n+        }\n+        this.threshold = threshold;\n+    }\n+\n+    /**\n+     * Computes the Damerau-Levenshtein distance between two Strings.\n+     *\n+     * <p>\n+     * A higher score indicates a greater distance.\n+     * </p>\n+     *\n+     * @param left  the first input, must not be null.\n+     * @param right the second input, must not be null.\n+     * @return result distance, or -1 if threshold is exceeded.\n+     * @throws IllegalArgumentException if either String input {@code null}.\n+     */\n+    @Override\n+    public Integer apply(final CharSequence left, final CharSequence right) {\n+        return apply(SimilarityInput.input(left), SimilarityInput.input(right));\n+    }\n+\n+    /**\n+     * Computes the Damerau-Levenshtein distance between two inputs.\n+     *\n+     * <p>\n+     * A higher score indicates a greater distance.\n+     * </p>\n+     *\n+     * @param <E>   The type of similarity score unit.\n+     * @param left  the first input, must not be null.\n+     * @param right the second input, must not be null.\n+     * @return result distance, or -1 if threshold is exceeded.\n+     * @throws IllegalArgumentException if either String input {@code null}.\n+     * @since 1.13.0\n+     */\n+    public <E> Integer apply(final SimilarityInput<E> left, final SimilarityInput<E> right) {\n+        if (threshold != null) {\n+            return limitedCompare(left, right, threshold);\n+        }\n+        return unlimitedCompare(left, right);\n+    }\n+\n+    /**\n+     * Gets the distance threshold.\n+     *\n+     * @return The distance threshold.\n+     */\n+    public Integer getThreshold() {\n+        return threshold;\n+    }\n+}\n",
  "test_patch" : "diff --git a/src/test/java/org/apache/commons/text/similarity/DamerauLevenshteinDistanceTest.java b/src/test/java/org/apache/commons/text/similarity/DamerauLevenshteinDistanceTest.java\nnew file mode 100644\nindex 0000000000..d1c1dcadc6\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/text/similarity/DamerauLevenshteinDistanceTest.java\n@@ -0,0 +1,220 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.text.similarity;\n+\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+import java.util.Arrays;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+public class DamerauLevenshteinDistanceTest {\n+\n+    private static DamerauLevenshteinDistance defaultInstance;\n+\n+    @BeforeAll\n+    static void createInstance() {\n+        defaultInstance = new DamerauLevenshteinDistance();\n+    }\n+\n+    @Test\n+    void testGetThresholdDirectlyAfterObjectInstantiation() {\n+        assertNull(defaultInstance.getThreshold());\n+    }\n+\n+    @Test\n+    void testGetThresholdIsCorrect() {\n+        DamerauLevenshteinDistance distance = new DamerauLevenshteinDistance(10);\n+\n+        assertEquals(10, distance.getThreshold());\n+    }\n+\n+    @Test\n+    void testNullInputsThrowUnlimited() {\n+        assertThrows(IllegalArgumentException.class, () -> defaultInstance.apply(null, \"test\"));\n+        assertThrows(IllegalArgumentException.class, () -> defaultInstance.apply(\"test\", null));\n+        assertThrows(IllegalArgumentException.class, () -> defaultInstance.apply(null, SimilarityInput.input(\"test\")));\n+        assertThrows(IllegalArgumentException.class, () -> defaultInstance.apply(SimilarityInput.input(\"test\"), null));\n+    }\n+\n+    @Test\n+    void testNullInputsThrowLimited() {\n+        DamerauLevenshteinDistance instance = new DamerauLevenshteinDistance(10);\n+\n+        assertThrows(IllegalArgumentException.class, () -> instance.apply(null, \"test\"));\n+        assertThrows(IllegalArgumentException.class, () -> instance.apply(\"test\", null));\n+        assertThrows(IllegalArgumentException.class, () -> instance.apply(null, SimilarityInput.input(\"test\")));\n+        assertThrows(IllegalArgumentException.class, () -> instance.apply(SimilarityInput.input(\"test\"), null));\n+    }\n+\n+    @Test\n+    void testInvalidThresholdThrows() {\n+        assertThrows(IllegalArgumentException.class, () -> new DamerauLevenshteinDistance(-1));\n+    }\n+\n+    @ParameterizedTest(name = \"DamerauLevenshteinDistance.unlimitedCompare(\\\"{0}\\\", \\\"{1}\\\") should return {2}\")\n+    @MethodSource(\"unlimitedDamerauLevenshteinDistanceTestCases\")\n+    void testCalculateDamerauLevenshteinDistance(String left, String right, int expectedDistance) {\n+        int leftRightDistance = defaultInstance.apply(left, right);\n+        int rightLeftDistance = defaultInstance.apply(right, left);\n+\n+        assertEquals(expectedDistance, leftRightDistance);\n+        assertEquals(expectedDistance, rightLeftDistance);\n+    }\n+\n+    @ParameterizedTest(name = \"DamerauLevenshteinDistance.unlimitedCompare(\\\"{0}\\\", \\\"{1}\\\") should return {2} ({3})\")\n+    @MethodSource(\"unlimitedDamerauLevenshteinDistanceTestCases_SimilarityInput\")\n+    void testCalculateDamerauLevenshteinDistance_SimilarityInput(String left, String right, int expectedDistance, final Class<?> cls) {\n+        SimilarityInput<Object> leftInput = SimilarityInputTest.build(cls, left);\n+        SimilarityInput<Object> rightInput = SimilarityInputTest.build(cls, right);\n+\n+        int leftRightDistance = defaultInstance.apply(leftInput, rightInput);\n+        int rightLeftDistance = defaultInstance.apply(rightInput, leftInput);\n+\n+        assertEquals(expectedDistance, leftRightDistance);\n+        assertEquals(expectedDistance, rightLeftDistance);\n+    }\n+\n+    @ParameterizedTest(name = \"DamerauLevenshteinDistance.limitedCompare(\\\"{0}\\\", \\\"{1}\\\") should return {2}\")\n+    @MethodSource(\"limitedDamerauLevenshteinDistanceTestCases\")\n+    void testCalculateDamerauLevenshteinDistance(String left, String right, int threshold, int expectedDistance) {\n+        DamerauLevenshteinDistance instance = new DamerauLevenshteinDistance(threshold);\n+\n+        int leftRightDistance = instance.apply(left, right);\n+        int rightLeftDistance = instance.apply(right, left);\n+\n+        assertEquals(expectedDistance, leftRightDistance);\n+        assertEquals(expectedDistance, rightLeftDistance);\n+    }\n+\n+    @ParameterizedTest(name = \"DamerauLevenshteinDistance.limitedCompare(\\\"{0}\\\", \\\"{1}\\\") should return {2}\")\n+    @MethodSource(\"limitedDamerauLevenshteinDistanceTestCases_SimilarityInput\")\n+    void testCalculateDamerauLevenshteinDistance_SimilarityInput(String left, String right, int threshold, int expectedDistance, final Class<?> cls) {\n+        DamerauLevenshteinDistance instance = new DamerauLevenshteinDistance(threshold);\n+\n+        SimilarityInput<Object> leftInput = SimilarityInputTest.build(cls, left);\n+        SimilarityInput<Object> rightInput = SimilarityInputTest.build(cls, right);\n+\n+        int leftRightDistance = instance.apply(leftInput, rightInput);\n+        int rightLeftDistance = instance.apply(rightInput, leftInput);\n+\n+        assertEquals(expectedDistance, leftRightDistance);\n+        assertEquals(expectedDistance, rightLeftDistance);\n+    }\n+\n+    static Stream<Arguments> unlimitedDamerauLevenshteinDistanceTestCases_SimilarityInput() {\n+        return SimilarityInputTest.similarityInputs()\n+                .flatMap(cls -> unlimitedDamerauLevenshteinDistanceTestCases().map(arguments -> {\n+                    Object[] values = Arrays.copyOf(arguments.get(), arguments.get().length + 1);\n+                    values[values.length - 1] = cls;\n+                    return Arguments.of(values);\n+                }));\n+    }\n+\n+    static Stream<Arguments> unlimitedDamerauLevenshteinDistanceTestCases() {\n+        return Stream.of(\n+                Arguments.of(\"\", \"test\", 4),\n+                Arguments.of(\"test\", \"\", 4),\n+                Arguments.of(\"kitten\", \"sitting\", 3),\n+                Arguments.of(\"saturday\", \"sunday\", 3),\n+                Arguments.of(\"hello\", \"world\", 4),\n+                Arguments.of(\"algorithm\", \"logarithm\", 3),\n+                Arguments.of(\"computer\", \"comptuer\", 1),\n+                Arguments.of(\"receive\", \"recieve\", 1),\n+                Arguments.of(\"programming\", \"porgramming\", 1),\n+                Arguments.of(\"test\", \"tset\", 1),\n+                Arguments.of(\"example\", \"exmaple\", 1),\n+                Arguments.of(\"transform\", \"transfrom\", 1),\n+                Arguments.of(\"information\", \"infromation\", 1),\n+                Arguments.of(\"development\", \"developemnt\", 1),\n+                Arguments.of(\"password\", \"passwrod\", 1),\n+                Arguments.of(\"separate\", \"seperate\", 1),\n+                Arguments.of(\"definitely\", \"definately\", 1),\n+                Arguments.of(\"occurrence\", \"occurence\", 1),\n+                Arguments.of(\"necessary\", \"neccessary\", 1),\n+                Arguments.of(\"restaurant\", \"restaraunt\", 2),\n+                Arguments.of(\"beginning\", \"begining\", 1),\n+                Arguments.of(\"government\", \"goverment\", 1),\n+                Arguments.of(\"abcdefghijklmnop\", \"ponmlkjihgfedcba\", 15),\n+                Arguments.of(\"AAAAAAAAAA\", \"BBBBBBBBBB\", 10),\n+                Arguments.of(\"abababababab\", \"babababababa\", 2),\n+                Arguments.of(\"supercalifragilisticexpialidocious\", \"supercalifragilisticexpialidocous\", 1),\n+                Arguments.of(\"pneumonoultramicroscopicsilicovolcanoconiosiss\", \"pneumonoultramicroscopicsilicovolcanoconiosis\", 1),\n+                Arguments.of(\"abcdefg\", \"gfedcba\", 6),\n+                Arguments.of(\"xyxyxyxyxy\", \"yxyxyxyxyx\", 2),\n+                Arguments.of(\"aaaaabbbbbccccc\", \"cccccbbbbbaaaaa\", 10),\n+                Arguments.of(\"thequickbrownfoxjumpsoverthelazydog\", \"thequickbrownfoxjumpsovrethelazydog\", 1),\n+                Arguments.of(\"antidisestablishmentarianism\", \"antidisestablishmentarianisn\", 1)\n+        );\n+    }\n+\n+    static Stream<Arguments> limitedDamerauLevenshteinDistanceTestCases_SimilarityInput() {\n+        return SimilarityInputTest.similarityInputs()\n+                .flatMap(cls -> limitedDamerauLevenshteinDistanceTestCases().map(arguments -> {\n+                    Object[] values = Arrays.copyOf(arguments.get(), arguments.get().length + 1);\n+                    values[values.length - 1] = cls;\n+                    return Arguments.of(values);\n+                }));\n+    }\n+\n+    static Stream<Arguments> limitedDamerauLevenshteinDistanceTestCases() {\n+        return Stream.of(\n+                Arguments.of(\"\", \"test\", 10, 4),\n+                Arguments.of(\"test\", \"\", 10, 4),\n+                Arguments.of(\"\", \"test\", 2, -1),\n+                Arguments.of(\"test\", \"\", 2, -1),\n+                Arguments.of(\"testing long string\", \"testing\", 2, -1),\n+                Arguments.of(\"kitten\", \"sitting\", 1, -1),\n+                Arguments.of(\"saturday\", \"sunday\", 3, 3),\n+                Arguments.of(\"hello\", \"world\", 6, 4),\n+                Arguments.of(\"algorithm\", \"logarithm\", 1, -1),\n+                Arguments.of(\"computer\", \"comptuer\", 1, 1),\n+                Arguments.of(\"receive\", \"recieve\", 3, 1),\n+                Arguments.of(\"programming\", \"porgramming\", 0, -1),\n+                Arguments.of(\"test\", \"tset\", 1, 1),\n+                Arguments.of(\"example\", \"exmaple\", 3, 1),\n+                Arguments.of(\"transform\", \"transfrom\", 0, -1),\n+                Arguments.of(\"information\", \"infromation\", 1, 1),\n+                Arguments.of(\"development\", \"developemnt\", 3, 1),\n+                Arguments.of(\"password\", \"passwrod\", 0, -1),\n+                Arguments.of(\"separate\", \"seperate\", 1, 1),\n+                Arguments.of(\"definitely\", \"definately\", 3, 1),\n+                Arguments.of(\"occurrence\", \"occurence\", 0, -1),\n+                Arguments.of(\"necessary\", \"neccessary\", 1, 1),\n+                Arguments.of(\"restaurant\", \"restaraunt\", 4, 2),\n+                Arguments.of(\"beginning\", \"begining\", 0, -1),\n+                Arguments.of(\"government\", \"goverment\", 1, 1),\n+                Arguments.of(\"abcdefghijklmnop\", \"ponmlkjihgfedcba\", 17, 15),\n+                Arguments.of(\"AAAAAAAAAA\", \"BBBBBBBBBB\", 5, -1),\n+                Arguments.of(\"abababababab\", \"babababababa\", 2, 2),\n+                Arguments.of(\"supercalifragilisticexpialidocious\", \"supercalifragilisticexpialidocous\", 3, 1),\n+                Arguments.of(\"pneumonoultramicroscopicsilicovolcanoconiosiss\", \"pneumonoultramicroscopicsilicovolcanoconiosis\", 0, -1),\n+                Arguments.of(\"abcdefg\", \"gfedcba\", 6, 6),\n+                Arguments.of(\"xyxyxyxyxy\", \"yxyxyxyxyx\", 4, 2),\n+                Arguments.of(\"aaaaabbbbbccccc\", \"cccccbbbbbaaaaa\", 5, -1),\n+                Arguments.of(\"thequickbrownfoxjumpsoverthelazydog\", \"thequickbrownfoxjumpsovrethelazydog\", 1, 1),\n+                Arguments.of(\"antidisestablishmentarianism\", \"antidisestablishmentarianisn\", 3, 1)\n+        );\n+    }\n+}\n",
  "problem_statement" : "[TEXT-235] Add Damerau-Levenshtein distance\n\nAdds Damerau-Levenshtein distance as a measure. Implementation based on original Levenshtein distance implementation, and [Wikipedia](https://en.wikipedia.org/wiki/Damerau%E2%80%93Levenshtein_distance#Optimal_string_alignment_distance). Unit tests written by comparing various strings manually, and by comparing to the value outputted by [RapidFuzz](https://github.com/rapidfuzz/RapidFuzz).\r\n\r\nRelevant Jira ticket; https://issues.apache.org/jira/browse/TEXT-235",
  "hints_text" : null,
  "created_at" : "Tue Aug 05 15:41:28 CEST 2025",
  "version" : null,
  "FAIL_TO_PASS" : [ "DamerauLevenshteinDistanceTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=DamerauLevenshteinDistanceTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 687,
  "metadata" : null
}, {
  "instance_id" : "apache-commons-text-PR-467",
  "repo" : "apache/commons-text",
  "base_commit" : "fb476ec5f1d64575f09b3187aeee02681e726a3e",
  "patch" : "diff --git a/src/main/java/org/apache/commons/text/numbers/DoubleFormat.java b/src/main/java/org/apache/commons/text/numbers/DoubleFormat.java\nindex 05cae505d3..cd42017bb1 100644\n--- a/src/main/java/org/apache/commons/text/numbers/DoubleFormat.java\n+++ b/src/main/java/org/apache/commons/text/numbers/DoubleFormat.java\n@@ -39,6 +39,16 @@\n  * much easier to work with in multi-threaded environments. They also provide performance\n  * comparable to, and in many cases faster than, {@code DecimalFormat}.\n  * </p>\n+ * <p>\n+ * It should be noted that the output {@code String} is created by formatting the output of\n+ * {@link Double#toString()}. This limits the output precision to the precision required\n+ * to exactly represent the input {@code double} and is dependent on the JDK implementation\n+ * of {@link Double#toString()}. A number formatted with the maximum\n+ * precision should be parsed to the same input {@code double}. This implementation\n+ * cannot extend the {@code String} to the required length to represent the exact decimal\n+ * value of the {@code double} as per\n+ * {@link java.math.BigDecimal#toString() BigDecimal#toString()}.\n+ * </p>\n  * <p><strong>Examples</strong></p>\n  * <pre>\n  * // construct a formatter equivalent to Double.toString()\n",
  "test_patch" : "diff --git a/src/test/java/org/apache/commons/text/numbers/DoubleFormatTest.java b/src/test/java/org/apache/commons/text/numbers/DoubleFormatTest.java\nindex 0ebc12d03c..e05cec3bc7 100644\n--- a/src/test/java/org/apache/commons/text/numbers/DoubleFormatTest.java\n+++ b/src/test/java/org/apache/commons/text/numbers/DoubleFormatTest.java\n@@ -22,9 +22,13 @@\n import java.util.Random;\n import java.util.function.DoubleFunction;\n import java.util.function.Function;\n+import java.util.stream.Stream;\n \n import org.junit.jupiter.api.Assertions;\n import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n \n public class DoubleFormatTest {\n \n@@ -37,8 +41,28 @@ private static void assertLocalizedFormatsAreEqual(final double d, final Decimal\n         final String dfStr = trimFormatChars(df.format(d));\n         final String fmtStr = trimFormatChars(fmt.apply(d));\n \n-        Assertions.assertEquals(dfStr, fmtStr,\n+        try {\n+            Assertions.assertEquals(dfStr, fmtStr,\n                 () -> \"Unexpected output for locale [\" + loc.toLanguageTag() + \"] and double value \" + d);\n+        } catch (AssertionError e) {\n+            // Note:\n+            // The DecimalFormat may omit the fraction component if it is zero\n+            // when using the ENGINEERING format \"##0.0##E0\".\n+            // e.g. new DecimalFormat(\"##0.0##E0\").format(1.1299999e-4) => 113E-6.\n+            // The DoubleFormat class either always includes the zero or removes it\n+            // with the setting includeFractionPlaceholder(false).\n+            // Since we expect this mismatch we can remove the decimal point followed\n+            // by a zero from the DoubleFormat output.\n+            // This effectively checks: abcExyz == abc.0Exyz\n+            final DecimalFormatSymbols dfs = new DecimalFormatSymbols(loc);\n+            final char decimalSeparator = dfs.getDecimalSeparator();\n+            final char zeroDigit = dfs.getZeroDigit();\n+            final String updated = fmtStr.replace(new String(new char[] {decimalSeparator, zeroDigit}), \"\");\n+            if (dfStr.equals(updated)) {\n+                return;\n+            }\n+            throw e;\n+        }\n     }\n \n     private static void checkDefaultFormatSpecial(final DoubleFunction<String> fmt) {\n@@ -113,9 +137,18 @@ private static void checkLocalizedFormat(final Locale loc, final String pattern,\n         assertLocalizedFormatsAreEqual(Math.PI, df, fmt, loc);\n         assertLocalizedFormatsAreEqual(Math.E, df, fmt, loc);\n \n+        // Locales are tested using:\n+        // DecimalFormat   DoubleFormat\n+        // ##0.0##E0     : ENGINEERING  maPrecision=6\n+        // 0.0##         : PLAIN        minDecimalExponent(-3)\n+        // #,##0.0##     : PLAIN        minDecimalExponent(-3)\n+        // 0.0##E0       : SCIENTIFIC   maPrecision=4\n+        // The data should not test full precision (17 digits) of the PLAIN format.\n+        // Set the exponent range to create decimals with exponents of approximately\n+        // 10^7 to 10^-7: log2(1e7) = 23.25.\n         final Random rnd = new Random(12L);\n-        final int minExp = -100;\n-        final int maxExp = 100;\n+        final int minExp = -24;\n+        final int maxExp = 24;\n         final int cnt = 1000;\n         for (int i = 0; i < cnt; ++i) {\n             assertLocalizedFormatsAreEqual(randomDouble(minExp, maxExp, rnd), df, fmt, loc);\n@@ -596,4 +629,29 @@ void testScientific_localeFormatComparison() {\n                 .formatSymbols(DecimalFormatSymbols.getInstance(loc))\n                 .build());\n     }\n+\n+    /**\n+     * Test formatting at the maximum precision. The formatting is based on the output\n+     * of {@link Double#toString()}. If cannot create an extended precision text\n+     * representation and is limited to 17 significant digits. This test verifies that\n+     * formatting does not lose information that would be required to recreate the\n+     * same double value.\n+     */\n+    @ParameterizedTest\n+    @MethodSource\n+    void testMaximumPrecision(DoubleFunction<String> fmt, double value) {\n+        final String s = fmt.apply(value);\n+        final double d = Double.parseDouble(s);\n+        Assertions.assertEquals(value, d, () -> value + \" formatted as \" + s);\n+    }\n+\n+    static Stream<Arguments> testMaximumPrecision() {\n+        return Stream.of(\n+            // Example of different Double.toString representations across JDKs\n+            // JDK 17: -9.3540047119774374E17\n+            // JDK 21: -9.354004711977437E17\n+            Arguments.of(DoubleFormat.PLAIN.builder().build(), -9.3540047119774374E17),\n+            Arguments.of(DoubleFormat.SCIENTIFIC.builder().build(), -9.3540047119774374E17)\n+        );\n+    }\n }\n",
  "problem_statement" : "Update DoubleFormat to state it is based on Double.toString.\n\nThis changes the tests to fix some incompatibility between the reference DecimalFormat class and DoubleFormat when:\r\n\r\n- The output string has a trailing .0 due to rounding (which may be omitted by DecimalFormat).\r\n- The Double.toString output has fewer chars than the full precision output from DecimalFormat.",
  "hints_text" : null,
  "created_at" : "Fri Oct 20 10:07:51 CEST 2023",
  "version" : null,
  "FAIL_TO_PASS" : [ "DoubleFormatTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=DoubleFormatTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 467,
  "metadata" : null
}, {
  "instance_id" : "apache-commons-text-PR-452",
  "repo" : "apache/commons-text",
  "base_commit" : "efa7475c3da2153a0d3a769dac8f5fe606c2b9fb",
  "patch" : "diff --git a/src/main/java/org/apache/commons/text/TextStringBuilder.java b/src/main/java/org/apache/commons/text/TextStringBuilder.java\nindex d391fc118d..50aa3c7fa5 100644\n--- a/src/main/java/org/apache/commons/text/TextStringBuilder.java\n+++ b/src/main/java/org/apache/commons/text/TextStringBuilder.java\n@@ -281,6 +281,18 @@ public void write(final String str, final int off, final int len) {\n      */\n     private static final int TRUE_STRING_SIZE = Boolean.TRUE.toString().length();\n \n+    /**\n+     * The maximum size buffer to allocate.\n+     *\n+     * <p>This is set to the same size used in the JDK {@code java.util.ArrayList}:</p>\n+     * <blockquote>\n+     * Some VMs reserve some header words in an array.\n+     * Attempts to allocate larger arrays may result in\n+     * OutOfMemoryError: Requested array size exceeds VM limit.\n+     * </blockquote>\n+     */\n+    private static final int MAX_BUFFER_SIZE = Integer.MAX_VALUE - 8;\n+\n     /**\n      * Constructs an instance from a reference to a character array. Changes to the input chars are reflected in this\n      * instance until the internal buffer needs to be reallocated. Using a reference to an array allows the instance to\n@@ -391,10 +403,10 @@ public TextStringBuilder(final String str) {\n      */\n     public TextStringBuilder append(final boolean value) {\n         if (value) {\n-            ensureCapacity(size + TRUE_STRING_SIZE);\n+            ensureCapacityInternal(size + TRUE_STRING_SIZE);\n             appendTrue(size);\n         } else {\n-            ensureCapacity(size + FALSE_STRING_SIZE);\n+            ensureCapacityInternal(size + FALSE_STRING_SIZE);\n             appendFalse(size);\n         }\n         return this;\n@@ -409,7 +421,7 @@ public TextStringBuilder append(final boolean value) {\n     @Override\n     public TextStringBuilder append(final char ch) {\n         final int len = length();\n-        ensureCapacity(len + 1);\n+        ensureCapacityInternal(len + 1);\n         buffer[size++] = ch;\n         return this;\n     }\n@@ -427,7 +439,7 @@ public TextStringBuilder append(final char[] chars) {\n         final int strLen = chars.length;\n         if (strLen > 0) {\n             final int len = length();\n-            ensureCapacity(len + strLen);\n+            ensureCapacityInternal(len + strLen);\n             System.arraycopy(chars, 0, buffer, len, strLen);\n             size += strLen;\n         }\n@@ -458,7 +470,7 @@ public TextStringBuilder append(final char[] chars, final int startIndex, final\n         }\n         if (length > 0) {\n             final int len = length();\n-            ensureCapacity(len + length);\n+            ensureCapacityInternal(len + length);\n             System.arraycopy(chars, startIndex, buffer, len, length);\n             size += length;\n         }\n@@ -496,7 +508,7 @@ public TextStringBuilder append(final CharBuffer buf, final int startIndex, fina\n                 throw new StringIndexOutOfBoundsException(\"length must be valid\");\n             }\n             final int len = length();\n-            ensureCapacity(len + length);\n+            ensureCapacityInternal(len + length);\n             System.arraycopy(buf.array(), buf.arrayOffset() + buf.position() + startIndex, buffer, len, length);\n             size += length;\n         } else {\n@@ -643,7 +655,7 @@ public TextStringBuilder append(final String str, final int startIndex, final in\n         }\n         if (length > 0) {\n             final int len = length();\n-            ensureCapacity(len + length);\n+            ensureCapacityInternal(len + length);\n             str.getChars(startIndex, startIndex + length, buffer, len);\n             size += length;\n         }\n@@ -692,7 +704,7 @@ public TextStringBuilder append(final StringBuffer str, final int startIndex, fi\n         }\n         if (length > 0) {\n             final int len = length();\n-            ensureCapacity(len + length);\n+            ensureCapacityInternal(len + length);\n             str.getChars(startIndex, startIndex + length, buffer, len);\n             size += length;\n         }\n@@ -729,7 +741,7 @@ public TextStringBuilder append(final StringBuilder str, final int startIndex, f\n         }\n         if (length > 0) {\n             final int len = length();\n-            ensureCapacity(len + length);\n+            ensureCapacityInternal(len + length);\n             str.getChars(startIndex, startIndex + length, buffer, len);\n             size += length;\n         }\n@@ -766,7 +778,7 @@ public TextStringBuilder append(final TextStringBuilder str, final int startInde\n         }\n         if (length > 0) {\n             final int len = length();\n-            ensureCapacity(len + length);\n+            ensureCapacityInternal(len + length);\n             str.getChars(startIndex, startIndex + length, buffer, len);\n             size += length;\n         }\n@@ -858,7 +870,7 @@ public TextStringBuilder appendFixedWidthPadLeft(final int value, final int widt\n      */\n     public TextStringBuilder appendFixedWidthPadLeft(final Object obj, final int width, final char padChar) {\n         if (width > 0) {\n-            ensureCapacity(size + width);\n+            ensureCapacityInternal(size + width);\n             String str = obj == null ? getNullText() : obj.toString();\n             if (str == null) {\n                 str = StringUtils.EMPTY;\n@@ -903,7 +915,7 @@ public TextStringBuilder appendFixedWidthPadRight(final int value, final int wid\n      */\n     public TextStringBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar) {\n         if (width > 0) {\n-            ensureCapacity(size + width);\n+            ensureCapacityInternal(size + width);\n             String str = obj == null ? getNullText() : obj.toString();\n             if (str == null) {\n                 str = StringUtils.EMPTY;\n@@ -1162,7 +1174,7 @@ public TextStringBuilder appendNull() {\n      */\n     public TextStringBuilder appendPadding(final int length, final char padChar) {\n         if (length >= 0) {\n-            ensureCapacity(size + length);\n+            ensureCapacityInternal(size + length);\n             for (int i = 0; i < length; i++) {\n                 buffer[size++] = padChar;\n             }\n@@ -1820,17 +1832,84 @@ public boolean endsWith(final String str) {\n     /**\n      * Tests the capacity and ensures that it is at least the size specified.\n      *\n+     * <p>Note: This method can be used to minimise memory reallocations during\n+     * repeated addition of values by pre-allocating the character buffer.\n+     * The method ignores a negative {@code capacity} argument.\n+     *\n      * @param capacity the capacity to ensure\n      * @return this, to enable chaining\n+     * @throws OutOfMemoryError if the capacity cannot be allocated\n      */\n     public TextStringBuilder ensureCapacity(final int capacity) {\n-        // checks for overflow\n-        if (capacity > 0 && capacity - buffer.length > 0) {\n-            reallocate(capacity);\n+        if (capacity > 0) {\n+            ensureCapacityInternal(capacity);\n         }\n         return this;\n     }\n \n+    /**\n+     * Ensure that the buffer is at least the size specified. The {@code capacity} argument\n+     * is treated as an unsigned integer.\n+     *\n+     * <p>This method will raise an {@link OutOfMemoryError} if the capacity is too large\n+     * for an array, or cannot be allocated.\n+     *\n+     * @param capacity the capacity to ensure\n+     * @throws OutOfMemoryError if the capacity cannot be allocated\n+     */\n+    private void ensureCapacityInternal(final int capacity) {\n+        // Check for overflow of the current buffer.\n+        // Assumes capacity is an unsigned integer up to Integer.MAX_VALUE * 2\n+        // (the largest possible addition of two maximum length arrays).\n+        if (capacity - buffer.length > 0) {\n+            resizeBuffer(capacity);\n+        }\n+    }\n+\n+    /**\n+     * Resizes the buffer to at least the size specified.\n+     *\n+     * @param minCapacity the minimum required capacity\n+     * @throws OutOfMemoryError if the {@code minCapacity} is negative\n+     */\n+    private void resizeBuffer(final int minCapacity) {\n+        // Overflow-conscious code treats the min and new capacity as unsigned.\n+        final int oldCapacity = buffer.length;\n+        int newCapacity = oldCapacity * 2;\n+        if (Integer.compareUnsigned(newCapacity, minCapacity) < 0) {\n+            newCapacity = minCapacity;\n+        }\n+        if (Integer.compareUnsigned(newCapacity, MAX_BUFFER_SIZE) > 0) {\n+            newCapacity = createPositiveCapacity(minCapacity);\n+        }\n+        reallocate(newCapacity);\n+    }\n+\n+    /**\n+     * Create a positive capacity at least as large the minimum required capacity.\n+     * If the minimum capacity is negative then this throws an OutOfMemoryError as no array\n+     * can be allocated.\n+     *\n+     * @param minCapacity the minimum capacity\n+     * @return the capacity\n+     * @throws OutOfMemoryError if the {@code minCapacity} is negative\n+     */\n+    private static int createPositiveCapacity(final int minCapacity) {\n+        if (minCapacity < 0) {\n+            // overflow\n+            throw new OutOfMemoryError(\"Unable to allocate array size: \" + Integer.toUnsignedString(minCapacity));\n+        }\n+        // This is called when we require buffer expansion to a very big array.\n+        // Use the conservative maximum buffer size if possible, otherwise the biggest required.\n+        //\n+        // Note: In this situation JDK 1.8 java.util.ArrayList returns Integer.MAX_VALUE.\n+        // This excludes some VMs that can exceed MAX_BUFFER_SIZE but not allocate a full\n+        // Integer.MAX_VALUE length array.\n+        // The result is that we may have to allocate an array of this size more than once if\n+        // the capacity must be expanded again.\n+        return Math.max(minCapacity, MAX_BUFFER_SIZE);\n+    }\n+\n     /**\n      * Tests the contents of this builder against another to see if they contain the same character content.\n      *\n@@ -2107,11 +2186,11 @@ public int indexOf(final StringMatcher matcher, int startIndex) {\n     public TextStringBuilder insert(final int index, final boolean value) {\n         validateIndex(index);\n         if (value) {\n-            ensureCapacity(size + TRUE_STRING_SIZE);\n+            ensureCapacityInternal(size + TRUE_STRING_SIZE);\n             System.arraycopy(buffer, index, buffer, index + TRUE_STRING_SIZE, size - index);\n             appendTrue(index);\n         } else {\n-            ensureCapacity(size + FALSE_STRING_SIZE);\n+            ensureCapacityInternal(size + FALSE_STRING_SIZE);\n             System.arraycopy(buffer, index, buffer, index + FALSE_STRING_SIZE, size - index);\n             appendFalse(index);\n         }\n@@ -2128,7 +2207,7 @@ public TextStringBuilder insert(final int index, final boolean value) {\n      */\n     public TextStringBuilder insert(final int index, final char value) {\n         validateIndex(index);\n-        ensureCapacity(size + 1);\n+        ensureCapacityInternal(size + 1);\n         System.arraycopy(buffer, index, buffer, index + 1, size - index);\n         buffer[index] = value;\n         size++;\n@@ -2150,7 +2229,7 @@ public TextStringBuilder insert(final int index, final char[] chars) {\n         }\n         final int len = chars.length;\n         if (len > 0) {\n-            ensureCapacity(size + len);\n+            ensureCapacityInternal(size + len);\n             System.arraycopy(buffer, index, buffer, index + len, size - index);\n             System.arraycopy(chars, 0, buffer, index, len);\n             size += len;\n@@ -2180,7 +2259,7 @@ public TextStringBuilder insert(final int index, final char[] chars, final int o\n             throw new StringIndexOutOfBoundsException(\"Invalid length: \" + length);\n         }\n         if (length > 0) {\n-            ensureCapacity(size + length);\n+            ensureCapacityInternal(size + length);\n             System.arraycopy(buffer, index, buffer, index + length, size - index);\n             System.arraycopy(chars, offset, buffer, index, length);\n             size += length;\n@@ -2269,7 +2348,7 @@ public TextStringBuilder insert(final int index, String str) {\n             final int strLen = str.length();\n             if (strLen > 0) {\n                 final int newSize = size + strLen;\n-                ensureCapacity(newSize);\n+                ensureCapacityInternal(newSize);\n                 System.arraycopy(buffer, index, buffer, index + strLen, size - index);\n                 size = newSize;\n                 str.getChars(0, strLen, buffer, index);\n@@ -2514,7 +2593,7 @@ public TextStringBuilder minimizeCapacity() {\n     public int readFrom(final CharBuffer charBuffer) {\n         final int oldSize = size;\n         final int remaining = charBuffer.remaining();\n-        ensureCapacity(size + remaining);\n+        ensureCapacityInternal(size + remaining);\n         charBuffer.get(buffer, size, remaining);\n         size += remaining;\n         return size - oldSize;\n@@ -2539,7 +2618,7 @@ public int readFrom(final Readable readable) throws IOException {\n         }\n         final int oldSize = size;\n         while (true) {\n-            ensureCapacity(size + 1);\n+            ensureCapacityInternal(size + 1);\n             final CharBuffer buf = CharBuffer.wrap(buffer, size, buffer.length - size);\n             final int read = readable.read(buf);\n             if (read == EOS) {\n@@ -2563,14 +2642,14 @@ public int readFrom(final Readable readable) throws IOException {\n      */\n     public int readFrom(final Reader reader) throws IOException {\n         final int oldSize = size;\n-        ensureCapacity(size + 1);\n+        ensureCapacityInternal(size + 1);\n         int readCount = reader.read(buffer, size, buffer.length - size);\n         if (readCount == EOS) {\n             return EOS;\n         }\n         do {\n             size += readCount;\n-            ensureCapacity(size + 1);\n+            ensureCapacityInternal(size + 1);\n             readCount = reader.read(buffer, size, buffer.length - size);\n         } while (readCount != EOS);\n         return size - oldSize;\n@@ -2593,7 +2672,7 @@ public int readFrom(final Reader reader, final int count) throws IOException {\n             return 0;\n         }\n         final int oldSize = size;\n-        ensureCapacity(size + count);\n+        ensureCapacityInternal(size + count);\n         int target = count;\n         int readCount = reader.read(buffer, size, target);\n         if (readCount == EOS) {\n@@ -2775,7 +2854,7 @@ private void replaceImpl(final int startIndex, final int endIndex, final int rem\n         final int insertLen) {\n         final int newSize = size - removeLen + insertLen;\n         if (insertLen != removeLen) {\n-            ensureCapacity(newSize);\n+            ensureCapacityInternal(newSize);\n             System.arraycopy(buffer, endIndex, buffer, startIndex + insertLen, size - endIndex);\n             size = newSize;\n         }\n@@ -2905,7 +2984,7 @@ public TextStringBuilder setLength(final int length) {\n         if (length < size) {\n             size = length;\n         } else if (length > size) {\n-            ensureCapacity(length);\n+            ensureCapacityInternal(length);\n             final int oldEnd = size;\n             size = length;\n             Arrays.fill(buffer, oldEnd, length, '\\0');\n",
  "test_patch" : "diff --git a/src/test/java/org/apache/commons/text/TextStringBuilderTest.java b/src/test/java/org/apache/commons/text/TextStringBuilderTest.java\nindex 7a13e5b793..38ad2720ba 100644\n--- a/src/test/java/org/apache/commons/text/TextStringBuilderTest.java\n+++ b/src/test/java/org/apache/commons/text/TextStringBuilderTest.java\n@@ -45,6 +45,7 @@\n import org.apache.commons.lang3.StringUtils;\n import org.apache.commons.text.matcher.StringMatcher;\n import org.apache.commons.text.matcher.StringMatcherFactory;\n+import org.junit.jupiter.api.Assumptions;\n import org.junit.jupiter.api.Test;\n \n /**\n@@ -893,6 +894,112 @@ public void testEnsureCapacityOutOfMemoryError() {\n         assertThrows(OutOfMemoryError.class, () -> sb.ensureCapacity(Integer.MAX_VALUE));\n     }\n \n+    @Test\n+    public void testOutOfMemoryError() {\n+        // This test is memory hungry requiring at least 7GiB of memory.\n+        // By default expansion will double the buffer size. If we repeat\n+        // add 1GiB of char data then we require at maximum:\n+        // 1GiB char[] data\n+        // 2GiB char[] buffer\n+        // ~4GiB char[] new buffer during reallocation\n+\n+        // Attempts to guess the amount of free memory available using\n+        // java.lang.Runtime and skipping the test often did not work.\n+        // The JVM can allocating large arrays using far more memory than\n+        // the raw byte size.\n+        // So here we just run the test and return a skip result if the\n+        // OutOfMemoryError occurs too early.\n+\n+        final TextStringBuilder sb = new TextStringBuilder();\n+        sb.minimizeCapacity();\n+        assertEquals(0, sb.capacity());\n+\n+        // 1GiB char[] buffer: length is roughly 1/4 the maximum array size\n+        final char[] chars = new char[1 << 29];\n+\n+        // With infinite memory it should be possible to add this 3 times.\n+        try {\n+            for (int i = 0; i < 3; i++) {\n+                sb.append(chars);\n+            }\n+        } catch (OutOfMemoryError ignored) {\n+            Assumptions.abort(\"Not enough memory for the test\");\n+        }\n+\n+        // Now at 3/4 of the maximum array length.\n+        // Adding is not possible so we expect an OOM error.\n+        assertThrows(OutOfMemoryError.class, () -> sb.append(chars));\n+    }\n+\n+    @Test\n+    public void testOutOfMemoryError2() {\n+        // This test is memory hungry requiring at least 4GiB of memory\n+        // in a single allocation. If not possible then skip the test.\n+\n+        final TextStringBuilder sb = new TextStringBuilder();\n+        sb.minimizeCapacity();\n+        assertEquals(0, sb.capacity());\n+\n+        // Allocate a lot\n+        final int small = 10;\n+        final int big = Integer.MAX_VALUE - small;\n+        final char[] extra = new char[small + 1];\n+        try {\n+            sb.ensureCapacity(big);\n+        } catch (OutOfMemoryError ignored) {\n+            Assumptions.abort(\"Not enough memory for the test\");\n+        }\n+\n+        fill(sb, big);\n+\n+        // Adding more than the maximum array size is not possible so we expect an OOM error.\n+        assertThrows(OutOfMemoryError.class, () -> sb.append(extra));\n+    }\n+\n+    @Test\n+    public void testOutOfMemoryError3() {\n+        // This test is memory hungry requiring at least 2GiB of memory\n+        // in a single allocation. If not possible then skip the test.\n+\n+        final TextStringBuilder sb = new TextStringBuilder();\n+        sb.minimizeCapacity();\n+        assertEquals(0, sb.capacity());\n+\n+        final int length = 1 << 30;\n+        try {\n+            sb.ensureCapacity(length);\n+        } catch (OutOfMemoryError ignored) {\n+            Assumptions.abort(\"Not enough memory for the test\");\n+        }\n+\n+        fill(sb, length);\n+\n+        // Adding to itself requires a new buffer above the limits of an array\n+        assertThrows(OutOfMemoryError.class, () -> sb.append(sb));\n+    }\n+\n+    /**\n+     * Clear the string builder and fill up to the specified length.\n+     *\n+     * @param sb the string builder\n+     * @param length the length\n+     */\n+    private static void fill(TextStringBuilder sb, int length) {\n+        sb.clear();\n+        // Some initial data.\n+        final int limit = Math.min(64, length);\n+        for (int i = 0; i < limit; i++) {\n+            sb.append(' ');\n+        }\n+        // Fill by doubling\n+        while (sb.length() * 2L <= length) {\n+            sb.append(sb);\n+        }\n+        // Remaining fill\n+        sb.append(sb, 0, length - sb.length());\n+        assertEquals(length, sb.length(), \"Expected the buffer to be full to the given length\");\n+    }\n+\n     @Test\n     public void testEquals() {\n         final TextStringBuilder sb1 = new TextStringBuilder(50);\n",
  "problem_statement" : "TEXT-228: Fix TextStringBuilder to over-allocate when ensuring capacity\n\nThis fixes a performance regression where allocation was only using the exact size necessary for the additional chars (resulting in buffer reallocation on each append).",
  "hints_text" : null,
  "created_at" : "Mon Aug 21 15:17:46 CEST 2023",
  "version" : null,
  "FAIL_TO_PASS" : [ "TextStringBuilderTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=TextStringBuilderTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 452,
  "metadata" : null
}, {
  "instance_id" : "apache-commons-text-PR-449",
  "repo" : "apache/commons-text",
  "base_commit" : "28b6e1d38a47cab1b6beaadd8585780b49a178ef",
  "patch" : "diff --git a/src/main/java/org/apache/commons/text/StringSubstitutor.java b/src/main/java/org/apache/commons/text/StringSubstitutor.java\nindex af49341dac..b9960d9907 100644\n--- a/src/main/java/org/apache/commons/text/StringSubstitutor.java\n+++ b/src/main/java/org/apache/commons/text/StringSubstitutor.java\n@@ -368,6 +368,14 @@ public String toString() {\n      * <td>{@value org.apache.commons.text.lookup.StringLookupFactory#KEY_XML}</td>\n      * <td>{@link StringLookupFactory#xmlStringLookup()}</td>\n      * </tr>\n+     * <tr>\n+     * <td>{@value org.apache.commons.text.lookup.StringLookupFactory#KEY_XML_DECODER}</td>\n+     * <td>{@link StringLookupFactory#xmlDecoderStringLookup()}</td>\n+     * </tr>\n+     * <tr>\n+     * <td>{@value org.apache.commons.text.lookup.StringLookupFactory#KEY_XML_ENCODER}</td>\n+     * <td>{@link StringLookupFactory#xmlEncoderStringLookup()}</td>\n+     * </tr>\n      * </table>\n      *\n      * @return a new instance using the interpolator string lookup.\ndiff --git a/src/main/java/org/apache/commons/text/lookup/DefaultStringLookup.java b/src/main/java/org/apache/commons/text/lookup/DefaultStringLookup.java\nindex c23d97dd4e..baf1351bb2 100644\n--- a/src/main/java/org/apache/commons/text/lookup/DefaultStringLookup.java\n+++ b/src/main/java/org/apache/commons/text/lookup/DefaultStringLookup.java\n@@ -151,7 +151,23 @@ public enum DefaultStringLookup {\n      * @see StringLookupFactory#KEY_XML\n      * @see StringLookupFactory#xmlStringLookup()\n      */\n-    XML(StringLookupFactory.KEY_XML, StringLookupFactory.INSTANCE.xmlStringLookup());\n+    XML(StringLookupFactory.KEY_XML, StringLookupFactory.INSTANCE.xmlStringLookup()),\n+\n+    /**\n+     * The lookup for XML decoding using the key {@code \"xmlDecoder\"}.\n+     * @see StringLookupFactory#KEY_XML_DECODER\n+     * @see StringLookupFactory#xmlDecoderStringLookup()\n+     * @since 1.11.0\n+     */\n+    XML_DECODER(StringLookupFactory.KEY_XML_DECODER, StringLookupFactory.INSTANCE.xmlDecoderStringLookup()),\n+\n+    /**\n+     * The lookup for XML encoding using the key {@code \"xmlEncoder\"}.\n+     * @see StringLookupFactory#KEY_XML_ENCODER\n+     * @see StringLookupFactory#xmlEncoderStringLookup()\n+     * @since 1.11.0\n+     */\n+    XML_ENCODER(StringLookupFactory.KEY_XML_ENCODER, StringLookupFactory.INSTANCE.xmlEncoderStringLookup());\n \n     /** The prefix under which the associated lookup object is registered. */\n     private final String key;\ndiff --git a/src/main/java/org/apache/commons/text/lookup/StringLookupFactory.java b/src/main/java/org/apache/commons/text/lookup/StringLookupFactory.java\nindex be952db1eb..bea9143bd2 100644\n--- a/src/main/java/org/apache/commons/text/lookup/StringLookupFactory.java\n+++ b/src/main/java/org/apache/commons/text/lookup/StringLookupFactory.java\n@@ -152,6 +152,18 @@\n  * <td>{@link #xmlStringLookup()}</td>\n  * <td>1.5</td>\n  * </tr>\n+ * <tr>\n+ * <td>{@value #KEY_XML_DECODER}</td>\n+ * <td>{@link StringLookup}</td>\n+ * <td>{@link #xmlDecoderStringLookup()}</td>\n+ * <td>1.11.0</td>\n+ * </tr>\n+ * <tr>\n+ * <td>{@value #KEY_XML_ENCODER}</td>\n+ * <td>{@link StringLookup}</td>\n+ * <td>{@link #xmlEncoderStringLookup()}</td>\n+ * <td>1.11.0</td>\n+ * </tr>\n  * </table>\n  *\n  * <table>\n@@ -252,6 +264,8 @@ private static Map<String, StringLookup> createDefaultStringLookups() {\n             addLookup(DefaultStringLookup.URL_DECODER, lookupMap);\n             addLookup(DefaultStringLookup.URL_ENCODER, lookupMap);\n             addLookup(DefaultStringLookup.XML, lookupMap);\n+            addLookup(DefaultStringLookup.XML_DECODER, lookupMap);\n+            addLookup(DefaultStringLookup.XML_ENCODER, lookupMap);\n \n             return lookupMap;\n         }\n@@ -508,6 +522,20 @@ Map<String, StringLookup> getDefaultStringLookups() {\n      */\n     public static final String KEY_XML = \"xml\";\n \n+    /**\n+     * Default lookup key for interpolation {@value #KEY_XML_DECODER}.\n+     *\n+     * @since 1.11.0\n+     */\n+    public static final String KEY_XML_DECODER = \"xmlDecoder\";\n+\n+    /**\n+     * Default lookup key for interpolation {@value #KEY_XML_ENCODER}.\n+     *\n+     * @since 1.11.0\n+     */\n+    public static final String KEY_XML_ENCODER = \"xmlEncoder\";\n+\n     /**\n      * Name of the system property used to determine the string lookups added by the\n      * {@link #addDefaultStringLookups(Map)} method. Use of this property is only required\n@@ -1353,4 +1381,70 @@ public StringLookup xmlStringLookup() {\n     public StringLookup xmlStringLookup(final Map<String, Boolean> xPathFactoryFeatures) {\n         return new XmlStringLookup(xPathFactoryFeatures);\n     }\n+\n+    /**\n+     * Returns the XmlDecoderStringLookup singleton instance.\n+     * <p>\n+     * Decodes strings according to the XML 1.0 specification.\n+     * </p>\n+     * <p>\n+     * For example: \"&amp;lt;element&amp;gt;\" becomes \"&lt;element&gt;\".\n+     * </p>\n+     * <p>\n+     * Using a {@link StringLookup} from the {@link StringLookupFactory}:\n+     * </p>\n+     *\n+     * <pre>\n+     * StringLookupFactory.INSTANCE.xmlDecoderStringLookup().lookup(\"&amp;lt;element&amp;gt;\");\n+     * </pre>\n+     * <p>\n+     * Using a {@link StringSubstitutor}:\n+     * </p>\n+     *\n+     * <pre>\n+     * StringSubstitutor.createInterpolator().replace(\"... ${xmlDecoder:&amp;lt;element&amp;gt;} ...\"));\n+     * </pre>\n+     * <p>\n+     * The above examples convert {@code \"&lt;element&gt;\"} to {@code \"<element>\"}.\n+     * </p>\n+     *\n+     * @return The XmlDecoderStringLookup singleton instance.\n+     * @since 1.11.0\n+     */\n+    public StringLookup xmlDecoderStringLookup() {\n+        return XmlDecoderStringLookup.INSTANCE;\n+    }\n+\n+    /**\n+     * Returns the XmlEncoderStringLookup singleton instance.\n+     * <p>\n+     * Encodes strings according to the XML 1.0 specification.\n+     * </p>\n+     * <p>\n+     * For example: \"&lt;element&gt;\" becomes \"&amp;lt;element&amp;gt;\".\n+     * </p>\n+     * <p>\n+     * Using a {@link StringLookup} from the {@link StringLookupFactory}:\n+     * </p>\n+     *\n+     * <pre>\n+     * StringLookupFactory.INSTANCE.xmlEncoderStringLookup().lookup(\"&lt;element&gt;\");\n+     * </pre>\n+     * <p>\n+     * Using a {@link StringSubstitutor}:\n+     * </p>\n+     *\n+     * <pre>\n+     * StringSubstitutor.createInterpolator().replace(\"... ${xmlEncoder:&lt;element&gt;} ...\"));\n+     * </pre>\n+     * <p>\n+     * The above examples convert {@code \"<element>\"} to {@code \"&lt;element&gt;\"}.\n+     * </p>\n+     *\n+     * @return The XmlEncoderStringLookup singleton instance.\n+     * @since 1.11.0\n+     */\n+    public StringLookup xmlEncoderStringLookup() {\n+        return XmlEncoderStringLookup.INSTANCE;\n+    }\n }\ndiff --git a/src/main/java/org/apache/commons/text/lookup/XmlDecoderStringLookup.java b/src/main/java/org/apache/commons/text/lookup/XmlDecoderStringLookup.java\nnew file mode 100644\nindex 0000000000..9fd878f081\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/text/lookup/XmlDecoderStringLookup.java\n@@ -0,0 +1,43 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache license, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the license for the specific language governing permissions and\n+ * limitations under the license.\n+ */\n+\n+package org.apache.commons.text.lookup;\n+\n+import org.apache.commons.text.StringEscapeUtils;\n+\n+/**\n+ * Decodes strings according to the XML 1.0 specification.\n+ *\n+ * @see StringEscapeUtils#unescapeXml(String)\n+ */\n+final class XmlDecoderStringLookup extends AbstractStringLookup {\n+\n+    /**\n+     * Defines the singleton for this class.\n+     */\n+    static final XmlDecoderStringLookup INSTANCE = new XmlDecoderStringLookup();\n+\n+    private XmlDecoderStringLookup() {\n+        // empty\n+    }\n+\n+    @Override\n+    public String lookup(String key) {\n+        return StringEscapeUtils.unescapeXml(key);\n+    }\n+\n+}\ndiff --git a/src/main/java/org/apache/commons/text/lookup/XmlEncoderStringLookup.java b/src/main/java/org/apache/commons/text/lookup/XmlEncoderStringLookup.java\nnew file mode 100644\nindex 0000000000..77bd5aa13d\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/text/lookup/XmlEncoderStringLookup.java\n@@ -0,0 +1,44 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache license, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the license for the specific language governing permissions and\n+ * limitations under the license.\n+ */\n+\n+package org.apache.commons.text.lookup;\n+\n+import org.apache.commons.text.StringEscapeUtils;\n+\n+/**\n+ * Encodes strings according to the XML 1.0 specification.\n+ *\n+ * @see StringEscapeUtils#escapeXml10(String)\n+ * @since 1.11.0\n+ */\n+final class XmlEncoderStringLookup extends AbstractStringLookup {\n+\n+    /**\n+     * Defines the singleton for this class.\n+     */\n+    static final XmlEncoderStringLookup INSTANCE = new XmlEncoderStringLookup();\n+\n+    XmlEncoderStringLookup() {\n+        // empty\n+    }\n+\n+    @Override\n+    public String lookup(String key) {\n+        return StringEscapeUtils.escapeXml10(key);\n+    }\n+\n+}\n",
  "test_patch" : "diff --git a/src/test/java/org/apache/commons/text/lookup/StringLookupFactoryTest.java b/src/test/java/org/apache/commons/text/lookup/StringLookupFactoryTest.java\nindex 0529b65f3f..1c00bf1915 100644\n--- a/src/test/java/org/apache/commons/text/lookup/StringLookupFactoryTest.java\n+++ b/src/test/java/org/apache/commons/text/lookup/StringLookupFactoryTest.java\n@@ -49,7 +49,9 @@ public static void assertDefaultKeys(final Map<String, StringLookup> stringLooku\n                 StringLookupFactory.KEY_SYS,\n                 StringLookupFactory.KEY_URL_DECODER,\n                 StringLookupFactory.KEY_URL_ENCODER,\n-                StringLookupFactory.KEY_XML);\n+                StringLookupFactory.KEY_XML,\n+                StringLookupFactory.KEY_XML_DECODER,\n+                StringLookupFactory.KEY_XML_ENCODER);\n     }\n \n     private static void assertMappedLookups(final Map<String, StringLookup> lookupMap, final String... keys) {\n@@ -188,7 +190,9 @@ public void testDefaultStringLookupsHolder_lookupsPropertyNotPresent() {\n                 StringLookupFactory.KEY_SYS,\n                 StringLookupFactory.KEY_URL_DECODER,\n                 StringLookupFactory.KEY_URL_ENCODER,\n-                StringLookupFactory.KEY_XML);\n+                StringLookupFactory.KEY_XML,\n+                StringLookupFactory.KEY_XML_DECODER,\n+                StringLookupFactory.KEY_XML_ENCODER);\n     }\n \n     @Test\n@@ -229,6 +233,8 @@ public void testSingletons() {\n         Assertions.assertSame(UrlEncoderStringLookup.INSTANCE, stringLookupFactory.urlEncoderStringLookup());\n         Assertions.assertSame(UrlStringLookup.INSTANCE, stringLookupFactory.urlStringLookup());\n         Assertions.assertSame(XmlStringLookup.INSTANCE, stringLookupFactory.xmlStringLookup());\n+        Assertions.assertSame(XmlDecoderStringLookup.INSTANCE, stringLookupFactory.xmlDecoderStringLookup());\n+        Assertions.assertSame(XmlEncoderStringLookup.INSTANCE, stringLookupFactory.xmlEncoderStringLookup());\n     }\n \n     @Test\ndiff --git a/src/test/java/org/apache/commons/text/lookup/XmlDecoderStringLookupTest.java b/src/test/java/org/apache/commons/text/lookup/XmlDecoderStringLookupTest.java\nnew file mode 100644\nindex 0000000000..6fba2d55f3\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/text/lookup/XmlDecoderStringLookupTest.java\n@@ -0,0 +1,46 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache license, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the license for the specific language governing permissions and\n+ * limitations under the license.\n+ */\n+\n+package org.apache.commons.text.lookup;\n+\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+\n+/**\n+ * Tests {@link XmlDecoderStringLookup}.\n+ */\n+public class XmlDecoderStringLookupTest {\n+\n+    private static final String DATA = \"<element>\";\n+\n+    @Test\n+    public void testDecode() {\n+        Assertions.assertEquals(DATA, XmlDecoderStringLookup.INSTANCE.lookup(\"&lt;element&gt;\"));\n+    }\n+\n+    @Test\n+    public void testNull() {\n+        Assertions.assertNull(XmlDecoderStringLookup.INSTANCE.lookup(null));\n+    }\n+\n+    @Test\n+    public void testToString() {\n+        // does not blow up and gives some kind of string.\n+        Assertions.assertFalse(XmlDecoderStringLookup.INSTANCE.toString().isEmpty());\n+    }\n+\n+}\ndiff --git a/src/test/java/org/apache/commons/text/lookup/XmlEncoderStringLookupTest.java b/src/test/java/org/apache/commons/text/lookup/XmlEncoderStringLookupTest.java\nnew file mode 100644\nindex 0000000000..d5f0615ed8\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/text/lookup/XmlEncoderStringLookupTest.java\n@@ -0,0 +1,46 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache license, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the license for the specific language governing permissions and\n+ * limitations under the license.\n+ */\n+\n+package org.apache.commons.text.lookup;\n+\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+\n+/**\n+ * Tests {@link XmlEncoderStringLookup}.\n+ */\n+public class XmlEncoderStringLookupTest {\n+\n+    private static final String DATA = \"&lt;element&gt;\";\n+\n+    @Test\n+    public void testDecode() {\n+        Assertions.assertEquals(DATA, XmlEncoderStringLookup.INSTANCE.lookup(\"<element>\"));\n+    }\n+\n+    @Test\n+    public void testNull() {\n+        Assertions.assertNull(XmlEncoderStringLookup.INSTANCE.lookup(null));\n+    }\n+\n+    @Test\n+    public void testToString() {\n+        // does not blow up and gives some kind of string.\n+        Assertions.assertFalse(XmlEncoderStringLookup.INSTANCE.toString().isEmpty());\n+    }\n+\n+}\n",
  "problem_statement" : "[TEXT-229] Add XmlEncoderStringLookup/XmlDecoderStringLookup\n\nThis closes #449",
  "hints_text" : null,
  "created_at" : "Tue Aug 15 15:17:14 CEST 2023",
  "version" : null,
  "FAIL_TO_PASS" : [ "XmlEncoderStringLookupTest", "XmlDecoderStringLookupTest", "StringLookupFactoryTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=XmlEncoderStringLookupTest,XmlDecoderStringLookupTest,StringLookupFactoryTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 449,
  "metadata" : null
} ]