diff --git a/gson/src/test/java/com/google/gson/GenericArrayTypeTest.java b/gson/src/test/java/com/google/gson/GenericArrayTypeTest.java
index f17f29c721..5733df296d 100644
--- a/gson/src/test/java/com/google/gson/GenericArrayTypeTest.java
+++ b/gson/src/test/java/com/google/gson/GenericArrayTypeTest.java
@@ -18,7 +18,7 @@
 
 import static com.google.common.truth.Truth.assertThat;
 
-import com.google.gson.internal.$Gson$Types;
+import com.google.gson.internal.GsonTypes;
 import com.google.gson.reflect.TypeToken;
 import java.lang.reflect.GenericArrayType;
 import java.lang.reflect.Type;
@@ -27,7 +27,7 @@
 import org.junit.Test;
 
 /**
- * Unit tests for the {@code GenericArrayType}s created by the {@link $Gson$Types} class.
+ * Unit tests for the {@code GenericArrayType}s created by the {@link GsonTypes} class.
  *
  * @author Inderjeet Singh
  * @author Joel Leitch
@@ -38,8 +38,7 @@ public class GenericArrayTypeTest {
   @Before
   public void setUp() throws Exception {
     ourType =
-        $Gson$Types.arrayOf(
-            $Gson$Types.newParameterizedTypeWithOwner(null, List.class, String.class));
+        GsonTypes.arrayOf(GsonTypes.newParameterizedTypeWithOwner(null, List.class, String.class));
   }
 
   @Test
diff --git a/gson/src/test/java/com/google/gson/ParameterizedTypeFixtures.java b/gson/src/test/java/com/google/gson/ParameterizedTypeFixtures.java
index f606ec44d1..29b180e040 100644
--- a/gson/src/test/java/com/google/gson/ParameterizedTypeFixtures.java
+++ b/gson/src/test/java/com/google/gson/ParameterizedTypeFixtures.java
@@ -16,7 +16,7 @@
 
 package com.google.gson;
 
-import com.google.gson.internal.$Gson$Types;
+import com.google.gson.internal.GsonTypes;
 import com.google.gson.internal.Primitives;
 import java.lang.reflect.Method;
 import java.lang.reflect.ParameterizedType;
@@ -139,7 +139,7 @@ public MyParameterizedType<T> deserialize(
         JsonElement json, Type typeOfT, JsonDeserializationContext context)
         throws JsonParseException {
       Type genericClass = ((ParameterizedType) typeOfT).getActualTypeArguments()[0];
-      Class<?> rawType = $Gson$Types.getRawType(genericClass);
+      Class<?> rawType = GsonTypes.getRawType(genericClass);
       String className = rawType.getSimpleName();
       JsonElement jsonElement = json.getAsJsonObject().get(className);
 
diff --git a/gson/src/test/java/com/google/gson/ParameterizedTypeTest.java b/gson/src/test/java/com/google/gson/ParameterizedTypeTest.java
index ca837c540e..46cf1dcd4b 100644
--- a/gson/src/test/java/com/google/gson/ParameterizedTypeTest.java
+++ b/gson/src/test/java/com/google/gson/ParameterizedTypeTest.java
@@ -18,7 +18,7 @@
 
 import static com.google.common.truth.Truth.assertThat;
 
-import com.google.gson.internal.$Gson$Types;
+import com.google.gson.internal.GsonTypes;
 import com.google.gson.reflect.TypeToken;
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
@@ -27,7 +27,7 @@
 import org.junit.Test;
 
 /**
- * Unit tests for {@code ParameterizedType}s created by the {@link $Gson$Types} class.
+ * Unit tests for {@code ParameterizedType}s created by the {@link GsonTypes} class.
  *
  * @author Inderjeet Singh
  * @author Joel Leitch
@@ -37,7 +37,7 @@ public class ParameterizedTypeTest {
 
   @Before
   public void setUp() throws Exception {
-    ourType = $Gson$Types.newParameterizedTypeWithOwner(null, List.class, String.class);
+    ourType = GsonTypes.newParameterizedTypeWithOwner(null, List.class, String.class);
   }
 
   @Test
diff --git a/gson/src/test/java/com/google/gson/functional/MapTest.java b/gson/src/test/java/com/google/gson/functional/MapTest.java
index 04c18d46b0..b48484e224 100644
--- a/gson/src/test/java/com/google/gson/functional/MapTest.java
+++ b/gson/src/test/java/com/google/gson/functional/MapTest.java
@@ -32,7 +32,7 @@
 import com.google.gson.JsonSerializer;
 import com.google.gson.JsonSyntaxException;
 import com.google.gson.common.TestTypes;
-import com.google.gson.internal.$Gson$Types;
+import com.google.gson.internal.GsonTypes;
 import com.google.gson.internal.LinkedTreeMap;
 import com.google.gson.reflect.TypeToken;
 import java.lang.reflect.Type;
@@ -368,8 +368,7 @@ public void testMapSubclassDeserialization() {
 
   @Test
   public void testCustomSerializerForSpecificMapType() {
-    Type type =
-        $Gson$Types.newParameterizedTypeWithOwner(null, Map.class, String.class, Long.class);
+    Type type = GsonTypes.newParameterizedTypeWithOwner(null, Map.class, String.class, Long.class);
     Gson gson =
         new GsonBuilder()
             .registerTypeAdapter(
diff --git a/gson/src/test/java/com/google/gson/internal/GsonTypesTest.java b/gson/src/test/java/com/google/gson/internal/GsonTypesTest.java
index facfd62731..95eee256c8 100644
--- a/gson/src/test/java/com/google/gson/internal/GsonTypesTest.java
+++ b/gson/src/test/java/com/google/gson/internal/GsonTypesTest.java
@@ -33,25 +33,24 @@ public final class GsonTypesTest {
   @Test
   public void testNewParameterizedTypeWithoutOwner() throws Exception {
     // List<A>. List is a top-level class
-    ParameterizedType type = $Gson$Types.newParameterizedTypeWithOwner(null, List.class, A.class);
+    ParameterizedType type = GsonTypes.newParameterizedTypeWithOwner(null, List.class, A.class);
     assertThat(type.getOwnerType()).isNull();
     assertThat(type.getRawType()).isEqualTo(List.class);
     assertThat(type.getActualTypeArguments()).asList().containsExactly(A.class);
 
     // A<B>. A is a static inner class.
-    type = $Gson$Types.newParameterizedTypeWithOwner(null, A.class, B.class);
+    type = GsonTypes.newParameterizedTypeWithOwner(null, A.class, B.class);
     assertThat(getFirstTypeArgument(type)).isEqualTo(B.class);
 
     IllegalArgumentException e =
         assertThrows(
             IllegalArgumentException.class,
             // NonStaticInner<A> is not allowed without owner
-            () -> $Gson$Types.newParameterizedTypeWithOwner(null, NonStaticInner.class, A.class));
+            () -> GsonTypes.newParameterizedTypeWithOwner(null, NonStaticInner.class, A.class));
     assertThat(e).hasMessageThat().isEqualTo("Must specify owner type for " + NonStaticInner.class);
 
     type =
-        $Gson$Types.newParameterizedTypeWithOwner(
-            GsonTypesTest.class, NonStaticInner.class, A.class);
+        GsonTypes.newParameterizedTypeWithOwner(GsonTypesTest.class, NonStaticInner.class, A.class);
     assertThat(type.getOwnerType()).isEqualTo(GsonTypesTest.class);
     assertThat(type.getRawType()).isEqualTo(NonStaticInner.class);
     assertThat(type.getActualTypeArguments()).asList().containsExactly(A.class);
@@ -59,13 +58,13 @@ public void testNewParameterizedTypeWithoutOwner() throws Exception {
     final class D {}
 
     // D<A> is allowed since D has no owner type
-    type = $Gson$Types.newParameterizedTypeWithOwner(null, D.class, A.class);
+    type = GsonTypes.newParameterizedTypeWithOwner(null, D.class, A.class);
     assertThat(type.getOwnerType()).isNull();
     assertThat(type.getRawType()).isEqualTo(D.class);
     assertThat(type.getActualTypeArguments()).asList().containsExactly(A.class);
 
     // A<D> is allowed.
-    type = $Gson$Types.newParameterizedTypeWithOwner(null, A.class, D.class);
+    type = GsonTypes.newParameterizedTypeWithOwner(null, A.class, D.class);
     assertThat(getFirstTypeArgument(type)).isEqualTo(D.class);
   }
 
@@ -73,7 +72,7 @@ final class D {}
   public void testGetFirstTypeArgument() throws Exception {
     assertThat(getFirstTypeArgument(A.class)).isNull();
 
-    Type type = $Gson$Types.newParameterizedTypeWithOwner(null, A.class, B.class, C.class);
+    Type type = GsonTypes.newParameterizedTypeWithOwner(null, A.class, B.class, C.class);
     assertThat(getFirstTypeArgument(type)).isEqualTo(B.class);
   }
 
@@ -99,7 +98,7 @@ public static Type getFirstTypeArgument(Type type) throws Exception {
     if (actualTypeArguments.length == 0) {
       return null;
     }
-    return $Gson$Types.canonicalize(actualTypeArguments[0]);
+    return GsonTypes.canonicalize(actualTypeArguments[0]);
   }
 
   @Test
@@ -110,7 +109,7 @@ public void testEqualsOnMethodTypeVariables() throws Exception {
     Type rt1 = m1.getGenericReturnType();
     Type rt2 = m2.getGenericReturnType();
 
-    assertThat($Gson$Types.equals(rt1, rt2)).isTrue();
+    assertThat(GsonTypes.equals(rt1, rt2)).isTrue();
   }
 
   @Test
@@ -121,7 +120,7 @@ public void testEqualsOnConstructorParameterTypeVariables() throws Exception {
     Type rt1 = c1.getGenericParameterTypes()[0];
     Type rt2 = c2.getGenericParameterTypes()[0];
 
-    assertThat($Gson$Types.equals(rt1, rt2)).isTrue();
+    assertThat(GsonTypes.equals(rt1, rt2)).isTrue();
   }
 
   private static final class TypeVariableTest {
@@ -141,8 +140,7 @@ class CustomProperties extends Properties {
       private static final long serialVersionUID = 4112578634029874840L;
     }
 
-    Type[] types =
-        $Gson$Types.getMapKeyAndValueTypes(CustomProperties.class, CustomProperties.class);
+    Type[] types = GsonTypes.getMapKeyAndValueTypes(CustomProperties.class, CustomProperties.class);
 
     assertThat(types[0]).isEqualTo(String.class);
     assertThat(types[1]).isEqualTo(String.class);
diff --git a/gson/src/test/java/com/google/gson/internal/bind/RecursiveTypesResolveTest.java b/gson/src/test/java/com/google/gson/internal/bind/RecursiveTypesResolveTest.java
index 78d253dfb0..b30df4cac6 100644
--- a/gson/src/test/java/com/google/gson/internal/bind/RecursiveTypesResolveTest.java
+++ b/gson/src/test/java/com/google/gson/internal/bind/RecursiveTypesResolveTest.java
@@ -20,11 +20,11 @@
 
 import com.google.gson.Gson;
 import com.google.gson.TypeAdapter;
-import com.google.gson.internal.$Gson$Types;
+import com.google.gson.internal.GsonTypes;
 import org.junit.Test;
 
 /**
- * Test fixes for infinite recursion on {@link $Gson$Types#resolve(java.lang.reflect.Type, Class,
+ * Test fixes for infinite recursion on {@link GsonTypes#resolve(java.lang.reflect.Type, Class,
  * java.lang.reflect.Type)}, described at <a href="https://github.com/google/gson/issues/440">Issue
  * #440</a> and similar issues.
  *
@@ -55,26 +55,26 @@ public void testRecursiveResolveSimple() {
   /** Tests below check the behavior of the methods changed for the fix. */
   @Test
   public void testDoubleSupertype() {
-    assertThat($Gson$Types.supertypeOf($Gson$Types.supertypeOf(Number.class)))
-        .isEqualTo($Gson$Types.supertypeOf(Number.class));
+    assertThat(GsonTypes.supertypeOf(GsonTypes.supertypeOf(Number.class)))
+        .isEqualTo(GsonTypes.supertypeOf(Number.class));
   }
 
   @Test
   public void testDoubleSubtype() {
-    assertThat($Gson$Types.subtypeOf($Gson$Types.subtypeOf(Number.class)))
-        .isEqualTo($Gson$Types.subtypeOf(Number.class));
+    assertThat(GsonTypes.subtypeOf(GsonTypes.subtypeOf(Number.class)))
+        .isEqualTo(GsonTypes.subtypeOf(Number.class));
   }
 
   @Test
   public void testSuperSubtype() {
-    assertThat($Gson$Types.supertypeOf($Gson$Types.subtypeOf(Number.class)))
-        .isEqualTo($Gson$Types.subtypeOf(Object.class));
+    assertThat(GsonTypes.supertypeOf(GsonTypes.subtypeOf(Number.class)))
+        .isEqualTo(GsonTypes.subtypeOf(Object.class));
   }
 
   @Test
   public void testSubSupertype() {
-    assertThat($Gson$Types.subtypeOf($Gson$Types.supertypeOf(Number.class)))
-        .isEqualTo($Gson$Types.subtypeOf(Object.class));
+    assertThat(GsonTypes.subtypeOf(GsonTypes.supertypeOf(Number.class)))
+        .isEqualTo(GsonTypes.subtypeOf(Object.class));
   }
 
   /** Tests for recursion while resolving type variables. */
diff --git a/gson/src/test/java/com/google/gson/reflect/TypeTokenTest.java b/gson/src/test/java/com/google/gson/reflect/TypeTokenTest.java
index ddc6b92973..eb2e76ed43 100644
--- a/gson/src/test/java/com/google/gson/reflect/TypeTokenTest.java
+++ b/gson/src/test/java/com/google/gson/reflect/TypeTokenTest.java
@@ -95,7 +95,7 @@ public void testIsAssignableFromWithBasicWildcards() throws Exception {
         .isEqualTo(
             "Unsupported type, expected one of: java.lang.Class,"
                 + " java.lang.reflect.ParameterizedType, java.lang.reflect.GenericArrayType, but"
-                + " got: com.google.gson.internal.$Gson$Types$WildcardTypeImpl, for type token: "
+                + " got: com.google.gson.internal.GsonTypes$WildcardTypeImpl, for type token: "
                 + wildcardTypeToken);
   }
 
