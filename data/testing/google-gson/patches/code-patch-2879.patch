diff --git a/gson/src/main/java/com/google/gson/GsonBuilder.java b/gson/src/main/java/com/google/gson/GsonBuilder.java
index f0ea0ae4c8..5879973223 100644
--- a/gson/src/main/java/com/google/gson/GsonBuilder.java
+++ b/gson/src/main/java/com/google/gson/GsonBuilder.java
@@ -33,7 +33,6 @@
 import com.google.gson.annotations.Since;
 import com.google.gson.annotations.Until;
 import com.google.gson.internal.Excluder;
-import com.google.gson.internal.GsonPreconditions;
 import com.google.gson.internal.bind.DefaultDateTypeAdapter;
 import com.google.gson.internal.bind.TreeTypeAdapter;
 import com.google.gson.internal.bind.TypeAdapters;
@@ -704,11 +703,16 @@ private static int checkDateFormatStyle(int style) {
   @CanIgnoreReturnValue
   public GsonBuilder registerTypeAdapter(Type type, Object typeAdapter) {
     Objects.requireNonNull(type);
-    GsonPreconditions.checkArgument(
-        typeAdapter instanceof JsonSerializer<?>
-            || typeAdapter instanceof JsonDeserializer<?>
-            || typeAdapter instanceof InstanceCreator<?>
-            || typeAdapter instanceof TypeAdapter<?>);
+    Objects.requireNonNull(typeAdapter);
+    if (!(typeAdapter instanceof JsonSerializer<?>
+        || typeAdapter instanceof JsonDeserializer<?>
+        || typeAdapter instanceof InstanceCreator<?>
+        || typeAdapter instanceof TypeAdapter<?>)) {
+      throw new IllegalArgumentException(
+          "Class "
+              + typeAdapter.getClass().getName()
+              + " does not implement any supported type adapter class or interface");
+    }
 
     if (hasNonOverridableAdapter(type)) {
       throw new IllegalArgumentException("Cannot override built-in adapter for " + type);
@@ -778,10 +782,15 @@ public GsonBuilder registerTypeAdapterFactory(TypeAdapterFactory factory) {
   @CanIgnoreReturnValue
   public GsonBuilder registerTypeHierarchyAdapter(Class<?> baseType, Object typeAdapter) {
     Objects.requireNonNull(baseType);
-    GsonPreconditions.checkArgument(
-        typeAdapter instanceof JsonSerializer<?>
-            || typeAdapter instanceof JsonDeserializer<?>
-            || typeAdapter instanceof TypeAdapter<?>);
+    Objects.requireNonNull(typeAdapter);
+    if (!(typeAdapter instanceof JsonSerializer<?>
+        || typeAdapter instanceof JsonDeserializer<?>
+        || typeAdapter instanceof TypeAdapter<?>)) {
+      throw new IllegalArgumentException(
+          "Class "
+              + typeAdapter.getClass().getName()
+              + " does not implement any supported type adapter class or interface");
+    }
 
     if (typeAdapter instanceof JsonDeserializer || typeAdapter instanceof JsonSerializer) {
       hierarchyFactories.add(TreeTypeAdapter.newTypeHierarchyFactory(baseType, typeAdapter));
diff --git a/gson/src/main/java/com/google/gson/internal/GsonPreconditions.java b/gson/src/main/java/com/google/gson/internal/GsonPreconditions.java
deleted file mode 100644
index 780d26e957..0000000000
--- a/gson/src/main/java/com/google/gson/internal/GsonPreconditions.java
+++ /dev/null
@@ -1,43 +0,0 @@
-/*
- * Copyright (C) 2008 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.google.gson.internal;
-
-/**
- * A simple utility class used to check method Preconditions.
- *
- * <pre>
- * public long divideBy(long value) {
- *   Preconditions.checkArgument(value != 0);
- *   return this.value / value;
- * }
- * </pre>
- *
- * @author Inderjeet Singh
- * @author Joel Leitch
- */
-@SuppressWarnings("MemberName") // legacy class name
-public final class GsonPreconditions {
-  private GsonPreconditions() {
-    throw new UnsupportedOperationException();
-  }
-
-  public static void checkArgument(boolean condition) {
-    if (!condition) {
-      throw new IllegalArgumentException();
-    }
-  }
-}
diff --git a/gson/src/main/java/com/google/gson/internal/GsonTypes.java b/gson/src/main/java/com/google/gson/internal/GsonTypes.java
index a29d142cbb..caaad3b46c 100644
--- a/gson/src/main/java/com/google/gson/internal/GsonTypes.java
+++ b/gson/src/main/java/com/google/gson/internal/GsonTypes.java
@@ -16,7 +16,6 @@
 
 package com.google.gson.internal;
 
-import static com.google.gson.internal.GsonPreconditions.checkArgument;
 import static java.util.Objects.requireNonNull;
 
 import java.io.Serializable;
@@ -139,7 +138,6 @@ public static Class<?> getRawType(Type type) {
       // getRawType() returns Type instead of Class; that seems to be an API mistake,
       // see https://bugs.openjdk.org/browse/JDK-8250659
       Type rawType = parameterizedType.getRawType();
-      checkArgument(rawType instanceof Class);
       return (Class<?>) rawType;
 
     } else if (type instanceof GenericArrayType) {
@@ -286,7 +284,10 @@ private static Type getSupertype(Type context, Class<?> contextRawType, Class<?>
       assert bounds.length == 1;
       context = bounds[0];
     }
-    checkArgument(supertype.isAssignableFrom(contextRawType));
+    if (!supertype.isAssignableFrom(contextRawType)) {
+      throw new IllegalArgumentException(
+          contextRawType + " is not the same as or a subtype of " + supertype);
+    }
     return resolve(
         context, contextRawType, GsonTypes.getGenericSupertype(context, contextRawType, supertype));
   }
@@ -485,7 +486,9 @@ private static Class<?> declaringClassOf(TypeVariable<?> typeVariable) {
   }
 
   static void checkNotPrimitive(Type type) {
-    checkArgument(!(type instanceof Class<?>) || !((Class<?>) type).isPrimitive());
+    if (type instanceof Class<?> && ((Class<?>) type).isPrimitive()) {
+      throw new IllegalArgumentException("Primitive type is not allowed");
+    }
   }
 
   /**
@@ -632,13 +635,20 @@ private static final class WildcardTypeImpl implements WildcardType, Serializabl
     private final Type lowerBound;
 
     public WildcardTypeImpl(Type[] upperBounds, Type[] lowerBounds) {
-      checkArgument(lowerBounds.length <= 1);
-      checkArgument(upperBounds.length == 1);
+      if (lowerBounds.length > 1) {
+        throw new IllegalArgumentException("At most one lower bound is supported");
+      }
+      if (upperBounds.length != 1) {
+        throw new IllegalArgumentException("Exactly one upper bound must be specified");
+      }
 
       if (lowerBounds.length == 1) {
         requireNonNull(lowerBounds[0]);
         checkNotPrimitive(lowerBounds[0]);
-        checkArgument(upperBounds[0] == Object.class);
+        if (upperBounds[0] != Object.class) {
+          throw new IllegalArgumentException(
+              "When lower bound is specified, upper bound must be Object");
+        }
         this.lowerBound = canonicalize(lowerBounds[0]);
         this.upperBound = Object.class;
 
diff --git a/gson/src/main/java/com/google/gson/internal/bind/TreeTypeAdapter.java b/gson/src/main/java/com/google/gson/internal/bind/TreeTypeAdapter.java
index 67d7cdf873..62ea14d383 100644
--- a/gson/src/main/java/com/google/gson/internal/bind/TreeTypeAdapter.java
+++ b/gson/src/main/java/com/google/gson/internal/bind/TreeTypeAdapter.java
@@ -25,13 +25,13 @@
 import com.google.gson.JsonSerializer;
 import com.google.gson.TypeAdapter;
 import com.google.gson.TypeAdapterFactory;
-import com.google.gson.internal.GsonPreconditions;
 import com.google.gson.internal.Streams;
 import com.google.gson.reflect.TypeToken;
 import com.google.gson.stream.JsonReader;
 import com.google.gson.stream.JsonWriter;
 import java.io.IOException;
 import java.lang.reflect.Type;
+import java.util.Objects;
 
 /**
  * Adapts a Gson 1.x tree-style adapter as a streaming TypeAdapter. Since the tree adapter may be
@@ -162,7 +162,13 @@ private static final class SingleTypeFactory implements TypeAdapterFactory {
       serializer = typeAdapter instanceof JsonSerializer ? (JsonSerializer<?>) typeAdapter : null;
       deserializer =
           typeAdapter instanceof JsonDeserializer ? (JsonDeserializer<?>) typeAdapter : null;
-      GsonPreconditions.checkArgument(serializer != null || deserializer != null);
+      if (serializer == null && deserializer == null) {
+        Objects.requireNonNull(typeAdapter);
+        throw new IllegalArgumentException(
+            "Type adapter "
+                + typeAdapter.getClass().getName()
+                + " must implement JsonSerializer or JsonDeserializer");
+      }
       this.exactType = exactType;
       this.matchRawType = matchRawType;
       this.hierarchyType = hierarchyType;
