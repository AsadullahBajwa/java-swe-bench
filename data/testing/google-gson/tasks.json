[ {
  "instance_id" : "google-gson-PR-2967",
  "repo" : "google/gson",
  "base_commit" : "c47db7bc13875db690bcfb76e02b1e1bbb3a3353",
  "patch" : "diff --git a/gson/pom.xml b/gson/pom.xml\nindex 10969fb8a9..0d03552ce0 100644\n--- a/gson/pom.xml\n+++ b/gson/pom.xml\n@@ -50,7 +50,7 @@\n     <dependency>\n       <groupId>com.google.errorprone</groupId>\n       <artifactId>error_prone_annotations</artifactId>\n-      <version>2.43.0</version>\n+      <version>2.45.0</version>\n     </dependency>\n \n     <dependency>\n@@ -211,7 +211,7 @@\n           <dependency>\n             <groupId>com.guardsquare</groupId>\n             <artifactId>proguard-base</artifactId>\n-            <version>7.8.0</version>\n+            <version>7.8.2</version>\n           </dependency>\n           <dependency>\n             <groupId>com.guardsquare</groupId>\n@@ -235,7 +235,7 @@\n       <plugin>\n         <groupId>org.apache.maven.plugins</groupId>\n         <artifactId>maven-resources-plugin</artifactId>\n-        <version>3.3.1</version>\n+        <version>3.4.0</version>\n         <executions>\n           <execution>\n             <id>pre-obfuscate-class</id>\ndiff --git a/pom.xml b/pom.xml\nindex 61e6d84787..0277a5b7fe 100644\n--- a/pom.xml\n+++ b/pom.xml\n@@ -132,7 +132,7 @@\n       <plugin>\n         <groupId>com.diffplug.spotless</groupId>\n         <artifactId>spotless-maven-plugin</artifactId>\n-        <version>3.0.0</version>\n+        <version>3.1.0</version>\n         <executions>\n           <execution>\n             <goals>\n@@ -293,7 +293,7 @@\n               <path>\n                 <groupId>com.google.errorprone</groupId>\n                 <artifactId>error_prone_core</artifactId>\n-                <version>2.43.0</version>\n+                <version>2.45.0</version>\n               </path>\n             </annotationProcessorPaths>\n           </configuration>\n@@ -341,7 +341,7 @@\n         <plugin>\n           <groupId>org.apache.maven.plugins</groupId>\n           <artifactId>maven-jar-plugin</artifactId>\n-          <version>3.4.2</version>\n+          <version>3.5.0</version>\n         </plugin>\n         <plugin>\n           <groupId>org.apache.maven.plugins</groupId>\n@@ -354,7 +354,7 @@\n         <plugin>\n           <groupId>org.apache.maven.plugins</groupId>\n           <artifactId>maven-source-plugin</artifactId>\n-          <version>3.3.1</version>\n+          <version>3.4.0</version>\n           <configuration>\n             <skipSource>${gson.isTestModule}</skipSource>\n           </configuration>\n@@ -388,7 +388,7 @@\n         <plugin>\n           <groupId>org.apache.maven.plugins</groupId>\n           <artifactId>maven-release-plugin</artifactId>\n-          <version>3.1.1</version>\n+          <version>3.3.0</version>\n           <configuration>\n             <autoVersionSubmodules>true</autoVersionSubmodules>\n             <!-- Disable Maven Super POM release profile and instead use own one -->\ndiff --git a/proto/pom.xml b/proto/pom.xml\nindex 53057bf09b..02589da25d 100644\n--- a/proto/pom.xml\n+++ b/proto/pom.xml\n@@ -31,7 +31,7 @@\n     <!-- This is duplicated here because that is recommended by `artifact:check-buildplan` -->\n     <project.build.outputTimestamp>2025-09-10T20:39:14Z</project.build.outputTimestamp>\n \n-    <protobufVersion>4.33.0</protobufVersion>\n+    <protobufVersion>4.33.1</protobufVersion>\n   </properties>\n \n   <licenses>\ndiff --git a/test-shrinker/pom.xml b/test-shrinker/pom.xml\nindex 996f8ad079..fd9cfd148c 100644\n--- a/test-shrinker/pom.xml\n+++ b/test-shrinker/pom.xml\n@@ -79,7 +79,7 @@\n           <dependency>\n             <groupId>com.guardsquare</groupId>\n             <artifactId>proguard-base</artifactId>\n-            <version>7.8.0</version>\n+            <version>7.8.2</version>\n           </dependency>\n           <dependency>\n             <groupId>com.guardsquare</groupId>\n@@ -189,7 +189,7 @@\n               but it appears that can be ignored -->\n             <groupId>com.android.tools</groupId>\n             <artifactId>r8</artifactId>\n-            <version>8.11.18</version>\n+            <version>8.13.17</version>\n           </dependency>\n         </dependencies>\n       </plugin>\n",
  "test_patch" : "diff --git a/gson/src/test/java/com/google/gson/functional/DefaultTypeAdaptersTest.java b/gson/src/test/java/com/google/gson/functional/DefaultTypeAdaptersTest.java\nindex 79eeadb8b9..6dac057a8e 100644\n--- a/gson/src/test/java/com/google/gson/functional/DefaultTypeAdaptersTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/DefaultTypeAdaptersTest.java\n@@ -538,11 +538,11 @@ public void testDateSerializationWithStyle() {\n \n         Gson gson = new GsonBuilder().setDateFormat(dateStyle, timeStyle).create();\n         String json = gson.toJson(date);\n-        assertWithMessage(\"dateStyle=\" + dateStyle + \", timeStyle=\" + timeStyle)\n+        assertWithMessage(\"dateStyle=%s, timeStyle=%s\", dateStyle, timeStyle)\n             .that(json)\n             .isEqualTo(\"\\\"\" + expectedFormatted + \"\\\"\");\n \n-        assertWithMessage(\"dateStyle=\" + dateStyle + \", timeStyle=\" + timeStyle)\n+        assertWithMessage(\"dateStyle=%s, timeStyle=%s\", dateStyle, timeStyle)\n             .that(gson.fromJson(json, Date.class).getTime())\n             .isEqualTo(date.getTime());\n       }\n@@ -568,11 +568,11 @@ public void testDateSerializationWithDateStyle() {\n \n       Gson gson = new GsonBuilder().setDateFormat(dateStyle).create();\n       String json = gson.toJson(date);\n-      assertWithMessage(\"dateStyle=\" + dateStyle)\n+      assertWithMessage(\"dateStyle=%s\", dateStyle)\n           .that(json)\n           .isEqualTo(\"\\\"\" + expectedFormatted + \"\\\"\");\n \n-      assertWithMessage(\"dateStyle=\" + dateStyle)\n+      assertWithMessage(\"dateStyle=%s\", dateStyle)\n           .that(gson.fromJson(json, Date.class).getTime())\n           .isEqualTo(date.getTime());\n     }\ndiff --git a/gson/src/test/java/com/google/gson/internal/ConstructorConstructorTest.java b/gson/src/test/java/com/google/gson/internal/ConstructorConstructorTest.java\nindex f4e8029260..102eaf7e06 100644\n--- a/gson/src/test/java/com/google/gson/internal/ConstructorConstructorTest.java\n+++ b/gson/src/test/java/com/google/gson/internal/ConstructorConstructorTest.java\n@@ -126,8 +126,7 @@ public void testCustomCollectionCreation() {\n           constructorConstructor\n               .get(TypeToken.getParameterized(collectionType, Integer.class))\n               .construct();\n-      assertWithMessage(\n-              \"Failed for \" + collectionType + \"; created instance of \" + actual.getClass())\n+      assertWithMessage(\"Failed for %s; created instance of %s\", collectionType, actual.getClass())\n           .that(actual)\n           .isInstanceOf(collectionType);\n     }\n@@ -182,7 +181,7 @@ public void testStringMapCreation() {\n               .get(TypeToken.getParameterized(Map.class, keyType, Integer.class))\n               .construct();\n       assertWithMessage(\n-              \"Failed for key type \" + keyType + \"; created instance of \" + actual.getClass())\n+              \"Failed for key type %s; created instance of %s\", keyType, actual.getClass())\n           .that(actual)\n           .isInstanceOf(LinkedHashMap.class);\n     }\n@@ -249,7 +248,7 @@ public void testCustomMapCreation() {\n           constructorConstructor\n               .get(TypeToken.getParameterized(mapType, String.class, Integer.class))\n               .construct();\n-      assertWithMessage(\"Failed for \" + mapType + \"; created instance of \" + actual.getClass())\n+      assertWithMessage(\"Failed for %s; created instance of %s\", mapType, actual.getClass())\n           .that(actual)\n           .isInstanceOf(mapType);\n     }\n",
  "problem_statement" : "Bump the maven group across 1 directory with 14 updates\n\nThis is a copy of @dependabot's #2964 but with a few changes reverted that cause problems, and some test updates to fix ErrorProne warnings.\r\n\r\nBumps the maven group with several updates in the / directory:\r\n\r\n| Package | From | To |\r\n| --- | --- | --- |\r\n| [com.google.errorprone:error_prone_core](https://github.com/google/error-prone) | `2.43.0` | `2.45.0` | | [com.diffplug.spotless:spotless-maven-plugin](https://github.com/diffplug/spotless) | `3.0.0` | `3.1.0` | | [org.apache.maven.plugins:maven-jar-plugin](https://github.com/apache/maven-jar-plugin) | `3.4.2` | `3.5.0` | | [org.apache.maven.plugins:maven-source-plugin](https://github.com/apache/maven-source-plugin) | `3.3.1` | `3.4.0` | | [org.apache.maven.plugins:maven-release-plugin](https://github.com/apache/maven-release) | `3.1.1` | `3.3.0` | | [com.github.siom79.japicmp:japicmp-maven-plugin](https://github.com/siom79/japicmp) | `0.24.2` | `0.25.0` | | [com.google.errorprone:error_prone_annotations](https://github.com/google/error-prone) | `2.43.0` | `2.45.0` | | [com.guardsquare:proguard-base](https://github.com/Guardsquare/proguard) | `7.8.0` | `7.8.2` | | [org.apache.maven.plugins:maven-resources-plugin](https://github.com/apache/maven-resources-plugin) | `3.3.1` | `3.4.0` | | [org.junit:junit-bom](https://github.com/junit-team/junit-framework) | `6.0.0` | `6.0.1` | | [org.graalvm.buildtools:native-maven-plugin](https://github.com/graalvm/native-build-tools) | `0.11.2` | `0.11.3` | | com.android.tools:r8 | `8.11.18` | `8.13.17` |\r\n| [com.google.protobuf:protobuf-java](https://github.com/protocolbuffers/protobuf) | `4.33.0` | `4.33.1` | | [io.github.ascopes:protobuf-maven-plugin](https://github.com/ascopes/protobuf-maven-plugin) | `4.0.2` | `4.0.3` |\r\n\r\n\r\n\r\nUpdates `com.google.errorprone:error_prone_core` from 2.43.0 to 2.45.0\r\n- [Release notes](https://github.com/google/error-prone/releases)\r\n- [Commits](https://github.com/google/error-prone/compare/v2.43.0...v2.45.0)\r\n\r\nUpdates `com.diffplug.spotless:spotless-maven-plugin` from 3.0.0 to 3.1.0\r\n- [Release notes](https://github.com/diffplug/spotless/releases)\r\n- [Changelog](https://github.com/diffplug/spotless/blob/main/CHANGES.md)\r\n- [Commits](https://github.com/diffplug/spotless/compare/lib/3.0.0...lib/3.1.0)\r\n\r\nUpdates `org.apache.maven.plugins:maven-jar-plugin` from 3.4.2 to 3.5.0\r\n- [Release notes](https://github.com/apache/maven-jar-plugin/releases)\r\n- [Commits](https://github.com/apache/maven-jar-plugin/compare/maven-jar-plugin-3.4.2...maven-jar-plugin-3.5.0)\r\n\r\nUpdates `org.apache.maven.plugins:maven-source-plugin` from 3.3.1 to 3.4.0\r\n- [Release notes](https://github.com/apache/maven-source-plugin/releases)\r\n- [Commits](https://github.com/apache/maven-source-plugin/compare/maven-source-plugin-3.3.1...maven-source-plugin-3.4.0)\r\n\r\nUpdates `org.apache.maven.plugins:maven-release-plugin` from 3.1.1 to 3.3.0\r\n- [Release notes](https://github.com/apache/maven-release/releases)\r\n- [Commits](https://github.com/apache/maven-release/compare/maven-release-3.1.1...maven-release-3.3.0)\r\n\r\nUpdates `com.github.siom79.japicmp:japicmp-maven-plugin` from 0.24.2 to 0.25.0\r\n- [Release notes](https://github.com/siom79/japicmp/releases)\r\n- [Changelog](https://github.com/siom79/japicmp/blob/master/release.py)\r\n- [Commits](https://github.com/siom79/japicmp/compare/japicmp-base-0.24.2...japicmp-base-0.25.0)\r\n\r\nUpdates `com.google.errorprone:error_prone_annotations` from 2.43.0 to 2.45.0\r\n- [Release notes](https://github.com/google/error-prone/releases)\r\n- [Commits](https://github.com/google/error-prone/compare/v2.43.0...v2.45.0)\r\n\r\nUpdates `com.guardsquare:proguard-base` from 7.8.0 to 7.8.2\r\n- [Release notes](https://github.com/Guardsquare/proguard/releases)\r\n- [Commits](https://github.com/Guardsquare/proguard/compare/v7.8...v7.8.2)\r\n\r\nUpdates `org.apache.maven.plugins:maven-resources-plugin` from 3.3.1 to 3.4.0\r\n- [Release notes](https://github.com/apache/maven-resources-plugin/releases)\r\n- [Commits](https://github.com/apache/maven-resources-plugin/compare/maven-resources-plugin-3.3.1...v3.4.0)\r\n\r\nUpdates `org.junit:junit-bom` from 6.0.0 to 6.0.1\r\n- [Release notes](https://github.com/junit-team/junit-framework/releases)\r\n- [Commits](https://github.com/junit-team/junit-framework/compare/r6.0.0...r6.0.1)\r\n\r\nUpdates `org.graalvm.buildtools:native-maven-plugin` from 0.11.2 to 0.11.3\r\n- [Release notes](https://github.com/graalvm/native-build-tools/releases)\r\n- [Commits](https://github.com/graalvm/native-build-tools/compare/0.11.2...0.11.3)\r\n\r\nUpdates `com.android.tools:r8` from 8.11.18 to 8.13.17\r\n\r\nUpdates `com.google.protobuf:protobuf-java` from 4.33.0 to 4.33.1\r\n- [Release notes](https://github.com/protocolbuffers/protobuf/releases)\r\n- [Commits](https://github.com/protocolbuffers/protobuf/commits)\r\n\r\nUpdates `io.github.ascopes:protobuf-maven-plugin` from 4.0.2 to 4.0.3\r\n- [Release notes](https://github.com/ascopes/protobuf-maven-plugin/releases)\r\n- [Commits](https://github.com/ascopes/protobuf-maven-plugin/compare/v4.0.2...v4.0.3)\r\n\r\n---\r\nupdated-dependencies:\r\n- dependency-name: com.google.errorprone:error_prone_core dependency-version: 2.45.0 dependency-type: direct:production update-type: version-update:semver-minor dependency-group: maven\r\n- dependency-name: com.diffplug.spotless:spotless-maven-plugin dependency-version: 3.1.0 dependency-type: direct:production update-type: version-update:semver-minor dependency-group: maven\r\n- dependency-name: org.apache.maven.plugins:maven-jar-plugin dependency-version: 3.5.0 dependency-type: direct:production update-type: version-update:semver-minor dependency-group: maven\r\n- dependency-name: org.apache.maven.plugins:maven-source-plugin dependency-version: 3.4.0 dependency-type: direct:production update-type: version-update:semver-minor dependency-group: maven\r\n- dependency-name: org.apache.maven.plugins:maven-release-plugin dependency-version: 3.3.0 dependency-type: direct:production update-type: version-update:semver-minor dependency-group: maven\r\n- dependency-name: com.github.siom79.japicmp:japicmp-maven-plugin dependency-version: 0.25.0 dependency-type: direct:production update-type: version-update:semver-minor dependency-group: maven\r\n- dependency-name: com.google.errorprone:error_prone_annotations dependency-version: 2.45.0 dependency-type: direct:production update-type: version-update:semver-minor dependency-group: maven\r\n- dependency-name: com.guardsquare:proguard-base dependency-version: 7.8.2 dependency-type: direct:production update-type: version-update:semver-patch dependency-group: maven\r\n- dependency-name: org.apache.maven.plugins:maven-resources-plugin dependency-version: 3.4.0 dependency-type: direct:production update-type: version-update:semver-minor dependency-group: maven\r\n- dependency-name: org.junit:junit-bom dependency-version: 6.0.1 dependency-type: direct:production update-type: version-update:semver-patch dependency-group: maven\r\n- dependency-name: org.graalvm.buildtools:native-maven-plugin dependency-version: 0.11.3 dependency-type: direct:production update-type: version-update:semver-patch dependency-group: maven\r\n- dependency-name: com.android.tools:r8 dependency-version: 8.13.17 dependency-type: direct:production update-type: version-update:semver-minor dependency-group: maven\r\n- dependency-name: com.google.protobuf:protobuf-java dependency-version: 4.33.1 dependency-type: direct:production update-type: version-update:semver-patch dependency-group: maven\r\n- dependency-name: io.github.ascopes:protobuf-maven-plugin dependency-version: 4.0.3 dependency-type: direct:production update-type: version-update:semver-patch dependency-group: maven ...\r\n\r\n",
  "hints_text" : null,
  "created_at" : "Wed Dec 24 20:53:25 CET 2025",
  "version" : null,
  "FAIL_TO_PASS" : [ "DefaultTypeAdaptersTest", "ConstructorConstructorTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=DefaultTypeAdaptersTest,ConstructorConstructorTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 2967,
  "metadata" : null
}, {
  "instance_id" : "google-gson-PR-2965",
  "repo" : "google/gson",
  "base_commit" : "d437954171858e0efd53f7720acf480f11176535",
  "patch" : "diff --git a/proto/pom.xml b/proto/pom.xml\nindex 7d0cc73495..53057bf09b 100644\n--- a/proto/pom.xml\n+++ b/proto/pom.xml\n@@ -79,7 +79,7 @@\n       <plugin>\n         <groupId>io.github.ascopes</groupId>\n         <artifactId>protobuf-maven-plugin</artifactId>\n-        <version>4.0.2</version>\n+        <version>4.0.3</version>\n         <configuration>\n           <skip>${maven.test.skip}</skip>\n           <protoc>${protobufVersion}</protoc>\n",
  "test_patch" : "diff --git a/gson/src/test/java/com/google/gson/integration/OSGiManifestIT.java b/gson/src/test/java/com/google/gson/integration/OSGiManifestIT.java\nindex 4182c05ca4..23294c30f5 100644\n--- a/gson/src/test/java/com/google/gson/integration/OSGiManifestIT.java\n+++ b/gson/src/test/java/com/google/gson/integration/OSGiManifestIT.java\n@@ -130,7 +130,12 @@ public void testImports() throws Exception {\n   public void testExports() {\n     String gsonVersion = GSON_VERSION.replace(\"-SNAPSHOT\", \"\");\n \n-    List<String> exports = splitPackages(getAttribute(\"Export-Package\"));\n+    // Sometimes the `uses` and `exports` clauses can end up in the opposite order, so we use a\n+    // quick substitution to canonicalize them.\n+    List<String> exports =\n+        splitPackages(getAttribute(\"Export-Package\")).stream()\n+            .map(line -> line.replaceAll(\"(;version=\\\".*\\\")(;uses:=\\\".*\\\")\", \"$2$1\"))\n+            .collect(Collectors.toList());\n     // When not running `mvn clean` the exports might differ slightly, see\n     // https://github.com/bndtools/bnd/issues/6221\n     assertWithMessage(\"Unexpected exports; make sure you are running `mvn clean ...`\")\n",
  "problem_statement" : "Update `OSGiManifestIT` not to depend on order.\n\nIt appears that sometimes the clauses being checked for appear in the other order, possibly because of a `HashMap` or the like somewhere in the guts of OSGi. I haven't seen this on GitHub, but I do see it when running locally with Google's JDK, which has more hash randomization.\r\n\r\nAlso update `protobuf-maven-plugin`.",
  "hints_text" : null,
  "created_at" : "Tue Dec 23 22:11:38 CET 2025",
  "version" : null,
  "FAIL_TO_PASS" : [ "OSGiManifestIT" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=OSGiManifestIT",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 2965,
  "metadata" : null
}, {
  "instance_id" : "google-gson-PR-2951",
  "repo" : "google/gson",
  "base_commit" : "ae9604c201b3ba44babc48e982e012b1d23b69c8",
  "patch" : "diff --git a/gson/src/main/java/com/google/gson/Gson.java b/gson/src/main/java/com/google/gson/Gson.java\nindex 2e904131d7..ab66f2cd2a 100644\n--- a/gson/src/main/java/com/google/gson/Gson.java\n+++ b/gson/src/main/java/com/google/gson/Gson.java\n@@ -16,11 +16,13 @@\n \n package com.google.gson;\n \n+import static com.google.gson.internal.bind.TypeAdapters.atomicLongAdapter;\n+import static com.google.gson.internal.bind.TypeAdapters.atomicLongArrayAdapter;\n+\n import com.google.gson.annotations.JsonAdapter;\n import com.google.gson.internal.ConstructorConstructor;\n import com.google.gson.internal.Excluder;\n import com.google.gson.internal.GsonBuildConfig;\n-import com.google.gson.internal.LazilyParsedNumber;\n import com.google.gson.internal.Primitives;\n import com.google.gson.internal.Streams;\n import com.google.gson.internal.bind.ArrayTypeAdapter;\n@@ -47,8 +49,6 @@\n import java.io.StringReader;\n import java.io.Writer;\n import java.lang.reflect.Type;\n-import java.math.BigDecimal;\n-import java.math.BigInteger;\n import java.text.DateFormat;\n import java.util.ArrayList;\n import java.util.Collections;\n@@ -337,14 +337,10 @@ public Gson() {\n     factories.add(TypeAdapters.BOOLEAN_FACTORY);\n     factories.add(TypeAdapters.BYTE_FACTORY);\n     factories.add(TypeAdapters.SHORT_FACTORY);\n-    TypeAdapter<Number> longAdapter = longAdapter(longSerializationPolicy);\n+    TypeAdapter<Number> longAdapter = longSerializationPolicy.typeAdapter();\n     factories.add(TypeAdapters.newFactory(long.class, Long.class, longAdapter));\n-    factories.add(\n-        TypeAdapters.newFactory(\n-            double.class, Double.class, doubleAdapter(serializeSpecialFloatingPointValues)));\n-    factories.add(\n-        TypeAdapters.newFactory(\n-            float.class, Float.class, floatAdapter(serializeSpecialFloatingPointValues)));\n+    factories.add(TypeAdapters.newFactory(double.class, Double.class, doubleAdapter()));\n+    factories.add(TypeAdapters.newFactory(float.class, Float.class, floatAdapter()));\n     factories.add(NumberTypeAdapter.getFactory(numberToNumberStrategy));\n     factories.add(TypeAdapters.ATOMIC_INTEGER_FACTORY);\n     factories.add(TypeAdapters.ATOMIC_BOOLEAN_FACTORY);\n@@ -355,12 +351,11 @@ public Gson() {\n     factories.add(TypeAdapters.CHARACTER_FACTORY);\n     factories.add(TypeAdapters.STRING_BUILDER_FACTORY);\n     factories.add(TypeAdapters.STRING_BUFFER_FACTORY);\n-    factories.add(TypeAdapters.newFactory(BigDecimal.class, TypeAdapters.BIG_DECIMAL));\n-    factories.add(TypeAdapters.newFactory(BigInteger.class, TypeAdapters.BIG_INTEGER));\n+    factories.add(TypeAdapters.BIG_DECIMAL_FACTORY);\n+    factories.add(TypeAdapters.BIG_INTEGER_FACTORY);\n     // Add adapter for LazilyParsedNumber because user can obtain it from Gson and then try to\n     // serialize it again\n-    factories.add(\n-        TypeAdapters.newFactory(LazilyParsedNumber.class, TypeAdapters.LAZILY_PARSED_NUMBER));\n+    factories.add(TypeAdapters.LAZILY_PARSED_NUMBER_FACTORY);\n     factories.add(TypeAdapters.URL_FACTORY);\n     factories.add(TypeAdapters.URI_FACTORY);\n     factories.add(TypeAdapters.UUID_FACTORY);\n@@ -370,17 +365,11 @@ public Gson() {\n     factories.add(TypeAdapters.BIT_SET_FACTORY);\n     factories.add(DefaultDateTypeAdapter.DEFAULT_STYLE_FACTORY);\n     factories.add(TypeAdapters.CALENDAR_FACTORY);\n+    factories.addAll(SqlTypesSupport.SQL_TYPE_FACTORIES);\n     TypeAdapterFactory javaTimeFactory = TypeAdapters.javaTimeTypeAdapterFactory();\n     if (javaTimeFactory != null) {\n       factories.add(javaTimeFactory);\n     }\n-\n-    if (SqlTypesSupport.SUPPORTS_SQL_TYPES) {\n-      factories.add(SqlTypesSupport.TIME_FACTORY);\n-      factories.add(SqlTypesSupport.DATE_FACTORY);\n-      factories.add(SqlTypesSupport.TIMESTAMP_FACTORY);\n-    }\n-\n     factories.add(ArrayTypeAdapter.FACTORY);\n     factories.add(TypeAdapters.CLASS_FACTORY);\n \n@@ -450,141 +439,12 @@ public boolean htmlSafe() {\n     return htmlSafe;\n   }\n \n-  private TypeAdapter<Number> doubleAdapter(boolean serializeSpecialFloatingPointValues) {\n-    if (serializeSpecialFloatingPointValues) {\n-      return TypeAdapters.DOUBLE;\n-    }\n-    return new TypeAdapter<Number>() {\n-      @Override\n-      public Double read(JsonReader in) throws IOException {\n-        if (in.peek() == JsonToken.NULL) {\n-          in.nextNull();\n-          return null;\n-        }\n-        return in.nextDouble();\n-      }\n-\n-      @Override\n-      public void write(JsonWriter out, Number value) throws IOException {\n-        if (value == null) {\n-          out.nullValue();\n-          return;\n-        }\n-        double doubleValue = value.doubleValue();\n-        checkValidFloatingPoint(doubleValue);\n-        out.value(doubleValue);\n-      }\n-    };\n-  }\n-\n-  private TypeAdapter<Number> floatAdapter(boolean serializeSpecialFloatingPointValues) {\n-    if (serializeSpecialFloatingPointValues) {\n-      return TypeAdapters.FLOAT;\n-    }\n-    return new TypeAdapter<Number>() {\n-      @Override\n-      public Float read(JsonReader in) throws IOException {\n-        if (in.peek() == JsonToken.NULL) {\n-          in.nextNull();\n-          return null;\n-        }\n-        return (float) in.nextDouble();\n-      }\n-\n-      @Override\n-      public void write(JsonWriter out, Number value) throws IOException {\n-        if (value == null) {\n-          out.nullValue();\n-          return;\n-        }\n-        float floatValue = value.floatValue();\n-        checkValidFloatingPoint(floatValue);\n-        // For backward compatibility don't call `JsonWriter.value(float)` because that method has\n-        // been newly added and not all custom JsonWriter implementations might override it yet\n-        Number floatNumber = value instanceof Float ? value : floatValue;\n-        out.value(floatNumber);\n-      }\n-    };\n-  }\n-\n-  static void checkValidFloatingPoint(double value) {\n-    if (Double.isNaN(value) || Double.isInfinite(value)) {\n-      throw new IllegalArgumentException(\n-          value\n-              + \" is not a valid double value as per JSON specification. To override this\"\n-              + \" behavior, use GsonBuilder.serializeSpecialFloatingPointValues() method.\");\n-    }\n-  }\n-\n-  private static TypeAdapter<Number> longAdapter(LongSerializationPolicy longSerializationPolicy) {\n-    if (longSerializationPolicy == LongSerializationPolicy.DEFAULT) {\n-      return TypeAdapters.LONG;\n-    }\n-    return new TypeAdapter<Number>() {\n-      @Override\n-      public Number read(JsonReader in) throws IOException {\n-        if (in.peek() == JsonToken.NULL) {\n-          in.nextNull();\n-          return null;\n-        }\n-        return in.nextLong();\n-      }\n-\n-      @Override\n-      public void write(JsonWriter out, Number value) throws IOException {\n-        if (value == null) {\n-          out.nullValue();\n-          return;\n-        }\n-        out.value(value.toString());\n-      }\n-    };\n-  }\n-\n-  private static TypeAdapter<AtomicLong> atomicLongAdapter(TypeAdapter<Number> longAdapter) {\n-    return new TypeAdapter<AtomicLong>() {\n-      @Override\n-      public void write(JsonWriter out, AtomicLong value) throws IOException {\n-        longAdapter.write(out, value.get());\n-      }\n-\n-      @Override\n-      public AtomicLong read(JsonReader in) throws IOException {\n-        Number value = longAdapter.read(in);\n-        return new AtomicLong(value.longValue());\n-      }\n-    }.nullSafe();\n+  private TypeAdapter<Number> floatAdapter() {\n+    return serializeSpecialFloatingPointValues ? TypeAdapters.FLOAT : TypeAdapters.FLOAT_STRICT;\n   }\n \n-  private static TypeAdapter<AtomicLongArray> atomicLongArrayAdapter(\n-      TypeAdapter<Number> longAdapter) {\n-    return new TypeAdapter<AtomicLongArray>() {\n-      @Override\n-      public void write(JsonWriter out, AtomicLongArray value) throws IOException {\n-        out.beginArray();\n-        for (int i = 0, length = value.length(); i < length; i++) {\n-          longAdapter.write(out, value.get(i));\n-        }\n-        out.endArray();\n-      }\n-\n-      @Override\n-      public AtomicLongArray read(JsonReader in) throws IOException {\n-        List<Long> list = new ArrayList<>();\n-        in.beginArray();\n-        while (in.hasNext()) {\n-          long value = longAdapter.read(in).longValue();\n-          list.add(value);\n-        }\n-        in.endArray();\n-        int length = list.size();\n-        AtomicLongArray array = new AtomicLongArray(length);\n-        for (int i = 0; i < length; ++i) {\n-          array.set(i, list.get(i));\n-        }\n-        return array;\n-      }\n-    }.nullSafe();\n+  private TypeAdapter<Number> doubleAdapter() {\n+    return serializeSpecialFloatingPointValues ? TypeAdapters.DOUBLE : TypeAdapters.DOUBLE_STRICT;\n   }\n \n   /**\ndiff --git a/gson/src/main/java/com/google/gson/LongSerializationPolicy.java b/gson/src/main/java/com/google/gson/LongSerializationPolicy.java\nindex df7c8fa167..2e2f17a59a 100644\n--- a/gson/src/main/java/com/google/gson/LongSerializationPolicy.java\n+++ b/gson/src/main/java/com/google/gson/LongSerializationPolicy.java\n@@ -16,6 +16,8 @@\n \n package com.google.gson;\n \n+import com.google.gson.internal.bind.TypeAdapters;\n+\n /**\n  * Defines the expected format for a {@code long} or {@code Long} type when it is serialized.\n  *\n@@ -39,6 +41,11 @@ public JsonElement serialize(Long value) {\n       }\n       return new JsonPrimitive(value);\n     }\n+\n+    @Override\n+    TypeAdapter<Number> typeAdapter() {\n+      return TypeAdapters.LONG;\n+    }\n   },\n \n   /**\n@@ -55,6 +62,11 @@ public JsonElement serialize(Long value) {\n       }\n       return new JsonPrimitive(value.toString());\n     }\n+\n+    @Override\n+    TypeAdapter<Number> typeAdapter() {\n+      return TypeAdapters.LONG_AS_STRING;\n+    }\n   };\n \n   /**\n@@ -64,4 +76,8 @@ public JsonElement serialize(Long value) {\n    * @return the serialized version of {@code value}\n    */\n   public abstract JsonElement serialize(Long value);\n+\n+  /** Returns the corresponding {@link TypeAdapter} for this serialization policy. */\n+  // Internal method\n+  abstract TypeAdapter<Number> typeAdapter();\n }\ndiff --git a/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java b/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java\nindex 88b0855768..852ae56c5b 100644\n--- a/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java\n@@ -44,11 +44,14 @@\n import java.util.GregorianCalendar;\n import java.util.List;\n import java.util.Locale;\n+import java.util.Objects;\n import java.util.StringTokenizer;\n import java.util.UUID;\n import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicInteger;\n import java.util.concurrent.atomic.AtomicIntegerArray;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicLongArray;\n \n /**\n  * Type adapters for basic types. More complex adapters exist as separate classes in the enclosing\n@@ -300,6 +303,22 @@ public void write(JsonWriter out, AtomicInteger value) throws IOException {\n   public static final TypeAdapterFactory ATOMIC_INTEGER_FACTORY =\n       newFactory(AtomicInteger.class, TypeAdapters.ATOMIC_INTEGER);\n \n+  public static TypeAdapter<AtomicLong> atomicLongAdapter(TypeAdapter<Number> longAdapter) {\n+    Objects.requireNonNull(longAdapter);\n+    return new TypeAdapter<AtomicLong>() {\n+      @Override\n+      public AtomicLong read(JsonReader in) throws IOException {\n+        Number value = longAdapter.read(in);\n+        return new AtomicLong(value.longValue());\n+      }\n+\n+      @Override\n+      public void write(JsonWriter out, AtomicLong value) throws IOException {\n+        longAdapter.write(out, value.get());\n+      }\n+    }.nullSafe();\n+  }\n+\n   public static final TypeAdapter<AtomicBoolean> ATOMIC_BOOLEAN =\n       new TypeAdapter<AtomicBoolean>() {\n         @Override\n@@ -350,6 +369,38 @@ public void write(JsonWriter out, AtomicIntegerArray value) throws IOException {\n   public static final TypeAdapterFactory ATOMIC_INTEGER_ARRAY_FACTORY =\n       newFactory(AtomicIntegerArray.class, TypeAdapters.ATOMIC_INTEGER_ARRAY);\n \n+  public static TypeAdapter<AtomicLongArray> atomicLongArrayAdapter(\n+      TypeAdapter<Number> longAdapter) {\n+    Objects.requireNonNull(longAdapter);\n+    return new TypeAdapter<AtomicLongArray>() {\n+      @Override\n+      public AtomicLongArray read(JsonReader in) throws IOException {\n+        List<Long> list = new ArrayList<>();\n+        in.beginArray();\n+        while (in.hasNext()) {\n+          long value = longAdapter.read(in).longValue();\n+          list.add(value);\n+        }\n+        in.endArray();\n+        int length = list.size();\n+        AtomicLongArray array = new AtomicLongArray(length);\n+        for (int i = 0; i < length; ++i) {\n+          array.set(i, list.get(i));\n+        }\n+        return array;\n+      }\n+\n+      @Override\n+      public void write(JsonWriter out, AtomicLongArray value) throws IOException {\n+        out.beginArray();\n+        for (int i = 0, length = value.length(); i < length; i++) {\n+          longAdapter.write(out, value.get(i));\n+        }\n+        out.endArray();\n+      }\n+    }.nullSafe();\n+  }\n+\n   public static final TypeAdapter<Number> LONG =\n       new TypeAdapter<Number>() {\n         @Override\n@@ -375,7 +426,7 @@ public void write(JsonWriter out, Number value) throws IOException {\n         }\n       };\n \n-  public static final TypeAdapter<Number> FLOAT =\n+  public static final TypeAdapter<Number> LONG_AS_STRING =\n       new TypeAdapter<Number>() {\n         @Override\n         public Number read(JsonReader in) throws IOException {\n@@ -383,43 +434,96 @@ public Number read(JsonReader in) throws IOException {\n             in.nextNull();\n             return null;\n           }\n-          return (float) in.nextDouble();\n+          return in.nextLong();\n         }\n \n         @Override\n         public void write(JsonWriter out, Number value) throws IOException {\n           if (value == null) {\n             out.nullValue();\n-          } else {\n-            // For backward compatibility don't call `JsonWriter.value(float)` because that method\n-            // has been newly added and not all custom JsonWriter implementations might override\n-            // it yet\n-            Number floatNumber = value instanceof Float ? value : value.floatValue();\n-            out.value(floatNumber);\n+            return;\n           }\n+          out.value(value.toString());\n         }\n       };\n \n-  public static final TypeAdapter<Number> DOUBLE =\n-      new TypeAdapter<Number>() {\n-        @Override\n-        public Number read(JsonReader in) throws IOException {\n-          if (in.peek() == JsonToken.NULL) {\n-            in.nextNull();\n-            return null;\n-          }\n-          return in.nextDouble();\n-        }\n+  private static class FloatAdapter extends TypeAdapter<Number> {\n+    private final boolean strict;\n \n-        @Override\n-        public void write(JsonWriter out, Number value) throws IOException {\n-          if (value == null) {\n-            out.nullValue();\n-          } else {\n-            out.value(value.doubleValue());\n-          }\n-        }\n-      };\n+    FloatAdapter(boolean strict) {\n+      this.strict = strict;\n+    }\n+\n+    @Override\n+    public Float read(JsonReader in) throws IOException {\n+      if (in.peek() == JsonToken.NULL) {\n+        in.nextNull();\n+        return null;\n+      }\n+      return (float) in.nextDouble();\n+    }\n+\n+    @Override\n+    public void write(JsonWriter out, Number value) throws IOException {\n+      if (value == null) {\n+        out.nullValue();\n+        return;\n+      }\n+      float floatValue = value.floatValue();\n+      if (strict) {\n+        checkValidFloatingPoint(floatValue);\n+      }\n+      // For backward compatibility don't call `JsonWriter.value(float)` because that method has\n+      // been newly added and not all custom JsonWriter implementations might override it yet\n+      Number floatNumber = value instanceof Float ? value : floatValue;\n+      out.value(floatNumber);\n+    }\n+  }\n+\n+  private static class DoubleAdapter extends TypeAdapter<Number> {\n+    private final boolean strict;\n+\n+    DoubleAdapter(boolean strict) {\n+      this.strict = strict;\n+    }\n+\n+    @Override\n+    public Double read(JsonReader in) throws IOException {\n+      if (in.peek() == JsonToken.NULL) {\n+        in.nextNull();\n+        return null;\n+      }\n+      return in.nextDouble();\n+    }\n+\n+    @Override\n+    public void write(JsonWriter out, Number value) throws IOException {\n+      if (value == null) {\n+        out.nullValue();\n+        return;\n+      }\n+      double doubleValue = value.doubleValue();\n+      if (strict) {\n+        checkValidFloatingPoint(doubleValue);\n+      }\n+      out.value(doubleValue);\n+    }\n+  }\n+\n+  private static void checkValidFloatingPoint(double value) {\n+    if (Double.isNaN(value) || Double.isInfinite(value)) {\n+      throw new IllegalArgumentException(\n+          value\n+              + \" is not a valid double value as per JSON specification. To override this\"\n+              + \" behavior, use GsonBuilder.serializeSpecialFloatingPointValues() method.\");\n+    }\n+  }\n+\n+  public static final TypeAdapter<Number> FLOAT = new FloatAdapter(false);\n+  public static final TypeAdapter<Number> FLOAT_STRICT = new FloatAdapter(true);\n+\n+  public static final TypeAdapter<Number> DOUBLE = new DoubleAdapter(false);\n+  public static final TypeAdapter<Number> DOUBLE_STRICT = new DoubleAdapter(true);\n \n   public static final TypeAdapter<Character> CHARACTER =\n       new TypeAdapter<Character>() {\n@@ -491,6 +595,9 @@ public void write(JsonWriter out, BigDecimal value) throws IOException {\n         }\n       };\n \n+  public static final TypeAdapterFactory BIG_DECIMAL_FACTORY =\n+      newFactory(BigDecimal.class, BIG_DECIMAL);\n+\n   public static final TypeAdapter<BigInteger> BIG_INTEGER =\n       new TypeAdapter<BigInteger>() {\n         @Override\n@@ -514,6 +621,9 @@ public void write(JsonWriter out, BigInteger value) throws IOException {\n         }\n       };\n \n+  public static final TypeAdapterFactory BIG_INTEGER_FACTORY =\n+      newFactory(BigInteger.class, BIG_INTEGER);\n+\n   public static final TypeAdapter<LazilyParsedNumber> LAZILY_PARSED_NUMBER =\n       new TypeAdapter<LazilyParsedNumber>() {\n         // Normally users should not be able to access and deserialize LazilyParsedNumber because\n@@ -534,6 +644,9 @@ public void write(JsonWriter out, LazilyParsedNumber value) throws IOException {\n         }\n       };\n \n+  public static final TypeAdapterFactory LAZILY_PARSED_NUMBER_FACTORY =\n+      newFactory(LazilyParsedNumber.class, LAZILY_PARSED_NUMBER);\n+\n   public static final TypeAdapterFactory STRING_FACTORY = newFactory(String.class, STRING);\n \n   public static final TypeAdapter<StringBuilder> STRING_BUILDER =\ndiff --git a/gson/src/main/java/com/google/gson/internal/sql/SqlTypesSupport.java b/gson/src/main/java/com/google/gson/internal/sql/SqlTypesSupport.java\nindex e1a384b0b9..02f6eae857 100644\n--- a/gson/src/main/java/com/google/gson/internal/sql/SqlTypesSupport.java\n+++ b/gson/src/main/java/com/google/gson/internal/sql/SqlTypesSupport.java\n@@ -19,7 +19,10 @@\n import com.google.gson.TypeAdapterFactory;\n import com.google.gson.internal.bind.DefaultDateTypeAdapter.DateType;\n import java.sql.Timestamp;\n+import java.util.Arrays;\n+import java.util.Collections;\n import java.util.Date;\n+import java.util.List;\n \n /**\n  * Encapsulates access to {@code java.sql} types, to allow Gson to work without the {@code java.sql}\n@@ -27,8 +30,10 @@\n  * java.sql} module is not present.\n  *\n  * <p>If {@link #SUPPORTS_SQL_TYPES} is {@code true}, all other constants of this class will be\n- * non-{@code null}. However, if it is {@code false} all other constants will be {@code null} and\n- * there will be no support for {@code java.sql} types.\n+ * non-{@code null} and {@link #SQL_TYPE_FACTORIES} will contain the SQL type adapter factories.\n+ * However, if it is {@code false} all other constants will be {@code null} and {@link\n+ * #SQL_TYPE_FACTORIES} will be an empty list, and there will be no support for {@code java.sql}\n+ * types.\n  */\n @SuppressWarnings(\"JavaUtilDate\")\n public final class SqlTypesSupport {\n@@ -42,6 +47,8 @@ public final class SqlTypesSupport {\n   public static final TypeAdapterFactory TIME_FACTORY;\n   public static final TypeAdapterFactory TIMESTAMP_FACTORY;\n \n+  public static final List<TypeAdapterFactory> SQL_TYPE_FACTORIES;\n+\n   static {\n     boolean sqlTypesSupport;\n     try {\n@@ -71,6 +78,10 @@ protected Timestamp deserialize(Date date) {\n       DATE_FACTORY = SqlDateTypeAdapter.FACTORY;\n       TIME_FACTORY = SqlTimeTypeAdapter.FACTORY;\n       TIMESTAMP_FACTORY = SqlTimestampTypeAdapter.FACTORY;\n+\n+      SQL_TYPE_FACTORIES =\n+          Collections.unmodifiableList(\n+              Arrays.asList(TIME_FACTORY, DATE_FACTORY, TIMESTAMP_FACTORY));\n     } else {\n       DATE_DATE_TYPE = null;\n       TIMESTAMP_DATE_TYPE = null;\n@@ -78,6 +89,8 @@ protected Timestamp deserialize(Date date) {\n       DATE_FACTORY = null;\n       TIME_FACTORY = null;\n       TIMESTAMP_FACTORY = null;\n+\n+      SQL_TYPE_FACTORIES = Collections.emptyList();\n     }\n   }\n \n",
  "test_patch" : "diff --git a/gson/src/test/java/com/google/gson/internal/sql/SqlTypesSupportTest.java b/gson/src/test/java/com/google/gson/internal/sql/SqlTypesSupportTest.java\nindex 23778079c7..2334cd9647 100644\n--- a/gson/src/test/java/com/google/gson/internal/sql/SqlTypesSupportTest.java\n+++ b/gson/src/test/java/com/google/gson/internal/sql/SqlTypesSupportTest.java\n@@ -31,5 +31,11 @@ public void testSupported() {\n     assertThat(SqlTypesSupport.DATE_FACTORY).isNotNull();\n     assertThat(SqlTypesSupport.TIME_FACTORY).isNotNull();\n     assertThat(SqlTypesSupport.TIMESTAMP_FACTORY).isNotNull();\n+    assertThat(SqlTypesSupport.SQL_TYPE_FACTORIES)\n+        .containsExactly(\n+            SqlTypesSupport.TIME_FACTORY,\n+            SqlTypesSupport.DATE_FACTORY,\n+            SqlTypesSupport.TIMESTAMP_FACTORY)\n+        .inOrder();\n   }\n }\n",
  "problem_statement" : "```\nSee the discussion at: \nhttp://groups.google.com/group/google-gson/browse_thread/thread/af43e04cb644b734\n?hl=en\n```\n\nOriginal issue reported on code.google.com by `inder123` on 8 May 2009 at 4:26\n",
  "hints_text" : null,
  "created_at" : "Tue Nov 25 16:39:11 CET 2025",
  "version" : null,
  "FAIL_TO_PASS" : [ "SqlTypesSupportTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -pl gson -Dtest=SqlTypesSupportTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : 123,
  "pull_number" : 2951,
  "metadata" : null
}, {
  "instance_id" : "google-gson-PR-2948",
  "repo" : "google/gson",
  "base_commit" : "d437954171858e0efd53f7720acf480f11176535",
  "patch" : "diff --git a/gson/src/main/java/com/google/gson/Gson.java b/gson/src/main/java/com/google/gson/Gson.java\nindex ef8c81e378..2e904131d7 100644\n--- a/gson/src/main/java/com/google/gson/Gson.java\n+++ b/gson/src/main/java/com/google/gson/Gson.java\n@@ -370,6 +370,10 @@ public Gson() {\n     factories.add(TypeAdapters.BIT_SET_FACTORY);\n     factories.add(DefaultDateTypeAdapter.DEFAULT_STYLE_FACTORY);\n     factories.add(TypeAdapters.CALENDAR_FACTORY);\n+    TypeAdapterFactory javaTimeFactory = TypeAdapters.javaTimeTypeAdapterFactory();\n+    if (javaTimeFactory != null) {\n+      factories.add(javaTimeFactory);\n+    }\n \n     if (SqlTypesSupport.SUPPORTS_SQL_TYPES) {\n       factories.add(SqlTypesSupport.TIME_FACTORY);\ndiff --git a/gson/src/main/java/com/google/gson/internal/bind/IgnoreJRERequirement.java b/gson/src/main/java/com/google/gson/internal/bind/IgnoreJRERequirement.java\nnew file mode 100644\nindex 0000000000..c51a034867\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/internal/bind/IgnoreJRERequirement.java\n@@ -0,0 +1,11 @@\n+package com.google.gson.internal.bind;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+@Retention(RetentionPolicy.CLASS)\n+@Target({ElementType.METHOD, ElementType.CONSTRUCTOR, ElementType.TYPE, ElementType.FIELD})\n+@SuppressWarnings(\"IdentifierName\")\n+@interface IgnoreJRERequirement {}\ndiff --git a/gson/src/main/java/com/google/gson/internal/bind/JavaTimeTypeAdapters.java b/gson/src/main/java/com/google/gson/internal/bind/JavaTimeTypeAdapters.java\nnew file mode 100644\nindex 0000000000..791f15b44a\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/internal/bind/JavaTimeTypeAdapters.java\n@@ -0,0 +1,449 @@\n+package com.google.gson.internal.bind;\n+\n+import static java.lang.Math.toIntExact;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+import com.google.gson.TypeAdapter;\n+import com.google.gson.TypeAdapterFactory;\n+import com.google.gson.internal.bind.TypeAdapters.IntegerFieldsTypeAdapter;\n+import com.google.gson.reflect.TypeToken;\n+import com.google.gson.stream.JsonReader;\n+import com.google.gson.stream.JsonToken;\n+import com.google.gson.stream.JsonWriter;\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.time.MonthDay;\n+import java.time.OffsetDateTime;\n+import java.time.OffsetTime;\n+import java.time.Period;\n+import java.time.Year;\n+import java.time.YearMonth;\n+import java.time.ZoneId;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+\n+/**\n+ * Type adapters for {@code java.time} types.\n+ *\n+ * <p>These adapters mimic what {@link ReflectiveTypeAdapterFactory} would produce for the same\n+ * types. That is by no means a natural encoding, given that many of the types have standard ISO\n+ * representations. If Gson had added support for the types at the same time they appeared (in Java\n+ * 8, released in 2014), it would surely have used those representations. Unfortunately, in the\n+ * intervening time, people have been using the reflective representations, and changing that would\n+ * potentially be incompatible. Meanwhile, depending on the details of private fields in JDK classes\n+ * is obviously fragile, and it also needs special {@code --add-opens} configuration with more\n+ * recent JDK versions. So here we freeze the representation that was current with JDK 21, in a way\n+ * that does not use reflection.\n+ */\n+@IgnoreJRERequirement // Protected by a reflective check\n+final class JavaTimeTypeAdapters implements TypeAdapters.FactorySupplier {\n+\n+  @Override\n+  public TypeAdapterFactory get() {\n+    return JAVA_TIME_FACTORY;\n+  }\n+\n+  private static final TypeAdapter<Duration> DURATION =\n+      new IntegerFieldsTypeAdapter<Duration>(\"seconds\", \"nanos\") {\n+        @Override\n+        Duration create(long[] values) {\n+          return Duration.ofSeconds(values[0], values[1]);\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"JavaDurationGetSecondsGetNano\")\n+        long[] integerValues(Duration duration) {\n+          return new long[] {duration.getSeconds(), duration.getNano()};\n+        }\n+      };\n+\n+  private static final TypeAdapter<Instant> INSTANT =\n+      new IntegerFieldsTypeAdapter<Instant>(\"seconds\", \"nanos\") {\n+        @Override\n+        Instant create(long[] values) {\n+          return Instant.ofEpochSecond(values[0], values[1]);\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"JavaInstantGetSecondsGetNano\")\n+        long[] integerValues(Instant instant) {\n+          return new long[] {instant.getEpochSecond(), instant.getNano()};\n+        }\n+      };\n+\n+  private static final TypeAdapter<LocalDate> LOCAL_DATE =\n+      new IntegerFieldsTypeAdapter<LocalDate>(\"year\", \"month\", \"day\") {\n+        @Override\n+        LocalDate create(long[] values) {\n+          return LocalDate.of(toIntExact(values[0]), toIntExact(values[1]), toIntExact(values[2]));\n+        }\n+\n+        @Override\n+        long[] integerValues(LocalDate localDate) {\n+          return new long[] {\n+            localDate.getYear(), localDate.getMonthValue(), localDate.getDayOfMonth()\n+          };\n+        }\n+      };\n+\n+  public static final TypeAdapter<LocalTime> LOCAL_TIME =\n+      new IntegerFieldsTypeAdapter<LocalTime>(\"hour\", \"minute\", \"second\", \"nano\") {\n+        @Override\n+        LocalTime create(long[] values) {\n+          return LocalTime.of(\n+              toIntExact(values[0]),\n+              toIntExact(values[1]),\n+              toIntExact(values[2]),\n+              toIntExact(values[3]));\n+        }\n+\n+        @Override\n+        long[] integerValues(LocalTime localTime) {\n+          return new long[] {\n+            localTime.getHour(), localTime.getMinute(), localTime.getSecond(), localTime.getNano()\n+          };\n+        }\n+      };\n+\n+  private static TypeAdapter<LocalDateTime> localDateTime(Gson gson) {\n+    TypeAdapter<LocalDate> localDateAdapter = gson.getAdapter(LocalDate.class);\n+    TypeAdapter<LocalTime> localTimeAdapter = gson.getAdapter(LocalTime.class);\n+    return new TypeAdapter<LocalDateTime>() {\n+      @Override\n+      public LocalDateTime read(JsonReader in) throws IOException {\n+        LocalDate localDate = null;\n+        LocalTime localTime = null;\n+        in.beginObject();\n+        while (in.peek() != JsonToken.END_OBJECT) {\n+          String name = in.nextName();\n+          switch (name) {\n+            case \"date\":\n+              localDate = localDateAdapter.read(in);\n+              break;\n+            case \"time\":\n+              localTime = localTimeAdapter.read(in);\n+              break;\n+            default:\n+              // Ignore other fields.\n+              in.skipValue();\n+          }\n+        }\n+        in.endObject();\n+        return LocalDateTime.of(\n+            requireNonNullField(localDate, \"date\", in), requireNonNullField(localTime, \"time\", in));\n+      }\n+\n+      @Override\n+      public void write(JsonWriter out, LocalDateTime value) throws IOException {\n+        out.beginObject();\n+        out.name(\"date\");\n+        localDateAdapter.write(out, value.toLocalDate());\n+        out.name(\"time\");\n+        localTimeAdapter.write(out, value.toLocalTime());\n+        out.endObject();\n+      }\n+    }.nullSafe();\n+  }\n+\n+  private static final TypeAdapter<MonthDay> MONTH_DAY =\n+      new IntegerFieldsTypeAdapter<MonthDay>(\"month\", \"day\") {\n+        @Override\n+        MonthDay create(long[] values) {\n+          return MonthDay.of(toIntExact(values[0]), toIntExact(values[1]));\n+        }\n+\n+        @Override\n+        long[] integerValues(MonthDay monthDay) {\n+          return new long[] {monthDay.getMonthValue(), monthDay.getDayOfMonth()};\n+        }\n+      };\n+\n+  private static TypeAdapter<OffsetDateTime> offsetDateTime(Gson gson) {\n+    TypeAdapter<LocalDateTime> localDateTimeAdapter = localDateTime(gson);\n+    TypeAdapter<ZoneOffset> zoneOffsetAdapter = gson.getAdapter(ZoneOffset.class);\n+    return new TypeAdapter<OffsetDateTime>() {\n+      @Override\n+      public OffsetDateTime read(JsonReader in) throws IOException {\n+        in.beginObject();\n+        LocalDateTime localDateTime = null;\n+        ZoneOffset zoneOffset = null;\n+        while (in.peek() != JsonToken.END_OBJECT) {\n+          String name = in.nextName();\n+          switch (name) {\n+            case \"dateTime\":\n+              localDateTime = localDateTimeAdapter.read(in);\n+              break;\n+            case \"offset\":\n+              zoneOffset = zoneOffsetAdapter.read(in);\n+              break;\n+            default:\n+              // Ignore other fields.\n+              in.skipValue();\n+          }\n+        }\n+        in.endObject();\n+        return OffsetDateTime.of(\n+            requireNonNullField(localDateTime, \"dateTime\", in),\n+            requireNonNullField(zoneOffset, \"offset\", in));\n+      }\n+\n+      @Override\n+      public void write(JsonWriter out, OffsetDateTime value) throws IOException {\n+        out.beginObject();\n+        out.name(\"dateTime\");\n+        localDateTimeAdapter.write(out, value.toLocalDateTime());\n+        out.name(\"offset\");\n+        zoneOffsetAdapter.write(out, value.getOffset());\n+        out.endObject();\n+      }\n+    }.nullSafe();\n+  }\n+\n+  private static TypeAdapter<OffsetTime> offsetTime(Gson gson) {\n+    TypeAdapter<LocalTime> localTimeAdapter = gson.getAdapter(LocalTime.class);\n+    TypeAdapter<ZoneOffset> zoneOffsetAdapter = gson.getAdapter(ZoneOffset.class);\n+    return new TypeAdapter<OffsetTime>() {\n+      @Override\n+      public OffsetTime read(JsonReader in) throws IOException {\n+        in.beginObject();\n+        LocalTime localTime = null;\n+        ZoneOffset zoneOffset = null;\n+        while (in.peek() != JsonToken.END_OBJECT) {\n+          String name = in.nextName();\n+          switch (name) {\n+            case \"time\":\n+              localTime = localTimeAdapter.read(in);\n+              break;\n+            case \"offset\":\n+              zoneOffset = zoneOffsetAdapter.read(in);\n+              break;\n+            default:\n+              // Ignore other fields.\n+              in.skipValue();\n+          }\n+        }\n+        in.endObject();\n+        return OffsetTime.of(\n+            requireNonNullField(localTime, \"time\", in),\n+            requireNonNullField(zoneOffset, \"offset\", in));\n+      }\n+\n+      @Override\n+      public void write(JsonWriter out, OffsetTime value) throws IOException {\n+        out.beginObject();\n+        out.name(\"time\");\n+        localTimeAdapter.write(out, value.toLocalTime());\n+        out.name(\"offset\");\n+        zoneOffsetAdapter.write(out, value.getOffset());\n+        out.endObject();\n+      }\n+    }.nullSafe();\n+  }\n+\n+  private static final TypeAdapter<Period> PERIOD =\n+      new IntegerFieldsTypeAdapter<Period>(\"years\", \"months\", \"days\") {\n+        @Override\n+        Period create(long[] values) {\n+          return Period.of(toIntExact(values[0]), toIntExact(values[1]), toIntExact(values[2]));\n+        }\n+\n+        @Override\n+        long[] integerValues(Period period) {\n+          return new long[] {period.getYears(), period.getMonths(), period.getDays()};\n+        }\n+      };\n+\n+  private static final TypeAdapter<Year> YEAR =\n+      new IntegerFieldsTypeAdapter<Year>(\"year\") {\n+        @Override\n+        Year create(long[] values) {\n+          return Year.of(toIntExact(values[0]));\n+        }\n+\n+        @Override\n+        long[] integerValues(Year year) {\n+          return new long[] {year.getValue()};\n+        }\n+      };\n+\n+  private static final TypeAdapter<YearMonth> YEAR_MONTH =\n+      new IntegerFieldsTypeAdapter<YearMonth>(\"year\", \"month\") {\n+        @Override\n+        YearMonth create(long[] values) {\n+          return YearMonth.of(toIntExact(values[0]), toIntExact(values[1]));\n+        }\n+\n+        @Override\n+        long[] integerValues(YearMonth yearMonth) {\n+          return new long[] {yearMonth.getYear(), yearMonth.getMonthValue()};\n+        }\n+      };\n+\n+  // A ZoneId is either a ZoneOffset or a ZoneRegion, where ZoneOffset is public and ZoneRegion is\n+  // not. For compatibility with reflection-based serialization, we need to write the \"id\" field of\n+  // ZoneRegion if we have a ZoneRegion, and we need to write the \"totalSeconds\" field of ZoneOffset\n+  // if we have a ZoneOffset. When reading, we need to construct the the appropriate thing depending\n+  // on which of those two fields we see.\n+  private static final TypeAdapter<ZoneId> ZONE_ID =\n+      new TypeAdapter<ZoneId>() {\n+        @Override\n+        public ZoneId read(JsonReader in) throws IOException {\n+          in.beginObject();\n+          String id = null;\n+          Integer totalSeconds = null;\n+          while (in.peek() != JsonToken.END_OBJECT) {\n+            String name = in.nextName();\n+            switch (name) {\n+              case \"id\":\n+                id = in.nextString();\n+                break;\n+              case \"totalSeconds\":\n+                totalSeconds = in.nextInt();\n+                break;\n+              default:\n+                // Ignore other fields.\n+                in.skipValue();\n+            }\n+          }\n+          in.endObject();\n+          if (id != null) {\n+            return ZoneId.of(id);\n+          } else if (totalSeconds != null) {\n+            return ZoneOffset.ofTotalSeconds(totalSeconds);\n+          } else {\n+            throw new JsonSyntaxException(\n+                \"Missing id or totalSeconds field; at path \" + in.getPreviousPath());\n+          }\n+        }\n+\n+        @Override\n+        public void write(JsonWriter out, ZoneId value) throws IOException {\n+          if (value instanceof ZoneOffset) {\n+            out.beginObject();\n+            out.name(\"totalSeconds\");\n+            out.value(((ZoneOffset) value).getTotalSeconds());\n+            out.endObject();\n+          } else {\n+            out.beginObject();\n+            out.name(\"id\");\n+            out.value(value.getId());\n+            out.endObject();\n+          }\n+        }\n+      }.nullSafe();\n+\n+  private static TypeAdapter<ZonedDateTime> zonedDateTime(Gson gson) {\n+    TypeAdapter<LocalDateTime> localDateTimeAdapter = localDateTime(gson);\n+    TypeAdapter<ZoneOffset> zoneOffsetAdapter = gson.getAdapter(ZoneOffset.class);\n+    TypeAdapter<ZoneId> zoneIdAdapter = gson.getAdapter(ZoneId.class);\n+    return new TypeAdapter<ZonedDateTime>() {\n+      @Override\n+      public ZonedDateTime read(JsonReader in) throws IOException {\n+        in.beginObject();\n+        LocalDateTime localDateTime = null;\n+        ZoneOffset zoneOffset = null;\n+        ZoneId zoneId = null;\n+        while (in.peek() != JsonToken.END_OBJECT) {\n+          String name = in.nextName();\n+          switch (name) {\n+            case \"dateTime\":\n+              localDateTime = localDateTimeAdapter.read(in);\n+              break;\n+            case \"offset\":\n+              zoneOffset = zoneOffsetAdapter.read(in);\n+              break;\n+            case \"zone\":\n+              zoneId = zoneIdAdapter.read(in);\n+              break;\n+            default:\n+              // Ignore other fields.\n+              in.skipValue();\n+          }\n+        }\n+        in.endObject();\n+        return ZonedDateTime.ofInstant(\n+            requireNonNullField(localDateTime, \"dateTime\", in),\n+            requireNonNullField(zoneOffset, \"offset\", in),\n+            requireNonNullField(zoneId, \"zone\", in));\n+      }\n+\n+      @Override\n+      public void write(JsonWriter out, ZonedDateTime value) throws IOException {\n+        if (value == null) {\n+          out.nullValue();\n+          return;\n+        }\n+        out.beginObject();\n+        out.name(\"dateTime\");\n+        localDateTimeAdapter.write(out, value.toLocalDateTime());\n+        out.name(\"offset\");\n+        zoneOffsetAdapter.write(out, value.getOffset());\n+        out.name(\"zone\");\n+        zoneIdAdapter.write(out, value.getZone());\n+        out.endObject();\n+      }\n+    }.nullSafe();\n+  }\n+\n+  static final TypeAdapterFactory JAVA_TIME_FACTORY =\n+      new TypeAdapterFactory() {\n+        @Override\n+        public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n+          Class<? super T> rawType = typeToken.getRawType();\n+          if (!rawType.getName().startsWith(\"java.time.\")) {\n+            // Immediately return null so we don't load all these classes when nobody's doing\n+            // anything with java.time.\n+            return null;\n+          }\n+          TypeAdapter<?> adapter = null;\n+          if (rawType == Duration.class) {\n+            adapter = DURATION;\n+          } else if (rawType == Instant.class) {\n+            adapter = INSTANT;\n+          } else if (rawType == LocalDate.class) {\n+            adapter = LOCAL_DATE;\n+          } else if (rawType == LocalTime.class) {\n+            adapter = LOCAL_TIME;\n+          } else if (rawType == LocalDateTime.class) {\n+            adapter = localDateTime(gson);\n+          } else if (rawType == MonthDay.class) {\n+            adapter = MONTH_DAY;\n+          } else if (rawType == OffsetDateTime.class) {\n+            adapter = offsetDateTime(gson);\n+          } else if (rawType == OffsetTime.class) {\n+            adapter = offsetTime(gson);\n+          } else if (rawType == Period.class) {\n+            adapter = PERIOD;\n+          } else if (rawType == Year.class) {\n+            adapter = YEAR;\n+          } else if (rawType == YearMonth.class) {\n+            adapter = YEAR_MONTH;\n+          } else if (rawType == ZoneId.class || rawType == ZoneOffset.class) {\n+            // We don't check ZoneId.class.isAssignableFrom(rawType) because we don't want to match\n+            // the non-public class ZoneRegion in the runtime type check in\n+            // TypeAdapterRuntimeTypeWrapper.write. If we did, then our ZONE_ID would take\n+            // precedence over a ZoneId adapter that the user might have registered. (This exact\n+            // situation showed up in a Google-internal test.)\n+            adapter = ZONE_ID;\n+          } else if (rawType == ZonedDateTime.class) {\n+            adapter = zonedDateTime(gson);\n+          }\n+          @SuppressWarnings(\"unchecked\")\n+          TypeAdapter<T> result = (TypeAdapter<T>) adapter;\n+          return result;\n+        }\n+      };\n+\n+  private static <T> T requireNonNullField(T field, String fieldName, JsonReader reader) {\n+    if (field == null) {\n+      throw new JsonSyntaxException(\n+          \"Missing \" + fieldName + \" field; at path \" + reader.getPreviousPath());\n+    }\n+    return field;\n+  }\n+}\ndiff --git a/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java b/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java\nindex 71f98c0034..927bc6ffff 100644\n--- a/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java\n@@ -16,6 +16,8 @@\n \n package com.google.gson.internal.bind;\n \n+import static java.lang.Math.toIntExact;\n+\n import com.google.gson.Gson;\n import com.google.gson.JsonElement;\n import com.google.gson.JsonIOException;\n@@ -37,6 +39,7 @@\n import java.net.URISyntaxException;\n import java.net.URL;\n import java.util.ArrayList;\n+import java.util.Arrays;\n import java.util.BitSet;\n import java.util.Calendar;\n import java.util.Currency;\n@@ -689,78 +692,84 @@ public void write(JsonWriter out, Currency value) throws IOException {\n       }.nullSafe();\n   public static final TypeAdapterFactory CURRENCY_FACTORY = newFactory(Currency.class, CURRENCY);\n \n+  /**\n+   * An abstract {@link TypeAdapter} for classes whose JSON serialization consists of a fixed set of\n+   * integer fields. That is the case for {@link Calendar} and the legacy serialization of various\n+   * {@code java.time} types.\n+   */\n+  abstract static class IntegerFieldsTypeAdapter<T> extends TypeAdapter<T> {\n+    private final List<String> fields;\n+\n+    IntegerFieldsTypeAdapter(String... fields) {\n+      this.fields = Arrays.asList(fields);\n+    }\n+\n+    abstract T create(long[] values);\n+\n+    abstract long[] integerValues(T t);\n+\n+    @Override\n+    public T read(JsonReader in) throws IOException {\n+      if (in.peek() == JsonToken.NULL) {\n+        in.nextNull();\n+        return null;\n+      }\n+      in.beginObject();\n+      long[] values = new long[fields.size()];\n+      while (in.peek() != JsonToken.END_OBJECT) {\n+        String name = in.nextName();\n+        int index = fields.indexOf(name);\n+        if (index >= 0) {\n+          values[index] = in.nextLong();\n+        } else {\n+          in.skipValue();\n+        }\n+      }\n+      in.endObject();\n+      return create(values);\n+    }\n+\n+    @Override\n+    public void write(JsonWriter out, T value) throws IOException {\n+      if (value == null) {\n+        out.nullValue();\n+        return;\n+      }\n+      out.beginObject();\n+      long[] values = integerValues(value);\n+      for (int i = 0; i < fields.size(); i++) {\n+        out.name(fields.get(i));\n+        out.value(values[i]);\n+      }\n+      out.endObject();\n+    }\n+  }\n+\n   public static final TypeAdapter<Calendar> CALENDAR =\n-      new TypeAdapter<Calendar>() {\n-        private static final String YEAR = \"year\";\n-        private static final String MONTH = \"month\";\n-        private static final String DAY_OF_MONTH = \"dayOfMonth\";\n-        private static final String HOUR_OF_DAY = \"hourOfDay\";\n-        private static final String MINUTE = \"minute\";\n-        private static final String SECOND = \"second\";\n+      new IntegerFieldsTypeAdapter<Calendar>(\n+          \"year\", \"month\", \"dayOfMonth\", \"hourOfDay\", \"minute\", \"second\") {\n \n         @Override\n-        public Calendar read(JsonReader in) throws IOException {\n-          if (in.peek() == JsonToken.NULL) {\n-            in.nextNull();\n-            return null;\n-          }\n-          in.beginObject();\n-          int year = 0;\n-          int month = 0;\n-          int dayOfMonth = 0;\n-          int hourOfDay = 0;\n-          int minute = 0;\n-          int second = 0;\n-          while (in.peek() != JsonToken.END_OBJECT) {\n-            String name = in.nextName();\n-            int value = in.nextInt();\n-            switch (name) {\n-              case YEAR:\n-                year = value;\n-                break;\n-              case MONTH:\n-                month = value;\n-                break;\n-              case DAY_OF_MONTH:\n-                dayOfMonth = value;\n-                break;\n-              case HOUR_OF_DAY:\n-                hourOfDay = value;\n-                break;\n-              case MINUTE:\n-                minute = value;\n-                break;\n-              case SECOND:\n-                second = value;\n-                break;\n-              default:\n-                // Ignore unknown JSON property\n-            }\n-          }\n-          in.endObject();\n-          return new GregorianCalendar(year, month, dayOfMonth, hourOfDay, minute, second);\n+        Calendar create(long[] values) {\n+          return new GregorianCalendar(\n+              toIntExact(values[0]),\n+              toIntExact(values[1]),\n+              toIntExact(values[2]),\n+              toIntExact(values[3]),\n+              toIntExact(values[4]),\n+              toIntExact(values[5]));\n         }\n \n         @Override\n-        public void write(JsonWriter out, Calendar value) throws IOException {\n-          if (value == null) {\n-            out.nullValue();\n-            return;\n-          }\n-          out.beginObject();\n-          out.name(YEAR);\n-          out.value(value.get(Calendar.YEAR));\n-          out.name(MONTH);\n-          out.value(value.get(Calendar.MONTH));\n-          out.name(DAY_OF_MONTH);\n-          out.value(value.get(Calendar.DAY_OF_MONTH));\n-          out.name(HOUR_OF_DAY);\n-          out.value(value.get(Calendar.HOUR_OF_DAY));\n-          out.name(MINUTE);\n-          out.value(value.get(Calendar.MINUTE));\n-          out.name(SECOND);\n-          out.value(value.get(Calendar.SECOND));\n-          out.endObject();\n+        long[] integerValues(Calendar calendar) {\n+          return new long[] {\n+            calendar.get(Calendar.YEAR),\n+            calendar.get(Calendar.MONTH),\n+            calendar.get(Calendar.DAY_OF_MONTH),\n+            calendar.get(Calendar.HOUR_OF_DAY),\n+            calendar.get(Calendar.MINUTE),\n+            calendar.get(Calendar.SECOND)\n+          };\n         }\n       };\n \n@@ -813,6 +822,22 @@ public void write(JsonWriter out, Locale value) throws IOException {\n \n   public static final TypeAdapterFactory ENUM_FACTORY = EnumTypeAdapter.FACTORY;\n \n+  interface FactorySupplier {\n+    TypeAdapterFactory get();\n+  }\n+\n+  public static TypeAdapterFactory javaTimeTypeAdapterFactory() {\n+    try {\n+      Class<?> javaTimeTypeAdapterFactoryClass =\n+          Class.forName(\"com.google.gson.internal.bind.JavaTimeTypeAdapters\");\n+      FactorySupplier supplier =\n+          (FactorySupplier) javaTimeTypeAdapterFactoryClass.getDeclaredConstructor().newInstance();\n+      return supplier.get();\n+    } catch (ReflectiveOperationException e) {\n+      return null;\n+    }\n+  }\n+\n   @SuppressWarnings(\"TypeParameterNaming\")\n   public static <TT> TypeAdapterFactory newFactory(\n       TypeToken<TT> type, TypeAdapter<TT> typeAdapter) {\ndiff --git a/pom.xml b/pom.xml\nindex f25a4110ce..61e6d84787 100644\n--- a/pom.xml\n+++ b/pom.xml\n@@ -521,15 +521,14 @@\n               </goals>\n               <configuration>\n                 <skip>${gson.isTestModule}</skip>\n-\n                 <signature>\n-                  <!-- Note: In case Android compatibility impedes Gson development too much in the\n-                    future, could consider switching to https://github.com/open-toast/gummy-bears\n-                    which accounts for Android desugaring and might allow usage of more Java classes -->\n-                  <groupId>net.sf.androidscents.signature</groupId>\n-                  <artifactId>android-api-level-21</artifactId>\n-                  <version>5.0.1_r2</version>\n+                  <groupId>com.toasttab.android</groupId>\n+                  <artifactId>gummy-bears-api-23</artifactId>\n+                  <version>0.8.0</version>\n                 </signature>\n+                <annotations>\n+                  <annotation>com.google.gson.internal.bind.IgnoreJRERequirement</annotation>\n+                </annotations>\n               </configuration>\n             </execution>\n           </executions>\ndiff --git a/proto/pom.xml b/proto/pom.xml\nindex 7d0cc73495..53057bf09b 100644\n--- a/proto/pom.xml\n+++ b/proto/pom.xml\n@@ -79,7 +79,7 @@\n       <plugin>\n         <groupId>io.github.ascopes</groupId>\n         <artifactId>protobuf-maven-plugin</artifactId>\n-        <version>4.0.2</version>\n+        <version>4.0.3</version>\n         <configuration>\n           <skip>${maven.test.skip}</skip>\n           <protoc>${protobufVersion}</protoc>\n",
  "test_patch" : "diff --git a/gson/src/test/java/com/google/gson/functional/DefaultTypeAdaptersTest.java b/gson/src/test/java/com/google/gson/functional/DefaultTypeAdaptersTest.java\nindex c3892188be..79eeadb8b9 100644\n--- a/gson/src/test/java/com/google/gson/functional/DefaultTypeAdaptersTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/DefaultTypeAdaptersTest.java\n@@ -30,11 +30,14 @@\n import com.google.gson.JsonPrimitive;\n import com.google.gson.JsonSyntaxException;\n import com.google.gson.TypeAdapter;\n+import com.google.gson.internal.bind.ReflectiveTypeAdapterFactory;\n import com.google.gson.reflect.TypeToken;\n import com.google.gson.stream.JsonReader;\n import com.google.gson.stream.JsonWriter;\n import java.io.IOException;\n import java.lang.reflect.Constructor;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.InaccessibleObjectException;\n import java.lang.reflect.Type;\n import java.math.BigDecimal;\n import java.math.BigInteger;\n@@ -42,6 +45,20 @@\n import java.net.URI;\n import java.net.URL;\n import java.text.DateFormat;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.time.MonthDay;\n+import java.time.OffsetDateTime;\n+import java.time.OffsetTime;\n+import java.time.Period;\n+import java.time.Year;\n+import java.time.YearMonth;\n+import java.time.ZoneId;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.BitSet;\n@@ -200,6 +217,13 @@ public void testNullSerialization() {\n     testNullSerializationAndDeserialization(GregorianCalendar.class);\n     testNullSerializationAndDeserialization(Calendar.class);\n     testNullSerializationAndDeserialization(Class.class);\n+    testNullSerializationAndDeserialization(Duration.class);\n+    testNullSerializationAndDeserialization(Instant.class);\n+    testNullSerializationAndDeserialization(LocalDate.class);\n+    testNullSerializationAndDeserialization(LocalTime.class);\n+    testNullSerializationAndDeserialization(LocalDateTime.class);\n+    testNullSerializationAndDeserialization(ZoneId.class);\n+    testNullSerializationAndDeserialization(ZonedDateTime.class);\n   }\n \n   private void testNullSerializationAndDeserialization(Class<?> c) {\n@@ -812,6 +836,232 @@ public void testStringBufferDeserialization() {\n     assertThat(sb.toString()).isEqualTo(\"abc\");\n   }\n \n+  @Test\n+  public void testJavaTimeDuration() {\n+    Duration duration = Duration.ofSeconds(123, 456_789_012);\n+    String json = \"{\\\"seconds\\\":123,\\\"nanos\\\":456789012}\";\n+    roundTrip(duration, json);\n+  }\n+\n+  @Test\n+  public void testJavaTimeDurationWithUnknownFields() {\n+    Duration duration = Duration.ofSeconds(123, 456_789_012);\n+    String json = \"{\\\"seconds\\\":123,\\\"nanos\\\":456789012,\\\"tiddly\\\":\\\"pom\\\",\\\"wibble\\\":\\\"wobble\\\"}\";\n+    assertThat(gson.fromJson(json, Duration.class)).isEqualTo(duration);\n+  }\n+\n+  @Test\n+  public void testJavaTimeInstant() {\n+    Instant instant = Instant.ofEpochSecond(123, 456_789_012);\n+    String json = \"{\\\"seconds\\\":123,\\\"nanos\\\":456789012}\";\n+    roundTrip(instant, json);\n+  }\n+\n+  @Test\n+  public void testJavaTimeLocalDate() {\n+    LocalDate localDate = LocalDate.of(2021, 12, 2);\n+    String json = \"{\\\"year\\\":2021,\\\"month\\\":12,\\\"day\\\":2}\";\n+    roundTrip(localDate, json);\n+  }\n+\n+  @Test\n+  public void testJavaTimeLocalTime() {\n+    LocalTime localTime = LocalTime.of(12, 34, 56, 789_012_345);\n+    String json = \"{\\\"hour\\\":12,\\\"minute\\\":34,\\\"second\\\":56,\\\"nano\\\":789012345}\";\n+    roundTrip(localTime, json);\n+  }\n+\n+  @Test\n+  public void testJavaTimeLocalDateTime() {\n+    LocalDateTime localDateTime = LocalDateTime.of(2021, 12, 2, 12, 34, 56, 789_012_345);\n+    String json =\n+        \"{\\\"date\\\":{\\\"year\\\":2021,\\\"month\\\":12,\\\"day\\\":2},\"\n+            + \"\\\"time\\\":{\\\"hour\\\":12,\\\"minute\\\":34,\\\"second\\\":56,\\\"nano\\\":789012345}}\";\n+    roundTrip(localDateTime, json);\n+  }\n+\n+  @Test\n+  public void testJavaTimeMonthDay() {\n+    MonthDay monthDay = MonthDay.of(2, 17);\n+    String json = \"{\\\"month\\\":2,\\\"day\\\":17}\";\n+    roundTrip(monthDay, json);\n+  }\n+\n+  @Test\n+  public void testJavaTimeOffsetDateTime() {\n+    OffsetDateTime offsetDateTime =\n+        OffsetDateTime.of(\n+            LocalDate.of(2021, 12, 2), LocalTime.of(12, 34, 56, 789_012_345), ZoneOffset.UTC);\n+    String json =\n+        \"{\\\"dateTime\\\":{\\\"date\\\":{\\\"year\\\":2021,\\\"month\\\":12,\\\"day\\\":2},\"\n+            + \"\\\"time\\\":{\\\"hour\\\":12,\\\"minute\\\":34,\\\"second\\\":56,\\\"nano\\\":789012345}},\"\n+            + \"\\\"offset\\\":{\\\"totalSeconds\\\":0}}\";\n+    roundTrip(offsetDateTime, json);\n+  }\n+\n+  @Test\n+  public void testJavaTimeOffsetTime() {\n+    OffsetTime offsetTime = OffsetTime.of(LocalTime.of(12, 34, 56, 789_012_345), ZoneOffset.UTC);\n+    String json =\n+        \"{\\\"time\\\":{\\\"hour\\\":12,\\\"minute\\\":34,\\\"second\\\":56,\\\"nano\\\":789012345},\"\n+            + \"\\\"offset\\\":{\\\"totalSeconds\\\":0}}\";\n+    roundTrip(offsetTime, json);\n+  }\n+\n+  @Test\n+  public void testJavaTimePeriod() {\n+    Period period = Period.of(2025, 2, 3);\n+    String json = \"{\\\"years\\\":2025,\\\"months\\\":2,\\\"days\\\":3}\";\n+    roundTrip(period, json);\n+  }\n+\n+  @Test\n+  public void testJavaTimeYear() {\n+    Year year = Year.of(2025);\n+    String json = \"{\\\"year\\\":2025}\";\n+    roundTrip(year, json);\n+  }\n+\n+  @Test\n+  public void testJavaTimeYearMonth() {\n+    YearMonth yearMonth = YearMonth.of(2025, 2);\n+    String json = \"{\\\"year\\\":2025,\\\"month\\\":2}\";\n+    roundTrip(yearMonth, json);\n+  }\n+\n+  @Test\n+  public void testJavaTimeZoneOffset() {\n+    ZoneOffset zoneOffset = ZoneOffset.ofTotalSeconds(-8 * 60 * 60);\n+    String json = \"{\\\"totalSeconds\\\":-28800}\";\n+    roundTrip(zoneOffset, json);\n+  }\n+\n+  @Test\n+  public void testJavaTimeZoneRegion() {\n+    ZoneId zoneId = ZoneId.of(\"Asia/Shanghai\");\n+    String json = \"{\\\"id\\\":\\\"Asia/Shanghai\\\"}\";\n+    roundTrip(zoneId, ZoneId.class, json);\n+  }\n+\n+  @Test\n+  public void testJavaTimeZonedDateTimeWithZoneOffset() {\n+    ZonedDateTime zonedDateTime =\n+        ZonedDateTime.of(\n+            LocalDate.of(2021, 12, 2), LocalTime.of(12, 34, 56, 789_012_345), ZoneOffset.UTC);\n+    String json =\n+        \"{\\\"dateTime\\\":{\\\"date\\\":{\\\"year\\\":2021,\\\"month\\\":12,\\\"day\\\":2},\"\n+            + \"\\\"time\\\":{\\\"hour\\\":12,\\\"minute\\\":34,\\\"second\\\":56,\\\"nano\\\":789012345}},\"\n+            + \"\\\"offset\\\":{\\\"totalSeconds\\\":0},\"\n+            + \"\\\"zone\\\":{\\\"totalSeconds\\\":0}}\";\n+    roundTrip(zonedDateTime, json);\n+  }\n+\n+  @Test\n+  public void testJavaTimeZonedDateTimeWithZoneId() {\n+    ZoneId zoneId = ZoneId.of(\"UTC+01:00\");\n+    int totalSeconds = ((ZoneOffset) zoneId.normalized()).getTotalSeconds();\n+    ZonedDateTime zonedDateTime =\n+        ZonedDateTime.of(LocalDate.of(2021, 12, 2), LocalTime.of(12, 34, 56, 789_012_345), zoneId);\n+    String json =\n+        \"{\\\"dateTime\\\":{\\\"date\\\":{\\\"year\\\":2021,\\\"month\\\":12,\\\"day\\\":2},\"\n+            + \"\\\"time\\\":{\\\"hour\\\":12,\\\"minute\\\":34,\\\"second\\\":56,\\\"nano\\\":789012345}},\"\n+            + \"\\\"offset\\\":{\\\"totalSeconds\\\":\"\n+            + totalSeconds\n+            + \"},\"\n+            + \"\\\"zone\\\":{\\\"id\\\":\\\"\"\n+            + zoneId.getId()\n+            + \"\\\"}}\";\n+    roundTrip(zonedDateTime, json);\n+  }\n+\n+  @Test\n+  public void testJavaTimeZonedDateTimeWithZoneIdThatHasAdapter() {\n+    TypeAdapter<ZoneId> zoneIdAdapter =\n+        new TypeAdapter<ZoneId>() {\n+          @Override\n+          public void write(JsonWriter out, ZoneId value) throws IOException {\n+            out.value(value.getId());\n+          }\n+\n+          @Override\n+          public ZoneId read(JsonReader in) throws IOException {\n+            return ZoneId.of(in.nextString());\n+          }\n+        };\n+    Gson customGson = new GsonBuilder().registerTypeAdapter(ZoneId.class, zoneIdAdapter).create();\n+    ZoneId zoneId = ZoneId.of(\"UTC+01:00\");\n+    int totalSeconds = ((ZoneOffset) zoneId.normalized()).getTotalSeconds();\n+    ZonedDateTime zonedDateTime =\n+        ZonedDateTime.of(LocalDate.of(2021, 12, 2), LocalTime.of(12, 34, 56, 789_012_345), zoneId);\n+    String json =\n+        \"{\\\"dateTime\\\":{\\\"date\\\":{\\\"year\\\":2021,\\\"month\\\":12,\\\"day\\\":2},\"\n+            + \"\\\"time\\\":{\\\"hour\\\":12,\\\"minute\\\":34,\\\"second\\\":56,\\\"nano\\\":789012345}},\"\n+            + \"\\\"offset\\\":{\\\"totalSeconds\\\":\"\n+            + totalSeconds\n+            + \"},\"\n+            + \"\\\"zone\\\":\\\"\"\n+            + zoneId.getId()\n+            + \"\\\"}\";\n+    roundTrip(customGson, zonedDateTime, ZonedDateTime.class, json);\n+  }\n+\n+  private static final boolean JAVA_TIME_FIELDS_ARE_ACCESSIBLE;\n+\n+  static {\n+    boolean accessible = false;\n+    try {\n+      Instant.class.getDeclaredField(\"seconds\").setAccessible(true);\n+      accessible = true;\n+    } catch (InaccessibleObjectException e) {\n+      // OK: we can't reflect on java.time fields\n+    } catch (NoSuchFieldException e) {\n+      // JDK implementation has changed and we no longer have an Instant.seconds field.\n+      throw new AssertionError(e);\n+    }\n+    JAVA_TIME_FIELDS_ARE_ACCESSIBLE = accessible;\n+  }\n+\n+  private void roundTrip(Object value, String expectedJson) {\n+    roundTrip(value, value.getClass(), expectedJson);\n+  }\n+\n+  private void roundTrip(Object value, Class<?> valueClass, String expectedJson) {\n+    roundTrip(gson, value, valueClass, expectedJson);\n+    if (JAVA_TIME_FIELDS_ARE_ACCESSIBLE) {\n+      checkReflectiveTypeAdapterFactory(value, expectedJson);\n+    }\n+  }\n+\n+  private void roundTrip(Gson customGson, Object value, Class<?> valueClass, String expectedJson) {\n+    assertThat(customGson.getAdapter(valueClass).getClass().getName()).doesNotContain(\"Reflective\");\n+    assertThat(customGson.toJson(value, valueClass)).isEqualTo(expectedJson);\n+    assertThat(customGson.fromJson(expectedJson, valueClass)).isEqualTo(value);\n+  }\n+\n+  // Assuming we have reflective access to the fields of java.time classes, check that\n+  // ReflectiveTypeAdapterFactory would produce the same JSON. This ensures that we are preserving\n+  // a compatible JSON format for those classes even though we no longer use reflection.\n+  private void checkReflectiveTypeAdapterFactory(Object value, String expectedJson) {\n+    List<?> factories;\n+    try {\n+      Field factoriesField = gson.getClass().getDeclaredField(\"factories\");\n+      factoriesField.setAccessible(true);\n+      factories = (List<?>) factoriesField.get(gson);\n+    } catch (ReflectiveOperationException e) {\n+      throw new LinkageError(e.getMessage(), e);\n+    }\n+    ReflectiveTypeAdapterFactory adapterFactory =\n+        factories.stream()\n+            .filter(f -> f instanceof ReflectiveTypeAdapterFactory)\n+            .map(f -> (ReflectiveTypeAdapterFactory) f)\n+            .findFirst()\n+            .get();\n+    TypeToken<?> typeToken = TypeToken.get(value.getClass());\n+    @SuppressWarnings(\"unchecked\")\n+    TypeAdapter<Object> adapter = (TypeAdapter<Object>) adapterFactory.create(gson, typeToken);\n+    assertThat(adapter.toJson(value)).isEqualTo(expectedJson);\n+  }\n+\n   private static class MyClassTypeAdapter extends TypeAdapter<Class<?>> {\n     @Override\n     public void write(JsonWriter out, Class<?> value) throws IOException {\ndiff --git a/gson/src/test/java/com/google/gson/integration/OSGiManifestIT.java b/gson/src/test/java/com/google/gson/integration/OSGiManifestIT.java\nindex 4182c05ca4..23294c30f5 100644\n--- a/gson/src/test/java/com/google/gson/integration/OSGiManifestIT.java\n+++ b/gson/src/test/java/com/google/gson/integration/OSGiManifestIT.java\n@@ -130,7 +130,12 @@ public void testImports() throws Exception {\n   public void testExports() {\n     String gsonVersion = GSON_VERSION.replace(\"-SNAPSHOT\", \"\");\n \n-    List<String> exports = splitPackages(getAttribute(\"Export-Package\"));\n+    // Sometimes the `uses` and `exports` clauses can end up in the opposite order, so we use a\n+    // quick substitution to canonicalize them.\n+    List<String> exports =\n+        splitPackages(getAttribute(\"Export-Package\")).stream()\n+            .map(line -> line.replaceAll(\"(;version=\\\".*\\\")(;uses:=\\\".*\\\")\", \"$2$1\"))\n+            .collect(Collectors.toList());\n     // When not running `mvn clean` the exports might differ slightly, see\n     // https://github.com/bndtools/bnd/issues/6221\n     assertWithMessage(\"Unexpected exports; make sure you are running `mvn clean ...`\")\n",
  "problem_statement" : "When serializing / deserializing an object with the Date and Time classes of the new java.time API, the results are diferent from expected.\r\n\r\nFor example, here's a java.util.Date serialized with gson (using version 2.8.0):\r\n\r\n**\"created\": \"2017-04-07T18:07:00\",**\r\n\r\nand here's a java.time.LocalDate:\r\n\r\n**\"expiration\": {\r\n    \"year\": 2017,\r\n    \"month\": 4,\r\n    \"day\": 7\r\n  }**\r\nthe expected result for javatime api was a ISO-8601.\r\n\r\n",
  "hints_text" : null,
  "created_at" : "Tue Nov 25 01:30:06 CET 2025",
  "version" : null,
  "FAIL_TO_PASS" : [ "OSGiManifestIT", "DefaultTypeAdaptersTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -pl gson -Dtest=OSGiManifestIT,DefaultTypeAdaptersTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : 1059,
  "pull_number" : 2948,
  "metadata" : null
}, {
  "instance_id" : "google-gson-PR-2946",
  "repo" : "google/gson",
  "base_commit" : "50a93686df9e49dd20fecff222bb9ca169a29754",
  "patch" : "diff --git a/gson/src/main/java/com/google/gson/internal/Streams.java b/gson/src/main/java/com/google/gson/internal/Streams.java\nindex b46dfe2a70..12b8be86ee 100644\n--- a/gson/src/main/java/com/google/gson/internal/Streams.java\n+++ b/gson/src/main/java/com/google/gson/internal/Streams.java\n@@ -21,7 +21,7 @@\n import com.google.gson.JsonNull;\n import com.google.gson.JsonParseException;\n import com.google.gson.JsonSyntaxException;\n-import com.google.gson.internal.bind.TypeAdapters;\n+import com.google.gson.internal.bind.JsonElementTypeAdapter;\n import com.google.gson.stream.JsonReader;\n import com.google.gson.stream.JsonToken;\n import com.google.gson.stream.JsonWriter;\n@@ -45,7 +45,7 @@ public static JsonElement parse(JsonReader reader) throws JsonParseException {\n     try {\n       JsonToken unused = reader.peek();\n       isEmpty = false;\n-      return TypeAdapters.JSON_ELEMENT.read(reader);\n+      return JsonElementTypeAdapter.ADAPTER.read(reader);\n     } catch (EOFException e) {\n       /*\n        * For compatibility with JSON 1.5 and earlier, we return a JsonNull for\n@@ -67,7 +67,7 @@ public static JsonElement parse(JsonReader reader) throws JsonParseException {\n \n   /** Writes the JSON element to the writer, recursively. */\n   public static void write(JsonElement element, JsonWriter writer) throws IOException {\n-    TypeAdapters.JSON_ELEMENT.write(writer, element);\n+    JsonElementTypeAdapter.ADAPTER.write(writer, element);\n   }\n \n   public static Writer writerForAppendable(Appendable appendable) {\ndiff --git a/gson/src/main/java/com/google/gson/internal/bind/JsonElementTypeAdapter.java b/gson/src/main/java/com/google/gson/internal/bind/JsonElementTypeAdapter.java\nindex 9ffeadb676..6590dcff1b 100644\n--- a/gson/src/main/java/com/google/gson/internal/bind/JsonElementTypeAdapter.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/JsonElementTypeAdapter.java\n@@ -32,8 +32,8 @@\n import java.util.Map;\n \n /** Adapter for {@link JsonElement} and subclasses. */\n-class JsonElementTypeAdapter extends TypeAdapter<JsonElement> {\n-  static final JsonElementTypeAdapter ADAPTER = new JsonElementTypeAdapter();\n+public class JsonElementTypeAdapter extends TypeAdapter<JsonElement> {\n+  public static final JsonElementTypeAdapter ADAPTER = new JsonElementTypeAdapter();\n \n   private JsonElementTypeAdapter() {}\n \ndiff --git a/gson/src/main/java/com/google/gson/stream/JsonReader.java b/gson/src/main/java/com/google/gson/stream/JsonReader.java\nindex a76f1563ec..0e7dd30843 100644\n--- a/gson/src/main/java/com/google/gson/stream/JsonReader.java\n+++ b/gson/src/main/java/com/google/gson/stream/JsonReader.java\n@@ -16,10 +16,7 @@\n \n package com.google.gson.stream;\n \n-import com.google.gson.Gson;\n-import com.google.gson.GsonBuilder;\n import com.google.gson.Strictness;\n-import com.google.gson.TypeAdapter;\n import com.google.gson.internal.JsonReaderInternalAccess;\n import com.google.gson.internal.TroubleshootingGuide;\n import com.google.gson.internal.bind.JsonTreeReader;\n@@ -74,8 +71,9 @@\n  *   <li>{@link #setNestingLimit(int)}, the default is {@value #DEFAULT_NESTING_LIMIT}\n  * </ul>\n  *\n- * The default configuration of {@code JsonReader} instances used internally by the {@link Gson}\n- * class differs, and can be adjusted with the various {@link GsonBuilder} methods.\n+ * The default configuration of {@code JsonReader} instances used internally by the {@link\n+ * com.google.gson.Gson} class differs, and can be adjusted with the various {@link\n+ * com.google.gson.GsonBuilder} methods.\n  *\n  * <h2>Example</h2>\n  *\n@@ -426,7 +424,7 @@ public final Strictness getStrictness() {\n    * fail at the inner {@code [true]}.\n    *\n    * <p>The nesting limit can help to protect against a {@link StackOverflowError} when recursive\n-   * {@link TypeAdapter} implementations process deeply nested JSON data.\n+   * {@link com.google.gson.TypeAdapter} implementations process deeply nested JSON data.\n    *\n    * <p>The default nesting limit is {@value #DEFAULT_NESTING_LIMIT}.\n    *\ndiff --git a/gson/src/main/java/com/google/gson/stream/JsonWriter.java b/gson/src/main/java/com/google/gson/stream/JsonWriter.java\nindex 42fc24cf55..f08a698240 100644\n--- a/gson/src/main/java/com/google/gson/stream/JsonWriter.java\n+++ b/gson/src/main/java/com/google/gson/stream/JsonWriter.java\n@@ -26,8 +26,6 @@\n \n import com.google.errorprone.annotations.CanIgnoreReturnValue;\n import com.google.gson.FormattingStyle;\n-import com.google.gson.Gson;\n-import com.google.gson.GsonBuilder;\n import com.google.gson.Strictness;\n import java.io.Closeable;\n import java.io.Flushable;\n@@ -74,8 +72,9 @@\n  *   <li>{@link #setSerializeNulls(boolean)}, by default {@code null} is serialized\n  * </ul>\n  *\n- * The default configuration of {@code JsonWriter} instances used internally by the {@link Gson}\n- * class differs, and can be adjusted with the various {@link GsonBuilder} methods.\n+ * The default configuration of {@code JsonWriter} instances used internally by the {@link\n+ * com.google.gson.Gson} class differs, and can be adjusted with the various {@link\n+ * com.google.gson.GsonBuilder} methods.\n  *\n  * <h2>Example</h2>\n  *\n",
  "test_patch" : "diff --git a/gson/src/test/java/com/google/gson/JsonObjectTest.java b/gson/src/test/java/com/google/gson/JsonObjectTest.java\nindex a728fda3be..a68a9c9cf5 100644\n--- a/gson/src/test/java/com/google/gson/JsonObjectTest.java\n+++ b/gson/src/test/java/com/google/gson/JsonObjectTest.java\n@@ -135,7 +135,7 @@ public void testAddingCharacterProperties() {\n   public void testPropertyWithQuotes() {\n     JsonObject jsonObj = new JsonObject();\n     jsonObj.add(\"a\\\"b\", new JsonPrimitive(\"c\\\"d\"));\n-    String json = new Gson().toJson(jsonObj);\n+    String json = jsonObj.toString();\n     assertThat(json).isEqualTo(\"{\\\"a\\\\\\\"b\\\":\\\"c\\\\\\\"d\\\"}\");\n   }\n \n@@ -144,7 +144,7 @@ public void testPropertyWithQuotes() {\n   public void testWritePropertyWithEmptyStringName() {\n     JsonObject jsonObj = new JsonObject();\n     jsonObj.add(\"\", new JsonPrimitive(true));\n-    assertThat(new Gson().toJson(jsonObj)).isEqualTo(\"{\\\"\\\":true}\");\n+    assertThat(jsonObj.toString()).isEqualTo(\"{\\\"\\\":true}\");\n   }\n \n   @Test\ndiff --git a/gson/src/test/java/com/google/gson/JsonParserParameterizedTest.java b/gson/src/test/java/com/google/gson/JsonParserParameterizedTest.java\nindex 3ec42b258b..5c8f91bc65 100644\n--- a/gson/src/test/java/com/google/gson/JsonParserParameterizedTest.java\n+++ b/gson/src/test/java/com/google/gson/JsonParserParameterizedTest.java\n@@ -18,6 +18,7 @@\n \n import static com.google.common.truth.Truth.assertThat;\n \n+import com.google.gson.internal.bind.JsonElementTypeAdapter;\n import java.util.Arrays;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n@@ -40,7 +41,7 @@ public static Iterable<String> data() {\n         \"{\\\"\\\":1.0,\\\"a\\\":true,\\\"b\\\":null,\\\"c\\\":[],\\\"d\\\":{\\\"a1\\\":2.0,\\\"b2\\\":[true,{\\\"a3\\\":3.0}]},\\\"e\\\":[{\\\"f\\\":4.0},\\\"test\\\"]}\");\n   }\n \n-  private final TypeAdapter<JsonElement> adapter = new Gson().getAdapter(JsonElement.class);\n+  private final TypeAdapter<JsonElement> adapter = JsonElementTypeAdapter.ADAPTER;\n   @Parameter public String json;\n \n   @Test\ndiff --git a/gson/src/test/java/com/google/gson/SubsetTest.java b/gson/src/test/java/com/google/gson/SubsetTest.java\nnew file mode 100644\nindex 0000000000..2cd6c0206c\n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/SubsetTest.java\n@@ -0,0 +1,30 @@\n+package com.google.gson;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import java.util.List;\n+import org.junit.Test;\n+\n+/** Tests that we can parse and create JSON using the {@link JsonElement} subset. */\n+public final class SubsetTest {\n+  @Test\n+  public void read() {\n+    JsonElement json = JsonParser.parseString(\"{\\\"a\\\":1,\\\"b\\\":[2.1, null]}\");\n+    assertThat(json.isJsonObject()).isTrue();\n+    JsonObject jsonObject = json.getAsJsonObject();\n+    assertThat(jsonObject.get(\"a\").getAsInt()).isEqualTo(1);\n+    assertThat(jsonObject.get(\"b\").getAsJsonArray().asList())\n+        .isEqualTo(List.of(new JsonPrimitive(2.1), JsonNull.INSTANCE));\n+  }\n+\n+  @Test\n+  public void write() {\n+    JsonObject jsonObject = new JsonObject();\n+    jsonObject.addProperty(\"a\", 1);\n+    JsonArray array = new JsonArray();\n+    array.add(2.1);\n+    array.add(JsonNull.INSTANCE);\n+    jsonObject.add(\"b\", array);\n+    assertThat(jsonObject.toString()).isEqualTo(\"{\\\"a\\\":1,\\\"b\\\":[2.1,null]}\");\n+  }\n+}\n",
  "problem_statement" : "Small modifications to make building a subset possible.\n\nThe changes here make it possible to build a subset of Gson that includes `JsonReader`, `JsonWriter`, `JsonParser`, and `JsonElement` and its subclasses, but does not include the `Gson` class or the standard `TypeAdapter` classes. The idea is that this subset avoids the problematic uses of reflection that make Gson inappropriate for use on Android and similar platforms.\r\n\r\nThis change makes the class `com.google.gson.internal.bind.JsonElementTypeAdapter` public, which is convenient but of course means that people are going to start referencing it despite the `.internal.` in its name. However, they can already reference `TypeAdapters.JSON_ELEMENT` in the same package, so we're not really exposing anything new.\r\n\r\nThe subsetting is currently designed to be used internally at Google. At a later date, we may release a new artifact containing just the subset.",
  "hints_text" : null,
  "created_at" : "Thu Nov 20 20:08:34 CET 2025",
  "version" : null,
  "FAIL_TO_PASS" : [ "JsonObjectTest", "JsonParserParameterizedTest", "SubsetTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -pl gson -Dtest=JsonObjectTest,JsonParserParameterizedTest,SubsetTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 2946,
  "metadata" : null
}, {
  "instance_id" : "google-gson-PR-2925",
  "repo" : "google/gson",
  "base_commit" : "569279fada1f623732ca4836404954d8cf8ca89c",
  "patch" : "diff --git a/gson/src/main/java/com/google/gson/internal/Streams.java b/gson/src/main/java/com/google/gson/internal/Streams.java\nindex 46df853f5a..b46dfe2a70 100644\n--- a/gson/src/main/java/com/google/gson/internal/Streams.java\n+++ b/gson/src/main/java/com/google/gson/internal/Streams.java\n@@ -26,7 +26,9 @@\n import com.google.gson.stream.JsonToken;\n import com.google.gson.stream.JsonWriter;\n import com.google.gson.stream.MalformedJsonException;\n+import java.io.Closeable;\n import java.io.EOFException;\n+import java.io.Flushable;\n import java.io.IOException;\n import java.io.Writer;\n import java.util.Objects;\n@@ -89,10 +91,18 @@ public void write(char[] chars, int offset, int length) throws IOException {\n     }\n \n     @Override\n-    public void flush() {}\n+    public void flush() throws IOException {\n+      if (appendable instanceof Flushable) {\n+        ((Flushable) appendable).flush();\n+      }\n+    }\n \n     @Override\n-    public void close() {}\n+    public void close() throws IOException {\n+      if (appendable instanceof Closeable) {\n+        ((Closeable) appendable).close();\n+      }\n+    }\n \n     // Override these methods for better performance\n     // They would otherwise unnecessarily create Strings or char arrays\n",
  "test_patch" : "diff --git a/gson/src/test/java/com/google/gson/internal/StreamsTest.java b/gson/src/test/java/com/google/gson/internal/StreamsTest.java\nindex 049a7ee0a1..93f3e5d027 100644\n--- a/gson/src/test/java/com/google/gson/internal/StreamsTest.java\n+++ b/gson/src/test/java/com/google/gson/internal/StreamsTest.java\n@@ -19,15 +19,59 @@\n import static com.google.common.truth.Truth.assertThat;\n import static org.junit.Assert.assertThrows;\n \n+import java.io.Closeable;\n+import java.io.Flushable;\n import java.io.IOException;\n import java.io.Writer;\n import org.junit.Test;\n \n public class StreamsTest {\n+  private static class TestAppendable implements Appendable, Flushable, Closeable {\n+    boolean closed = false;\n+    int flushCount = 0;\n+    Appendable append;\n+\n+    TestAppendable(Appendable append) {\n+      this.append = append;\n+    }\n+\n+    @Override\n+    public void close() {\n+      closed = true;\n+    }\n+\n+    @Override\n+    public void flush() {\n+      flushCount++;\n+    }\n+\n+    @Override\n+    public TestAppendable append(CharSequence csq) throws IOException {\n+      append.append(csq);\n+      return this;\n+    }\n+\n+    @Override\n+    public TestAppendable append(CharSequence csq, int start, int end) throws IOException {\n+      append.append(csq, start, end);\n+      return this;\n+    }\n+\n+    @Override\n+    public TestAppendable append(char c) throws IOException {\n+      append.append(c);\n+      return this;\n+    }\n+  }\n+\n   @Test\n   public void testWriterForAppendable() throws IOException {\n     StringBuilder stringBuilder = new StringBuilder();\n-    Writer writer = Streams.writerForAppendable(stringBuilder);\n+    TestAppendable appendable = new TestAppendable(stringBuilder);\n+    Writer writer = Streams.writerForAppendable(appendable);\n+\n+    assertThat(appendable.closed).isFalse();\n+    assertThat(appendable.flushCount).isEqualTo(0);\n \n     writer.append('a');\n     writer.append('\\u1234');\n@@ -62,7 +106,9 @@ public void testWriterForAppendable() throws IOException {\n     writer.flush();\n     writer.close();\n \n-    // flush() and close() calls should have had no effect\n+    assertThat(appendable.closed).isTrue();\n+    assertThat(appendable.flushCount).isEqualTo(1);\n+\n     assertThat(stringBuilder.toString()).isEqualTo(actualOutput);\n   }\n }\n",
  "problem_statement" : "```\nSee the discussion at: \nhttp://groups.google.com/group/google-gson/browse_thread/thread/af43e04cb644b734\n?hl=en\n```\n\nOriginal issue reported on code.google.com by `inder123` on 8 May 2009 at 4:26\n",
  "hints_text" : null,
  "created_at" : "Thu Oct 23 09:59:02 CEST 2025",
  "version" : null,
  "FAIL_TO_PASS" : [ "StreamsTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -pl gson -Dtest=StreamsTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : 123,
  "pull_number" : 2925,
  "metadata" : null
}, {
  "instance_id" : "google-gson-PR-2918",
  "repo" : "google/gson",
  "base_commit" : "72d3702919e11e6e6a9bb529dd842bec510ca2d9",
  "patch" : "diff --git a/.github/workflows/build.yml b/.github/workflows/build.yml\nindex 693da389ca..6db4ae6fe1 100644\n--- a/.github/workflows/build.yml\n+++ b/.github/workflows/build.yml\n@@ -16,7 +16,14 @@ jobs:\n     name: \"Build on JDK ${{ matrix.java }}\"\n     strategy:\n       matrix:\n-        java: [ 11, 17, 21 ]\n+        java: [ 17, 21 ]\n+        # Custom JDK 11 configuration because some of the plugins and test dependencies don't support it anymore,\n+        # but it is important to still test with a JDK version without Record classes\n+        include:\n+          - java: 11\n+            # Disable Enforcer check which (intentionally) prevents using JDK 11 for building\n+            # Exclude 'test-graal-native-image' module because JUnit 6 requires >= Java 17\n+            extra-mvn-args: -Denforcer.fail=false --projects '!:test-graal-native-image'\n     runs-on: ubuntu-latest\n \n     steps:\n@@ -29,7 +36,7 @@ jobs:\n           cache: 'maven'\n       - name: Build with Maven\n         # This also runs javadoc:jar to detect any issues with the Javadoc generated during release\n-        run: mvn --batch-mode --no-transfer-progress verify javadoc:jar\n+        run: mvn --batch-mode --no-transfer-progress verify javadoc:jar ${{ matrix.extra-mvn-args || '' }}\n \n   native-image-test:\n     name: \"GraalVM Native Image test\"\n@@ -56,7 +63,7 @@ jobs:\n \n     steps:\n       - uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8  # v5.0.0\n-      - name: \"Set up JDK 17\"\n+      - name: Set up JDK\n         uses: actions/setup-java@dded0888837ed1f317902acf8a20df0ad188d165  # v5.0.0\n         with:\n           distribution: 'temurin'\ndiff --git a/.github/workflows/check-android-compatibility.yml b/.github/workflows/check-android-compatibility.yml\nindex db807306e8..2c410cb6be 100644\n--- a/.github/workflows/check-android-compatibility.yml\n+++ b/.github/workflows/check-android-compatibility.yml\n@@ -22,11 +22,11 @@ jobs:\n     steps:\n       - uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8  # v5.0.0\n \n-      - name: Set up JDK 11\n+      - name: Set up JDK\n         uses: actions/setup-java@dded0888837ed1f317902acf8a20df0ad188d165  # v5.0.0\n         with:\n           distribution: 'temurin'\n-          java-version: '11'\n+          java-version: '17'\n           cache: 'maven'\n \n       - name: Check Android compatibility\ndiff --git a/.github/workflows/check-api-compatibility.yml b/.github/workflows/check-api-compatibility.yml\nindex 1ecc40f266..dc919fb29b 100644\n--- a/.github/workflows/check-api-compatibility.yml\n+++ b/.github/workflows/check-api-compatibility.yml\n@@ -26,11 +26,11 @@ jobs:\n           ref: ${{ github.event.pull_request.base.sha }}\n           path: 'gson-old-japicmp'\n \n-      - name: Set up JDK 11\n+      - name: Set up JDK\n         uses: actions/setup-java@dded0888837ed1f317902acf8a20df0ad188d165  # v5.0.0\n         with:\n           distribution: 'temurin'\n-          java-version: '11'\n+          java-version: '17'\n           cache: 'maven'\n \n       - name: Build old version\ndiff --git a/.github/workflows/codeql-analysis.yml b/.github/workflows/codeql-analysis.yml\nindex 28d76360e9..274f62dd2c 100644\n--- a/.github/workflows/codeql-analysis.yml\n+++ b/.github/workflows/codeql-analysis.yml\n@@ -35,7 +35,7 @@ jobs:\n     - name: Checkout repository\n       uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8  # v5.0.0\n \n-    - name: Set up JDK 17\n+    - name: Set up JDK\n       if: ${{ matrix.language == 'java' }}\n       uses: actions/setup-java@dded0888837ed1f317902acf8a20df0ad188d165  # v5.0.0\n       with:\ndiff --git a/README.md b/README.md\nindex aa99d05e13..f5eab3fe26 100644\n--- a/README.md\n+++ b/README.md\n@@ -100,7 +100,7 @@ Gson uses Maven to build the project:\n mvn clean verify\n ```\n \n-JDK 11 or newer is required for building, JDK 17 or 21 is recommended. Newer JDKs are currently not supported for building (but are supported when _using_ Gson).\n+JDK 17 or newer is required for building, JDK 21 is recommended. Newer JDKs are currently not supported for building (but are supported when _using_ Gson).\n \n ### Contributing\n \ndiff --git a/pom.xml b/pom.xml\nindex a456bff96b..e009b152eb 100644\n--- a/pom.xml\n+++ b/pom.xml\n@@ -116,10 +116,11 @@\n \n                 <!-- Enforce that correct JDK version is used to avoid cryptic build errors -->\n                 <requireJavaVersion>\n-                  <!-- Other plugins of this build require at least JDK 11 -->\n-                  <!-- Disallow newer JDK versions; they might introduce new lints, drop support for\n-                    older compiler Java target versions or cause issues for some Maven plugins -->\n-                  <version>[11,22)</version>\n+                  <!-- Some plugins and test dependencies require at least JDK 17 -->\n+                  <!-- Also disallow too new JDK versions; they might introduce new lints, drop support\n+                    for older compiler Java target versions or cause issues for some Maven plugins.\n+                    Failing fast for such versions is better than failing with a confusing error during build. -->\n+                  <version>[17,22)</version>\n                 </requireJavaVersion>\n               </rules>\n             </configuration>\n@@ -131,7 +132,7 @@\n       <plugin>\n         <groupId>com.diffplug.spotless</groupId>\n         <artifactId>spotless-maven-plugin</artifactId>\n-        <version>2.46.1</version>\n+        <version>3.0.0</version>\n         <executions>\n           <execution>\n             <goals>\n@@ -165,12 +166,6 @@\n           </formats>\n \n           <java>\n-            <excludes>\n-              <!-- Exclude classes which need Java 17 for compilation; Google Java Format internally relies on javac,\n-                so formatting will fail if build is executed with JDK 11 -->\n-              <exclude>src/test/java/com/google/gson/functional/Java17RecordTest.java</exclude>\n-              <exclude>src/test/java/com/google/gson/native_test/Java17RecordReflectionTest.java</exclude>\n-            </excludes>\n             <googleJavaFormat>\n               <style>GOOGLE</style>\n               <reflowLongStrings>true</reflowLongStrings>\n@@ -547,6 +542,27 @@\n   </build>\n \n   <profiles>\n+    <!-- Disable Spotless before Java 17 -->\n+    <profile>\n+      <id>disable-spotless</id>\n+      <activation>\n+        <jdk>[,17)</jdk>\n+      </activation>\n+      <build>\n+        <plugins>\n+          <plugin>\n+            <groupId>com.diffplug.spotless</groupId>\n+            <artifactId>spotless-maven-plugin</artifactId>\n+            <executions>\n+              <execution>\n+                <id>default</id>\n+                <phase>none</phase>\n+              </execution>\n+            </executions>\n+          </plugin>\n+        </plugins>\n+      </build>\n+    </profile>\n     <!-- Disable Error Prone before Java 17 -->\n     <profile>\n       <id>disable-error-prone</id>\ndiff --git a/test-graal-native-image/pom.xml b/test-graal-native-image/pom.xml\nindex cd564e7c59..b36c7e49d4 100644\n--- a/test-graal-native-image/pom.xml\n+++ b/test-graal-native-image/pom.xml\n@@ -39,7 +39,7 @@\n       <dependency>\n         <groupId>org.junit</groupId>\n         <artifactId>junit-bom</artifactId>\n-        <version>5.13.4</version>\n+        <version>6.0.0</version>\n         <type>pom</type>\n         <scope>import</scope>\n       </dependency>\n@@ -137,7 +137,7 @@\n           <plugin>\n             <groupId>org.graalvm.buildtools</groupId>\n             <artifactId>native-maven-plugin</artifactId>\n-            <version>0.11.0</version>\n+            <version>0.11.1</version>\n             <extensions>true</extensions>\n             <executions>\n               <execution>\n",
  "test_patch" : "diff --git a/gson/src/test/java/com/google/gson/functional/Java17RecordTest.java b/gson/src/test/java/com/google/gson/functional/Java17RecordTest.java\nindex dc83ad59ff..807ef05d50 100644\n--- a/gson/src/test/java/com/google/gson/functional/Java17RecordTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/Java17RecordTest.java\n@@ -157,7 +157,9 @@ record LocalRecord(String s) {\n     }\n \n     // TODO: Adjust this once Gson throws more specific exception type\n-    var e = assertThrows(RuntimeException.class, () -> gson.fromJson(\"{\\\"s\\\":\\\"value\\\"}\", LocalRecord.class));\n+    var e =\n+        assertThrows(\n+            RuntimeException.class, () -> gson.fromJson(\"{\\\"s\\\":\\\"value\\\"}\", LocalRecord.class));\n     assertThat(e)\n         .hasMessageThat()\n         .isEqualTo(\n",
  "problem_statement" : "Require JDK 17 for building & update plugins and dependencies\n\n### Purpose\r\nRequire JDK 17 for building, and applies some of the version updates of #2914\r\n\r\n### Description\r\nApplies the version updates of #2914 which require JDK 17 or newer. I have omitted the other version updates to keep this cleaner; they can be applies independently afterwards.\r\n\r\nThe CI build still runs on JDK 11 as well (but with a custom configuration) to ensure that Gson works on a version without Record classes properly as well.\r\n\r\n### Checklist\r\n<!-- The following checklist is mainly intended for yourself to verify that you did not miss anything -->\r\n\r\n- [x] New code follows the [Google Java Style Guide](https://google.github.io/styleguide/javaguide.html)\\\r\n  This is automatically checked by `mvn verify`, but can also be checked on its own using `mvn spotless:check`.\\\r\n  Style violations can be fixed using `mvn spotless:apply`; this can be done in a separate commit to verify that it did not cause undesired changes.\r\n- [ ] If necessary, new public API validates arguments, for example rejects `null`\r\n- [ ] New public API has Javadoc\r\n    - [ ] Javadoc uses `@since $next-version$`  \r\n      (`$next-version$` is a special placeholder which is automatically replaced during release)\r\n- [ ] If necessary, new unit tests have been added  \r\n  - [ ] Assertions in unit tests use [Truth](https://truth.dev/), see existing tests\r\n  - [ ] No JUnit 3 features are used (such as extending class `TestCase`)\r\n  - [ ] If this pull request fixes a bug, a new test was added for a situation which failed previously and is now fixed\r\n- [x] `mvn clean verify javadoc:jar` passes without errors\r\n",
  "hints_text" : null,
  "created_at" : "Sat Oct 04 23:44:41 CEST 2025",
  "version" : null,
  "FAIL_TO_PASS" : [ "Java17RecordTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=Java17RecordTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 2918,
  "metadata" : null
}, {
  "instance_id" : "google-gson-PR-2887",
  "repo" : "google/gson",
  "base_commit" : "5eab3eda9fff9db77b82eae621c26f1d7263386f",
  "patch" : "diff --git a/gson/src/main/java/com/google/gson/internal/GsonTypes.java b/gson/src/main/java/com/google/gson/internal/GsonTypes.java\nindex 6a87c6637d..412c3bf98a 100644\n--- a/gson/src/main/java/com/google/gson/internal/GsonTypes.java\n+++ b/gson/src/main/java/com/google/gson/internal/GsonTypes.java\n@@ -520,7 +520,7 @@ private static final class ParameterizedTypeImpl implements ParameterizedType, S\n     @SuppressWarnings(\"serial\")\n     private final Type[] typeArguments;\n \n-    public ParameterizedTypeImpl(Type ownerType, Class<?> rawType, Type... typeArguments) {\n+    ParameterizedTypeImpl(Type ownerType, Class<?> rawType, Type... typeArguments) {\n       requireNonNull(rawType);\n \n       if (ownerType == null && requiresOwnerType(rawType)) {\n@@ -592,7 +592,7 @@ private static final class GenericArrayTypeImpl implements GenericArrayType, Ser\n     @SuppressWarnings(\"serial\")\n     private final Type componentType;\n \n-    public GenericArrayTypeImpl(Type componentType) {\n+    GenericArrayTypeImpl(Type componentType) {\n       requireNonNull(componentType);\n       this.componentType = canonicalize(componentType);\n     }\n@@ -633,7 +633,7 @@ private static final class WildcardTypeImpl implements WildcardType, Serializabl\n     @SuppressWarnings(\"serial\")\n     private final Type lowerBound;\n \n-    public WildcardTypeImpl(Type[] upperBounds, Type[] lowerBounds) {\n+    WildcardTypeImpl(Type[] upperBounds, Type[] lowerBounds) {\n       if (lowerBounds.length > 1) {\n         throw new IllegalArgumentException(\"At most one lower bound is supported\");\n       }\ndiff --git a/gson/src/main/java/com/google/gson/internal/ReflectionAccessFilterHelper.java b/gson/src/main/java/com/google/gson/internal/ReflectionAccessFilterHelper.java\nindex 980b29562f..ead949ae1e 100644\n--- a/gson/src/main/java/com/google/gson/internal/ReflectionAccessFilterHelper.java\n+++ b/gson/src/main/java/com/google/gson/internal/ReflectionAccessFilterHelper.java\n@@ -78,7 +78,7 @@ public static boolean canAccess(AccessibleObject accessibleObject, Object object\n   }\n \n   private abstract static class AccessChecker {\n-    public static final AccessChecker INSTANCE;\n+    static final AccessChecker INSTANCE;\n \n     static {\n       AccessChecker accessChecker = null;\n@@ -116,6 +116,6 @@ public boolean canAccess(AccessibleObject accessibleObject, Object object) {\n       INSTANCE = accessChecker;\n     }\n \n-    public abstract boolean canAccess(AccessibleObject accessibleObject, Object object);\n+    abstract boolean canAccess(AccessibleObject accessibleObject, Object object);\n   }\n }\ndiff --git a/gson/src/main/java/com/google/gson/internal/bind/CollectionTypeAdapterFactory.java b/gson/src/main/java/com/google/gson/internal/bind/CollectionTypeAdapterFactory.java\nindex f1f91f7380..7dd48a3ebb 100644\n--- a/gson/src/main/java/com/google/gson/internal/bind/CollectionTypeAdapterFactory.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/CollectionTypeAdapterFactory.java\n@@ -65,7 +65,7 @@ private static final class Adapter<E> extends TypeAdapter<Collection<E>> {\n     private final TypeAdapter<E> elementTypeAdapter;\n     private final ObjectConstructor<? extends Collection<E>> constructor;\n \n-    public Adapter(\n+    Adapter(\n         TypeAdapter<E> elementTypeAdapter, ObjectConstructor<? extends Collection<E>> constructor) {\n       this.elementTypeAdapter = elementTypeAdapter;\n       this.constructor = constructor;\ndiff --git a/gson/src/main/java/com/google/gson/internal/bind/MapTypeAdapterFactory.java b/gson/src/main/java/com/google/gson/internal/bind/MapTypeAdapterFactory.java\nindex 25c73efee8..49fc731edf 100644\n--- a/gson/src/main/java/com/google/gson/internal/bind/MapTypeAdapterFactory.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/MapTypeAdapterFactory.java\n@@ -163,7 +163,7 @@ private final class Adapter<K, V> extends TypeAdapter<Map<K, V>> {\n     private final TypeAdapter<V> valueTypeAdapter;\n     private final ObjectConstructor<? extends Map<K, V>> constructor;\n \n-    public Adapter(\n+    Adapter(\n         TypeAdapter<K> keyTypeAdapter,\n         TypeAdapter<V> valueTypeAdapter,\n         ObjectConstructor<? extends Map<K, V>> constructor) {\ndiff --git a/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java b/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java\nindex 89465dd627..ef464684aa 100644\n--- a/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java\n@@ -286,16 +286,14 @@ void readIntoField(JsonReader reader, Object target)\n   }\n \n   private static class FieldsData {\n-    public static final FieldsData EMPTY =\n-        new FieldsData(Collections.emptyMap(), Collections.emptyList());\n+    static final FieldsData EMPTY = new FieldsData(Collections.emptyMap(), Collections.emptyList());\n \n     /** Maps from JSON member name to field */\n-    public final Map<String, BoundField> deserializedFields;\n+    final Map<String, BoundField> deserializedFields;\n \n-    public final List<BoundField> serializedFields;\n+    final List<BoundField> serializedFields;\n \n-    public FieldsData(\n-        Map<String, BoundField> deserializedFields, List<BoundField> serializedFields) {\n+    FieldsData(Map<String, BoundField> deserializedFields, List<BoundField> serializedFields) {\n       this.deserializedFields = deserializedFields;\n       this.serializedFields = serializedFields;\n     }\ndiff --git a/gson/src/main/java/com/google/gson/internal/reflect/ReflectionHelper.java b/gson/src/main/java/com/google/gson/internal/reflect/ReflectionHelper.java\nindex 7a845ce515..0452942260 100644\n--- a/gson/src/main/java/com/google/gson/internal/reflect/ReflectionHelper.java\n+++ b/gson/src/main/java/com/google/gson/internal/reflect/ReflectionHelper.java\n@@ -227,7 +227,7 @@ private abstract static class RecordHelper {\n \n     abstract <T> Constructor<T> getCanonicalRecordConstructor(Class<T> raw);\n \n-    public abstract Method getAccessor(Class<?> raw, Field field);\n+    abstract Method getAccessor(Class<?> raw, Field field);\n   }\n \n   private static class RecordSupportedHelper extends RecordHelper {\n",
  "test_patch" : "diff --git a/extras/src/test/java/com/google/gson/interceptors/InterceptorTest.java b/extras/src/test/java/com/google/gson/interceptors/InterceptorTest.java\nindex 6c5cc91fa6..9c969b2869 100644\n--- a/extras/src/test/java/com/google/gson/interceptors/InterceptorTest.java\n+++ b/extras/src/test/java/com/google/gson/interceptors/InterceptorTest.java\n@@ -157,7 +157,7 @@ private static final class User {\n     String email;\n     Address address;\n \n-    public User(String name, String password) {\n+    User(String name, String password) {\n       this.name = name;\n       this.password = password;\n     }\ndiff --git a/gson/src/test/java/com/google/gson/ExposeAnnotationExclusionStrategyTest.java b/gson/src/test/java/com/google/gson/ExposeAnnotationExclusionStrategyTest.java\nindex 8738e5b98c..2146c3ff21 100644\n--- a/gson/src/test/java/com/google/gson/ExposeAnnotationExclusionStrategyTest.java\n+++ b/gson/src/test/java/com/google/gson/ExposeAnnotationExclusionStrategyTest.java\n@@ -83,22 +83,22 @@ public void testDifferentSerializeAndDeserializeField() throws Exception {\n   }\n \n   private static Field createFieldAttributes(String fieldName) throws Exception {\n-    return MockObject.class.getField(fieldName);\n+    return MockObject.class.getDeclaredField(fieldName);\n   }\n \n   @SuppressWarnings(\"unused\")\n   private static class MockObject {\n-    @Expose public final int exposedField = 0;\n+    @Expose final int exposedField = 0;\n \n     @Expose(serialize = true, deserialize = true)\n-    public final int explicitlyExposedField = 0;\n+    final int explicitlyExposedField = 0;\n \n     @Expose(serialize = false, deserialize = false)\n-    public final int explicitlyHiddenField = 0;\n+    final int explicitlyHiddenField = 0;\n \n     @Expose(serialize = true, deserialize = false)\n-    public final int explicitlyDifferentModeField = 0;\n+    final int explicitlyDifferentModeField = 0;\n \n-    public final int hiddenField = 0;\n+    final int hiddenField = 0;\n   }\n }\ndiff --git a/gson/src/test/java/com/google/gson/FieldAttributesTest.java b/gson/src/test/java/com/google/gson/FieldAttributesTest.java\nindex 672fb3fdbc..e07b414328 100644\n--- a/gson/src/test/java/com/google/gson/FieldAttributesTest.java\n+++ b/gson/src/test/java/com/google/gson/FieldAttributesTest.java\n@@ -75,7 +75,7 @@ public void testDeclaredTypeAndClass() {\n   }\n \n   private static class Foo {\n-    @SuppressWarnings(\"unused\")\n+    @SuppressWarnings({\"unused\", \"EffectivelyPrivate\"})\n     public transient List<String> bar;\n   }\n }\ndiff --git a/gson/src/test/java/com/google/gson/GsonBuilderTest.java b/gson/src/test/java/com/google/gson/GsonBuilderTest.java\nindex 9020cf9e39..94cc8362d3 100644\n--- a/gson/src/test/java/com/google/gson/GsonBuilderTest.java\n+++ b/gson/src/test/java/com/google/gson/GsonBuilderTest.java\n@@ -202,7 +202,7 @@ public void testDisableJdkUnsafe() {\n   }\n \n   private static class ClassWithoutNoArgsConstructor {\n-    @SuppressWarnings(\"unused\")\n+    @SuppressWarnings({\"unused\", \"EffectivelyPrivate\"})\n     public ClassWithoutNoArgsConstructor(String s) {}\n   }\n \ndiff --git a/gson/src/test/java/com/google/gson/GsonTest.java b/gson/src/test/java/com/google/gson/GsonTest.java\nindex 18ad4cbc2e..4798168984 100644\n--- a/gson/src/test/java/com/google/gson/GsonTest.java\n+++ b/gson/src/test/java/com/google/gson/GsonTest.java\n@@ -664,11 +664,12 @@ private static class CustomClass3 {\n \n     final String s;\n \n+    @SuppressWarnings(\"EffectivelyPrivate\")\n     public CustomClass3(String s) {\n       this.s = s;\n     }\n \n-    @SuppressWarnings(\"unused\") // called by Gson\n+    @SuppressWarnings({\"unused\", \"EffectivelyPrivate\"}) // called by Gson\n     public CustomClass3() {\n       this(NO_ARG_CONSTRUCTOR_VALUE);\n     }\ndiff --git a/gson/src/test/java/com/google/gson/functional/CollectionTest.java b/gson/src/test/java/com/google/gson/functional/CollectionTest.java\nindex 47a39de80c..383790c2bb 100644\n--- a/gson/src/test/java/com/google/gson/functional/CollectionTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/CollectionTest.java\n@@ -178,7 +178,7 @@ public void testStack() {\n \n   private static class CollectionWithoutNoArgsConstructor<E> extends AbstractCollection<E> {\n     // Remove implicit no-args constructor\n-    public CollectionWithoutNoArgsConstructor(int unused) {}\n+    CollectionWithoutNoArgsConstructor(int unused) {}\n \n     @Override\n     public boolean add(E e) {\n@@ -440,11 +440,11 @@ private static int[] toIntArray(Collection<?> collection) {\n   private static class ObjectWithWildcardCollection {\n     private final Collection<? extends BagOfPrimitives> collection;\n \n-    public ObjectWithWildcardCollection(Collection<? extends BagOfPrimitives> collection) {\n+    ObjectWithWildcardCollection(Collection<? extends BagOfPrimitives> collection) {\n       this.collection = collection;\n     }\n \n-    public Collection<? extends BagOfPrimitives> getCollection() {\n+    Collection<? extends BagOfPrimitives> getCollection() {\n       return collection;\n     }\n   }\ndiff --git a/gson/src/test/java/com/google/gson/functional/ConcurrencyTest.java b/gson/src/test/java/com/google/gson/functional/ConcurrencyTest.java\nindex b4af36128a..3c9e475448 100644\n--- a/gson/src/test/java/com/google/gson/functional/ConcurrencyTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/ConcurrencyTest.java\n@@ -144,7 +144,7 @@ private static class MyObject {\n       this(\"hello\", \"world\", 42);\n     }\n \n-    public MyObject(String a, String b, int i) {\n+    MyObject(String a, String b, int i) {\n       this.a = a;\n       this.b = b;\n       this.i = i;\ndiff --git a/gson/src/test/java/com/google/gson/functional/CustomDeserializerTest.java b/gson/src/test/java/com/google/gson/functional/CustomDeserializerTest.java\nindex 075399a864..2c27e6c117 100644\n--- a/gson/src/test/java/com/google/gson/functional/CustomDeserializerTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/CustomDeserializerTest.java\n@@ -78,11 +78,11 @@ private DataHolder() {\n       throw new IllegalStateException();\n     }\n \n-    public DataHolder(String data) {\n+    DataHolder(String data) {\n       this.data = data;\n     }\n \n-    public String getData() {\n+    String getData() {\n       return data;\n     }\n   }\n@@ -96,11 +96,11 @@ private DataHolderWrapper() {\n       this(new DataHolder(DEFAULT_VALUE));\n     }\n \n-    public DataHolderWrapper(DataHolder data) {\n+    DataHolderWrapper(DataHolder data) {\n       this.wrappedData = data;\n     }\n \n-    public DataHolder getWrappedData() {\n+    DataHolder getWrappedData() {\n       return wrappedData;\n     }\n   }\n@@ -148,7 +148,7 @@ private SubTypes(Type subClass) {\n       this.subClass = subClass;\n     }\n \n-    public Type getSubclass() {\n+    Type getSubclass() {\n       return subClass;\n     }\n   }\ndiff --git a/gson/src/test/java/com/google/gson/functional/CustomTypeAdaptersTest.java b/gson/src/test/java/com/google/gson/functional/CustomTypeAdaptersTest.java\nindex ff0570dc33..caa4ba7696 100644\n--- a/gson/src/test/java/com/google/gson/functional/CustomTypeAdaptersTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/CustomTypeAdaptersTest.java\n@@ -304,13 +304,13 @@ private static final class StringHolder {\n     String part1;\n     String part2;\n \n-    public StringHolder(String string) {\n+    StringHolder(String string) {\n       List<String> parts = Splitter.on(':').splitToList(string);\n       part1 = parts.get(0);\n       part2 = parts.get(1);\n     }\n \n-    public StringHolder(String part1, String part2) {\n+    StringHolder(String part1, String part2) {\n       this.part1 = part1;\n       this.part2 = part2;\n     }\n@@ -466,7 +466,7 @@ public void testRegisterHierarchyAdapterForDate() {\n   private static class DataHolder {\n     final String data;\n \n-    public DataHolder(String data) {\n+    DataHolder(String data) {\n       this.data = data;\n     }\n   }\n@@ -474,7 +474,7 @@ public DataHolder(String data) {\n   private static class DataHolderWrapper {\n     final DataHolder wrappedData;\n \n-    public DataHolderWrapper(DataHolder data) {\n+    DataHolderWrapper(DataHolder data) {\n       this.wrappedData = data;\n     }\n   }\ndiff --git a/gson/src/test/java/com/google/gson/functional/DelegateTypeAdapterTest.java b/gson/src/test/java/com/google/gson/functional/DelegateTypeAdapterTest.java\nindex d10ab42dcb..86d0a75b6e 100644\n--- a/gson/src/test/java/com/google/gson/functional/DelegateTypeAdapterTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/DelegateTypeAdapterTest.java\n@@ -72,8 +72,8 @@ public void testDelegateInvokedOnStrings() {\n   }\n \n   private static class StatsTypeAdapterFactory implements TypeAdapterFactory {\n-    public int numReads = 0;\n-    public int numWrites = 0;\n+    int numReads = 0;\n+    int numWrites = 0;\n \n     @Override\n     public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {\ndiff --git a/gson/src/test/java/com/google/gson/functional/EnumTest.java b/gson/src/test/java/com/google/gson/functional/EnumTest.java\nindex 990a6463e8..e2a52328d7 100644\n--- a/gson/src/test/java/com/google/gson/functional/EnumTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/EnumTest.java\n@@ -113,7 +113,7 @@ private static class ClassWithEnumFields {\n     private final MyEnum value1 = MyEnum.VALUE1;\n     private final MyEnum value2 = MyEnum.VALUE2;\n \n-    public String getExpectedJson() {\n+    String getExpectedJson() {\n       return \"{\\\"value1\\\":\\\"\" + value1 + \"\\\",\\\"value2\\\":\\\"\" + value2 + \"\\\"}\";\n     }\n   }\ndiff --git a/gson/src/test/java/com/google/gson/functional/ExclusionStrategyFunctionalTest.java b/gson/src/test/java/com/google/gson/functional/ExclusionStrategyFunctionalTest.java\nindex 43ffc0eb80..dc0fb05da5 100644\n--- a/gson/src/test/java/com/google/gson/functional/ExclusionStrategyFunctionalTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/ExclusionStrategyFunctionalTest.java\n@@ -189,11 +189,11 @@ private static class SampleObjectForTest {\n     private final String stringField;\n     private final long longField;\n \n-    public SampleObjectForTest() {\n+    SampleObjectForTest() {\n       this(5, \"someDefaultValue\", 12345L);\n     }\n \n-    public SampleObjectForTest(int annotatedField, String stringField, long longField) {\n+    SampleObjectForTest(int annotatedField, String stringField, long longField) {\n       this.annotatedField = annotatedField;\n       this.stringField = stringField;\n       this.longField = longField;\ndiff --git a/gson/src/test/java/com/google/gson/functional/ExposeFieldsTest.java b/gson/src/test/java/com/google/gson/functional/ExposeFieldsTest.java\nindex 678b1bcad8..68fe256301 100644\n--- a/gson/src/test/java/com/google/gson/functional/ExposeFieldsTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/ExposeFieldsTest.java\n@@ -138,11 +138,11 @@ private static class ClassWithExposedFields {\n     @Keep\n     final char e;\n \n-    public ClassWithExposedFields(Integer a, Integer b) {\n+    ClassWithExposedFields(Integer a, Integer b) {\n       this(a, b, 1L, 2.0, 'a');\n     }\n \n-    public ClassWithExposedFields(Integer a, Integer b, long c, double d, char e) {\n+    ClassWithExposedFields(Integer a, Integer b, long c, double d, char e) {\n       this.a = a;\n       this.b = b;\n       this.c = c;\n@@ -150,7 +150,7 @@ public ClassWithExposedFields(Integer a, Integer b, long c, double d, char e) {\n       this.e = e;\n     }\n \n-    public String getExpectedJson() {\n+    String getExpectedJson() {\n       StringBuilder sb = new StringBuilder(\"{\");\n       if (a != null) {\n         sb.append(\"\\\"a\\\":\").append(a).append(\",\");\n@@ -184,7 +184,7 @@ public SomeInterface createInstance(Type type) {\n   private static class ClassWithInterfaceField {\n     @Expose private final SomeInterface interfaceField;\n \n-    public ClassWithInterfaceField(SomeInterface interfaceField) {\n+    ClassWithInterfaceField(SomeInterface interfaceField) {\n       this.interfaceField = interfaceField;\n     }\n   }\ndiff --git a/gson/src/test/java/com/google/gson/functional/FieldExclusionTest.java b/gson/src/test/java/com/google/gson/functional/FieldExclusionTest.java\nindex 591cb2fd9d..01b322e420 100644\n--- a/gson/src/test/java/com/google/gson/functional/FieldExclusionTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/FieldExclusionTest.java\n@@ -78,7 +78,7 @@ private static class Outer {\n \n     @SuppressWarnings(\"ClassCanBeStatic\")\n     private class Inner extends NestedClass {\n-      public Inner(String value) {\n+      Inner(String value) {\n         super(value);\n       }\n     }\n@@ -87,11 +87,11 @@ public Inner(String value) {\n   private static class NestedClass {\n     private final String value;\n \n-    public NestedClass(String value) {\n+    NestedClass(String value) {\n       this.value = value;\n     }\n \n-    public String toJson() {\n+    String toJson() {\n       return \"{\\\"value\\\":\\\"\" + value + \"\\\"}\";\n     }\n   }\ndiff --git a/gson/src/test/java/com/google/gson/functional/InheritanceTest.java b/gson/src/test/java/com/google/gson/functional/InheritanceTest.java\nindex f41b133fb3..02b750183e 100644\n--- a/gson/src/test/java/com/google/gson/functional/InheritanceTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/InheritanceTest.java\n@@ -156,7 +156,7 @@ public void testBaseSerializedAsSubWhenSpecifiedWithExplicitTypeForToJsonMethod(\n   private static class SubTypeOfNested extends Nested {\n     private final long value = 5;\n \n-    public SubTypeOfNested(BagOfPrimitives primitive1, BagOfPrimitives primitive2) {\n+    SubTypeOfNested(BagOfPrimitives primitive1, BagOfPrimitives primitive2) {\n       super(primitive1, primitive2);\n     }\n \n@@ -215,7 +215,7 @@ private static class ClassWithSubInterfacesOfCollection {\n     private Set<Float> set;\n     private SortedSet<Character> sortedSet;\n \n-    public ClassWithSubInterfacesOfCollection(\n+    ClassWithSubInterfacesOfCollection(\n         List<Integer> list, Queue<Long> queue, Set<Float> set, SortedSet<Character> sortedSet) {\n       this.list = list;\n       this.queue = queue;\n@@ -259,7 +259,7 @@ boolean sortedSetContains(char... values) {\n       return true;\n     }\n \n-    public String getExpectedJson() {\n+    String getExpectedJson() {\n       StringBuilder sb = new StringBuilder();\n       sb.append(\"{\");\n       sb.append(\"\\\"list\\\":\");\ndiff --git a/gson/src/test/java/com/google/gson/functional/JsonAdapterAnnotationOnClassesTest.java b/gson/src/test/java/com/google/gson/functional/JsonAdapterAnnotationOnClassesTest.java\nindex a4e694112b..9e8077569e 100644\n--- a/gson/src/test/java/com/google/gson/functional/JsonAdapterAnnotationOnClassesTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/JsonAdapterAnnotationOnClassesTest.java\n@@ -180,7 +180,7 @@ public void testFactoryReturningNull() {\n   private static class WithNullReturningFactory<T> {\n     T t;\n \n-    public WithNullReturningFactory(T t) {\n+    WithNullReturningFactory(T t) {\n       this.t = t;\n     }\n \n@@ -761,11 +761,11 @@ static class Serializer implements JsonSerializer<CreatedByInstanceCreator> {\n       private final String value;\n \n       @SuppressWarnings(\"unused\")\n-      public Serializer() {\n+      Serializer() {\n         throw new AssertionError(\"should not be called\");\n       }\n \n-      public Serializer(String value) {\n+      Serializer(String value) {\n         this.value = value;\n       }\n \n@@ -792,7 +792,7 @@ static class Serializer implements JsonSerializer<CreatedByJdkUnsafe> {\n \n       // Explicit constructor with args to remove implicit no-args constructor\n       @SuppressWarnings(\"unused\")\n-      public Serializer(int i) {\n+      Serializer(int i) {\n         throw new AssertionError(\"should not be called\");\n       }\n \ndiff --git a/gson/src/test/java/com/google/gson/functional/JsonAdapterAnnotationOnFieldsTest.java b/gson/src/test/java/com/google/gson/functional/JsonAdapterAnnotationOnFieldsTest.java\nindex 0c8422952b..459877d68f 100644\n--- a/gson/src/test/java/com/google/gson/functional/JsonAdapterAnnotationOnFieldsTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/JsonAdapterAnnotationOnFieldsTest.java\n@@ -126,7 +126,7 @@ private static final class Gizmo {\n   private static final class Part {\n     final String name;\n \n-    public Part(String name) {\n+    Part(String name) {\n       this.name = name;\n     }\n   }\n@@ -173,7 +173,7 @@ private static final class Computer {\n \n   @JsonAdapter(UserClassAnnotationAdapter.class)\n   private static class User {\n-    public final String name;\n+    final String name;\n \n     private User(String name) {\n       this.name = name;\ndiff --git a/gson/src/test/java/com/google/gson/functional/JsonAdapterSerializerDeserializerTest.java b/gson/src/test/java/com/google/gson/functional/JsonAdapterSerializerDeserializerTest.java\nindex 393aebe4a6..0e177a289d 100644\n--- a/gson/src/test/java/com/google/gson/functional/JsonAdapterSerializerDeserializerTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/JsonAdapterSerializerDeserializerTest.java\n@@ -76,7 +76,7 @@ private static final class Computer {\n   }\n \n   private static final class User {\n-    public final String name;\n+    final String name;\n \n     private User(String name) {\n       this.name = name;\n@@ -131,7 +131,7 @@ private static final class Computer2 {\n \n   @JsonAdapter(UserSerializerDeserializer2.class)\n   private static final class User2 {\n-    public final String name;\n+    final String name;\n \n     private User2(String name) {\n       this.name = name;\ndiff --git a/gson/src/test/java/com/google/gson/functional/JsonTreeTest.java b/gson/src/test/java/com/google/gson/functional/JsonTreeTest.java\nindex 82f8aae88c..e1efa62ea1 100644\n--- a/gson/src/test/java/com/google/gson/functional/JsonTreeTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/JsonTreeTest.java\n@@ -104,7 +104,7 @@ private static class SubTypeOfBagOfPrimitives extends BagOfPrimitives {\n     @SuppressWarnings(\"unused\")\n     float f = 1.2F;\n \n-    public SubTypeOfBagOfPrimitives(long l, int i, boolean b, String string, float f) {\n+    SubTypeOfBagOfPrimitives(long l, int i, boolean b, String string, float f) {\n       super(l, i, b, string);\n       this.f = f;\n     }\ndiff --git a/gson/src/test/java/com/google/gson/functional/MapTest.java b/gson/src/test/java/com/google/gson/functional/MapTest.java\nindex 7d2158ffda..39b4118de7 100644\n--- a/gson/src/test/java/com/google/gson/functional/MapTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/MapTest.java\n@@ -393,7 +393,7 @@ public void testCustomSerializerForSpecificMapType() {\n \n   private static class MapWithoutNoArgsConstructor<K, V> extends AbstractMap<K, V> {\n     // Remove implicit no-args constructor\n-    public MapWithoutNoArgsConstructor(int unused) {}\n+    MapWithoutNoArgsConstructor(int unused) {}\n \n     @Override\n     public V put(K key, V value) {\ndiff --git a/gson/src/test/java/com/google/gson/functional/NamingPolicyTest.java b/gson/src/test/java/com/google/gson/functional/NamingPolicyTest.java\nindex 9369b2b744..bd91e36e1d 100644\n--- a/gson/src/test/java/com/google/gson/functional/NamingPolicyTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/NamingPolicyTest.java\n@@ -324,20 +324,20 @@ public String translateName(Field f) {\n \n   @SuppressWarnings(\"unused\")\n   private static class ClassWithDuplicateFields {\n-    public Integer a;\n+    Integer a;\n \n     @SerializedName(\"a\")\n-    public Double b;\n+    Double b;\n \n-    public ClassWithDuplicateFields(Integer a) {\n+    ClassWithDuplicateFields(Integer a) {\n       this(a, null);\n     }\n \n-    public ClassWithDuplicateFields(Double b) {\n+    ClassWithDuplicateFields(Double b) {\n       this(null, b);\n     }\n \n-    public ClassWithDuplicateFields(Integer a, Double b) {\n+    ClassWithDuplicateFields(Integer a, Double b) {\n       this.a = a;\n       this.b = b;\n     }\n@@ -345,7 +345,7 @@ public ClassWithDuplicateFields(Integer a, Double b) {\n \n   private static class ClassWithComplexFieldName {\n     @SerializedName(\"@value\\\"_s$\\\\\")\n-    public final long value;\n+    final long value;\n \n     ClassWithComplexFieldName(long value) {\n       this.value = value;\n@@ -354,9 +354,9 @@ private static class ClassWithComplexFieldName {\n \n   @SuppressWarnings(\"unused\")\n   private static class ClassWithTwoFields {\n-    public int a;\n-    public int b;\n+    int a;\n+    int b;\n \n-    public ClassWithTwoFields() {}\n+    ClassWithTwoFields() {}\n   }\n }\ndiff --git a/gson/src/test/java/com/google/gson/functional/ObjectTest.java b/gson/src/test/java/com/google/gson/functional/ObjectTest.java\nindex 5812daf8f1..72ea432df4 100644\n--- a/gson/src/test/java/com/google/gson/functional/ObjectTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/ObjectTest.java\n@@ -497,7 +497,7 @@ private class Child {\n   private static class ArrayOfArrays {\n     private final BagOfPrimitives[][] elements;\n \n-    public ArrayOfArrays() {\n+    ArrayOfArrays() {\n       elements = new BagOfPrimitives[3][2];\n       for (int i = 0; i < elements.length; ++i) {\n         BagOfPrimitives[] row = elements[i];\n@@ -507,7 +507,7 @@ public ArrayOfArrays() {\n       }\n     }\n \n-    public String getExpectedJson() {\n+    String getExpectedJson() {\n       StringBuilder sb = new StringBuilder(\"{\\\"elements\\\":[\");\n       boolean first = true;\n       for (BagOfPrimitives[] row : elements) {\n@@ -534,7 +534,7 @@ public String getExpectedJson() {\n   }\n \n   private static class ClassWithPrivateNoArgsConstructor {\n-    public int a;\n+    int a;\n \n     private ClassWithPrivateNoArgsConstructor() {\n       a = 10;\ndiff --git a/gson/src/test/java/com/google/gson/functional/ParameterizedTypesTest.java b/gson/src/test/java/com/google/gson/functional/ParameterizedTypesTest.java\nindex 81de888043..bba470774b 100644\n--- a/gson/src/test/java/com/google/gson/functional/ParameterizedTypesTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/ParameterizedTypesTest.java\n@@ -305,7 +305,7 @@ private ObjectWithTypeVariables() {\n       this(null, null, null, null, null, null);\n     }\n \n-    public ObjectWithTypeVariables(\n+    ObjectWithTypeVariables(\n         T obj,\n         T[] array,\n         List<T> list,\n@@ -320,7 +320,7 @@ public ObjectWithTypeVariables(\n       this.arrayOfListOfWildcardTypeParameters = arrayOfWildcardList;\n     }\n \n-    public String getExpectedJson() {\n+    String getExpectedJson() {\n       StringBuilder sb = new StringBuilder().append(\"{\");\n \n       boolean needsComma = false;\n@@ -410,7 +410,7 @@ private void appendObjectsToBuilder(StringBuilder sb, List<? extends T>[] arrayO\n       }\n     }\n \n-    public String toString(T obj) {\n+    String toString(T obj) {\n       return obj.toString();\n     }\n   }\ndiff --git a/gson/src/test/java/com/google/gson/functional/ReflectionAccessFilterTest.java b/gson/src/test/java/com/google/gson/functional/ReflectionAccessFilterTest.java\nindex 5b50fbe1a9..5e981b572e 100644\n--- a/gson/src/test/java/com/google/gson/functional/ReflectionAccessFilterTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/ReflectionAccessFilterTest.java\n@@ -190,12 +190,12 @@ private static class SuperTestClass {}\n \n   private static class SubTestClass extends SuperTestClass {\n     @SuppressWarnings(\"unused\")\n-    public int i = 1;\n+    int i = 1;\n   }\n \n   private static class OtherClass {\n     @SuppressWarnings(\"unused\")\n-    public int i = 2;\n+    int i = 2;\n   }\n \n   @Test\n@@ -329,9 +329,9 @@ public FilterResult check(Class<?> rawClass) {\n   }\n \n   private static class ClassWithoutNoArgsConstructor {\n-    public String s;\n+    String s;\n \n-    public ClassWithoutNoArgsConstructor(String s) {\n+    ClassWithoutNoArgsConstructor(String s) {\n       this.s = s;\n     }\n   }\ndiff --git a/gson/src/test/java/com/google/gson/functional/ReusedTypeVariablesFullyResolveTest.java b/gson/src/test/java/com/google/gson/functional/ReusedTypeVariablesFullyResolveTest.java\nindex e83c5771b5..831438234a 100644\n--- a/gson/src/test/java/com/google/gson/functional/ReusedTypeVariablesFullyResolveTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/ReusedTypeVariablesFullyResolveTest.java\n@@ -68,6 +68,6 @@ private static class TestEnumSetCollection extends SetCollection<TestEnum> {}\n   private static class SetCollection<T> extends BaseCollection<T, Set<T>> {}\n \n   private static class BaseCollection<U, C extends Collection<U>> {\n-    public C collection;\n+    C collection;\n   }\n }\ndiff --git a/gson/src/test/java/com/google/gson/functional/RuntimeTypeAdapterFactoryFunctionalTest.java b/gson/src/test/java/com/google/gson/functional/RuntimeTypeAdapterFactoryFunctionalTest.java\nindex 1a9e6bc916..d115c0df53 100644\n--- a/gson/src/test/java/com/google/gson/functional/RuntimeTypeAdapterFactoryFunctionalTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/RuntimeTypeAdapterFactoryFunctionalTest.java\n@@ -67,7 +67,7 @@ static class Shape {\n     }\n \n     private static final class JsonAdapterFactory extends RuntimeTypeAdapterFactory<Shape> {\n-      public JsonAdapterFactory() {\n+      JsonAdapterFactory() {\n         super(Shape.class, \"type\");\n         registerSubtype(Circle.class, ShapeType.CIRCLE.toString());\n         registerSubtype(Square.class, ShapeType.SQUARE.toString());\ndiff --git a/gson/src/test/java/com/google/gson/functional/TreeTypeAdaptersTest.java b/gson/src/test/java/com/google/gson/functional/TreeTypeAdaptersTest.java\nindex 6e9debbb0c..2d9efca61a 100644\n--- a/gson/src/test/java/com/google/gson/functional/TreeTypeAdaptersTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/TreeTypeAdaptersTest.java\n@@ -91,7 +91,7 @@ private Id(String value, Type typeOfId) {\n       this.typeOfId = typeOfId;\n     }\n \n-    public String getValue() {\n+    String getValue() {\n       return value;\n     }\n   }\n@@ -127,7 +127,7 @@ private Student() {\n       this(null, null);\n     }\n \n-    public Student(Id<Student> id, String name) {\n+    Student(Id<Student> id, String name) {\n       this.id = id;\n       this.name = name;\n     }\n@@ -144,7 +144,7 @@ private Course() {\n       this(null, 0, null, new ArrayList<>());\n     }\n \n-    public Course(\n+    Course(\n         Id<Course<T>> courseId,\n         int numAssignments,\n         Assignment<T> assignment,\n@@ -155,7 +155,7 @@ public Course(\n       this.students = players;\n     }\n \n-    public Id<Course<T>> getId() {\n+    Id<Course<T>> getId() {\n       return courseId;\n     }\n \n@@ -173,7 +173,7 @@ private Assignment() {\n       this(null, null);\n     }\n \n-    public Assignment(Id<Assignment<T>> id, T data) {\n+    Assignment(Id<Assignment<T>> id, T data) {\n       this.id = id;\n       this.data = data;\n     }\ndiff --git a/gson/src/test/java/com/google/gson/functional/TypeAdapterRuntimeTypeWrapperTest.java b/gson/src/test/java/com/google/gson/functional/TypeAdapterRuntimeTypeWrapperTest.java\nindex b81907a335..82fe45ff6a 100644\n--- a/gson/src/test/java/com/google/gson/functional/TypeAdapterRuntimeTypeWrapperTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/TypeAdapterRuntimeTypeWrapperTest.java\n@@ -185,7 +185,7 @@ private static class CyclicSub extends CyclicBase {\n     @SuppressWarnings(\"unused\")\n     int i;\n \n-    public CyclicSub(int i) {\n+    CyclicSub(int i) {\n       this.i = i;\n     }\n   }\ndiff --git a/gson/src/test/java/com/google/gson/integration/OSGiManifestIT.java b/gson/src/test/java/com/google/gson/integration/OSGiManifestIT.java\nindex fd407279de..4182c05ca4 100644\n--- a/gson/src/test/java/com/google/gson/integration/OSGiManifestIT.java\n+++ b/gson/src/test/java/com/google/gson/integration/OSGiManifestIT.java\n@@ -48,10 +48,10 @@\n @SuppressWarnings(\"MemberName\") // class name must end with 'IT' for Maven Failsafe Plugin\n public class OSGiManifestIT {\n   private static class ManifestData {\n-    public final URL url;\n-    public final Manifest manifest;\n+    final URL url;\n+    final Manifest manifest;\n \n-    public ManifestData(URL url, Manifest manifest) {\n+    ManifestData(URL url, Manifest manifest) {\n       this.url = url;\n       this.manifest = manifest;\n     }\ndiff --git a/gson/src/test/java/com/google/gson/internal/ConstructorConstructorTest.java b/gson/src/test/java/com/google/gson/internal/ConstructorConstructorTest.java\nindex ad201fb346..f4e8029260 100644\n--- a/gson/src/test/java/com/google/gson/internal/ConstructorConstructorTest.java\n+++ b/gson/src/test/java/com/google/gson/internal/ConstructorConstructorTest.java\n@@ -43,7 +43,7 @@ public class ConstructorConstructorTest {\n \n   private abstract static class AbstractClass {\n     @SuppressWarnings(\"unused\")\n-    public AbstractClass() {}\n+    AbstractClass() {}\n   }\n \n   private interface Interface {}\ndiff --git a/gson/src/test/java/com/google/gson/internal/GsonTypesTest.java b/gson/src/test/java/com/google/gson/internal/GsonTypesTest.java\nindex 443ef944b9..b76a7e0753 100644\n--- a/gson/src/test/java/com/google/gson/internal/GsonTypesTest.java\n+++ b/gson/src/test/java/com/google/gson/internal/GsonTypesTest.java\n@@ -113,8 +113,8 @@ public static Type getFirstTypeArgument(Type type) throws Exception {\n \n   @Test\n   public void testEqualsOnMethodTypeVariables() throws Exception {\n-    Method m1 = TypeVariableTest.class.getMethod(\"method\");\n-    Method m2 = TypeVariableTest.class.getMethod(\"method\");\n+    Method m1 = TypeVariableTest.class.getDeclaredMethod(\"method\");\n+    Method m2 = TypeVariableTest.class.getDeclaredMethod(\"method\");\n \n     Type rt1 = m1.getGenericReturnType();\n     Type rt2 = m2.getGenericReturnType();\n@@ -124,8 +124,8 @@ public void testEqualsOnMethodTypeVariables() throws Exception {\n \n   @Test\n   public void testEqualsOnConstructorParameterTypeVariables() throws Exception {\n-    Constructor<TypeVariableTest> c1 = TypeVariableTest.class.getConstructor(Object.class);\n-    Constructor<TypeVariableTest> c2 = TypeVariableTest.class.getConstructor(Object.class);\n+    Constructor<TypeVariableTest> c1 = TypeVariableTest.class.getDeclaredConstructor(Object.class);\n+    Constructor<TypeVariableTest> c2 = TypeVariableTest.class.getDeclaredConstructor(Object.class);\n \n     Type rt1 = c1.getGenericParameterTypes()[0];\n     Type rt2 = c2.getGenericParameterTypes()[0];\n@@ -136,10 +136,10 @@ public void testEqualsOnConstructorParameterTypeVariables() throws Exception {\n   private static final class TypeVariableTest {\n \n     @SuppressWarnings(\"unused\")\n-    public <T> TypeVariableTest(T parameter) {}\n+    <T> TypeVariableTest(T parameter) {}\n \n     @SuppressWarnings({\"unused\", \"TypeParameterUnusedInFormals\"})\n-    public <T> T method() {\n+    <T> T method() {\n       return null;\n     }\n   }\ndiff --git a/gson/src/test/java/com/google/gson/internal/LinkedTreeMapSuiteTest.java b/gson/src/test/java/com/google/gson/internal/LinkedTreeMapSuiteTest.java\nindex 4335e7ca11..4979717525 100644\n--- a/gson/src/test/java/com/google/gson/internal/LinkedTreeMapSuiteTest.java\n+++ b/gson/src/test/java/com/google/gson/internal/LinkedTreeMapSuiteTest.java\n@@ -25,7 +25,7 @@ public class LinkedTreeMapSuiteTest {\n   private static class MapGenerator extends TestStringMapGenerator {\n     private final boolean allowNullValues;\n \n-    public MapGenerator(boolean allowNullValues) {\n+    MapGenerator(boolean allowNullValues) {\n       this.allowNullValues = allowNullValues;\n     }\n \ndiff --git a/gson/src/test/java/com/google/gson/internal/bind/Java17ReflectiveTypeAdapterFactoryTest.java b/gson/src/test/java/com/google/gson/internal/bind/Java17ReflectiveTypeAdapterFactoryTest.java\nindex 931b1252b0..441ae17d99 100644\n--- a/gson/src/test/java/com/google/gson/internal/bind/Java17ReflectiveTypeAdapterFactoryTest.java\n+++ b/gson/src/test/java/com/google/gson/internal/bind/Java17ReflectiveTypeAdapterFactoryTest.java\n@@ -47,7 +47,7 @@ public void setUp() throws Exception {\n   // Class for which the normal reflection based adapter is used\n   private static class DummyClass {\n     @SuppressWarnings(\"unused\")\n-    public String s;\n+    String s;\n   }\n \n   @Test\ndiff --git a/gson/src/test/java/com/google/gson/internal/bind/RecursiveTypesResolveTest.java b/gson/src/test/java/com/google/gson/internal/bind/RecursiveTypesResolveTest.java\nindex b30df4cac6..ed93d84b70 100644\n--- a/gson/src/test/java/com/google/gson/internal/bind/RecursiveTypesResolveTest.java\n+++ b/gson/src/test/java/com/google/gson/internal/bind/RecursiveTypesResolveTest.java\n@@ -36,12 +36,12 @@ public class RecursiveTypesResolveTest {\n \n   @SuppressWarnings(\"unused\")\n   private static class Foo1<A> {\n-    public Foo2<? extends A> foo2;\n+    Foo2<? extends A> foo2;\n   }\n \n   @SuppressWarnings(\"unused\")\n   private static class Foo2<B> {\n-    public Foo1<? super B> foo1;\n+    Foo1<? super B> foo1;\n   }\n \n   /** Test simplest case of recursion. */\ndiff --git a/gson/src/test/java/com/google/gson/metrics/PerformanceTest.java b/gson/src/test/java/com/google/gson/metrics/PerformanceTest.java\nindex 2e2add3050..fc401610e3 100644\n--- a/gson/src/test/java/com/google/gson/metrics/PerformanceTest.java\n+++ b/gson/src/test/java/com/google/gson/metrics/PerformanceTest.java\n@@ -83,8 +83,8 @@ private void parseLongJson(String json) throws JsonParseException {\n   }\n \n   private static class ExceptionHolder {\n-    public final String message;\n-    public final String stackTrace;\n+    final String message;\n+    final String stackTrace;\n \n     // For use by Gson\n     @SuppressWarnings(\"unused\")\n@@ -92,7 +92,7 @@ private ExceptionHolder() {\n       this(\"\", \"\");\n     }\n \n-    public ExceptionHolder(String message, String stackTrace) {\n+    ExceptionHolder(String message, String stackTrace) {\n       this.message = message;\n       this.stackTrace = stackTrace;\n     }\n@@ -334,7 +334,7 @@ private static final class ClassWithField {\n       this(\"\");\n     }\n \n-    public ClassWithField(String field) {\n+    ClassWithField(String field) {\n       this.field = field;\n     }\n   }\n",
  "problem_statement" : "Update sources to satisfy a new Error Prone check.\n\nThe latest Error Prone release includes a new check `EffectivelyPrivate`, which flags class members that are public or protected when the enclosing class isn't. This is only a warning in Error Prone, but because we treat warnings as errors it currently breaks the build.\r\n\r\nNearly all cases were in private nested classes in tests. For the most part the members didn't need to be public. In a couple of places they were accessed through reflection in the test, and it was enough to change `getField` to `getDeclaredField` (etc). (`getField` only retrieves public fields.) I don't believe any of these tests depended on the public members for the correctness of what they were testing. Although `getField` works when the target field is public, regardless of the visibility of the containing class, actually reading or writing a field requires both the field and its containing class to be public unless `Field.setAccessible(true)` is called, and likewise for constructors and methods.\r\n\r\n",
  "hints_text" : null,
  "created_at" : "Fri Aug 01 17:21:24 CEST 2025",
  "version" : null,
  "FAIL_TO_PASS" : [ "LinkedTreeMapSuiteTest", "CustomTypeAdaptersTest", "InterceptorTest", "CustomDeserializerTest", "FieldExclusionTest", "NamingPolicyTest", "GsonBuilderTest", "GsonTypesTest", "ExposeAnnotationExclusionStrategyTest", "InheritanceTest", "RecursiveTypesResolveTest", "TypeAdapterRuntimeTypeWrapperTest", "FieldAttributesTest", "PerformanceTest", "RuntimeTypeAdapterFactoryFunctionalTest", "TreeTypeAdaptersTest", "ParameterizedTypesTest", "ReflectionAccessFilterTest", "GsonTest", "ExposeFieldsTest", "OSGiManifestIT", "Java17ReflectiveTypeAdapterFactoryTest", "ConcurrencyTest", "ConstructorConstructorTest", "JsonAdapterSerializerDeserializerTest", "JsonAdapterAnnotationOnFieldsTest", "ReusedTypeVariablesFullyResolveTest", "DelegateTypeAdapterTest", "ExclusionStrategyFunctionalTest", "JsonTreeTest", "MapTest", "ObjectTest", "JsonAdapterAnnotationOnClassesTest", "EnumTest", "CollectionTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -pl gson -Dtest=LinkedTreeMapSuiteTest,CustomTypeAdaptersTest,InterceptorTest,CustomDeserializerTest,FieldExclusionTest,NamingPolicyTest,GsonBuilderTest,GsonTypesTest,ExposeAnnotationExclusionStrategyTest,InheritanceTest,RecursiveTypesResolveTest,TypeAdapterRuntimeTypeWrapperTest,FieldAttributesTest,PerformanceTest,RuntimeTypeAdapterFactoryFunctionalTest,TreeTypeAdaptersTest,ParameterizedTypesTest,ReflectionAccessFilterTest,GsonTest,ExposeFieldsTest,OSGiManifestIT,Java17ReflectiveTypeAdapterFactoryTest,ConcurrencyTest,ConstructorConstructorTest,JsonAdapterSerializerDeserializerTest,JsonAdapterAnnotationOnFieldsTest,ReusedTypeVariablesFullyResolveTest,DelegateTypeAdapterTest,ExclusionStrategyFunctionalTest,JsonTreeTest,MapTest,ObjectTest,JsonAdapterAnnotationOnClassesTest,EnumTest,CollectionTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 2887,
  "metadata" : null
}, {
  "instance_id" : "google-gson-PR-2879",
  "repo" : "google/gson",
  "base_commit" : "164ac9dfe1e9b056faf5e37ec1a2baaf4681dc4f",
  "patch" : "diff --git a/gson/src/main/java/com/google/gson/GsonBuilder.java b/gson/src/main/java/com/google/gson/GsonBuilder.java\nindex f0ea0ae4c8..5879973223 100644\n--- a/gson/src/main/java/com/google/gson/GsonBuilder.java\n+++ b/gson/src/main/java/com/google/gson/GsonBuilder.java\n@@ -33,7 +33,6 @@\n import com.google.gson.annotations.Since;\n import com.google.gson.annotations.Until;\n import com.google.gson.internal.Excluder;\n-import com.google.gson.internal.GsonPreconditions;\n import com.google.gson.internal.bind.DefaultDateTypeAdapter;\n import com.google.gson.internal.bind.TreeTypeAdapter;\n import com.google.gson.internal.bind.TypeAdapters;\n@@ -704,11 +703,16 @@ private static int checkDateFormatStyle(int style) {\n   @CanIgnoreReturnValue\n   public GsonBuilder registerTypeAdapter(Type type, Object typeAdapter) {\n     Objects.requireNonNull(type);\n-    GsonPreconditions.checkArgument(\n-        typeAdapter instanceof JsonSerializer<?>\n-            || typeAdapter instanceof JsonDeserializer<?>\n-            || typeAdapter instanceof InstanceCreator<?>\n-            || typeAdapter instanceof TypeAdapter<?>);\n+    Objects.requireNonNull(typeAdapter);\n+    if (!(typeAdapter instanceof JsonSerializer<?>\n+        || typeAdapter instanceof JsonDeserializer<?>\n+        || typeAdapter instanceof InstanceCreator<?>\n+        || typeAdapter instanceof TypeAdapter<?>)) {\n+      throw new IllegalArgumentException(\n+          \"Class \"\n+              + typeAdapter.getClass().getName()\n+              + \" does not implement any supported type adapter class or interface\");\n+    }\n \n     if (hasNonOverridableAdapter(type)) {\n       throw new IllegalArgumentException(\"Cannot override built-in adapter for \" + type);\n@@ -778,10 +782,15 @@ public GsonBuilder registerTypeAdapterFactory(TypeAdapterFactory factory) {\n   @CanIgnoreReturnValue\n   public GsonBuilder registerTypeHierarchyAdapter(Class<?> baseType, Object typeAdapter) {\n     Objects.requireNonNull(baseType);\n-    GsonPreconditions.checkArgument(\n-        typeAdapter instanceof JsonSerializer<?>\n-            || typeAdapter instanceof JsonDeserializer<?>\n-            || typeAdapter instanceof TypeAdapter<?>);\n+    Objects.requireNonNull(typeAdapter);\n+    if (!(typeAdapter instanceof JsonSerializer<?>\n+        || typeAdapter instanceof JsonDeserializer<?>\n+        || typeAdapter instanceof TypeAdapter<?>)) {\n+      throw new IllegalArgumentException(\n+          \"Class \"\n+              + typeAdapter.getClass().getName()\n+              + \" does not implement any supported type adapter class or interface\");\n+    }\n \n     if (typeAdapter instanceof JsonDeserializer || typeAdapter instanceof JsonSerializer) {\n       hierarchyFactories.add(TreeTypeAdapter.newTypeHierarchyFactory(baseType, typeAdapter));\ndiff --git a/gson/src/main/java/com/google/gson/internal/GsonPreconditions.java b/gson/src/main/java/com/google/gson/internal/GsonPreconditions.java\ndeleted file mode 100644\nindex 780d26e957..0000000000\n--- a/gson/src/main/java/com/google/gson/internal/GsonPreconditions.java\n+++ /dev/null\n@@ -1,43 +0,0 @@\n-/*\n- * Copyright (C) 2008 Google Inc.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package com.google.gson.internal;\n-\n-/**\n- * A simple utility class used to check method Preconditions.\n- *\n- * <pre>\n- * public long divideBy(long value) {\n- *   Preconditions.checkArgument(value != 0);\n- *   return this.value / value;\n- * }\n- * </pre>\n- *\n- * @author Inderjeet Singh\n- * @author Joel Leitch\n- */\n-@SuppressWarnings(\"MemberName\") // legacy class name\n-public final class GsonPreconditions {\n-  private GsonPreconditions() {\n-    throw new UnsupportedOperationException();\n-  }\n-\n-  public static void checkArgument(boolean condition) {\n-    if (!condition) {\n-      throw new IllegalArgumentException();\n-    }\n-  }\n-}\ndiff --git a/gson/src/main/java/com/google/gson/internal/GsonTypes.java b/gson/src/main/java/com/google/gson/internal/GsonTypes.java\nindex a29d142cbb..caaad3b46c 100644\n--- a/gson/src/main/java/com/google/gson/internal/GsonTypes.java\n+++ b/gson/src/main/java/com/google/gson/internal/GsonTypes.java\n@@ -16,7 +16,6 @@\n \n package com.google.gson.internal;\n \n-import static com.google.gson.internal.GsonPreconditions.checkArgument;\n import static java.util.Objects.requireNonNull;\n \n import java.io.Serializable;\n@@ -139,7 +138,6 @@ public static Class<?> getRawType(Type type) {\n       // getRawType() returns Type instead of Class; that seems to be an API mistake,\n       // see https://bugs.openjdk.org/browse/JDK-8250659\n       Type rawType = parameterizedType.getRawType();\n-      checkArgument(rawType instanceof Class);\n       return (Class<?>) rawType;\n \n     } else if (type instanceof GenericArrayType) {\n@@ -286,7 +284,10 @@ private static Type getSupertype(Type context, Class<?> contextRawType, Class<?>\n       assert bounds.length == 1;\n       context = bounds[0];\n     }\n-    checkArgument(supertype.isAssignableFrom(contextRawType));\n+    if (!supertype.isAssignableFrom(contextRawType)) {\n+      throw new IllegalArgumentException(\n+          contextRawType + \" is not the same as or a subtype of \" + supertype);\n+    }\n     return resolve(\n         context, contextRawType, GsonTypes.getGenericSupertype(context, contextRawType, supertype));\n   }\n@@ -485,7 +486,9 @@ private static Class<?> declaringClassOf(TypeVariable<?> typeVariable) {\n   }\n \n   static void checkNotPrimitive(Type type) {\n-    checkArgument(!(type instanceof Class<?>) || !((Class<?>) type).isPrimitive());\n+    if (type instanceof Class<?> && ((Class<?>) type).isPrimitive()) {\n+      throw new IllegalArgumentException(\"Primitive type is not allowed\");\n+    }\n   }\n \n   /**\n@@ -632,13 +635,20 @@ private static final class WildcardTypeImpl implements WildcardType, Serializabl\n     private final Type lowerBound;\n \n     public WildcardTypeImpl(Type[] upperBounds, Type[] lowerBounds) {\n-      checkArgument(lowerBounds.length <= 1);\n-      checkArgument(upperBounds.length == 1);\n+      if (lowerBounds.length > 1) {\n+        throw new IllegalArgumentException(\"At most one lower bound is supported\");\n+      }\n+      if (upperBounds.length != 1) {\n+        throw new IllegalArgumentException(\"Exactly one upper bound must be specified\");\n+      }\n \n       if (lowerBounds.length == 1) {\n         requireNonNull(lowerBounds[0]);\n         checkNotPrimitive(lowerBounds[0]);\n-        checkArgument(upperBounds[0] == Object.class);\n+        if (upperBounds[0] != Object.class) {\n+          throw new IllegalArgumentException(\n+              \"When lower bound is specified, upper bound must be Object\");\n+        }\n         this.lowerBound = canonicalize(lowerBounds[0]);\n         this.upperBound = Object.class;\n \ndiff --git a/gson/src/main/java/com/google/gson/internal/bind/TreeTypeAdapter.java b/gson/src/main/java/com/google/gson/internal/bind/TreeTypeAdapter.java\nindex 67d7cdf873..62ea14d383 100644\n--- a/gson/src/main/java/com/google/gson/internal/bind/TreeTypeAdapter.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/TreeTypeAdapter.java\n@@ -25,13 +25,13 @@\n import com.google.gson.JsonSerializer;\n import com.google.gson.TypeAdapter;\n import com.google.gson.TypeAdapterFactory;\n-import com.google.gson.internal.GsonPreconditions;\n import com.google.gson.internal.Streams;\n import com.google.gson.reflect.TypeToken;\n import com.google.gson.stream.JsonReader;\n import com.google.gson.stream.JsonWriter;\n import java.io.IOException;\n import java.lang.reflect.Type;\n+import java.util.Objects;\n \n /**\n  * Adapts a Gson 1.x tree-style adapter as a streaming TypeAdapter. Since the tree adapter may be\n@@ -162,7 +162,13 @@ private static final class SingleTypeFactory implements TypeAdapterFactory {\n       serializer = typeAdapter instanceof JsonSerializer ? (JsonSerializer<?>) typeAdapter : null;\n       deserializer =\n           typeAdapter instanceof JsonDeserializer ? (JsonDeserializer<?>) typeAdapter : null;\n-      GsonPreconditions.checkArgument(serializer != null || deserializer != null);\n+      if (serializer == null && deserializer == null) {\n+        Objects.requireNonNull(typeAdapter);\n+        throw new IllegalArgumentException(\n+            \"Type adapter \"\n+                + typeAdapter.getClass().getName()\n+                + \" must implement JsonSerializer or JsonDeserializer\");\n+      }\n       this.exactType = exactType;\n       this.matchRawType = matchRawType;\n       this.hierarchyType = hierarchyType;\n",
  "test_patch" : "diff --git a/gson/src/test/java/com/google/gson/GsonBuilderTest.java b/gson/src/test/java/com/google/gson/GsonBuilderTest.java\nindex 3ead74fc82..9020cf9e39 100644\n--- a/gson/src/test/java/com/google/gson/GsonBuilderTest.java\n+++ b/gson/src/test/java/com/google/gson/GsonBuilderTest.java\n@@ -248,6 +248,20 @@ public void testSetStrictness() throws IOException {\n     assertThat(gson.newJsonWriter(new StringWriter()).getStrictness()).isEqualTo(strictness);\n   }\n \n+  @Test\n+  public void testRegisterTypeAdapterNotAdapterClass() {\n+    GsonBuilder gsonBuilder = new GsonBuilder();\n+    IllegalArgumentException e =\n+        assertThrows(\n+            IllegalArgumentException.class,\n+            () -> gsonBuilder.registerTypeAdapter(Integer.class, \"test\"));\n+    assertThat(e)\n+        .hasMessageThat()\n+        .isEqualTo(\n+            \"Class java.lang.String does not implement any supported type adapter class or\"\n+                + \" interface\");\n+  }\n+\n   @Test\n   public void testRegisterTypeAdapterForObjectAndJsonElements() {\n     String errorMessage = \"Cannot override built-in adapter for \";\n@@ -280,6 +294,20 @@ public void testRegisterTypeAdapterForJsonElements() {\n     assertThat(adapter.toJson(new JsonArray())).isEqualTo(\"[]\");\n   }\n \n+  @Test\n+  public void testRegisterTypeHierarchyAdapterNotAdapterClass() {\n+    GsonBuilder gsonBuilder = new GsonBuilder();\n+    IllegalArgumentException e =\n+        assertThrows(\n+            IllegalArgumentException.class,\n+            () -> gsonBuilder.registerTypeHierarchyAdapter(Integer.class, \"test\"));\n+    assertThat(e)\n+        .hasMessageThat()\n+        .isEqualTo(\n+            \"Class java.lang.String does not implement any supported type adapter class or\"\n+                + \" interface\");\n+  }\n+\n   @Ignore(\n       \"Registering adapter for JsonElement is allowed (for now) for backward compatibility, see\"\n           + \" https://github.com/google/gson/issues/2787\")\ndiff --git a/gson/src/test/java/com/google/gson/internal/GsonTypesTest.java b/gson/src/test/java/com/google/gson/internal/GsonTypesTest.java\nindex 95eee256c8..443ef944b9 100644\n--- a/gson/src/test/java/com/google/gson/internal/GsonTypesTest.java\n+++ b/gson/src/test/java/com/google/gson/internal/GsonTypesTest.java\n@@ -29,6 +29,16 @@\n \n @SuppressWarnings(\"ClassNamedLikeTypeParameter\") // for dummy classes A, B, ...\n public final class GsonTypesTest {\n+  @Test\n+  public void testWildcardBoundsInvalid() {\n+    String expectedMessage = \"Primitive type is not allowed\";\n+    IllegalArgumentException e =\n+        assertThrows(IllegalArgumentException.class, () -> GsonTypes.subtypeOf(int.class));\n+    assertThat(e).hasMessageThat().isEqualTo(expectedMessage);\n+\n+    e = assertThrows(IllegalArgumentException.class, () -> GsonTypes.supertypeOf(int.class));\n+    assertThat(e).hasMessageThat().isEqualTo(expectedMessage);\n+  }\n \n   @Test\n   public void testNewParameterizedTypeWithoutOwner() throws Exception {\n",
  "problem_statement" : "Remove internal class `GsonPreconditions`\n\nInstead manually throw exceptions, also with exception messages providing more context\r\n\r\nFollow-up for https://github.com/google/gson/pull/2878#pullrequestreview-3022433654",
  "hints_text" : null,
  "created_at" : "Wed Jul 16 21:54:50 CEST 2025",
  "version" : null,
  "FAIL_TO_PASS" : [ "GsonBuilderTest", "GsonTypesTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -pl gson -Dtest=GsonBuilderTest,GsonTypesTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 2879,
  "metadata" : null
}, {
  "instance_id" : "google-gson-PR-2874",
  "repo" : "google/gson",
  "base_commit" : "9a492d7b55080b60f8aa26ace0c91362ea65b962",
  "patch" : "diff --git a/gson/pom.xml b/gson/pom.xml\nindex 8e97368e22..4dff9e67b2 100644\n--- a/gson/pom.xml\n+++ b/gson/pom.xml\n@@ -50,7 +50,7 @@\n     <dependency>\n       <groupId>com.google.errorprone</groupId>\n       <artifactId>error_prone_annotations</artifactId>\n-      <version>2.38.0</version>\n+      <version>2.39.0</version>\n     </dependency>\n \n     <dependency>\ndiff --git a/pom.xml b/pom.xml\nindex 009ab4e475..e80e927670 100644\n--- a/pom.xml\n+++ b/pom.xml\n@@ -302,7 +302,7 @@\n               <path>\n                 <groupId>com.google.errorprone</groupId>\n                 <artifactId>error_prone_core</artifactId>\n-                <version>2.38.0</version>\n+                <version>2.39.0</version>\n               </path>\n             </annotationProcessorPaths>\n           </configuration>\n",
  "test_patch" : "diff --git a/gson/src/test/java/com/google/gson/functional/CustomTypeAdaptersTest.java b/gson/src/test/java/com/google/gson/functional/CustomTypeAdaptersTest.java\nindex 5a4371813a..ff0570dc33 100644\n--- a/gson/src/test/java/com/google/gson/functional/CustomTypeAdaptersTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/CustomTypeAdaptersTest.java\n@@ -252,8 +252,8 @@ public void testCustomDeserializerInvokedForPrimitives() {\n                 boolean.class,\n                 (JsonDeserializer<Boolean>) (json, type, context) -> json.getAsInt() != 0)\n             .create();\n-    assertThat(gson.fromJson(\"1\", boolean.class)).isEqualTo(Boolean.TRUE);\n-    assertThat(gson.fromJson(\"true\", Boolean.class)).isEqualTo(Boolean.TRUE);\n+    assertThat(gson.fromJson(\"1\", boolean.class)).isEqualTo(true);\n+    assertThat(gson.fromJson(\"true\", Boolean.class)).isEqualTo(true);\n   }\n \n   @Test\ndiff --git a/gson/src/test/java/com/google/gson/functional/MapTest.java b/gson/src/test/java/com/google/gson/functional/MapTest.java\nindex b48484e224..b9c1b504f8 100644\n--- a/gson/src/test/java/com/google/gson/functional/MapTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/MapTest.java\n@@ -536,7 +536,7 @@ public void testWriteMapsWithEmptyStringKey() {\n   public void testReadMapsWithEmptyStringKey() {\n     Map<String, Boolean> map =\n         gson.fromJson(\"{\\\"\\\":true}\", new TypeToken<Map<String, Boolean>>() {}.getType());\n-    assertThat(map.get(\"\")).isEqualTo(Boolean.TRUE);\n+    assertThat(map.get(\"\")).isEqualTo(true);\n   }\n \n   /** From bug report http://code.google.com/p/google-gson/issues/detail?id=204 */\ndiff --git a/gson/src/test/java/com/google/gson/stream/JsonReaderTest.java b/gson/src/test/java/com/google/gson/stream/JsonReaderTest.java\nindex f8a33be0df..e538d6b29b 100644\n--- a/gson/src/test/java/com/google/gson/stream/JsonReaderTest.java\n+++ b/gson/src/test/java/com/google/gson/stream/JsonReaderTest.java\n@@ -1729,10 +1729,9 @@ public void testDeeplyNestedArrays() throws IOException {\n   @Test\n   public void testDeeplyNestedObjects() throws IOException {\n     // Build a JSON document structured like {\"a\":{\"a\":{\"a\":{\"a\":true}}}}, but 40 levels deep\n-    String array = \"{\\\"a\\\":%s}\";\n     String json = \"true\";\n     for (int i = 0; i < 40; i++) {\n-      json = String.format(array, json);\n+      json = String.format(\"{\\\"a\\\":%s}\", json);\n     }\n \n     JsonReader reader = new JsonReader(reader(json));\n",
  "problem_statement" : "Update `com.google.errorprone` and fix issues it flags.\n\nThis time I actually tried building with the new dependency rather than fixing issues one at a time.\r\n",
  "hints_text" : null,
  "created_at" : "Sat Jul 05 17:59:29 CEST 2025",
  "version" : null,
  "FAIL_TO_PASS" : [ "CustomTypeAdaptersTest", "MapTest", "JsonReaderTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=CustomTypeAdaptersTest,MapTest,JsonReaderTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 2874,
  "metadata" : null
}, {
  "instance_id" : "google-gson-PR-2864",
  "repo" : "google/gson",
  "base_commit" : "286843d4a90a4690e5e1f438c944569b3fbfb1d2",
  "patch" : "diff --git a/gson/src/main/java/com/google/gson/Gson.java b/gson/src/main/java/com/google/gson/Gson.java\nindex ab66f2cd2a..a06f290747 100644\n--- a/gson/src/main/java/com/google/gson/Gson.java\n+++ b/gson/src/main/java/com/google/gson/Gson.java\n@@ -16,8 +16,7 @@\n \n package com.google.gson;\n \n-import static com.google.gson.internal.bind.TypeAdapters.atomicLongAdapter;\n-import static com.google.gson.internal.bind.TypeAdapters.atomicLongArrayAdapter;\n+import static com.google.gson.GsonBuilder.newImmutableList;\n \n import com.google.gson.annotations.JsonAdapter;\n import com.google.gson.internal.ConstructorConstructor;\n@@ -25,19 +24,10 @@\n import com.google.gson.internal.GsonBuildConfig;\n import com.google.gson.internal.Primitives;\n import com.google.gson.internal.Streams;\n-import com.google.gson.internal.bind.ArrayTypeAdapter;\n-import com.google.gson.internal.bind.CollectionTypeAdapterFactory;\n-import com.google.gson.internal.bind.DefaultDateTypeAdapter;\n import com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory;\n import com.google.gson.internal.bind.JsonTreeReader;\n import com.google.gson.internal.bind.JsonTreeWriter;\n-import com.google.gson.internal.bind.MapTypeAdapterFactory;\n-import com.google.gson.internal.bind.NumberTypeAdapter;\n-import com.google.gson.internal.bind.ObjectTypeAdapter;\n-import com.google.gson.internal.bind.ReflectiveTypeAdapterFactory;\n import com.google.gson.internal.bind.SerializationDelegatingTypeAdapter;\n-import com.google.gson.internal.bind.TypeAdapters;\n-import com.google.gson.internal.sql.SqlTypesSupport;\n import com.google.gson.reflect.TypeToken;\n import com.google.gson.stream.JsonReader;\n import com.google.gson.stream.JsonToken;\n@@ -49,17 +39,12 @@\n import java.io.StringReader;\n import java.io.Writer;\n import java.lang.reflect.Type;\n-import java.text.DateFormat;\n-import java.util.ArrayList;\n-import java.util.Collections;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n import java.util.Objects;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.ConcurrentMap;\n-import java.util.concurrent.atomic.AtomicLong;\n-import java.util.concurrent.atomic.AtomicLongArray;\n \n /**\n  * This is the main class for using Gson. Gson is typically used by first constructing a Gson\n@@ -149,21 +134,6 @@\n  */\n public final class Gson {\n \n-  static final boolean DEFAULT_JSON_NON_EXECUTABLE = false;\n-  // Strictness of `null` is the legacy mode where some Gson APIs are always lenient\n-  static final Strictness DEFAULT_STRICTNESS = null;\n-  static final FormattingStyle DEFAULT_FORMATTING_STYLE = FormattingStyle.COMPACT;\n-  static final boolean DEFAULT_ESCAPE_HTML = true;\n-  static final boolean DEFAULT_SERIALIZE_NULLS = false;\n-  static final boolean DEFAULT_COMPLEX_MAP_KEYS = false;\n-  static final boolean DEFAULT_SPECIALIZE_FLOAT_VALUES = false;\n-  static final boolean DEFAULT_USE_JDK_UNSAFE = true;\n-  static final String DEFAULT_DATE_PATTERN = null;\n-  static final FieldNamingStrategy DEFAULT_FIELD_NAMING_STRATEGY = FieldNamingPolicy.IDENTITY;\n-  static final ToNumberStrategy DEFAULT_OBJECT_TO_NUMBER_STRATEGY = ToNumberPolicy.DOUBLE;\n-  static final ToNumberStrategy DEFAULT_NUMBER_TO_NUMBER_STRATEGY =\n-      ToNumberPolicy.LAZILY_PARSED_NUMBER;\n-\n   private static final String JSON_NON_EXECUTABLE_PREFIX = \")]}'\\n\";\n \n   /**\n@@ -250,144 +220,40 @@ public final class Gson {\n    * </ul>\n    */\n   public Gson() {\n-    this(\n-        Excluder.DEFAULT,\n-        DEFAULT_FIELD_NAMING_STRATEGY,\n-        Collections.emptyMap(),\n-        DEFAULT_SERIALIZE_NULLS,\n-        DEFAULT_COMPLEX_MAP_KEYS,\n-        DEFAULT_JSON_NON_EXECUTABLE,\n-        DEFAULT_ESCAPE_HTML,\n-        DEFAULT_FORMATTING_STYLE,\n-        DEFAULT_STRICTNESS,\n-        DEFAULT_SPECIALIZE_FLOAT_VALUES,\n-        DEFAULT_USE_JDK_UNSAFE,\n-        LongSerializationPolicy.DEFAULT,\n-        DEFAULT_DATE_PATTERN,\n-        DateFormat.DEFAULT,\n-        DateFormat.DEFAULT,\n-        Collections.emptyList(),\n-        Collections.emptyList(),\n-        Collections.emptyList(),\n-        DEFAULT_OBJECT_TO_NUMBER_STRATEGY,\n-        DEFAULT_NUMBER_TO_NUMBER_STRATEGY,\n-        Collections.emptyList());\n+    this(GsonBuilder.DEFAULT);\n   }\n \n-  Gson(\n-      Excluder excluder,\n-      FieldNamingStrategy fieldNamingStrategy,\n-      Map<Type, InstanceCreator<?>> instanceCreators,\n-      boolean serializeNulls,\n-      boolean complexMapKeySerialization,\n-      boolean generateNonExecutableGson,\n-      boolean htmlSafe,\n-      FormattingStyle formattingStyle,\n-      Strictness strictness,\n-      boolean serializeSpecialFloatingPointValues,\n-      boolean useJdkUnsafe,\n-      LongSerializationPolicy longSerializationPolicy,\n-      String datePattern,\n-      int dateStyle,\n-      int timeStyle,\n-      List<TypeAdapterFactory> builderFactories,\n-      List<TypeAdapterFactory> builderHierarchyFactories,\n-      List<TypeAdapterFactory> factoriesToBeAdded,\n-      ToNumberStrategy objectToNumberStrategy,\n-      ToNumberStrategy numberToNumberStrategy,\n-      List<ReflectionAccessFilter> reflectionFilters) {\n-    this.excluder = excluder;\n-    this.fieldNamingStrategy = fieldNamingStrategy;\n-    this.instanceCreators = instanceCreators;\n-    this.constructorConstructor =\n-        new ConstructorConstructor(instanceCreators, useJdkUnsafe, reflectionFilters);\n-    this.serializeNulls = serializeNulls;\n-    this.complexMapKeySerialization = complexMapKeySerialization;\n-    this.generateNonExecutableJson = generateNonExecutableGson;\n-    this.htmlSafe = htmlSafe;\n-    this.formattingStyle = formattingStyle;\n-    this.strictness = strictness;\n-    this.serializeSpecialFloatingPointValues = serializeSpecialFloatingPointValues;\n-    this.useJdkUnsafe = useJdkUnsafe;\n-    this.longSerializationPolicy = longSerializationPolicy;\n-    this.datePattern = datePattern;\n-    this.dateStyle = dateStyle;\n-    this.timeStyle = timeStyle;\n-    this.builderFactories = builderFactories;\n-    this.builderHierarchyFactories = builderHierarchyFactories;\n-    this.objectToNumberStrategy = objectToNumberStrategy;\n-    this.numberToNumberStrategy = numberToNumberStrategy;\n-    this.reflectionFilters = reflectionFilters;\n-\n-    List<TypeAdapterFactory> factories = new ArrayList<>();\n-\n-    // built-in type adapters that cannot be overridden\n-    factories.add(TypeAdapters.JSON_ELEMENT_FACTORY);\n-    factories.add(ObjectTypeAdapter.getFactory(objectToNumberStrategy));\n-\n-    // the excluder must precede all adapters that handle user-defined types\n-    factories.add(excluder);\n-\n-    // users' type adapters\n-    factories.addAll(factoriesToBeAdded);\n-\n-    // type adapters for basic platform types\n-    factories.add(TypeAdapters.STRING_FACTORY);\n-    factories.add(TypeAdapters.INTEGER_FACTORY);\n-    factories.add(TypeAdapters.BOOLEAN_FACTORY);\n-    factories.add(TypeAdapters.BYTE_FACTORY);\n-    factories.add(TypeAdapters.SHORT_FACTORY);\n-    TypeAdapter<Number> longAdapter = longSerializationPolicy.typeAdapter();\n-    factories.add(TypeAdapters.newFactory(long.class, Long.class, longAdapter));\n-    factories.add(TypeAdapters.newFactory(double.class, Double.class, doubleAdapter()));\n-    factories.add(TypeAdapters.newFactory(float.class, Float.class, floatAdapter()));\n-    factories.add(NumberTypeAdapter.getFactory(numberToNumberStrategy));\n-    factories.add(TypeAdapters.ATOMIC_INTEGER_FACTORY);\n-    factories.add(TypeAdapters.ATOMIC_BOOLEAN_FACTORY);\n-    factories.add(TypeAdapters.newFactory(AtomicLong.class, atomicLongAdapter(longAdapter)));\n-    factories.add(\n-        TypeAdapters.newFactory(AtomicLongArray.class, atomicLongArrayAdapter(longAdapter)));\n-    factories.add(TypeAdapters.ATOMIC_INTEGER_ARRAY_FACTORY);\n-    factories.add(TypeAdapters.CHARACTER_FACTORY);\n-    factories.add(TypeAdapters.STRING_BUILDER_FACTORY);\n-    factories.add(TypeAdapters.STRING_BUFFER_FACTORY);\n-    factories.add(TypeAdapters.BIG_DECIMAL_FACTORY);\n-    factories.add(TypeAdapters.BIG_INTEGER_FACTORY);\n-    // Add adapter for LazilyParsedNumber because user can obtain it from Gson and then try to\n-    // serialize it again\n-    factories.add(TypeAdapters.LAZILY_PARSED_NUMBER_FACTORY);\n-    factories.add(TypeAdapters.URL_FACTORY);\n-    factories.add(TypeAdapters.URI_FACTORY);\n-    factories.add(TypeAdapters.UUID_FACTORY);\n-    factories.add(TypeAdapters.CURRENCY_FACTORY);\n-    factories.add(TypeAdapters.LOCALE_FACTORY);\n-    factories.add(TypeAdapters.INET_ADDRESS_FACTORY);\n-    factories.add(TypeAdapters.BIT_SET_FACTORY);\n-    factories.add(DefaultDateTypeAdapter.DEFAULT_STYLE_FACTORY);\n-    factories.add(TypeAdapters.CALENDAR_FACTORY);\n-    factories.addAll(SqlTypesSupport.SQL_TYPE_FACTORIES);\n-    TypeAdapterFactory javaTimeFactory = TypeAdapters.javaTimeTypeAdapterFactory();\n-    if (javaTimeFactory != null) {\n-      factories.add(javaTimeFactory);\n+  Gson(GsonBuilder builder) {\n+    this.excluder = builder.excluder;\n+    this.fieldNamingStrategy = builder.fieldNamingPolicy;\n+    this.instanceCreators = new HashMap<>(builder.instanceCreators);\n+    this.serializeNulls = builder.serializeNulls;\n+    this.complexMapKeySerialization = builder.complexMapKeySerialization;\n+    this.generateNonExecutableJson = builder.generateNonExecutableJson;\n+    this.htmlSafe = builder.escapeHtmlChars;\n+    this.formattingStyle = builder.formattingStyle;\n+    this.strictness = builder.strictness;\n+    this.serializeSpecialFloatingPointValues = builder.serializeSpecialFloatingPointValues;\n+    this.useJdkUnsafe = builder.useJdkUnsafe;\n+    this.longSerializationPolicy = builder.longSerializationPolicy;\n+    this.datePattern = builder.datePattern;\n+    this.dateStyle = builder.dateStyle;\n+    this.timeStyle = builder.timeStyle;\n+    this.builderFactories = newImmutableList(builder.factories);\n+    this.builderHierarchyFactories = newImmutableList(builder.hierarchyFactories);\n+    this.objectToNumberStrategy = builder.objectToNumberStrategy;\n+    this.numberToNumberStrategy = builder.numberToNumberStrategy;\n+    this.reflectionFilters = newImmutableList(builder.reflectionFilters);\n+    if (builder == GsonBuilder.DEFAULT) {\n+      this.constructorConstructor = GsonBuilder.DEFAULT_CONSTRUCTOR_CONSTRUCTOR;\n+      this.jsonAdapterFactory = GsonBuilder.DEFAULT_JSON_ADAPTER_ANNOTATION_TYPE_ADAPTER_FACTORY;\n+      this.factories = GsonBuilder.DEFAULT_TYPE_ADAPTER_FACTORIES;\n+    } else {\n+      this.constructorConstructor =\n+          new ConstructorConstructor(instanceCreators, useJdkUnsafe, reflectionFilters);\n+      this.jsonAdapterFactory = new JsonAdapterAnnotationTypeAdapterFactory(constructorConstructor);\n+      this.factories = builder.createFactories(constructorConstructor, jsonAdapterFactory);\n     }\n-    factories.add(ArrayTypeAdapter.FACTORY);\n-    factories.add(TypeAdapters.CLASS_FACTORY);\n-\n-    // type adapters for composite and user-defined types\n-    factories.add(new CollectionTypeAdapterFactory(constructorConstructor));\n-    factories.add(new MapTypeAdapterFactory(constructorConstructor, complexMapKeySerialization));\n-    this.jsonAdapterFactory = new JsonAdapterAnnotationTypeAdapterFactory(constructorConstructor);\n-    factories.add(jsonAdapterFactory);\n-    factories.add(TypeAdapters.ENUM_FACTORY);\n-    factories.add(\n-        new ReflectiveTypeAdapterFactory(\n-            constructorConstructor,\n-            fieldNamingStrategy,\n-            excluder,\n-            jsonAdapterFactory,\n-            reflectionFilters));\n-\n-    this.factories = Collections.unmodifiableList(factories);\n   }\n \n   /**\n@@ -439,14 +305,6 @@ public boolean htmlSafe() {\n     return htmlSafe;\n   }\n \n-  private TypeAdapter<Number> floatAdapter() {\n-    return serializeSpecialFloatingPointValues ? TypeAdapters.FLOAT : TypeAdapters.FLOAT_STRICT;\n-  }\n-\n-  private TypeAdapter<Number> doubleAdapter() {\n-    return serializeSpecialFloatingPointValues ? TypeAdapters.DOUBLE : TypeAdapters.DOUBLE_STRICT;\n-  }\n-\n   /**\n    * Returns the type adapter for {@code type}.\n    *\ndiff --git a/gson/src/main/java/com/google/gson/GsonBuilder.java b/gson/src/main/java/com/google/gson/GsonBuilder.java\nindex 5879973223..1cd29f9fff 100644\n--- a/gson/src/main/java/com/google/gson/GsonBuilder.java\n+++ b/gson/src/main/java/com/google/gson/GsonBuilder.java\n@@ -16,24 +16,20 @@\n \n package com.google.gson;\n \n-import static com.google.gson.Gson.DEFAULT_COMPLEX_MAP_KEYS;\n-import static com.google.gson.Gson.DEFAULT_DATE_PATTERN;\n-import static com.google.gson.Gson.DEFAULT_ESCAPE_HTML;\n-import static com.google.gson.Gson.DEFAULT_FORMATTING_STYLE;\n-import static com.google.gson.Gson.DEFAULT_JSON_NON_EXECUTABLE;\n-import static com.google.gson.Gson.DEFAULT_NUMBER_TO_NUMBER_STRATEGY;\n-import static com.google.gson.Gson.DEFAULT_OBJECT_TO_NUMBER_STRATEGY;\n-import static com.google.gson.Gson.DEFAULT_SERIALIZE_NULLS;\n-import static com.google.gson.Gson.DEFAULT_SPECIALIZE_FLOAT_VALUES;\n-import static com.google.gson.Gson.DEFAULT_STRICTNESS;\n-import static com.google.gson.Gson.DEFAULT_USE_JDK_UNSAFE;\n-\n import com.google.errorprone.annotations.CanIgnoreReturnValue;\n import com.google.errorprone.annotations.InlineMe;\n import com.google.gson.annotations.Since;\n import com.google.gson.annotations.Until;\n+import com.google.gson.internal.ConstructorConstructor;\n import com.google.gson.internal.Excluder;\n+import com.google.gson.internal.bind.ArrayTypeAdapter;\n+import com.google.gson.internal.bind.CollectionTypeAdapterFactory;\n import com.google.gson.internal.bind.DefaultDateTypeAdapter;\n+import com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory;\n+import com.google.gson.internal.bind.MapTypeAdapterFactory;\n+import com.google.gson.internal.bind.NumberTypeAdapter;\n+import com.google.gson.internal.bind.ObjectTypeAdapter;\n+import com.google.gson.internal.bind.ReflectiveTypeAdapterFactory;\n import com.google.gson.internal.bind.TreeTypeAdapter;\n import com.google.gson.internal.bind.TypeAdapters;\n import com.google.gson.internal.sql.SqlTypesSupport;\n@@ -45,12 +41,16 @@\n import java.text.SimpleDateFormat;\n import java.util.ArrayDeque;\n import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n import java.util.Collections;\n import java.util.Date;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicLongArray;\n \n /**\n  * Use this builder to construct a {@link Gson} instance when you need to set configuration options\n@@ -90,29 +90,64 @@\n  * @author Jesse Wilson\n  */\n public final class GsonBuilder {\n-  private Excluder excluder = Excluder.DEFAULT;\n-  private LongSerializationPolicy longSerializationPolicy = LongSerializationPolicy.DEFAULT;\n-  private FieldNamingStrategy fieldNamingPolicy = FieldNamingPolicy.IDENTITY;\n-  private final Map<Type, InstanceCreator<?>> instanceCreators = new HashMap<>();\n-  private final List<TypeAdapterFactory> factories = new ArrayList<>();\n+  private static final boolean DEFAULT_JSON_NON_EXECUTABLE = false;\n+  // Strictness of `null` is the legacy mode where some Gson APIs are always lenient\n+  private static final Strictness DEFAULT_STRICTNESS = null;\n+  private static final FormattingStyle DEFAULT_FORMATTING_STYLE = FormattingStyle.COMPACT;\n+  private static final boolean DEFAULT_ESCAPE_HTML = true;\n+  private static final boolean DEFAULT_SERIALIZE_NULLS = false;\n+  private static final boolean DEFAULT_COMPLEX_MAP_KEYS = false;\n+  private static final boolean DEFAULT_SPECIALIZE_FLOAT_VALUES = false;\n+  private static final boolean DEFAULT_USE_JDK_UNSAFE = true;\n+  private static final String DEFAULT_DATE_PATTERN = null;\n+  private static final FieldNamingStrategy DEFAULT_FIELD_NAMING_STRATEGY =\n+      FieldNamingPolicy.IDENTITY;\n+  private static final ToNumberStrategy DEFAULT_OBJECT_TO_NUMBER_STRATEGY = ToNumberPolicy.DOUBLE;\n+  private static final ToNumberStrategy DEFAULT_NUMBER_TO_NUMBER_STRATEGY =\n+      ToNumberPolicy.LAZILY_PARSED_NUMBER;\n+\n+  static final ConstructorConstructor DEFAULT_CONSTRUCTOR_CONSTRUCTOR =\n+      new ConstructorConstructor(\n+          Collections.emptyMap(), DEFAULT_USE_JDK_UNSAFE, Collections.emptyList());\n+\n+  static final JsonAdapterAnnotationTypeAdapterFactory\n+      DEFAULT_JSON_ADAPTER_ANNOTATION_TYPE_ADAPTER_FACTORY =\n+          new JsonAdapterAnnotationTypeAdapterFactory(DEFAULT_CONSTRUCTOR_CONSTRUCTOR);\n+\n+  /**\n+   * Default instance of the builder, to be used only by the default {@link Gson#Gson()}\n+   * constructor. Must not be used for anything else and must not be leaked to user code, since that\n+   * could lead to accidental modification of this default builder.\n+   */\n+  static final GsonBuilder DEFAULT = new GsonBuilder();\n+\n+  static final List<TypeAdapterFactory> DEFAULT_TYPE_ADAPTER_FACTORIES =\n+      GsonBuilder.DEFAULT.createFactories(\n+          DEFAULT_CONSTRUCTOR_CONSTRUCTOR, DEFAULT_JSON_ADAPTER_ANNOTATION_TYPE_ADAPTER_FACTORY);\n+\n+  Excluder excluder = Excluder.DEFAULT;\n+  LongSerializationPolicy longSerializationPolicy = LongSerializationPolicy.DEFAULT;\n+  FieldNamingStrategy fieldNamingPolicy = DEFAULT_FIELD_NAMING_STRATEGY;\n+  final Map<Type, InstanceCreator<?>> instanceCreators = new HashMap<>();\n+  final List<TypeAdapterFactory> factories = new ArrayList<>();\n \n   /** tree-style hierarchy factories. These come after factories for backwards compatibility. */\n-  private final List<TypeAdapterFactory> hierarchyFactories = new ArrayList<>();\n-\n-  private boolean serializeNulls = DEFAULT_SERIALIZE_NULLS;\n-  private String datePattern = DEFAULT_DATE_PATTERN;\n-  private int dateStyle = DateFormat.DEFAULT;\n-  private int timeStyle = DateFormat.DEFAULT;\n-  private boolean complexMapKeySerialization = DEFAULT_COMPLEX_MAP_KEYS;\n-  private boolean serializeSpecialFloatingPointValues = DEFAULT_SPECIALIZE_FLOAT_VALUES;\n-  private boolean escapeHtmlChars = DEFAULT_ESCAPE_HTML;\n-  private FormattingStyle formattingStyle = DEFAULT_FORMATTING_STYLE;\n-  private boolean generateNonExecutableJson = DEFAULT_JSON_NON_EXECUTABLE;\n-  private Strictness strictness = DEFAULT_STRICTNESS;\n-  private boolean useJdkUnsafe = DEFAULT_USE_JDK_UNSAFE;\n-  private ToNumberStrategy objectToNumberStrategy = DEFAULT_OBJECT_TO_NUMBER_STRATEGY;\n-  private ToNumberStrategy numberToNumberStrategy = DEFAULT_NUMBER_TO_NUMBER_STRATEGY;\n-  private final ArrayDeque<ReflectionAccessFilter> reflectionFilters = new ArrayDeque<>();\n+  final List<TypeAdapterFactory> hierarchyFactories = new ArrayList<>();\n+\n+  boolean serializeNulls = DEFAULT_SERIALIZE_NULLS;\n+  String datePattern = DEFAULT_DATE_PATTERN;\n+  int dateStyle = DateFormat.DEFAULT;\n+  int timeStyle = DateFormat.DEFAULT;\n+  boolean complexMapKeySerialization = DEFAULT_COMPLEX_MAP_KEYS;\n+  boolean serializeSpecialFloatingPointValues = DEFAULT_SPECIALIZE_FLOAT_VALUES;\n+  boolean escapeHtmlChars = DEFAULT_ESCAPE_HTML;\n+  FormattingStyle formattingStyle = DEFAULT_FORMATTING_STYLE;\n+  boolean generateNonExecutableJson = DEFAULT_JSON_NON_EXECUTABLE;\n+  Strictness strictness = DEFAULT_STRICTNESS;\n+  boolean useJdkUnsafe = DEFAULT_USE_JDK_UNSAFE;\n+  ToNumberStrategy objectToNumberStrategy = DEFAULT_OBJECT_TO_NUMBER_STRATEGY;\n+  ToNumberStrategy numberToNumberStrategy = DEFAULT_NUMBER_TO_NUMBER_STRATEGY;\n+  final ArrayDeque<ReflectionAccessFilter> reflectionFilters = new ArrayDeque<>();\n \n   /**\n    * Creates a GsonBuilder instance that can be used to build Gson with various configuration\n@@ -884,43 +919,127 @@ public GsonBuilder addReflectionAccessFilter(ReflectionAccessFilter filter) {\n    * @return an instance of Gson configured with the options currently set in this builder\n    */\n   public Gson create() {\n-    List<TypeAdapterFactory> factories =\n-        new ArrayList<>(this.factories.size() + this.hierarchyFactories.size() + 3);\n-    factories.addAll(this.factories);\n-    Collections.reverse(factories);\n-\n-    List<TypeAdapterFactory> hierarchyFactories = new ArrayList<>(this.hierarchyFactories);\n-    Collections.reverse(hierarchyFactories);\n-    factories.addAll(hierarchyFactories);\n-\n-    addTypeAdaptersForDate(datePattern, dateStyle, timeStyle, factories);\n-\n-    return new Gson(\n-        excluder,\n-        fieldNamingPolicy,\n-        new HashMap<>(instanceCreators),\n-        serializeNulls,\n-        complexMapKeySerialization,\n-        generateNonExecutableJson,\n-        escapeHtmlChars,\n-        formattingStyle,\n-        strictness,\n-        serializeSpecialFloatingPointValues,\n-        useJdkUnsafe,\n-        longSerializationPolicy,\n-        datePattern,\n-        dateStyle,\n-        timeStyle,\n-        new ArrayList<>(this.factories),\n-        new ArrayList<>(this.hierarchyFactories),\n-        factories,\n-        objectToNumberStrategy,\n-        numberToNumberStrategy,\n-        new ArrayList<>(reflectionFilters));\n-  }\n-\n-  private static void addTypeAdaptersForDate(\n-      String datePattern, int dateStyle, int timeStyle, List<TypeAdapterFactory> factories) {\n+    return new Gson(this);\n+  }\n+\n+  List<TypeAdapterFactory> createFactories(\n+      ConstructorConstructor constructorConstructor,\n+      JsonAdapterAnnotationTypeAdapterFactory jsonAdapterFactory) {\n+    ArrayList<TypeAdapterFactory> factories = new ArrayList<>();\n+\n+    // built-in type adapters that cannot be overridden\n+    factories.add(TypeAdapters.JSON_ELEMENT_FACTORY);\n+    factories.add(ObjectTypeAdapter.getFactory(objectToNumberStrategy));\n+\n+    // the excluder must precede all adapters that handle user-defined types\n+    factories.add(excluder);\n+\n+    // users' type adapters\n+    addUserDefinedAdapters(factories);\n+\n+    // custom Date adapters\n+    addDateTypeAdapters(factories);\n+\n+    // type adapters for basic platform types\n+    factories.add(TypeAdapters.STRING_FACTORY);\n+    factories.add(TypeAdapters.INTEGER_FACTORY);\n+    factories.add(TypeAdapters.BOOLEAN_FACTORY);\n+    factories.add(TypeAdapters.BYTE_FACTORY);\n+    factories.add(TypeAdapters.SHORT_FACTORY);\n+    TypeAdapter<Number> longAdapter = longSerializationPolicy.typeAdapter();\n+    factories.add(TypeAdapters.newFactory(long.class, Long.class, longAdapter));\n+    factories.add(TypeAdapters.newFactory(double.class, Double.class, doubleAdapter()));\n+    factories.add(TypeAdapters.newFactory(float.class, Float.class, floatAdapter()));\n+    factories.add(NumberTypeAdapter.getFactory(numberToNumberStrategy));\n+    factories.add(TypeAdapters.ATOMIC_INTEGER_FACTORY);\n+    factories.add(TypeAdapters.ATOMIC_BOOLEAN_FACTORY);\n+    factories.add(\n+        TypeAdapters.newFactory(AtomicLong.class, TypeAdapters.atomicLongAdapter(longAdapter)));\n+    factories.add(\n+        TypeAdapters.newFactory(\n+            AtomicLongArray.class, TypeAdapters.atomicLongArrayAdapter(longAdapter)));\n+    factories.add(TypeAdapters.ATOMIC_INTEGER_ARRAY_FACTORY);\n+    factories.add(TypeAdapters.CHARACTER_FACTORY);\n+    factories.add(TypeAdapters.STRING_BUILDER_FACTORY);\n+    factories.add(TypeAdapters.STRING_BUFFER_FACTORY);\n+    factories.add(TypeAdapters.BIG_DECIMAL_FACTORY);\n+    factories.add(TypeAdapters.BIG_INTEGER_FACTORY);\n+    // Add adapter for LazilyParsedNumber because user can obtain it from Gson and then try to\n+    // serialize it again\n+    factories.add(TypeAdapters.LAZILY_PARSED_NUMBER_FACTORY);\n+    factories.add(TypeAdapters.URL_FACTORY);\n+    factories.add(TypeAdapters.URI_FACTORY);\n+    factories.add(TypeAdapters.UUID_FACTORY);\n+    factories.add(TypeAdapters.CURRENCY_FACTORY);\n+    factories.add(TypeAdapters.LOCALE_FACTORY);\n+    factories.add(TypeAdapters.INET_ADDRESS_FACTORY);\n+    factories.add(TypeAdapters.BIT_SET_FACTORY);\n+    factories.add(DefaultDateTypeAdapter.DEFAULT_STYLE_FACTORY);\n+    factories.add(TypeAdapters.CALENDAR_FACTORY);\n+    TypeAdapterFactory javaTimeFactory = TypeAdapters.javaTimeTypeAdapterFactory();\n+    if (javaTimeFactory != null) {\n+      factories.add(javaTimeFactory);\n+    }\n+    factories.addAll(SqlTypesSupport.SQL_TYPE_FACTORIES);\n+    factories.add(ArrayTypeAdapter.FACTORY);\n+    factories.add(TypeAdapters.CLASS_FACTORY);\n+\n+    // type adapters for composite and user-defined types\n+    factories.add(new CollectionTypeAdapterFactory(constructorConstructor));\n+    factories.add(new MapTypeAdapterFactory(constructorConstructor, complexMapKeySerialization));\n+    factories.add(jsonAdapterFactory);\n+    factories.add(TypeAdapters.ENUM_FACTORY);\n+    factories.add(\n+        new ReflectiveTypeAdapterFactory(\n+            constructorConstructor,\n+            fieldNamingPolicy,\n+            excluder,\n+            jsonAdapterFactory,\n+            newImmutableList(reflectionFilters)));\n+\n+    factories.trimToSize();\n+    return Collections.unmodifiableList(factories);\n+  }\n+\n+  static <E> List<E> newImmutableList(Collection<E> collection) {\n+    if (collection.isEmpty()) {\n+      return Collections.emptyList();\n+    }\n+    if (collection.size() == 1) {\n+      return Collections.singletonList(\n+          collection instanceof List\n+              ? ((List<E>) collection).get(0)\n+              : collection.iterator().next());\n+    }\n+    @SuppressWarnings(\"unchecked\")\n+    List<E> list = (List<E>) Collections.unmodifiableList(Arrays.asList(collection.toArray()));\n+    return list;\n+  }\n+\n+  private TypeAdapter<Number> doubleAdapter() {\n+    return serializeSpecialFloatingPointValues ? TypeAdapters.DOUBLE : TypeAdapters.DOUBLE_STRICT;\n+  }\n+\n+  private TypeAdapter<Number> floatAdapter() {\n+    return serializeSpecialFloatingPointValues ? TypeAdapters.FLOAT : TypeAdapters.FLOAT_STRICT;\n+  }\n+\n+  private void addUserDefinedAdapters(List<TypeAdapterFactory> all) {\n+    if (!this.factories.isEmpty()) {\n+      List<TypeAdapterFactory> reversedFactories = new ArrayList<>(this.factories);\n+      Collections.reverse(reversedFactories);\n+      all.addAll(reversedFactories);\n+    }\n+\n+    if (!this.hierarchyFactories.isEmpty()) {\n+      List<TypeAdapterFactory> reversedHierarchyFactories =\n+          new ArrayList<>(this.hierarchyFactories);\n+      Collections.reverse(reversedHierarchyFactories);\n+      all.addAll(reversedHierarchyFactories);\n+    }\n+  }\n+\n+  private void addDateTypeAdapters(List<TypeAdapterFactory> factories) {\n     TypeAdapterFactory dateAdapterFactory;\n     boolean sqlTypesSupported = SqlTypesSupport.SUPPORTS_SQL_TYPES;\n     TypeAdapterFactory sqlTimestampAdapterFactory = null;\n",
  "test_patch" : "diff --git a/gson/src/test/java/com/google/gson/GsonTest.java b/gson/src/test/java/com/google/gson/GsonTest.java\nindex 4798168984..2d00dd4d35 100644\n--- a/gson/src/test/java/com/google/gson/GsonTest.java\n+++ b/gson/src/test/java/com/google/gson/GsonTest.java\n@@ -28,10 +28,6 @@\n import java.io.IOException;\n import java.io.StringReader;\n import java.io.StringWriter;\n-import java.text.DateFormat;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.HashMap;\n import java.util.concurrent.CountDownLatch;\n import java.util.concurrent.atomic.AtomicInteger;\n import java.util.concurrent.atomic.AtomicReference;\n@@ -53,6 +49,17 @@ public final class GsonTest {\n   private static final ToNumberStrategy CUSTOM_NUMBER_TO_NUMBER_STRATEGY =\n       ToNumberPolicy.LAZILY_PARSED_NUMBER;\n \n+  private static Gson createGson() {\n+    GsonBuilder gsonBuilder = new GsonBuilder();\n+    gsonBuilder.excluder = CUSTOM_EXCLUDER;\n+    gsonBuilder.fieldNamingPolicy = CUSTOM_FIELD_NAMING_STRATEGY;\n+    gsonBuilder.serializeNulls = true;\n+    gsonBuilder.disableHtmlEscaping();\n+    gsonBuilder.objectToNumberStrategy = CUSTOM_OBJECT_TO_NUMBER_STRATEGY;\n+    gsonBuilder.numberToNumberStrategy = CUSTOM_NUMBER_TO_NUMBER_STRATEGY;\n+    return gsonBuilder.create();\n+  }\n+\n   @Test\n   public void testStrictnessDefault() {\n     assertThat(new Gson().strictness).isNull();\n@@ -60,29 +67,7 @@ public void testStrictnessDefault() {\n \n   @Test\n   public void testOverridesDefaultExcluder() {\n-    Gson gson =\n-        new Gson(\n-            CUSTOM_EXCLUDER,\n-            CUSTOM_FIELD_NAMING_STRATEGY,\n-            new HashMap<>(),\n-            true,\n-            false,\n-            true,\n-            false,\n-            FormattingStyle.PRETTY,\n-            Strictness.LENIENT,\n-            false,\n-            true,\n-            LongSerializationPolicy.DEFAULT,\n-            null,\n-            DateFormat.DEFAULT,\n-            DateFormat.DEFAULT,\n-            new ArrayList<>(),\n-            new ArrayList<>(),\n-            new ArrayList<>(),\n-            CUSTOM_OBJECT_TO_NUMBER_STRATEGY,\n-            CUSTOM_NUMBER_TO_NUMBER_STRATEGY,\n-            Collections.emptyList());\n+    Gson gson = createGson();\n \n     assertThat(gson.excluder).isEqualTo(CUSTOM_EXCLUDER);\n     assertThat(gson.fieldNamingStrategy()).isEqualTo(CUSTOM_FIELD_NAMING_STRATEGY);\n@@ -92,29 +77,7 @@ public void testOverridesDefaultExcluder() {\n \n   @Test\n   public void testClonedTypeAdapterFactoryListsAreIndependent() {\n-    Gson original =\n-        new Gson(\n-            CUSTOM_EXCLUDER,\n-            CUSTOM_FIELD_NAMING_STRATEGY,\n-            new HashMap<>(),\n-            true,\n-            false,\n-            true,\n-            false,\n-            FormattingStyle.PRETTY,\n-            Strictness.LENIENT,\n-            false,\n-            true,\n-            LongSerializationPolicy.DEFAULT,\n-            null,\n-            DateFormat.DEFAULT,\n-            DateFormat.DEFAULT,\n-            new ArrayList<>(),\n-            new ArrayList<>(),\n-            new ArrayList<>(),\n-            CUSTOM_OBJECT_TO_NUMBER_STRATEGY,\n-            CUSTOM_NUMBER_TO_NUMBER_STRATEGY,\n-            Collections.emptyList());\n+    Gson original = createGson();\n \n     Gson clone =\n         original.newBuilder().registerTypeAdapter(int.class, new TestTypeAdapter()).create();\n",
  "problem_statement" : "Optimize `new Gson()`\n\nOptimizes `new Gson()`\r\n\r\ncloses https://github.com/google/gson/issues/2863 ",
  "hints_text" : null,
  "created_at" : "Mon Jun 23 08:14:46 CEST 2025",
  "version" : null,
  "FAIL_TO_PASS" : [ "GsonTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -pl gson -Dtest=GsonTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 2864,
  "metadata" : null
}, {
  "instance_id" : "google-gson-PR-2845",
  "repo" : "google/gson",
  "base_commit" : "00ae39775708147e115512be5d4f92bee02e9b89",
  "patch" : "diff --git a/test-shrinker/src/main/java/com/example/InterfaceWithImplementation.java b/test-shrinker/src/main/java/com/example/InterfaceWithImplementation.java\nnew file mode 100644\nindex 0000000000..a86c5f4fd5\n--- /dev/null\n+++ b/test-shrinker/src/main/java/com/example/InterfaceWithImplementation.java\n@@ -0,0 +1,21 @@\n+package com.example;\n+\n+import com.google.gson.annotations.SerializedName;\n+\n+/** Interface whose implementation class is only referenced for deserialization */\n+public interface InterfaceWithImplementation {\n+  String getValue();\n+\n+  // Implementation class which is only referenced in `TypeToken`, but nowhere else\n+  public static class Implementation implements InterfaceWithImplementation {\n+    public Implementation() {}\n+\n+    @SerializedName(\"s\")\n+    public String s;\n+\n+    @Override\n+    public String getValue() {\n+      return s;\n+    }\n+  }\n+}\ndiff --git a/test-shrinker/src/main/java/com/example/Main.java b/test-shrinker/src/main/java/com/example/Main.java\nindex 745200a026..ef6f0e646f 100644\n--- a/test-shrinker/src/main/java/com/example/Main.java\n+++ b/test-shrinker/src/main/java/com/example/Main.java\n@@ -53,6 +53,8 @@ public static void runTests(BiConsumer<String, String> outputConsumer) {\n     testJsonAdapterAnnotation(outputConsumer);\n \n     testGenericClasses(outputConsumer);\n+\n+    testDeserializingInterfaceImpl(outputConsumer);\n   }\n \n   private static void testTypeTokenWriteRead(\n@@ -290,4 +292,25 @@ private static void testGenericClasses(BiConsumer<String, String> outputConsumer\n                     \"{\\\"g\\\": {\\\"t\\\": 1}}\", new TypeToken<GenericUsingGenericClass<DummyClass>>() {})\n                 .toString());\n   }\n+\n+  private static void testDeserializingInterfaceImpl(BiConsumer<String, String> outputConsumer) {\n+    Gson gson = new Gson();\n+    TestExecutor.run(\n+        outputConsumer,\n+        \"Read: Interface implementation\",\n+        () -> {\n+          try {\n+            // Use the interface type here\n+            List<? extends InterfaceWithImplementation> list =\n+                gson.fromJson(\n+                    \"[{\\\"s\\\": \\\"value\\\"}]\",\n+                    // This is the only place where the implementation class is referenced\n+                    new TypeToken<List<InterfaceWithImplementation.Implementation>>() {});\n+            return list.get(0).getValue();\n+          } catch (ClassCastException e) {\n+            // TODO: R8 causes exception, see https://github.com/google/gson/issues/2658\n+            return \"ClassCastException\";\n+          }\n+        });\n+  }\n }\n",
  "test_patch" : "diff --git a/test-shrinker/src/test/java/com/google/gson/it/ShrinkingIT.java b/test-shrinker/src/test/java/com/google/gson/it/ShrinkingIT.java\nindex 527faac0d2..69fe9f7da6 100644\n--- a/test-shrinker/src/test/java/com/google/gson/it/ShrinkingIT.java\n+++ b/test-shrinker/src/test/java/com/google/gson/it/ShrinkingIT.java\n@@ -19,7 +19,7 @@\n import static com.google.common.truth.Truth.assertThat;\n import static org.junit.Assert.assertThrows;\n import static org.junit.Assert.fail;\n-import static org.junit.Assume.assumeTrue;\n+import static org.junit.Assume.assumeFalse;\n \n import com.example.UnusedClass;\n import java.lang.reflect.InvocationTargetException;\n@@ -61,6 +61,11 @@ public void verifyJarExists() {\n     }\n   }\n \n+  /** Returns whether the test is currently running for ProGuard, instead of R8 */\n+  private boolean isTestingProGuard() {\n+    return jarToTest.equals(PROGUARD_RESULT_PATH);\n+  }\n+\n   @FunctionalInterface\n   interface TestAction {\n     void run(Class<?> c) throws Exception;\n@@ -216,6 +221,10 @@ public void test() throws Exception {\n                 \"Read: Using Generic TypeToken\",\n                 \"{g={t=read-1}}\",\n                 \"===\",\n+                \"Read: Interface implementation\",\n+                // TODO: Currently only works for ProGuard but not R8\n+                isTestingProGuard() ? \"value\" : \"ClassCastException\",\n+                \"===\",\n                 \"\"));\n   }\n \n@@ -226,7 +235,7 @@ public void testNoSerializedName_NoArgsConstructor() throws Exception {\n         c -> {\n           Method m = c.getMethod(\"runTestNoArgsConstructor\");\n \n-          if (jarToTest.equals(PROGUARD_RESULT_PATH)) {\n+          if (isTestingProGuard()) {\n             Object result = m.invoke(null);\n             assertThat(result).isEqualTo(\"value\");\n           } else {\n@@ -251,7 +260,7 @@ public void testNoSerializedName_NoArgsConstructorNoJdkUnsafe() throws Exception\n         c -> {\n           Method m = c.getMethod(\"runTestNoJdkUnsafe\");\n \n-          if (jarToTest.equals(PROGUARD_RESULT_PATH)) {\n+          if (isTestingProGuard()) {\n             Object result = m.invoke(null);\n             assertThat(result).isEqualTo(\"value\");\n           } else {\n@@ -278,7 +287,7 @@ public void testNoSerializedName_HasArgsConstructor() throws Exception {\n         c -> {\n           Method m = c.getMethod(\"runTestHasArgsConstructor\");\n \n-          if (jarToTest.equals(PROGUARD_RESULT_PATH)) {\n+          if (isTestingProGuard()) {\n             Object result = m.invoke(null);\n             assertThat(result).isEqualTo(\"value\");\n           } else {\n@@ -300,7 +309,7 @@ public void testNoSerializedName_HasArgsConstructor() throws Exception {\n   public void testUnusedClassRemoved() throws Exception {\n     // For some reason this test only works for R8 but not for ProGuard; ProGuard keeps the unused\n     // class\n-    assumeTrue(jarToTest.equals(R8_RESULT_PATH));\n+    assumeFalse(isTestingProGuard());\n \n     String className = UnusedClass.class.getName();\n     ClassNotFoundException e =\n",
  "problem_statement" : "(Originally reported [here](https://github.com/google/gson/issues/2401#issuecomment-2009588140)).\r\n\r\n# Gson version\r\n2.10.1 + [those](https://github.com/google/gson/blob/main/gson/src/main/resources/META-INF/proguard/gson.pro) proguard rules.\r\n\r\n# Java / Android version\r\nI have tested on Android 34.\r\n\r\n# Used tools\r\n- [x] Gradle; version: 8.2\r\n- [x] R8; version: 8.2.47\r\n\r\n# Description\r\n@Marcono1234 First of all thanks a lot for introducing consumer proguard rules!  \r\n\r\nI have added the rules to one of my projects. Everything seemed to work fine, but I ran into one issue.  \r\nHere's a sample code that makes use of Gson's TypeToken:  \r\n```\r\nprivate List<? extends MyInterface> getData() {\r\n    String input = \"[{\\\"value\\\": \\\"data\\\"}]\";\r\n    Type type = new TypeToken<List<MyImplementation>>() { }.getType();\r\n    return new Gson().fromJson(input, type);\r\n}\r\n```\r\n`MyImplementation` class implements the `MyInterface` interface, and this is its only usage in code.  \r\n\r\nUpon minification, R8 removes the `MyImplementation` class completely, while `TypeToken` is being left with `java.lang.Object` as its generic argument:  \r\n```\r\n.class Linfo/osom/typetokenminify/a;\r\n.super Lh/a;\r\n.source \"SourceFile\"\r\n\r\n# annotations\r\n.annotation system Ldalvik/annotation/Signature;\r\n    value = {\r\n        \"Lh/a<\",\r\n        \"Ljava/util/List<\",\r\n        \"Ljava/lang/Object;\",\r\n        \">;>;\"\r\n    }\r\n.end annotation\r\n```\r\nThis, in turn, causes a runtime exception:\r\n```\r\nCaused by: java.lang.ClassCastException\r\n    at c.a.a(SourceFile:1)\r\n    at info.osom.typetokenminify.MainActivity.onCreate(SourceFile:163)\r\n```\r\n\r\nAs a workaround, I currently have to explicitly keep the class:  \r\n```\r\n-keep,allowobfuscation,allowoptimization class info.osom.typetokenminify.MyImplementation {\r\n  @com.google.gson.annotations.SerializedName <fields>;\r\n}\r\n```\r\nI'm wondering if more general rule can be used in such cases.\r\n\r\n\r\n## Expected behavior\r\nRun the application without errors.\r\n\r\n## Actual behavior\r\nThe application crash at runtime.\r\n\r\n# Reproduction steps\r\nI have uploaded a [sample project](https://github.com/alipov/typetoken-minify) for demonstration.\r\n\r\n",
  "hints_text" : null,
  "created_at" : "Wed Apr 16 00:37:56 CEST 2025",
  "version" : null,
  "FAIL_TO_PASS" : [ "ShrinkingIT" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -pl test-shrinker -Dtest=ShrinkingIT",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : 2658,
  "pull_number" : 2845,
  "metadata" : null
}, {
  "instance_id" : "google-gson-PR-2842",
  "repo" : "google/gson",
  "base_commit" : "e0dadb55f8bff55ffb232f1c6e3b8b0d83e9ecf8",
  "patch" : "diff --git a/gson/src/main/java/com/google/gson/internal/bind/TreeTypeAdapter.java b/gson/src/main/java/com/google/gson/internal/bind/TreeTypeAdapter.java\nindex 9ef79ef7d2..67d7cdf873 100644\n--- a/gson/src/main/java/com/google/gson/internal/bind/TreeTypeAdapter.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/TreeTypeAdapter.java\n@@ -195,7 +195,7 @@ public JsonElement serialize(Object src, Type typeOfSrc) {\n     }\n \n     @Override\n-    @SuppressWarnings({\"unchecked\", \"TypeParameterUnusedInFormals\"})\n+    @SuppressWarnings(\"TypeParameterUnusedInFormals\")\n     public <R> R deserialize(JsonElement json, Type typeOfT) throws JsonParseException {\n       return gson.fromJson(json, typeOfT);\n     }\n",
  "test_patch" : "diff --git a/gson/src/test/java/com/google/gson/functional/MapTest.java b/gson/src/test/java/com/google/gson/functional/MapTest.java\nindex b9c1b504f8..7d2158ffda 100644\n--- a/gson/src/test/java/com/google/gson/functional/MapTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/MapTest.java\n@@ -402,7 +402,7 @@ public V put(K key, V value) {\n \n     @Override\n     public Set<Entry<K, V>> entrySet() {\n-      return Set.of();\n+      return Collections.emptySet();\n     }\n   }\n \n",
  "problem_statement" : "Address some minor Error Prone warnings.",
  "hints_text" : null,
  "created_at" : "Tue Apr 08 22:10:41 CEST 2025",
  "version" : null,
  "FAIL_TO_PASS" : [ "MapTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -pl gson -Dtest=MapTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 2842,
  "metadata" : null
}, {
  "instance_id" : "google-gson-PR-2838",
  "repo" : "google/gson",
  "base_commit" : "c6d44259b53a9b2756b5767b843d15e8acacaa31",
  "patch" : "diff --git a/gson/src/main/java/com/google/gson/GsonBuilder.java b/gson/src/main/java/com/google/gson/GsonBuilder.java\nindex c387bc2d52..f0ea0ae4c8 100644\n--- a/gson/src/main/java/com/google/gson/GsonBuilder.java\n+++ b/gson/src/main/java/com/google/gson/GsonBuilder.java\n@@ -32,8 +32,8 @@\n import com.google.errorprone.annotations.InlineMe;\n import com.google.gson.annotations.Since;\n import com.google.gson.annotations.Until;\n-import com.google.gson.internal.$Gson$Preconditions;\n import com.google.gson.internal.Excluder;\n+import com.google.gson.internal.GsonPreconditions;\n import com.google.gson.internal.bind.DefaultDateTypeAdapter;\n import com.google.gson.internal.bind.TreeTypeAdapter;\n import com.google.gson.internal.bind.TypeAdapters;\n@@ -704,7 +704,7 @@ private static int checkDateFormatStyle(int style) {\n   @CanIgnoreReturnValue\n   public GsonBuilder registerTypeAdapter(Type type, Object typeAdapter) {\n     Objects.requireNonNull(type);\n-    $Gson$Preconditions.checkArgument(\n+    GsonPreconditions.checkArgument(\n         typeAdapter instanceof JsonSerializer<?>\n             || typeAdapter instanceof JsonDeserializer<?>\n             || typeAdapter instanceof InstanceCreator<?>\n@@ -778,7 +778,7 @@ public GsonBuilder registerTypeAdapterFactory(TypeAdapterFactory factory) {\n   @CanIgnoreReturnValue\n   public GsonBuilder registerTypeHierarchyAdapter(Class<?> baseType, Object typeAdapter) {\n     Objects.requireNonNull(baseType);\n-    $Gson$Preconditions.checkArgument(\n+    GsonPreconditions.checkArgument(\n         typeAdapter instanceof JsonSerializer<?>\n             || typeAdapter instanceof JsonDeserializer<?>\n             || typeAdapter instanceof TypeAdapter<?>);\ndiff --git a/gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java b/gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java\nindex 9db6c504ae..5588367366 100644\n--- a/gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java\n+++ b/gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java\n@@ -367,7 +367,7 @@ private static boolean hasStringKeyType(Type mapType) {\n     if (typeArguments.length == 0) {\n       return false;\n     }\n-    return $Gson$Types.getRawType(typeArguments[0]) == String.class;\n+    return GsonTypes.getRawType(typeArguments[0]) == String.class;\n   }\n \n   private static ObjectConstructor<? extends Map<? extends Object, Object>> newMapConstructor(\ndiff --git a/gson/src/main/java/com/google/gson/internal/$Gson$Preconditions.java b/gson/src/main/java/com/google/gson/internal/GsonPreconditions.java\nsimilarity index 95%\nrename from gson/src/main/java/com/google/gson/internal/$Gson$Preconditions.java\nrename to gson/src/main/java/com/google/gson/internal/GsonPreconditions.java\nindex 2398eff3ae..cb2c92480d 100644\n--- a/gson/src/main/java/com/google/gson/internal/$Gson$Preconditions.java\n+++ b/gson/src/main/java/com/google/gson/internal/GsonPreconditions.java\n@@ -32,8 +32,8 @@\n  * @author Joel Leitch\n  */\n @SuppressWarnings(\"MemberName\") // legacy class name\n-public final class $Gson$Preconditions {\n-  private $Gson$Preconditions() {\n+public final class GsonPreconditions {\n+  private GsonPreconditions() {\n     throw new UnsupportedOperationException();\n   }\n \ndiff --git a/gson/src/main/java/com/google/gson/internal/$Gson$Types.java b/gson/src/main/java/com/google/gson/internal/GsonTypes.java\nsimilarity index 97%\nrename from gson/src/main/java/com/google/gson/internal/$Gson$Types.java\nrename to gson/src/main/java/com/google/gson/internal/GsonTypes.java\nindex ab024b4bfa..a29d142cbb 100644\n--- a/gson/src/main/java/com/google/gson/internal/$Gson$Types.java\n+++ b/gson/src/main/java/com/google/gson/internal/GsonTypes.java\n@@ -16,7 +16,7 @@\n \n package com.google.gson.internal;\n \n-import static com.google.gson.internal.$Gson$Preconditions.checkArgument;\n+import static com.google.gson.internal.GsonPreconditions.checkArgument;\n import static java.util.Objects.requireNonNull;\n \n import java.io.Serializable;\n@@ -43,10 +43,10 @@\n  * @author Jesse Wilson\n  */\n @SuppressWarnings(\"MemberName\") // legacy class name\n-public final class $Gson$Types {\n+public final class GsonTypes {\n   static final Type[] EMPTY_TYPE_ARRAY = new Type[] {};\n \n-  private $Gson$Types() {\n+  private GsonTypes() {\n     throw new UnsupportedOperationException();\n   }\n \n@@ -288,9 +288,7 @@ private static Type getSupertype(Type context, Class<?> contextRawType, Class<?>\n     }\n     checkArgument(supertype.isAssignableFrom(contextRawType));\n     return resolve(\n-        context,\n-        contextRawType,\n-        $Gson$Types.getGenericSupertype(context, contextRawType, supertype));\n+        context, contextRawType, GsonTypes.getGenericSupertype(context, contextRawType, supertype));\n   }\n \n   /**\n@@ -555,7 +553,7 @@ public Type getOwnerType() {\n     @Override\n     public boolean equals(Object other) {\n       return other instanceof ParameterizedType\n-          && $Gson$Types.equals(this, (ParameterizedType) other);\n+          && GsonTypes.equals(this, (ParameterizedType) other);\n     }\n \n     private static int hashCodeOrZero(Object o) {\n@@ -604,7 +602,7 @@ public Type getGenericComponentType() {\n \n     @Override\n     public boolean equals(Object o) {\n-      return o instanceof GenericArrayType && $Gson$Types.equals(this, (GenericArrayType) o);\n+      return o instanceof GenericArrayType && GsonTypes.equals(this, (GenericArrayType) o);\n     }\n \n     @Override\n@@ -664,7 +662,7 @@ public Type[] getLowerBounds() {\n \n     @Override\n     public boolean equals(Object other) {\n-      return other instanceof WildcardType && $Gson$Types.equals(this, (WildcardType) other);\n+      return other instanceof WildcardType && GsonTypes.equals(this, (WildcardType) other);\n     }\n \n     @Override\ndiff --git a/gson/src/main/java/com/google/gson/internal/bind/ArrayTypeAdapter.java b/gson/src/main/java/com/google/gson/internal/bind/ArrayTypeAdapter.java\nindex a18cbf9262..50efa418c0 100644\n--- a/gson/src/main/java/com/google/gson/internal/bind/ArrayTypeAdapter.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/ArrayTypeAdapter.java\n@@ -19,7 +19,7 @@\n import com.google.gson.Gson;\n import com.google.gson.TypeAdapter;\n import com.google.gson.TypeAdapterFactory;\n-import com.google.gson.internal.$Gson$Types;\n+import com.google.gson.internal.GsonTypes;\n import com.google.gson.reflect.TypeToken;\n import com.google.gson.stream.JsonReader;\n import com.google.gson.stream.JsonToken;\n@@ -42,13 +42,12 @@ public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n             return null;\n           }\n \n-          Type componentType = $Gson$Types.getArrayComponentType(type);\n+          Type componentType = GsonTypes.getArrayComponentType(type);\n           TypeAdapter<?> componentTypeAdapter = gson.getAdapter(TypeToken.get(componentType));\n \n           @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n           TypeAdapter<T> arrayAdapter =\n-              new ArrayTypeAdapter(\n-                  gson, componentTypeAdapter, $Gson$Types.getRawType(componentType));\n+              new ArrayTypeAdapter(gson, componentTypeAdapter, GsonTypes.getRawType(componentType));\n           return arrayAdapter;\n         }\n       };\ndiff --git a/gson/src/main/java/com/google/gson/internal/bind/CollectionTypeAdapterFactory.java b/gson/src/main/java/com/google/gson/internal/bind/CollectionTypeAdapterFactory.java\nindex 7741edba33..f1f91f7380 100644\n--- a/gson/src/main/java/com/google/gson/internal/bind/CollectionTypeAdapterFactory.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/CollectionTypeAdapterFactory.java\n@@ -19,8 +19,8 @@\n import com.google.gson.Gson;\n import com.google.gson.TypeAdapter;\n import com.google.gson.TypeAdapterFactory;\n-import com.google.gson.internal.$Gson$Types;\n import com.google.gson.internal.ConstructorConstructor;\n+import com.google.gson.internal.GsonTypes;\n import com.google.gson.internal.ObjectConstructor;\n import com.google.gson.reflect.TypeToken;\n import com.google.gson.stream.JsonReader;\n@@ -47,7 +47,7 @@ public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n       return null;\n     }\n \n-    Type elementType = $Gson$Types.getCollectionElementType(type, rawType);\n+    Type elementType = GsonTypes.getCollectionElementType(type, rawType);\n     TypeAdapter<?> elementTypeAdapter = gson.getAdapter(TypeToken.get(elementType));\n     TypeAdapter<?> wrappedTypeAdapter =\n         new TypeAdapterRuntimeTypeWrapper<>(gson, elementTypeAdapter, elementType);\ndiff --git a/gson/src/main/java/com/google/gson/internal/bind/MapTypeAdapterFactory.java b/gson/src/main/java/com/google/gson/internal/bind/MapTypeAdapterFactory.java\nindex e8569557cb..25c73efee8 100644\n--- a/gson/src/main/java/com/google/gson/internal/bind/MapTypeAdapterFactory.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/MapTypeAdapterFactory.java\n@@ -22,8 +22,8 @@\n import com.google.gson.JsonSyntaxException;\n import com.google.gson.TypeAdapter;\n import com.google.gson.TypeAdapterFactory;\n-import com.google.gson.internal.$Gson$Types;\n import com.google.gson.internal.ConstructorConstructor;\n+import com.google.gson.internal.GsonTypes;\n import com.google.gson.internal.JsonReaderInternalAccess;\n import com.google.gson.internal.ObjectConstructor;\n import com.google.gson.internal.Streams;\n@@ -131,7 +131,7 @@ public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n       return null;\n     }\n \n-    Type[] keyAndValueTypes = $Gson$Types.getMapKeyAndValueTypes(type, rawType);\n+    Type[] keyAndValueTypes = GsonTypes.getMapKeyAndValueTypes(type, rawType);\n     Type keyType = keyAndValueTypes[0];\n     Type valueType = keyAndValueTypes[1];\n     TypeAdapter<?> keyAdapter = getKeyAdapter(gson, keyType);\ndiff --git a/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java b/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java\nindex 993a6828f9..827c0b5a48 100644\n--- a/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java\n@@ -27,9 +27,9 @@\n import com.google.gson.TypeAdapterFactory;\n import com.google.gson.annotations.JsonAdapter;\n import com.google.gson.annotations.SerializedName;\n-import com.google.gson.internal.$Gson$Types;\n import com.google.gson.internal.ConstructorConstructor;\n import com.google.gson.internal.Excluder;\n+import com.google.gson.internal.GsonTypes;\n import com.google.gson.internal.ObjectConstructor;\n import com.google.gson.internal.Primitives;\n import com.google.gson.internal.ReflectionAccessFilterHelper;\n@@ -387,7 +387,7 @@ private FieldsData getBoundFields(\n           ReflectionHelper.makeAccessible(field);\n         }\n \n-        Type fieldType = $Gson$Types.resolve(type.getType(), raw, field.getGenericType());\n+        Type fieldType = GsonTypes.resolve(type.getType(), raw, field.getGenericType());\n         List<String> fieldNames = getFieldNames(field);\n         String serializedName = fieldNames.get(0);\n         BoundField boundField =\n@@ -417,7 +417,7 @@ private FieldsData getBoundFields(\n           }\n         }\n       }\n-      type = TypeToken.get($Gson$Types.resolve(type.getType(), raw, raw.getGenericSuperclass()));\n+      type = TypeToken.get(GsonTypes.resolve(type.getType(), raw, raw.getGenericSuperclass()));\n       raw = type.getRawType();\n     }\n     return new FieldsData(deserializedFields, new ArrayList<>(serializedFields.values()));\ndiff --git a/gson/src/main/java/com/google/gson/internal/bind/TreeTypeAdapter.java b/gson/src/main/java/com/google/gson/internal/bind/TreeTypeAdapter.java\nindex 43226f302a..9ef79ef7d2 100644\n--- a/gson/src/main/java/com/google/gson/internal/bind/TreeTypeAdapter.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/TreeTypeAdapter.java\n@@ -25,7 +25,7 @@\n import com.google.gson.JsonSerializer;\n import com.google.gson.TypeAdapter;\n import com.google.gson.TypeAdapterFactory;\n-import com.google.gson.internal.$Gson$Preconditions;\n+import com.google.gson.internal.GsonPreconditions;\n import com.google.gson.internal.Streams;\n import com.google.gson.reflect.TypeToken;\n import com.google.gson.stream.JsonReader;\n@@ -162,7 +162,7 @@ private static final class SingleTypeFactory implements TypeAdapterFactory {\n       serializer = typeAdapter instanceof JsonSerializer ? (JsonSerializer<?>) typeAdapter : null;\n       deserializer =\n           typeAdapter instanceof JsonDeserializer ? (JsonDeserializer<?>) typeAdapter : null;\n-      $Gson$Preconditions.checkArgument(serializer != null || deserializer != null);\n+      GsonPreconditions.checkArgument(serializer != null || deserializer != null);\n       this.exactType = exactType;\n       this.matchRawType = matchRawType;\n       this.hierarchyType = hierarchyType;\ndiff --git a/gson/src/main/java/com/google/gson/reflect/TypeToken.java b/gson/src/main/java/com/google/gson/reflect/TypeToken.java\nindex 6298ae7f44..7e228de716 100644\n--- a/gson/src/main/java/com/google/gson/reflect/TypeToken.java\n+++ b/gson/src/main/java/com/google/gson/reflect/TypeToken.java\n@@ -16,7 +16,7 @@\n \n package com.google.gson.reflect;\n \n-import com.google.gson.internal.$Gson$Types;\n+import com.google.gson.internal.GsonTypes;\n import com.google.gson.internal.TroubleshootingGuide;\n import java.lang.reflect.GenericArrayType;\n import java.lang.reflect.ParameterizedType;\n@@ -72,15 +72,15 @@ public class TypeToken<T> {\n   @SuppressWarnings(\"unchecked\")\n   protected TypeToken() {\n     this.type = getTypeTokenTypeArgument();\n-    this.rawType = (Class<? super T>) $Gson$Types.getRawType(type);\n+    this.rawType = (Class<? super T>) GsonTypes.getRawType(type);\n     this.hashCode = type.hashCode();\n   }\n \n   /** Unsafe. Constructs a type literal manually. */\n   @SuppressWarnings(\"unchecked\")\n   private TypeToken(Type type) {\n-    this.type = $Gson$Types.canonicalize(Objects.requireNonNull(type));\n-    this.rawType = (Class<? super T>) $Gson$Types.getRawType(this.type);\n+    this.type = GsonTypes.canonicalize(Objects.requireNonNull(type));\n+    this.rawType = (Class<? super T>) GsonTypes.getRawType(this.type);\n     this.hashCode = this.type.hashCode();\n   }\n \n@@ -90,14 +90,14 @@ private static boolean isCapturingTypeVariablesForbidden() {\n \n   /**\n    * Verifies that {@code this} is an instance of a direct subclass of TypeToken and returns the\n-   * type argument for {@code T} in {@link $Gson$Types#canonicalize canonical form}.\n+   * type argument for {@code T} in {@link GsonTypes#canonicalize canonical form}.\n    */\n   private Type getTypeTokenTypeArgument() {\n     Type superclass = getClass().getGenericSuperclass();\n     if (superclass instanceof ParameterizedType) {\n       ParameterizedType parameterized = (ParameterizedType) superclass;\n       if (parameterized.getRawType() == TypeToken.class) {\n-        Type typeArgument = $Gson$Types.canonicalize(parameterized.getActualTypeArguments()[0]);\n+        Type typeArgument = GsonTypes.canonicalize(parameterized.getActualTypeArguments()[0]);\n \n         if (isCapturingTypeVariablesForbidden()) {\n           verifyNoTypeVariable(typeArgument);\n@@ -193,11 +193,11 @@ public boolean isAssignableFrom(Type from) {\n     }\n \n     if (type instanceof Class<?>) {\n-      return rawType.isAssignableFrom($Gson$Types.getRawType(from));\n+      return rawType.isAssignableFrom(GsonTypes.getRawType(from));\n     } else if (type instanceof ParameterizedType) {\n       return isAssignableFrom(from, (ParameterizedType) type, new HashMap<String, Type>());\n     } else if (type instanceof GenericArrayType) {\n-      return rawType.isAssignableFrom($Gson$Types.getRawType(from))\n+      return rawType.isAssignableFrom(GsonTypes.getRawType(from))\n           && isAssignableFrom(from, (GenericArrayType) type);\n     } else {\n       throw buildUnsupportedTypeException(\n@@ -253,7 +253,7 @@ private static boolean isAssignableFrom(\n     }\n \n     // First figure out the class and any type information.\n-    Class<?> clazz = $Gson$Types.getRawType(from);\n+    Class<?> clazz = GsonTypes.getRawType(from);\n     ParameterizedType ptype = null;\n     if (from instanceof ParameterizedType) {\n       ptype = (ParameterizedType) from;\n@@ -343,12 +343,12 @@ public final int hashCode() {\n \n   @Override\n   public final boolean equals(Object o) {\n-    return o instanceof TypeToken<?> && $Gson$Types.equals(type, ((TypeToken<?>) o).type);\n+    return o instanceof TypeToken<?> && GsonTypes.equals(type, ((TypeToken<?>) o).type);\n   }\n \n   @Override\n   public final String toString() {\n-    return $Gson$Types.typeToString(type);\n+    return GsonTypes.typeToString(type);\n   }\n \n   /** Gets type literal for the given {@code Type} instance. */\n@@ -412,7 +412,7 @@ public static TypeToken<?> getParameterized(Type rawType, Type... typeArguments)\n     }\n \n     // Check for this here to avoid misleading exception thrown by ParameterizedTypeImpl\n-    if ($Gson$Types.requiresOwnerType(rawType)) {\n+    if (GsonTypes.requiresOwnerType(rawType)) {\n       throw new IllegalArgumentException(\n           \"Raw type \"\n               + rawClass.getName()\n@@ -422,11 +422,11 @@ public static TypeToken<?> getParameterized(Type rawType, Type... typeArguments)\n     for (int i = 0; i < expectedArgsCount; i++) {\n       Type typeArgument =\n           Objects.requireNonNull(typeArguments[i], \"Type argument must not be null\");\n-      Class<?> rawTypeArgument = $Gson$Types.getRawType(typeArgument);\n+      Class<?> rawTypeArgument = GsonTypes.getRawType(typeArgument);\n       TypeVariable<?> typeVariable = typeVariables[i];\n \n       for (Type bound : typeVariable.getBounds()) {\n-        Class<?> rawBound = $Gson$Types.getRawType(bound);\n+        Class<?> rawBound = GsonTypes.getRawType(bound);\n \n         if (!rawBound.isAssignableFrom(rawTypeArgument)) {\n           throw new IllegalArgumentException(\n@@ -440,14 +440,13 @@ public static TypeToken<?> getParameterized(Type rawType, Type... typeArguments)\n       }\n     }\n \n-    return new TypeToken<>(\n-        $Gson$Types.newParameterizedTypeWithOwner(null, rawClass, typeArguments));\n+    return new TypeToken<>(GsonTypes.newParameterizedTypeWithOwner(null, rawClass, typeArguments));\n   }\n \n   /**\n    * Gets type literal for the array type whose elements are all instances of {@code componentType}.\n    */\n   public static TypeToken<?> getArray(Type componentType) {\n-    return new TypeToken<>($Gson$Types.arrayOf(componentType));\n+    return new TypeToken<>(GsonTypes.arrayOf(componentType));\n   }\n }\n",
  "test_patch" : "diff --git a/gson/src/test/java/com/google/gson/GenericArrayTypeTest.java b/gson/src/test/java/com/google/gson/GenericArrayTypeTest.java\nindex f17f29c721..5733df296d 100644\n--- a/gson/src/test/java/com/google/gson/GenericArrayTypeTest.java\n+++ b/gson/src/test/java/com/google/gson/GenericArrayTypeTest.java\n@@ -18,7 +18,7 @@\n \n import static com.google.common.truth.Truth.assertThat;\n \n-import com.google.gson.internal.$Gson$Types;\n+import com.google.gson.internal.GsonTypes;\n import com.google.gson.reflect.TypeToken;\n import java.lang.reflect.GenericArrayType;\n import java.lang.reflect.Type;\n@@ -27,7 +27,7 @@\n import org.junit.Test;\n \n /**\n- * Unit tests for the {@code GenericArrayType}s created by the {@link $Gson$Types} class.\n+ * Unit tests for the {@code GenericArrayType}s created by the {@link GsonTypes} class.\n  *\n  * @author Inderjeet Singh\n  * @author Joel Leitch\n@@ -38,8 +38,7 @@ public class GenericArrayTypeTest {\n   @Before\n   public void setUp() throws Exception {\n     ourType =\n-        $Gson$Types.arrayOf(\n-            $Gson$Types.newParameterizedTypeWithOwner(null, List.class, String.class));\n+        GsonTypes.arrayOf(GsonTypes.newParameterizedTypeWithOwner(null, List.class, String.class));\n   }\n \n   @Test\ndiff --git a/gson/src/test/java/com/google/gson/ParameterizedTypeFixtures.java b/gson/src/test/java/com/google/gson/ParameterizedTypeFixtures.java\nindex f606ec44d1..29b180e040 100644\n--- a/gson/src/test/java/com/google/gson/ParameterizedTypeFixtures.java\n+++ b/gson/src/test/java/com/google/gson/ParameterizedTypeFixtures.java\n@@ -16,7 +16,7 @@\n \n package com.google.gson;\n \n-import com.google.gson.internal.$Gson$Types;\n+import com.google.gson.internal.GsonTypes;\n import com.google.gson.internal.Primitives;\n import java.lang.reflect.Method;\n import java.lang.reflect.ParameterizedType;\n@@ -139,7 +139,7 @@ public MyParameterizedType<T> deserialize(\n         JsonElement json, Type typeOfT, JsonDeserializationContext context)\n         throws JsonParseException {\n       Type genericClass = ((ParameterizedType) typeOfT).getActualTypeArguments()[0];\n-      Class<?> rawType = $Gson$Types.getRawType(genericClass);\n+      Class<?> rawType = GsonTypes.getRawType(genericClass);\n       String className = rawType.getSimpleName();\n       JsonElement jsonElement = json.getAsJsonObject().get(className);\n \ndiff --git a/gson/src/test/java/com/google/gson/ParameterizedTypeTest.java b/gson/src/test/java/com/google/gson/ParameterizedTypeTest.java\nindex ca837c540e..46cf1dcd4b 100644\n--- a/gson/src/test/java/com/google/gson/ParameterizedTypeTest.java\n+++ b/gson/src/test/java/com/google/gson/ParameterizedTypeTest.java\n@@ -18,7 +18,7 @@\n \n import static com.google.common.truth.Truth.assertThat;\n \n-import com.google.gson.internal.$Gson$Types;\n+import com.google.gson.internal.GsonTypes;\n import com.google.gson.reflect.TypeToken;\n import java.lang.reflect.ParameterizedType;\n import java.lang.reflect.Type;\n@@ -27,7 +27,7 @@\n import org.junit.Test;\n \n /**\n- * Unit tests for {@code ParameterizedType}s created by the {@link $Gson$Types} class.\n+ * Unit tests for {@code ParameterizedType}s created by the {@link GsonTypes} class.\n  *\n  * @author Inderjeet Singh\n  * @author Joel Leitch\n@@ -37,7 +37,7 @@ public class ParameterizedTypeTest {\n \n   @Before\n   public void setUp() throws Exception {\n-    ourType = $Gson$Types.newParameterizedTypeWithOwner(null, List.class, String.class);\n+    ourType = GsonTypes.newParameterizedTypeWithOwner(null, List.class, String.class);\n   }\n \n   @Test\ndiff --git a/gson/src/test/java/com/google/gson/functional/MapTest.java b/gson/src/test/java/com/google/gson/functional/MapTest.java\nindex 04c18d46b0..b48484e224 100644\n--- a/gson/src/test/java/com/google/gson/functional/MapTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/MapTest.java\n@@ -32,7 +32,7 @@\n import com.google.gson.JsonSerializer;\n import com.google.gson.JsonSyntaxException;\n import com.google.gson.common.TestTypes;\n-import com.google.gson.internal.$Gson$Types;\n+import com.google.gson.internal.GsonTypes;\n import com.google.gson.internal.LinkedTreeMap;\n import com.google.gson.reflect.TypeToken;\n import java.lang.reflect.Type;\n@@ -368,8 +368,7 @@ public void testMapSubclassDeserialization() {\n \n   @Test\n   public void testCustomSerializerForSpecificMapType() {\n-    Type type =\n-        $Gson$Types.newParameterizedTypeWithOwner(null, Map.class, String.class, Long.class);\n+    Type type = GsonTypes.newParameterizedTypeWithOwner(null, Map.class, String.class, Long.class);\n     Gson gson =\n         new GsonBuilder()\n             .registerTypeAdapter(\ndiff --git a/gson/src/test/java/com/google/gson/internal/GsonTypesTest.java b/gson/src/test/java/com/google/gson/internal/GsonTypesTest.java\nindex facfd62731..95eee256c8 100644\n--- a/gson/src/test/java/com/google/gson/internal/GsonTypesTest.java\n+++ b/gson/src/test/java/com/google/gson/internal/GsonTypesTest.java\n@@ -33,25 +33,24 @@ public final class GsonTypesTest {\n   @Test\n   public void testNewParameterizedTypeWithoutOwner() throws Exception {\n     // List<A>. List is a top-level class\n-    ParameterizedType type = $Gson$Types.newParameterizedTypeWithOwner(null, List.class, A.class);\n+    ParameterizedType type = GsonTypes.newParameterizedTypeWithOwner(null, List.class, A.class);\n     assertThat(type.getOwnerType()).isNull();\n     assertThat(type.getRawType()).isEqualTo(List.class);\n     assertThat(type.getActualTypeArguments()).asList().containsExactly(A.class);\n \n     // A<B>. A is a static inner class.\n-    type = $Gson$Types.newParameterizedTypeWithOwner(null, A.class, B.class);\n+    type = GsonTypes.newParameterizedTypeWithOwner(null, A.class, B.class);\n     assertThat(getFirstTypeArgument(type)).isEqualTo(B.class);\n \n     IllegalArgumentException e =\n         assertThrows(\n             IllegalArgumentException.class,\n             // NonStaticInner<A> is not allowed without owner\n-            () -> $Gson$Types.newParameterizedTypeWithOwner(null, NonStaticInner.class, A.class));\n+            () -> GsonTypes.newParameterizedTypeWithOwner(null, NonStaticInner.class, A.class));\n     assertThat(e).hasMessageThat().isEqualTo(\"Must specify owner type for \" + NonStaticInner.class);\n \n     type =\n-        $Gson$Types.newParameterizedTypeWithOwner(\n-            GsonTypesTest.class, NonStaticInner.class, A.class);\n+        GsonTypes.newParameterizedTypeWithOwner(GsonTypesTest.class, NonStaticInner.class, A.class);\n     assertThat(type.getOwnerType()).isEqualTo(GsonTypesTest.class);\n     assertThat(type.getRawType()).isEqualTo(NonStaticInner.class);\n     assertThat(type.getActualTypeArguments()).asList().containsExactly(A.class);\n@@ -59,13 +58,13 @@ public void testNewParameterizedTypeWithoutOwner() throws Exception {\n     final class D {}\n \n     // D<A> is allowed since D has no owner type\n-    type = $Gson$Types.newParameterizedTypeWithOwner(null, D.class, A.class);\n+    type = GsonTypes.newParameterizedTypeWithOwner(null, D.class, A.class);\n     assertThat(type.getOwnerType()).isNull();\n     assertThat(type.getRawType()).isEqualTo(D.class);\n     assertThat(type.getActualTypeArguments()).asList().containsExactly(A.class);\n \n     // A<D> is allowed.\n-    type = $Gson$Types.newParameterizedTypeWithOwner(null, A.class, D.class);\n+    type = GsonTypes.newParameterizedTypeWithOwner(null, A.class, D.class);\n     assertThat(getFirstTypeArgument(type)).isEqualTo(D.class);\n   }\n \n@@ -73,7 +72,7 @@ final class D {}\n   public void testGetFirstTypeArgument() throws Exception {\n     assertThat(getFirstTypeArgument(A.class)).isNull();\n \n-    Type type = $Gson$Types.newParameterizedTypeWithOwner(null, A.class, B.class, C.class);\n+    Type type = GsonTypes.newParameterizedTypeWithOwner(null, A.class, B.class, C.class);\n     assertThat(getFirstTypeArgument(type)).isEqualTo(B.class);\n   }\n \n@@ -99,7 +98,7 @@ public static Type getFirstTypeArgument(Type type) throws Exception {\n     if (actualTypeArguments.length == 0) {\n       return null;\n     }\n-    return $Gson$Types.canonicalize(actualTypeArguments[0]);\n+    return GsonTypes.canonicalize(actualTypeArguments[0]);\n   }\n \n   @Test\n@@ -110,7 +109,7 @@ public void testEqualsOnMethodTypeVariables() throws Exception {\n     Type rt1 = m1.getGenericReturnType();\n     Type rt2 = m2.getGenericReturnType();\n \n-    assertThat($Gson$Types.equals(rt1, rt2)).isTrue();\n+    assertThat(GsonTypes.equals(rt1, rt2)).isTrue();\n   }\n \n   @Test\n@@ -121,7 +120,7 @@ public void testEqualsOnConstructorParameterTypeVariables() throws Exception {\n     Type rt1 = c1.getGenericParameterTypes()[0];\n     Type rt2 = c2.getGenericParameterTypes()[0];\n \n-    assertThat($Gson$Types.equals(rt1, rt2)).isTrue();\n+    assertThat(GsonTypes.equals(rt1, rt2)).isTrue();\n   }\n \n   private static final class TypeVariableTest {\n@@ -141,8 +140,7 @@ class CustomProperties extends Properties {\n       private static final long serialVersionUID = 4112578634029874840L;\n     }\n \n-    Type[] types =\n-        $Gson$Types.getMapKeyAndValueTypes(CustomProperties.class, CustomProperties.class);\n+    Type[] types = GsonTypes.getMapKeyAndValueTypes(CustomProperties.class, CustomProperties.class);\n \n     assertThat(types[0]).isEqualTo(String.class);\n     assertThat(types[1]).isEqualTo(String.class);\ndiff --git a/gson/src/test/java/com/google/gson/internal/bind/RecursiveTypesResolveTest.java b/gson/src/test/java/com/google/gson/internal/bind/RecursiveTypesResolveTest.java\nindex 78d253dfb0..b30df4cac6 100644\n--- a/gson/src/test/java/com/google/gson/internal/bind/RecursiveTypesResolveTest.java\n+++ b/gson/src/test/java/com/google/gson/internal/bind/RecursiveTypesResolveTest.java\n@@ -20,11 +20,11 @@\n \n import com.google.gson.Gson;\n import com.google.gson.TypeAdapter;\n-import com.google.gson.internal.$Gson$Types;\n+import com.google.gson.internal.GsonTypes;\n import org.junit.Test;\n \n /**\n- * Test fixes for infinite recursion on {@link $Gson$Types#resolve(java.lang.reflect.Type, Class,\n+ * Test fixes for infinite recursion on {@link GsonTypes#resolve(java.lang.reflect.Type, Class,\n  * java.lang.reflect.Type)}, described at <a href=\"https://github.com/google/gson/issues/440\">Issue\n  * #440</a> and similar issues.\n  *\n@@ -55,26 +55,26 @@ public void testRecursiveResolveSimple() {\n   /** Tests below check the behavior of the methods changed for the fix. */\n   @Test\n   public void testDoubleSupertype() {\n-    assertThat($Gson$Types.supertypeOf($Gson$Types.supertypeOf(Number.class)))\n-        .isEqualTo($Gson$Types.supertypeOf(Number.class));\n+    assertThat(GsonTypes.supertypeOf(GsonTypes.supertypeOf(Number.class)))\n+        .isEqualTo(GsonTypes.supertypeOf(Number.class));\n   }\n \n   @Test\n   public void testDoubleSubtype() {\n-    assertThat($Gson$Types.subtypeOf($Gson$Types.subtypeOf(Number.class)))\n-        .isEqualTo($Gson$Types.subtypeOf(Number.class));\n+    assertThat(GsonTypes.subtypeOf(GsonTypes.subtypeOf(Number.class)))\n+        .isEqualTo(GsonTypes.subtypeOf(Number.class));\n   }\n \n   @Test\n   public void testSuperSubtype() {\n-    assertThat($Gson$Types.supertypeOf($Gson$Types.subtypeOf(Number.class)))\n-        .isEqualTo($Gson$Types.subtypeOf(Object.class));\n+    assertThat(GsonTypes.supertypeOf(GsonTypes.subtypeOf(Number.class)))\n+        .isEqualTo(GsonTypes.subtypeOf(Object.class));\n   }\n \n   @Test\n   public void testSubSupertype() {\n-    assertThat($Gson$Types.subtypeOf($Gson$Types.supertypeOf(Number.class)))\n-        .isEqualTo($Gson$Types.subtypeOf(Object.class));\n+    assertThat(GsonTypes.subtypeOf(GsonTypes.supertypeOf(Number.class)))\n+        .isEqualTo(GsonTypes.subtypeOf(Object.class));\n   }\n \n   /** Tests for recursion while resolving type variables. */\ndiff --git a/gson/src/test/java/com/google/gson/reflect/TypeTokenTest.java b/gson/src/test/java/com/google/gson/reflect/TypeTokenTest.java\nindex ddc6b92973..eb2e76ed43 100644\n--- a/gson/src/test/java/com/google/gson/reflect/TypeTokenTest.java\n+++ b/gson/src/test/java/com/google/gson/reflect/TypeTokenTest.java\n@@ -95,7 +95,7 @@ public void testIsAssignableFromWithBasicWildcards() throws Exception {\n         .isEqualTo(\n             \"Unsupported type, expected one of: java.lang.Class,\"\n                 + \" java.lang.reflect.ParameterizedType, java.lang.reflect.GenericArrayType, but\"\n-                + \" got: com.google.gson.internal.$Gson$Types$WildcardTypeImpl, for type token: \"\n+                + \" got: com.google.gson.internal.GsonTypes$WildcardTypeImpl, for type token: \"\n                 + wildcardTypeToken);\n   }\n \n",
  "problem_statement" : "Please rename Gson classes whose name contains a `$`:\r\n- `com.google.gson.internal.$Gson$Types`\r\n- `com.google.gson.internal.$Gson$Preconditions`\r\n\r\n[JLS 14 3.8](https://docs.oracle.com/javase/specs/jls/se14/html/jls-3.html#jls-3.8) says:\r\n>The dollar sign should be used only in mechanically generated source code or, rarely, to access pre-existing names on legacy systems.\r\n\r\nIt appears these classes were renamed by 4efb133b4a6cc93708dda782d948b9c88c3b5ff0 to prevent IDE auto-importing. However, nowadays IDEs (at least Eclipse) have ways to prevent certain types or packages from appearing in import suggestions.\r\nAdditionally these classes are in the `internal` package and with the Java module system they won't be visible to users anymore.\r\n\r\nFor now maybe simply removing the `$`s and adding a documentation comment that these classes are internal might already solve the issue.\r\n\r\nCurrently when developing Gson having to deal with these classes is (at least under Eclipse but I assume IntelliJ has similar issues) pretty annoying:\r\n- Eclipse fails adding the imports\r\n- Eclipse suggests bogus types in the \"Open Types\" dialog\r\n- Using conditional breakpoints in these classes is not possible at all because Eclipse incorrectly assumes they are nested classes\r\n- ... _likely more_",
  "hints_text" : null,
  "created_at" : "Sat Apr 05 20:36:05 CEST 2025",
  "version" : null,
  "FAIL_TO_PASS" : [ "ParameterizedTypeTest", "ParameterizedTypeFixtures", "RecursiveTypesResolveTest", "MapTest", "GenericArrayTypeTest", "GsonTypesTest", "TypeTokenTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -pl gson -Dtest=ParameterizedTypeTest,ParameterizedTypeFixtures,RecursiveTypesResolveTest,MapTest,GenericArrayTypeTest,GsonTypesTest,TypeTokenTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : 1744,
  "pull_number" : 2838,
  "metadata" : null
}, {
  "instance_id" : "google-gson-PR-2834",
  "repo" : "google/gson",
  "base_commit" : "de190d7ef5feb4950d5daca819a625b39f3fd2f5",
  "patch" : "diff --git a/gson/pom.xml b/gson/pom.xml\nindex 04cadef3e3..de3ba32dee 100644\n--- a/gson/pom.xml\n+++ b/gson/pom.xml\n@@ -50,7 +50,7 @@\n     <dependency>\n       <groupId>com.google.errorprone</groupId>\n       <artifactId>error_prone_annotations</artifactId>\n-      <version>2.36.0</version>\n+      <version>2.37.0</version>\n     </dependency>\n \n     <dependency>\ndiff --git a/gson/src/main/java/com/google/gson/internal/LinkedTreeMap.java b/gson/src/main/java/com/google/gson/internal/LinkedTreeMap.java\nindex 099dd573c0..15a100730f 100644\n--- a/gson/src/main/java/com/google/gson/internal/LinkedTreeMap.java\n+++ b/gson/src/main/java/com/google/gson/internal/LinkedTreeMap.java\n@@ -451,13 +451,19 @@ private void rotateRight(Node<K, V> root) {\n   @Override\n   public Set<Entry<K, V>> entrySet() {\n     EntrySet result = entrySet;\n-    return result != null ? result : (entrySet = new EntrySet());\n+    if (result == null) {\n+      result = entrySet = new EntrySet();\n+    }\n+    return result;\n   }\n \n   @Override\n   public Set<K> keySet() {\n     KeySet result = keySet;\n-    return result != null ? result : (keySet = new KeySet());\n+    if (result == null) {\n+      result = keySet = new KeySet();\n+    }\n+    return result;\n   }\n \n   static final class Node<K, V> implements Entry<K, V> {\n@@ -576,7 +582,8 @@ final Node<K, V> nextNode() {\n         throw new ConcurrentModificationException();\n       }\n       next = e.next;\n-      return lastReturned = e;\n+      lastReturned = e;\n+      return e;\n     }\n \n     @Override\ndiff --git a/gson/src/main/java/com/google/gson/internal/bind/TreeTypeAdapter.java b/gson/src/main/java/com/google/gson/internal/bind/TreeTypeAdapter.java\nindex 1ef1e40b9f..43226f302a 100644\n--- a/gson/src/main/java/com/google/gson/internal/bind/TreeTypeAdapter.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/TreeTypeAdapter.java\n@@ -113,9 +113,10 @@ private TypeAdapter<T> delegate() {\n     // A race might lead to `delegate` being assigned by multiple threads but the last assignment\n     // will stick\n     TypeAdapter<T> d = delegate;\n-    return d != null\n-        ? d\n-        : (delegate = gson.getDelegateAdapter(skipPastForGetDelegateAdapter, typeToken));\n+    if (d == null) {\n+      d = delegate = gson.getDelegateAdapter(skipPastForGetDelegateAdapter, typeToken);\n+    }\n+    return d;\n   }\n \n   /**\ndiff --git a/gson/src/main/java/com/google/gson/stream/JsonReader.java b/gson/src/main/java/com/google/gson/stream/JsonReader.java\nindex 3dcf73729a..a76f1563ec 100644\n--- a/gson/src/main/java/com/google/gson/stream/JsonReader.java\n+++ b/gson/src/main/java/com/google/gson/stream/JsonReader.java\n@@ -590,7 +590,8 @@ int doPeek() throws IOException {\n       int c = nextNonWhitespace(true);\n       switch (c) {\n         case ']':\n-          return peeked = PEEKED_END_ARRAY;\n+          peeked = PEEKED_END_ARRAY;\n+          return peeked;\n         case ';':\n           checkLenient(); // fall-through\n         case ',':\n@@ -605,7 +606,8 @@ int doPeek() throws IOException {\n         int c = nextNonWhitespace(true);\n         switch (c) {\n           case '}':\n-            return peeked = PEEKED_END_OBJECT;\n+            peeked = PEEKED_END_OBJECT;\n+            return peeked;\n           case ';':\n             checkLenient(); // fall-through\n           case ',':\n@@ -617,13 +619,16 @@ int doPeek() throws IOException {\n       int c = nextNonWhitespace(true);\n       switch (c) {\n         case '\"':\n-          return peeked = PEEKED_DOUBLE_QUOTED_NAME;\n+          peeked = PEEKED_DOUBLE_QUOTED_NAME;\n+          return peeked;\n         case '\\'':\n           checkLenient();\n-          return peeked = PEEKED_SINGLE_QUOTED_NAME;\n+          peeked = PEEKED_SINGLE_QUOTED_NAME;\n+          return peeked;\n         case '}':\n           if (peekStack != JsonScope.NONEMPTY_OBJECT) {\n-            return peeked = PEEKED_END_OBJECT;\n+            peeked = PEEKED_END_OBJECT;\n+            return peeked;\n           } else {\n             throw syntaxError(\"Expected name\");\n           }\n@@ -631,7 +636,8 @@ int doPeek() throws IOException {\n           checkLenient();\n           pos--; // Don't consume the first character in an unquoted string.\n           if (isLiteral((char) c)) {\n-            return peeked = PEEKED_UNQUOTED_NAME;\n+            peeked = PEEKED_UNQUOTED_NAME;\n+            return peeked;\n           } else {\n             throw syntaxError(\"Expected name\");\n           }\n@@ -660,7 +666,8 @@ int doPeek() throws IOException {\n     } else if (peekStack == JsonScope.NONEMPTY_DOCUMENT) {\n       int c = nextNonWhitespace(false);\n       if (c == -1) {\n-        return peeked = PEEKED_EOF;\n+        peeked = PEEKED_EOF;\n+        return peeked;\n       } else {\n         checkLenient();\n         pos--;\n@@ -673,7 +680,8 @@ int doPeek() throws IOException {\n     switch (c) {\n       case ']':\n         if (peekStack == JsonScope.EMPTY_ARRAY) {\n-          return peeked = PEEKED_END_ARRAY;\n+          peeked = PEEKED_END_ARRAY;\n+          return peeked;\n         }\n       // fall-through to handle \",]\"\n       case ';':\n@@ -682,19 +690,24 @@ int doPeek() throws IOException {\n         if (peekStack == JsonScope.EMPTY_ARRAY || peekStack == JsonScope.NONEMPTY_ARRAY) {\n           checkLenient();\n           pos--;\n-          return peeked = PEEKED_NULL;\n+          peeked = PEEKED_NULL;\n+          return peeked;\n         } else {\n           throw syntaxError(\"Unexpected value\");\n         }\n       case '\\'':\n         checkLenient();\n-        return peeked = PEEKED_SINGLE_QUOTED;\n+        peeked = PEEKED_SINGLE_QUOTED;\n+        return peeked;\n       case '\"':\n-        return peeked = PEEKED_DOUBLE_QUOTED;\n+        peeked = PEEKED_DOUBLE_QUOTED;\n+        return peeked;\n       case '[':\n-        return peeked = PEEKED_BEGIN_ARRAY;\n+        peeked = PEEKED_BEGIN_ARRAY;\n+        return peeked;\n       case '{':\n-        return peeked = PEEKED_BEGIN_OBJECT;\n+        peeked = PEEKED_BEGIN_OBJECT;\n+        return peeked;\n       default:\n         pos--; // Don't consume the first character in a literal value.\n     }\n@@ -714,7 +727,8 @@ int doPeek() throws IOException {\n     }\n \n     checkLenient();\n-    return peeked = PEEKED_UNQUOTED;\n+    peeked = PEEKED_UNQUOTED;\n+    return peeked;\n   }\n \n   private int peekKeyword() throws IOException {\n@@ -763,7 +777,8 @@ private int peekKeyword() throws IOException {\n \n     // We've found the keyword followed either by EOF or by a non-literal character.\n     pos += length;\n-    return peeked = peeking;\n+    peeked = peeking;\n+    return peeked;\n   }\n \n   private int peekNumber() throws IOException {\n@@ -865,12 +880,14 @@ private int peekNumber() throws IOException {\n         && (value != 0 || !negative)) {\n       peekedLong = negative ? value : -value;\n       pos += i;\n-      return peeked = PEEKED_LONG;\n+      peeked = PEEKED_LONG;\n+      return peeked;\n     } else if (last == NUMBER_CHAR_DIGIT\n         || last == NUMBER_CHAR_FRACTION_DIGIT\n         || last == NUMBER_CHAR_EXP_DIGIT) {\n       peekedNumberLength = i;\n-      return peeked = PEEKED_NUMBER;\n+      peeked = PEEKED_NUMBER;\n+      return peeked;\n     } else {\n       return PEEKED_NONE;\n     }\ndiff --git a/pom.xml b/pom.xml\nindex c054249d2f..300c4b6ea4 100644\n--- a/pom.xml\n+++ b/pom.xml\n@@ -265,11 +265,13 @@\n                 -Xep:NonCanonicalStaticMemberImport\n                 -Xep:NonFinalStaticField\n                 -Xep:PackageLocation:WARN\n+                -Xep:PatternMatchingInstanceof:OFF <!-- disabled: requires Java 16 -->\n                 -Xep:PrimitiveArrayPassedToVarargsMethod\n                 -Xep:PrivateConstructorForUtilityClass:WARN\n                 -Xep:RemoveUnusedImports:WARN\n                 -Xep:StatementSwitchToExpressionSwitch:OFF <!-- disabled: requires Java 14 -->\n                 -Xep:StaticQualifiedUsingExpression <!-- required by style guide -->\n+                -Xep:StringConcatToTextBlock:OFF <!-- disabled: requires Java 15 -->\n                 -Xep:SwitchDefault:WARN\n                 -Xep:SystemExitOutsideMain\n                 -Xep:SystemOut\n@@ -300,7 +302,7 @@\n               <path>\n                 <groupId>com.google.errorprone</groupId>\n                 <artifactId>error_prone_core</artifactId>\n-                <version>2.36.0</version>\n+                <version>2.37.0</version>\n               </path>\n             </annotationProcessorPaths>\n           </configuration>\n",
  "test_patch" : "diff --git a/gson/src/test/java/com/google/gson/functional/Java17RecordTest.java b/gson/src/test/java/com/google/gson/functional/Java17RecordTest.java\nindex 2a067471ad..dc83ad59ff 100644\n--- a/gson/src/test/java/com/google/gson/functional/Java17RecordTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/Java17RecordTest.java\n@@ -90,6 +90,7 @@ public void testSerializedNameOnAccessor() {\n     record LocalRecord(int i) {\n       @SerializedName(\"a\")\n       @Override\n+      @SuppressWarnings(\"UnusedMethod\")\n       public int i() {\n         return i;\n       }\n@@ -170,6 +171,7 @@ record LocalRecord(String s) {\n   public void testAccessorIsCalled() {\n     record LocalRecord(String s) {\n       @Override\n+      @SuppressWarnings(\"UnusedMethod\")\n       public String s() {\n         return \"accessor-value\";\n       }\n@@ -186,6 +188,7 @@ record LocalRecord(String s) {\n       static final RuntimeException thrownException = new RuntimeException(\"Custom exception\");\n \n       @Override\n+      @SuppressWarnings(\"UnusedMethod\")\n       public String s() {\n         throw thrownException;\n       }\ndiff --git a/test-jpms/src/test/java/com/google/gson/jpms_test/ExportedPackagesTest.java b/test-jpms/src/test/java/com/google/gson/jpms_test/ExportedPackagesTest.java\nindex c30b3fb75e..9f5589f9aa 100644\n--- a/test-jpms/src/test/java/com/google/gson/jpms_test/ExportedPackagesTest.java\n+++ b/test-jpms/src/test/java/com/google/gson/jpms_test/ExportedPackagesTest.java\n@@ -49,6 +49,7 @@ public void testMainPackage() {\n   public void testAnnotationsPackage() throws Exception {\n     class Annotated {\n       @SerializedName(\"custom-name\")\n+      @SuppressWarnings(\"UnusedVariable\")\n       int i;\n     }\n \n",
  "problem_statement" : "Fix findings that are new with the latest Error Prone.",
  "hints_text" : null,
  "created_at" : "Wed Apr 02 02:06:17 CEST 2025",
  "version" : null,
  "FAIL_TO_PASS" : [ "Java17RecordTest", "ExportedPackagesTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -pl gson -Dtest=Java17RecordTest,ExportedPackagesTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 2834,
  "metadata" : null
}, {
  "instance_id" : "google-gson-PR-2811",
  "repo" : "google/gson",
  "base_commit" : "87d30c0686822426ad2711a85bced1b5bc582572",
  "patch" : "diff --git a/extras/src/main/java/com/google/gson/graph/GraphAdapterBuilder.java b/extras/src/main/java/com/google/gson/graph/GraphAdapterBuilder.java\nindex d158def78d..b9107dbacf 100644\n--- a/extras/src/main/java/com/google/gson/graph/GraphAdapterBuilder.java\n+++ b/extras/src/main/java/com/google/gson/graph/GraphAdapterBuilder.java\n@@ -76,7 +76,7 @@ public final class GraphAdapterBuilder {\n   public GraphAdapterBuilder() {\n     this.instanceCreators = new HashMap<>();\n     this.constructorConstructor =\n-        new ConstructorConstructor(instanceCreators, true, Collections.emptyList());\n+        new ConstructorConstructor(Collections.emptyMap(), true, Collections.emptyList());\n   }\n \n   /**\n@@ -121,6 +121,8 @@ public GraphAdapterBuilder addType(Type type, InstanceCreator<?> instanceCreator\n    * @param gsonBuilder the {@code GsonBuilder} on which to register the graph adapter\n    */\n   public void registerOn(GsonBuilder gsonBuilder) {\n+    // Create copy to allow reusing GraphAdapterBuilder without affecting adapter factory\n+    Map<Type, InstanceCreator<?>> instanceCreators = new HashMap<>(this.instanceCreators);\n     Factory factory = new Factory(instanceCreators);\n     gsonBuilder.registerTypeAdapterFactory(factory);\n     for (Map.Entry<Type, InstanceCreator<?>> entry : instanceCreators.entrySet()) {\n",
  "test_patch" : "diff --git a/extras/src/test/java/com/google/gson/graph/GraphAdapterBuilderTest.java b/extras/src/test/java/com/google/gson/graph/GraphAdapterBuilderTest.java\nindex 9c79130d0d..90612a0163 100644\n--- a/extras/src/test/java/com/google/gson/graph/GraphAdapterBuilderTest.java\n+++ b/extras/src/test/java/com/google/gson/graph/GraphAdapterBuilderTest.java\n@@ -80,6 +80,51 @@ public void testDeserializationDirectSelfReference() {\n     assertThat(suicide.beats).isSameInstanceAs(suicide);\n   }\n \n+  @Test\n+  public void testAddTypeCustomInstanceCreator() {\n+    GsonBuilder gsonBuilder = new GsonBuilder();\n+    new GraphAdapterBuilder()\n+        .addType(Company.class, type -> new Company(\"custom\"))\n+        .addType(Employee.class)\n+        .registerOn(gsonBuilder);\n+    Gson gson = gsonBuilder.create();\n+\n+    Company company =\n+        gson.fromJson(\n+            \"{'0x1':{'employees':['0x2']},'0x2':{'name':'Jesse','company':'0x1'}}\", Company.class);\n+    assertThat(company.name).isEqualTo(\"custom\");\n+    Employee employee = company.employees.get(0);\n+    assertThat(employee.name).isEqualTo(\"Jesse\");\n+    assertThat(employee.company).isSameInstanceAs(company);\n+  }\n+\n+  @Test\n+  public void testAddTypeOverwrite() {\n+    GsonBuilder gsonBuilder = new GsonBuilder();\n+    new GraphAdapterBuilder()\n+        .addType(Company.class, type -> new Company(\"custom\"))\n+        // Overwrite Company creator with different custom one\n+        .addType(Company.class, type -> new Company(\"custom-2\"))\n+        .addType(Employee.class)\n+        .registerOn(gsonBuilder);\n+    Gson gson = gsonBuilder.create();\n+\n+    Company company = gson.fromJson(\"{'0x1':{}}\", Company.class);\n+    assertThat(company.name).isEqualTo(\"custom-2\");\n+\n+    gsonBuilder = new GsonBuilder();\n+    new GraphAdapterBuilder()\n+        .addType(Company.class, type -> new Company(\"custom\"))\n+        // Overwrite Company creator with default one\n+        .addType(Company.class)\n+        .addType(Employee.class)\n+        .registerOn(gsonBuilder);\n+    gson = gsonBuilder.create();\n+\n+    company = gson.fromJson(\"{'0x1':{}}\", Company.class);\n+    assertThat(company.name).isNull();\n+  }\n+\n   @Test\n   public void testSerializeListOfLists() {\n     Type listOfListsType = new TypeToken<List<List<?>>>() {}.getType();\n@@ -156,10 +201,37 @@ public void testDeserializationWithMultipleTypes() {\n     assertThat(company.name).isEqualTo(\"Google\");\n     Employee jesse = company.employees.get(0);\n     assertThat(jesse.name).isEqualTo(\"Jesse\");\n-    assertThat(jesse.company).isEqualTo(company);\n+    assertThat(jesse.company).isSameInstanceAs(company);\n     Employee joel = company.employees.get(1);\n     assertThat(joel.name).isEqualTo(\"Joel\");\n-    assertThat(joel.company).isEqualTo(company);\n+    assertThat(joel.company).isSameInstanceAs(company);\n+  }\n+\n+  @Test\n+  public void testBuilderReuse() {\n+    GsonBuilder gsonBuilder = new GsonBuilder();\n+    GraphAdapterBuilder graphAdapterBuilder =\n+        new GraphAdapterBuilder()\n+            .addType(Company.class, type -> new Company(\"custom\"))\n+            .addType(Employee.class);\n+    graphAdapterBuilder.registerOn(gsonBuilder);\n+    Gson gson = gsonBuilder.create();\n+\n+    Company company = gson.fromJson(\"{'0x1':{}}\", Company.class);\n+    assertThat(company.name).isEqualTo(\"custom\");\n+\n+    GsonBuilder gsonBuilder2 = new GsonBuilder();\n+    // Reuse builder and overwrite creator\n+    graphAdapterBuilder.addType(Company.class, type -> new Company(\"custom-2\"));\n+    graphAdapterBuilder.registerOn(gsonBuilder2);\n+    Gson gson2 = gsonBuilder2.create();\n+\n+    company = gson2.fromJson(\"{'0x1':{}}\", Company.class);\n+    assertThat(company.name).isEqualTo(\"custom-2\");\n+\n+    // But first adapter should not have been affected\n+    company = gson.fromJson(\"{'0x1':{}}\", Company.class);\n+    assertThat(company.name).isEqualTo(\"custom\");\n   }\n \n   static class Roshambo {\n",
  "problem_statement" : "Fix `GraphAdapterBuilder#addType(Type)` delegating to previous creator\n\n### Purpose\r\nFix `GraphAdapterBuilder#addType(Type)` delegating to previous creator\r\n\r\n### Description\r\nWhen `addType(Type, InstanceCreator)` is used, it adds the creator to the `instanceCreators` map. However, previously that map was also used by the `constructorConstructor`.\r\nSo when `addType(Type)` was used afterwards, instead of actually obtaining the default creator from `constructorConstructor`, it obtained the previously registered creator. That does not seem intended to me.\r\n\r\nSide note: Passing `instanceCreators` to the `ConstructorConstructor` constructor was done in https://github.com/google/gson/commit/1d9e86e27c97cd85d898104b4ac42bb487d0d7d0. But I am not sure if this was done intentionally, or just to solve a compilation error due to the removal of the no-args `ConstructorConstructor` constructor in https://github.com/google/gson/commit/040bae34d701172375e5aaef7492a5782933d46d (?).\r\n\r\n### Checklist\r\n<!-- The following checklist is mainly intended for yourself to verify that you did not miss anything -->\r\n\r\n- [x] New code follows the [Google Java Style Guide](https://google.github.io/styleguide/javaguide.html)\\\r\n  This is automatically checked by `mvn verify`, but can also be checked on its own using `mvn spotless:check`.\\\r\n  Style violations can be fixed using `mvn spotless:apply`; this can be done in a separate commit to verify that it did not cause undesired changes.\r\n- [ ] If necessary, new public API validates arguments, for example rejects `null`\r\n- [ ] New public API has Javadoc\r\n    - [ ] Javadoc uses `@since $next-version$`  \r\n      (`$next-version$` is a special placeholder which is automatically replaced during release)\r\n- [x] If necessary, new unit tests have been added  \r\n  - [x] Assertions in unit tests use [Truth](https://truth.dev/), see existing tests\r\n  - [x] No JUnit 3 features are used (such as extending class `TestCase`)\r\n  - [x] If this pull request fixes a bug, a new test was added for a situation which failed previously and is now fixed\r\n- [x] `mvn clean verify javadoc:jar` passes without errors\r\n",
  "hints_text" : null,
  "created_at" : "Thu Feb 20 23:34:57 CET 2025",
  "version" : null,
  "FAIL_TO_PASS" : [ "GraphAdapterBuilderTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -pl extras -Dtest=GraphAdapterBuilderTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 2811,
  "metadata" : null
}, {
  "instance_id" : "google-gson-PR-2795",
  "repo" : "google/gson",
  "base_commit" : "b2e26fa97b7ccba080a082a9bf9741e24d5c523d",
  "patch" : "diff --git a/gson/pom.xml b/gson/pom.xml\nindex 97d4a470a1..42876fc60e 100644\n--- a/gson/pom.xml\n+++ b/gson/pom.xml\n@@ -146,8 +146,9 @@\n                 Bundle-ContactAddress: ${project.parent.url}\n \n                 # Optional dependency for JDK's sun.misc.Unsafe\n+                # Optional dependency to google.errorprone\n                 # https://bnd.bndtools.org/chapters/920-faq.html#remove-unwanted-imports-\n-                Import-Package: sun.misc;resolution:=optional, *\n+                Import-Package: sun.misc;resolution:=optional, com.google.errorprone.*;resolution:=optional, *\n \n                 -removeheaders: Private-Package\n \n",
  "test_patch" : "diff --git a/gson/src/test/java/com/google/gson/integration/OSGiManifestIT.java b/gson/src/test/java/com/google/gson/integration/OSGiManifestIT.java\nindex 9f6c5334aa..fd407279de 100644\n--- a/gson/src/test/java/com/google/gson/integration/OSGiManifestIT.java\n+++ b/gson/src/test/java/com/google/gson/integration/OSGiManifestIT.java\n@@ -114,7 +114,10 @@ public void testImports() throws Exception {\n         .containsExactly(\n             // Dependency on JDK's sun.misc.Unsafe should be optional\n             \"sun.misc;resolution:=optional\",\n-            \"com.google.errorprone.annotations;version=\\\"\" + errorProneVersionRange + \"\\\"\");\n+            // Dependency on error prone should be optional\n+            \"com.google.errorprone.annotations;resolution:=optional;version=\\\"\"\n+                + errorProneVersionRange\n+                + \"\\\"\");\n \n     // Should not contain any import for Gson's own packages, see\n     // https://github.com/google/gson/pull/2735#issuecomment-2330047410\n",
  "problem_statement" : "Make the import of com.google.errorprone optional\n\nFix https://github.com/google/gson/issues/2794\r\n",
  "hints_text" : null,
  "created_at" : "Thu Jan 30 11:17:04 CET 2025",
  "version" : null,
  "FAIL_TO_PASS" : [ "OSGiManifestIT" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=OSGiManifestIT",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 2795,
  "metadata" : null
}, {
  "instance_id" : "google-gson-PR-2789",
  "repo" : "google/gson",
  "base_commit" : "e5dce841f73382cb7acdfe32250767ddb2c86b49",
  "patch" : "diff --git a/gson/src/main/java/com/google/gson/GsonBuilder.java b/gson/src/main/java/com/google/gson/GsonBuilder.java\nindex a8212f8d9f..c387bc2d52 100644\n--- a/gson/src/main/java/com/google/gson/GsonBuilder.java\n+++ b/gson/src/main/java/com/google/gson/GsonBuilder.java\n@@ -710,7 +710,7 @@ public GsonBuilder registerTypeAdapter(Type type, Object typeAdapter) {\n             || typeAdapter instanceof InstanceCreator<?>\n             || typeAdapter instanceof TypeAdapter<?>);\n \n-    if (isTypeObjectOrJsonElement(type)) {\n+    if (hasNonOverridableAdapter(type)) {\n       throw new IllegalArgumentException(\"Cannot override built-in adapter for \" + type);\n     }\n \n@@ -730,9 +730,14 @@ public GsonBuilder registerTypeAdapter(Type type, Object typeAdapter) {\n     return this;\n   }\n \n-  private static boolean isTypeObjectOrJsonElement(Type type) {\n-    return type instanceof Class\n-        && (type == Object.class || JsonElement.class.isAssignableFrom((Class<?>) type));\n+  /** Whether the type has a built-in adapter which cannot be overridden. */\n+  private static boolean hasNonOverridableAdapter(Type type) {\n+    return type == Object.class;\n+    // This should also cover `JsonElement.class.isAssignableFrom(type)`, however for backward\n+    // compatibility this is not covered here because really old Gson versions had no built-in\n+    // adapter for JsonElement so users registered custom adapters. These adapters don't have any\n+    // effect in recent Gson versions. See\n+    // https://github.com/google/gson/issues/2787#issuecomment-2581568157\n   }\n \n   /**\n@@ -778,10 +783,6 @@ public GsonBuilder registerTypeHierarchyAdapter(Class<?> baseType, Object typeAd\n             || typeAdapter instanceof JsonDeserializer<?>\n             || typeAdapter instanceof TypeAdapter<?>);\n \n-    if (JsonElement.class.isAssignableFrom(baseType)) {\n-      throw new IllegalArgumentException(\"Cannot override built-in adapter for \" + baseType);\n-    }\n-\n     if (typeAdapter instanceof JsonDeserializer || typeAdapter instanceof JsonSerializer) {\n       hierarchyFactories.add(TreeTypeAdapter.newTypeHierarchyFactory(baseType, typeAdapter));\n     }\n",
  "test_patch" : "diff --git a/gson/src/test/java/com/google/gson/GsonBuilderTest.java b/gson/src/test/java/com/google/gson/GsonBuilderTest.java\nindex 757183fec0..3ead74fc82 100644\n--- a/gson/src/test/java/com/google/gson/GsonBuilderTest.java\n+++ b/gson/src/test/java/com/google/gson/GsonBuilderTest.java\n@@ -28,6 +28,7 @@\n import java.lang.reflect.Type;\n import java.text.DateFormat;\n import java.util.Date;\n+import org.junit.Ignore;\n import org.junit.Test;\n \n /**\n@@ -251,7 +252,10 @@ public void testSetStrictness() throws IOException {\n   public void testRegisterTypeAdapterForObjectAndJsonElements() {\n     String errorMessage = \"Cannot override built-in adapter for \";\n     Type[] types = {\n-      Object.class, JsonElement.class, JsonArray.class,\n+      Object.class,\n+      // TODO: Registering adapter for JsonElement is allowed (for now) for backward compatibility,\n+      //   see https://github.com/google/gson/issues/2787\n+      // JsonElement.class, JsonArray.class,\n     };\n     GsonBuilder gsonBuilder = new GsonBuilder();\n     for (Type type : types) {\n@@ -263,6 +267,22 @@ public void testRegisterTypeAdapterForObjectAndJsonElements() {\n     }\n   }\n \n+  /**\n+   * Verifies that (for now) registering adapter for {@link JsonElement} and subclasses is possible,\n+   * but has no effect. See {@link #testRegisterTypeAdapterForObjectAndJsonElements()}.\n+   */\n+  @Test\n+  public void testRegisterTypeAdapterForJsonElements() {\n+    Gson gson = new GsonBuilder().registerTypeAdapter(JsonArray.class, NULL_TYPE_ADAPTER).create();\n+    TypeAdapter<JsonArray> adapter = gson.getAdapter(JsonArray.class);\n+    // Does not use registered adapter\n+    assertThat(adapter).isNotSameInstanceAs(NULL_TYPE_ADAPTER);\n+    assertThat(adapter.toJson(new JsonArray())).isEqualTo(\"[]\");\n+  }\n+\n+  @Ignore(\n+      \"Registering adapter for JsonElement is allowed (for now) for backward compatibility, see\"\n+          + \" https://github.com/google/gson/issues/2787\")\n   @Test\n   public void testRegisterTypeHierarchyAdapterJsonElements() {\n     String errorMessage = \"Cannot override built-in adapter for \";\n@@ -282,6 +302,20 @@ public void testRegisterTypeHierarchyAdapterJsonElements() {\n     gsonBuilder.registerTypeHierarchyAdapter(Object.class, NULL_TYPE_ADAPTER);\n   }\n \n+  /**\n+   * Verifies that (for now) registering hierarchy adapter for {@link JsonElement} and subclasses is\n+   * possible, but has no effect. See {@link #testRegisterTypeHierarchyAdapterJsonElements()}.\n+   */\n+  @Test\n+  public void testRegisterTypeHierarchyAdapterJsonElements_Allowed() {\n+    Gson gson =\n+        new GsonBuilder().registerTypeHierarchyAdapter(JsonArray.class, NULL_TYPE_ADAPTER).create();\n+    TypeAdapter<JsonArray> adapter = gson.getAdapter(JsonArray.class);\n+    // Does not use registered adapter\n+    assertThat(adapter).isNotSameInstanceAs(NULL_TYPE_ADAPTER);\n+    assertThat(adapter.toJson(new JsonArray())).isEqualTo(\"[]\");\n+  }\n+\n   @Test\n   public void testSetDateFormatWithInvalidPattern() {\n     GsonBuilder builder = new GsonBuilder();\n",
  "problem_statement" : "# Gson version\n2.11\n\n\n# Java / Android version\nSemeru JDK 21.0.5\n\n\n# Used tools\n<!-- List relevant build tools and plugins with version number here which might affect Gson -->\n- [ ] Maven; version: \n- [x] Gradle; version: 8.12\n- [ ] ProGuard (attach the configuration file please); version: \n- [ ] ...\n\n# Description\nWe are currently maintaining a legacy application in an ongoing support mode. In order to address security vulnerabilities, we needed to update several third-party dependencies, which required upgrading to Gson version 2.11. However, after the update, another dependency, com.cloudant:cloudant-client:2.20.1 (https://github.com/cloudant/java-cloudant), began to fail. This dependency worked correctly with Gson 2.10.1 but now fails with Gson 2.11. The error encountered is as follows:\n```\njava.lang.IllegalArgumentException: Cannot override built-in adapter for class com.google.gson.JsonObject\n \tat com.google.gson.GsonBuilder.registerTypeAdapter(GsonBuilder.java:714) ~[gson-2.11.0.jar:?]\n \tat com.cloudant.client.org.lightcouch.internal.GsonHelper.initGson(GsonHelper.java:38) ~[cloudant-client-2.20.1.jar:?]\n \tat com.cloudant.client.org.lightcouch.CouchDbClient.<init>(CouchDbClient.java:95) ~[cloudant-client-2.20.1.jar:?]\n \tat com.cloudant.client.org.lightcouch.CouchDbClient.<init>(CouchDbClient.java:145) ~[cloudant-client-2.20.1.jar:?]\n \tat com.cloudant.client.api.CloudantClient.<init>(CloudantClient.java:141) ~[cloudant-client-2.20.1.jar:?]\n \tat com.cloudant.client.api.ClientBuilder.build(ClientBuilder.java:396) ~[cloudant-client-2.20.1.jar:?]\n```\nThe issue appears to be related to how GsonBuilder is used in the method defined in https://github.com/cloudant/java-cloudant/blob/master/cloudant-client/src/main/java/com/cloudant/client/org/lightcouch/internal/GsonHelper.java\n```\n    public static GsonBuilder initGson(GsonBuilder gsonBuilder) {\n        gsonBuilder.registerTypeAdapter(JsonObject.class, new JsonDeserializer<JsonObject>() {\n            public JsonObject deserialize(JsonElement json,\n                                          Type typeOfT, JsonDeserializationContext context)\n                    throws JsonParseException {\n                return json.getAsJsonObject();\n            }\n        });\n        gsonBuilder.registerTypeAdapter(JsonObject.class, new JsonSerializer<JsonObject>() {\n            public JsonElement serialize(JsonObject src, Type typeOfSrc,\n                                         JsonSerializationContext context) {\n                return src.getAsJsonObject();\n            }\n\n        });\n\n        return gsonBuilder;\n    }\n```\nIt seems that something has changed in GsonBuilder between versions 2.10.1 and 2.11 that is now causing a conflict and breaking backward compatibility. Could you clarify whether this is a bug, or is it the intended behavior in the new Gson version?\n\n\n\n## Expected behavior\nConsidering this was minor version update, I would expect that GsonBuilder would continue to work as it was.\n\n\n## Actual behavior\nIt seems that something has changed in GsonBuilder between versions 2.10.1 and 2.11 that is now causing a conflict and breaking backward compatibility. \n\n\n# Reproduction steps\nhttps://github.com/cloudant/java-cloudant/blob/master/cloudant-client/src/main/java/com/cloudant/client/org/lightcouch/internal/GsonHelper.java should still be able to register TypeAdapter in GsonBuilder.\n\n_NOTE: I can't change com.cloudant:cloudant-client:2.20.1 code. I know that it's deprecated, sunset and no longer supported by any team - but to replace it with some other library is involved change. Therefore I am trying to rather ask if backward compatibility of GsonBuilder could be kept._\n\n\n# Exception stack trace\n```\njava.lang.IllegalArgumentException: Cannot override built-in adapter for class com.google.gson.JsonObject\n \tat com.google.gson.GsonBuilder.registerTypeAdapter(GsonBuilder.java:714) ~[gson-2.11.0.jar:?]\n \tat com.cloudant.client.org.lightcouch.internal.GsonHelper.initGson(GsonHelper.java:38) ~[cloudant-client-2.20.1.jar:?]\n \tat com.cloudant.client.org.lightcouch.CouchDbClient.<init>(CouchDbClient.java:95) ~[cloudant-client-2.20.1.jar:?]\n \tat com.cloudant.client.org.lightcouch.CouchDbClient.<init>(CouchDbClient.java:145) ~[cloudant-client-2.20.1.jar:?]\n \tat com.cloudant.client.api.CloudantClient.<init>(CloudantClient.java:141) ~[cloudant-client-2.20.1.jar:?]\n \tat com.cloudant.client.api.ClientBuilder.build(ClientBuilder.java:396) ~[cloudant-client-2.20.1.jar:?]\n```\n",
  "hints_text" : null,
  "created_at" : "Mon Jan 27 22:48:50 CET 2025",
  "version" : null,
  "FAIL_TO_PASS" : [ "GsonBuilderTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -pl gson -Dtest=GsonBuilderTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : 2787,
  "pull_number" : 2789,
  "metadata" : null
}, {
  "instance_id" : "google-gson-PR-2784",
  "repo" : "google/gson",
  "base_commit" : "84e5f16acafaa7c55d80a3621a37c7884ca928b6",
  "patch" : "diff --git a/gson/pom.xml b/gson/pom.xml\nindex 02f9db85a9..9cacb0ad3f 100644\n--- a/gson/pom.xml\n+++ b/gson/pom.xml\n@@ -66,13 +66,13 @@\n     <dependency>\n       <groupId>com.google.guava</groupId>\n       <artifactId>guava-testlib</artifactId>\n-      <version>33.3.1-jre</version>\n+      <version>33.4.0-jre</version>\n       <scope>test</scope>\n     </dependency>\n     <dependency>\n       <groupId>com.google.guava</groupId>\n       <artifactId>guava</artifactId>\n-      <version>33.3.1-jre</version>\n+      <version>33.4.0-jre</version>\n       <scope>test</scope>\n     </dependency>\n   </dependencies>\n@@ -236,12 +236,12 @@\n           <dependency>\n             <groupId>com.guardsquare</groupId>\n             <artifactId>proguard-base</artifactId>\n-            <version>7.6.0</version>\n+            <version>7.6.1</version>\n           </dependency>\n           <dependency>\n             <groupId>com.guardsquare</groupId>\n             <artifactId>proguard-core</artifactId>\n-            <version>9.1.6</version>\n+            <version>9.1.7</version>\n           </dependency>\n         </dependencies>\n         <configuration>\ndiff --git a/pom.xml b/pom.xml\nindex 05e88c04bb..1a49e186de 100644\n--- a/pom.xml\n+++ b/pom.xml\n@@ -308,7 +308,7 @@\n         <plugin>\n           <groupId>org.apache.maven.plugins</groupId>\n           <artifactId>maven-javadoc-plugin</artifactId>\n-          <version>3.11.1</version>\n+          <version>3.11.2</version>\n           <configuration>\n             <skip>${gson.isTestModule}</skip>\n \ndiff --git a/proto/pom.xml b/proto/pom.xml\nindex 120016d0a3..1b7910e29b 100644\n--- a/proto/pom.xml\n+++ b/proto/pom.xml\n@@ -31,7 +31,7 @@\n     <!-- This is duplicated here because that is recommended by `artifact:check-buildplan` -->\n     <project.build.outputTimestamp>2024-05-19T18:54:10Z</project.build.outputTimestamp>\n \n-    <protobufVersion>4.29.0</protobufVersion>\n+    <protobufVersion>4.29.2</protobufVersion>\n \n     <!-- Overwrite property from parent; this module is currently not deployed -->\n     <gson.isInternalModule>true</gson.isInternalModule>\n@@ -60,7 +60,7 @@\n     <dependency>\n       <groupId>com.google.guava</groupId>\n       <artifactId>guava</artifactId>\n-      <version>33.3.1-jre</version>\n+      <version>33.4.0-jre</version>\n     </dependency>\n \n     <dependency>\ndiff --git a/test-graal-native-image/pom.xml b/test-graal-native-image/pom.xml\nindex b34cac8bcd..691b2ab1ef 100644\n--- a/test-graal-native-image/pom.xml\n+++ b/test-graal-native-image/pom.xml\n@@ -48,7 +48,7 @@\n     <dependency>\n       <groupId>org.junit.jupiter</groupId>\n       <artifactId>junit-jupiter</artifactId>\n-      <version>5.11.3</version>\n+      <version>5.11.4</version>\n       <scope>test</scope>\n     </dependency>\n \n@@ -118,7 +118,7 @@\n           <plugin>\n             <groupId>org.graalvm.buildtools</groupId>\n             <artifactId>native-maven-plugin</artifactId>\n-            <version>0.10.3</version>\n+            <version>0.10.4</version>\n             <extensions>true</extensions>\n             <executions>\n               <execution>\ndiff --git a/test-shrinker/pom.xml b/test-shrinker/pom.xml\nindex 5decdd6048..e64812cdcc 100644\n--- a/test-shrinker/pom.xml\n+++ b/test-shrinker/pom.xml\n@@ -79,12 +79,12 @@\n           <dependency>\n             <groupId>com.guardsquare</groupId>\n             <artifactId>proguard-base</artifactId>\n-            <version>7.6.0</version>\n+            <version>7.6.1</version>\n           </dependency>\n           <dependency>\n             <groupId>com.guardsquare</groupId>\n             <artifactId>proguard-core</artifactId>\n-            <version>9.1.6</version>\n+            <version>9.1.7</version>\n           </dependency>\n         </dependencies>\n         <configuration>\n",
  "test_patch" : "diff --git a/gson/src/test/java/com/google/gson/JsonArrayAsListSuiteTest.java b/gson/src/test/java/com/google/gson/JsonArrayAsListSuiteTest.java\nindex baca3846b9..81c8ead7b9 100644\n--- a/gson/src/test/java/com/google/gson/JsonArrayAsListSuiteTest.java\n+++ b/gson/src/test/java/com/google/gson/JsonArrayAsListSuiteTest.java\n@@ -42,10 +42,14 @@ public Iterable<JsonElement> order(List<JsonElement> insertionOrder) {\n     @Override\n     public List<JsonElement> create(Object... elements) {\n       JsonArray array = new JsonArray();\n+      // This is not completely accurate: Because there is no way to directly construct JsonArray or\n+      // its List view with existing elements, this has to add the elements individually with\n+      // `List#add`\n+      var list = array.asList();\n       for (Object element : elements) {\n-        array.add((JsonElement) element);\n+        list.add((JsonElement) element);\n       }\n-      return array.asList();\n+      return list;\n     }\n   }\n \n@@ -54,8 +58,6 @@ public static Test suite() {\n     return ListTestSuiteBuilder.using(new ListGenerator())\n         .withFeatures(\n             CollectionSize.ANY,\n-            // Note: There is current a Guava bug which causes 'null additions' to not be tested if\n-            // 'null queries' is enabled, see https://github.com/google/guava/issues/7401\n             CollectionFeature.ALLOWS_NULL_QUERIES,\n             CollectionFeature.RESTRICTS_ELEMENTS, // List only allows JsonElement\n             CollectionFeature.SUPPORTS_ADD,\ndiff --git a/gson/src/test/java/com/google/gson/JsonObjectAsMapSuiteTest.java b/gson/src/test/java/com/google/gson/JsonObjectAsMapSuiteTest.java\nindex c2fc8c73f8..bb1625d487 100644\n--- a/gson/src/test/java/com/google/gson/JsonObjectAsMapSuiteTest.java\n+++ b/gson/src/test/java/com/google/gson/JsonObjectAsMapSuiteTest.java\n@@ -34,11 +34,15 @@ public SampleElements<Entry<String, JsonElement>> samples() {\n     @Override\n     public Map<String, JsonElement> create(Object... elements) {\n       JsonObject object = new JsonObject();\n+      // This is not completely accurate: Because there is no way to directly construct JsonObject\n+      // or its Map view with existing entries, this has to add the entries individually with\n+      // `Map#put`\n+      var map = object.asMap();\n       for (Object element : elements) {\n         var entry = (Entry<?, ?>) element;\n-        object.add((String) entry.getKey(), (JsonElement) entry.getValue());\n+        map.put((String) entry.getKey(), (JsonElement) entry.getValue());\n       }\n-      return object.asMap();\n+      return map;\n     }\n \n     @SuppressWarnings(\"unchecked\")\n@@ -70,8 +74,6 @@ public static Test suite() {\n     return MapTestSuiteBuilder.using(new MapGenerator())\n         .withFeatures(\n             CollectionSize.ANY,\n-            // Note: There is current a Guava bug which causes 'null additions' to not be tested if\n-            // 'null queries' is enabled, see https://github.com/google/guava/issues/7401\n             MapFeature.ALLOWS_ANY_NULL_QUERIES,\n             MapFeature.RESTRICTS_KEYS, // Map only allows String keys\n             MapFeature.RESTRICTS_VALUES, // Map only allows JsonElement values\ndiff --git a/gson/src/test/java/com/google/gson/internal/LinkedTreeMapSuiteTest.java b/gson/src/test/java/com/google/gson/internal/LinkedTreeMapSuiteTest.java\nindex d81812fb1d..4335e7ca11 100644\n--- a/gson/src/test/java/com/google/gson/internal/LinkedTreeMapSuiteTest.java\n+++ b/gson/src/test/java/com/google/gson/internal/LinkedTreeMapSuiteTest.java\n@@ -31,6 +31,8 @@ public MapGenerator(boolean allowNullValues) {\n \n     @Override\n     protected Map<String, String> create(Entry<String, String>[] entries) {\n+      // This is not completely accurate: Because LinkedTreeMap has no constructor which accepts\n+      // existing entries, this has to add the entries individually with `Map#put`\n       var map = new LinkedTreeMap<String, String>(allowNullValues);\n       for (var entry : entries) {\n         map.put(entry.getKey(), entry.getValue());\n@@ -47,8 +49,6 @@ private static Feature<?>[] createFeatures(Feature<?>... additionalFeatures) {\n         new ArrayList<Feature<?>>(\n             List.of(\n                 CollectionSize.ANY,\n-                // Note: There is current a Guava bug which causes 'null additions' to not be tested\n-                // if 'null queries' is enabled, see https://github.com/google/guava/issues/7401\n                 MapFeature.ALLOWS_ANY_NULL_QUERIES,\n                 MapFeature.RESTRICTS_KEYS, // Map only allows comparable keys\n                 MapFeature.SUPPORTS_PUT,\n@@ -74,7 +74,8 @@ public static Test suite() {\n             .named(\"nullValues=false\")\n             .createTestSuite();\n \n-    TestSuite testSuite = new TestSuite(\"LinkedTreeMap\");\n+    // Use qualified class name to make it easier to find this test class in the IDE\n+    TestSuite testSuite = new TestSuite(LinkedTreeMapSuiteTest.class.getName());\n     testSuite.addTest(nullValuesSuite);\n     testSuite.addTest(nonNullValuesSuite);\n \n",
  "problem_statement" : "```\nSomething similar to what http://code.google.com/p/acra/ has done would be good.\n\nWe should also consider creating a survey like them.\n```\n\nOriginal issue reported on code.google.com by `inder123` on 8 Jul 2011 at 7:04\n",
  "hints_text" : null,
  "created_at" : "Wed Jan 01 04:40:55 CET 2025",
  "version" : null,
  "FAIL_TO_PASS" : [ "LinkedTreeMapSuiteTest", "JsonArrayAsListSuiteTest", "JsonObjectAsMapSuiteTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -Dtest=LinkedTreeMapSuiteTest,JsonArrayAsListSuiteTest,JsonObjectAsMapSuiteTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : 343,
  "pull_number" : 2784,
  "metadata" : null
}, {
  "instance_id" : "google-gson-PR-2776",
  "repo" : "google/gson",
  "base_commit" : "78caa5e69ec1c914bd0edbe888d0c10681cb8e91",
  "patch" : "diff --git a/gson/src/main/java/com/google/gson/FieldNamingStrategy.java b/gson/src/main/java/com/google/gson/FieldNamingStrategy.java\nindex 541588696e..eebd998dfa 100644\n--- a/gson/src/main/java/com/google/gson/FieldNamingStrategy.java\n+++ b/gson/src/main/java/com/google/gson/FieldNamingStrategy.java\n@@ -16,7 +16,10 @@\n \n package com.google.gson;\n \n+import com.google.gson.annotations.SerializedName;\n import java.lang.reflect.Field;\n+import java.util.Collections;\n+import java.util.List;\n \n /**\n  * A mechanism for providing custom field naming in Gson. This allows the client code to translate\n@@ -37,4 +40,16 @@ public interface FieldNamingStrategy {\n    * @since 1.3\n    */\n   public String translateName(Field f);\n+\n+  /**\n+   * Returns alternative names for this field when it is being deserialized. This is similar to\n+   * {@link SerializedName#alternate()}.\n+   *\n+   * @param f the field object\n+   * @return the list of alternative field names.\n+   * @since $next-version$\n+   */\n+  default List<String> alternateNames(Field f) {\n+    return Collections.emptyList();\n+  }\n }\ndiff --git a/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java b/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java\nindex 94396ff1eb..3447f0c331 100644\n--- a/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java\n@@ -84,21 +84,25 @@ private boolean includeField(Field f, boolean serialize) {\n   /** first element holds the default name */\n   @SuppressWarnings(\"MixedMutabilityReturnType\")\n   private List<String> getFieldNames(Field f) {\n+\n+    String fieldName;\n+    List<String> alternates;\n     SerializedName annotation = f.getAnnotation(SerializedName.class);\n     if (annotation == null) {\n-      String name = fieldNamingPolicy.translateName(f);\n-      return Collections.singletonList(name);\n+      fieldName = fieldNamingPolicy.translateName(f);\n+      alternates = fieldNamingPolicy.alternateNames(f);\n+    } else {\n+      fieldName = annotation.value();\n+      alternates = Arrays.asList(annotation.alternate());\n     }\n \n-    String serializedName = annotation.value();\n-    String[] alternates = annotation.alternate();\n-    if (alternates.length == 0) {\n-      return Collections.singletonList(serializedName);\n+    if (alternates.isEmpty()) {\n+      return Collections.singletonList(fieldName);\n     }\n \n-    List<String> fieldNames = new ArrayList<>(alternates.length + 1);\n-    fieldNames.add(serializedName);\n-    Collections.addAll(fieldNames, alternates);\n+    List<String> fieldNames = new ArrayList<>(alternates.size() + 1);\n+    fieldNames.add(fieldName);\n+    fieldNames.addAll(alternates);\n     return fieldNames;\n   }\n \n",
  "test_patch" : "diff --git a/gson/src/test/java/com/google/gson/functional/NamingPolicyTest.java b/gson/src/test/java/com/google/gson/functional/NamingPolicyTest.java\nindex c419f6155d..9369b2b744 100644\n--- a/gson/src/test/java/com/google/gson/functional/NamingPolicyTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/NamingPolicyTest.java\n@@ -26,6 +26,7 @@\n import com.google.gson.common.TestTypes.ClassWithSerializedNameFields;\n import com.google.gson.common.TestTypes.StringWrapper;\n import java.lang.reflect.Field;\n+import java.util.List;\n import java.util.Locale;\n import org.junit.Before;\n import org.junit.Test;\n@@ -237,6 +238,78 @@ public void testAtSignInSerializedName() {\n     assertThat(new Gson().toJson(new AtName())).isEqualTo(\"{\\\"@foo\\\":\\\"bar\\\"}\");\n   }\n \n+  @Test\n+  public void testGsonWithNameDeserialiation() {\n+    Gson gson =\n+        builder\n+            .setFieldNamingStrategy(\n+                new FieldNamingStrategy() {\n+\n+                  @Override\n+                  public String translateName(Field f) {\n+                    return \"primary-name\";\n+                  }\n+\n+                  @Override\n+                  public List<String> alternateNames(Field f) {\n+                    return List.of(\"alternate-name\");\n+                  }\n+                })\n+            .create();\n+    String target = \"{\\\"primary-name\\\":\\\"someValue\\\"}\";\n+    StringWrapper deserializedObject = gson.fromJson(target, StringWrapper.class);\n+    assertThat(deserializedObject.someConstantStringInstanceField).isEqualTo(\"someValue\");\n+  }\n+\n+  @Test\n+  public void testGsonWithAlternateNamesDeserialiation() {\n+    Gson gson =\n+        builder\n+            .setFieldNamingStrategy(\n+                new FieldNamingStrategy() {\n+\n+                  @Override\n+                  public String translateName(Field f) {\n+                    return \"primary-name\";\n+                  }\n+\n+                  @Override\n+                  public List<String> alternateNames(Field f) {\n+                    return List.of(\"alternate-name\");\n+                  }\n+                })\n+            .create();\n+    String target = \"{\\\"alternate-name\\\":\\\"someValue\\\"}\";\n+    StringWrapper deserializedObject = gson.fromJson(target, StringWrapper.class);\n+    assertThat(deserializedObject.someConstantStringInstanceField).isEqualTo(\"someValue\");\n+  }\n+\n+  @Test\n+  public void testGsonWithAlternateNamesSerialization() {\n+    Gson gson =\n+        builder\n+            .setFieldNamingStrategy(\n+                new FieldNamingStrategy() {\n+\n+                  @Override\n+                  public String translateName(Field f) {\n+                    return \"some-constant-string-instance-field\";\n+                  }\n+\n+                  @Override\n+                  public List<String> alternateNames(Field f) {\n+                    return List.of(\"alternate-name\");\n+                  }\n+                })\n+            .create();\n+    StringWrapper target = new StringWrapper(\"blah\");\n+    assertThat(gson.toJson(target))\n+        .isEqualTo(\n+            \"{\\\"some-constant-string-instance-field\\\":\\\"\"\n+                + target.someConstantStringInstanceField\n+                + \"\\\"}\");\n+  }\n+\n   static final class AtName {\n     @SerializedName(\"@foo\")\n     String f = \"bar\";\n",
  "problem_statement" : "Give FieldNamingStrategy the ability to return multiple String names\n\n<!--\r\n    Thank you for your contribution!\r\n    Please see the contributing guide: https://github.com/google/.github/blob/master/CONTRIBUTING.md\r\n\r\n    Keep in mind that Gson is in maintenance mode. If you want to add a new feature, please first search for existing GitHub issues, or create a new one to discuss the feature and get feedback.\r\n-->\r\n\r\n### Purpose\r\n<!-- Describe the purpose of this pull request, for example which new feature it adds or which bug it fixes -->\r\nThis pull request enhances the `FieldNamingStrategy` in Gson to support returning multiple strings for a field name. This behavior aligns with the alternate names functionality provided by the `@SerializedName` annotation, allowing for greater flexibility in field mapping.\r\n\r\n### Description\r\n<!-- If necessary provide more information, for example relevant implementation details or corner cases which are not covered yet -->\r\nThe `FieldNamingStrategy` interface has been updated to allow implementations to return a list of potential field name mappings. This allows deserialization to succeed if any of the alternate names are present in the JSON data. \r\n\r\nThe changes include is to modifying the `FieldNamingStrategy` interface to support returning a collection of names. This allows the `FieldNamingStrategy` interface to behave like the `@SerializedName` annotation.\r\n\r\n### Checklist\r\n<!-- The following checklist is mainly intended for yourself to verify that you did not miss anything -->\r\n\r\n- [ X] New code follows the [Google Java Style Guide](https://google.github.io/styleguide/javaguide.html)\\\r\n  This is automatically checked by `mvn verify`, but can also be checked on its own using `mvn spotless:check`.\\\r\n  Style violations can be fixed using `mvn spotless:apply`; this can be done in a separate commit to verify that it did not cause undesired changes.\r\n- [X ] If necessary, new public API validates arguments, for example rejects `null`\r\n- [X ] New public API has Javadoc\r\n    - [ X] Javadoc uses `@since $next-version$`  \r\n      (`$next-version$` is a special placeholder which is automatically replaced during release)\r\n- [ X] If necessary, new unit tests have been added  \r\n  - [ X] Assertions in unit tests use [Truth](https://truth.dev/), see existing tests\r\n  - [X ] No JUnit 3 features are used (such as extending class `TestCase`)\r\n  - [X ] If this pull request fixes a bug, a new test was added for a situation which failed previously and is now fixed\r\n- [X ] `mvn clean verify javadoc:jar` passes without errors\r\n",
  "hints_text" : null,
  "created_at" : "Sat Nov 16 00:49:54 CET 2024",
  "version" : null,
  "FAIL_TO_PASS" : [ "NamingPolicyTest" ],
  "PASS_TO_PASS" : null,
  "environment_setup_commit" : null,
  "test_command" : "mvn test -pl gson -Dtest=NamingPolicyTest",
  "build_tool" : "maven",
  "java_version" : null,
  "modules" : null,
  "issue_number" : null,
  "pull_number" : 2776,
  "metadata" : null
} ]